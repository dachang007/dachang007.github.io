<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Spring系列-简单聊聊Spring事务的隔离级别</title>
      <link href="/2025/05/03/Spring%E6%A1%86%E6%9E%B6/Spring-%E7%AE%80%E5%8D%95%E8%81%8A%E8%81%8ASpring%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
      <url>/2025/05/03/Spring%E6%A1%86%E6%9E%B6/Spring-%E7%AE%80%E5%8D%95%E8%81%8A%E8%81%8ASpring%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Spring 中的事务隔离级别和数据库中的事务隔离级别稍有不同，以 MySQL 为例，MySQL 的 InnoDB 引擎中的事务隔离级别有 4 种，而 Spring 中却包含了 5 种事务隔离级别。</p></blockquote><h2 id="1-什么是事务隔离级别？"><a href="#1-什么是事务隔离级别？" class="headerlink" title="1.什么是事务隔离级别？"></a>1.什么是事务隔离级别？</h2><p><strong>事务隔离级别是对事务 4 大特性中隔离性的具体体现，使用事务隔离级别可以控制并发事务在同时执行时的某种行为。</strong></p><p>比如，有两个事务同时操作同一张表，此时有一个事务修改了这张表的数据，但尚未提交事务，那么在另一个事务中，要不要（或者说能不能）看到其他事务尚未提交的数据呢？</p><p>这个问题的答案就要看事务的隔离级别了，不同的事务隔离级别，对应的行为模式也是不一样的（有些隔离级别可以看到其他事务尚未提交的数据，有些事务隔离级别看不到其他事务尚未提交的数据），这就是事务隔离级别的作用。</p><h2 id="2-Spring-事务隔离级别"><a href="#2-Spring-事务隔离级别" class="headerlink" title="2.Spring 事务隔离级别"></a>2.Spring 事务隔离级别</h2><p>Sping 中的事务隔离级别有 5 种，它们分别是：</p><ol><li>DEFAULT：<strong>Spring 中默认的事务隔离级别</strong>，以连接的数据库的事务隔离级别为准；</li><li>READ_UNCOMMITTED：读未提交，也叫未提交读，该隔离级别的事务可以看到其他事务中未提交的数据。该隔离级别因为可以读取到其他事务中未提交的数据，而未提交的数据可能会发生回滚，因此我们把该级别读取到的数据称之为脏数据，把这个问题称之为脏读；</li><li>READ_COMMITTED：读已提交，也叫提交读，该隔离级别的事务能读取到已经提交事务的数据，因此它不会有脏读问题。但由于在事务的执行中可以读取到其他事务提交的结果，所以在不同时间的相同 SQL 查询中，可能会得到不同的结果，这种现象叫做不可重复读；</li><li>REPEATABLE_READ：可重复读，它能确保同一事务多次查询的结果一致。但也会有新的问题，比如此级别的事务正在执行时，另一个事务成功的插入了某条数据，但因为它每次查询的结果都是一样的，所以会导致查询不到这条数据，自己重复插入时又失败（因为唯一约束的原因）。明明在事务中查询不到这条信息，但自己就是插入不进去，这就叫幻读 （Phantom Read）；</li><li>SERIALIZABLE：串行化，最高的事务隔离级别，它会强制事务排序，使之不会发生冲突，从而解决了脏读、不可重复读和幻读问题，但因为执行效率低，所以真正使用的场景并不多。</li></ol><p>所以，<strong>相比于 MySQL 的事务隔离级别，Spring 中多了一种 DEFAULT 的事务隔离级别</strong>。事务隔离级别与问题的对应关系如下：<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAIBHWlIzt51IRJpk-lP55zfi0Yc0ZbjAAMNaxunp0BWA5OsVRrMFBYBAAMCAAN5AAM2BA.png"></p><blockquote><ul><li>脏读：一个事务读取到了另一个事务修改的数据之后，后一个事务又进行了回滚操作，从而导致第一个事务读取的数据是错误的。</li><li>不可重复读：一个事务两次查询得到的结果不同，因为在两次查询中间，有另一个事务把数据修改了。</li><li>幻读：一个事务两次查询中得到的结果集不同，因为在两次查询中另一个事务有新增了一部分数据。</li></ul></blockquote><h2 id="3-设置事务隔离级别"><a href="#3-设置事务隔离级别" class="headerlink" title="3.设置事务隔离级别"></a>3.设置事务隔离级别</h2><p>在 Spring 中，事务的隔离级别有 2 种设置方法，一种是在编程式事务中，可以通过以下代码来设置事务隔离级别：<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAIBHmlIzvAo9TBPVbmSayP97GLdOIEIAAIBDWsbp6dAVq4gZEgp9PhZAQADAgADdwADNgQ.png"><br>另一种是在声明式事务中设置事务隔离级别，设置方法如下：<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAIBH2lIzv40c_1cKFR5tqIo31Q9EFg5AAICDWsbp6dAVu7kOry1RYwJAQADAgADdwADNgQ.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Spring 中的事务隔离级别比 MySQL 中的事务隔离级别多了一种，它包含的 5 种隔离级别分别是：</p><ol><li><strong>Isolation.DEFAULT：默认的事务隔离级别，以连接的数据库的事务隔离级别为准。</strong></li><li>Isolation.READ_UNCOMMITTED：读未提交，可以读取到未提交的事务，存在脏读。</li><li>Isolation.READ_COMMITTED：读已提交，只能读取到已经提交的事务，解决了脏读，存在不可重复读。</li><li>Isolation.REPEATABLE_READ：可重复读，解决了不可重复读，但存在幻读（MySQL 数据库默认的事务隔离级别）。</li><li>Isolation.SERIALIZABLE：串行化，可以解决所有并发问题，但性能太低。</li></ol><p>但<strong>需要注意是 Spring 是事务隔离级别是建立在连接的数据库支持事务的基础上的</strong>，如果 Spring 项目连接的数据库不支持事务（或事务隔离级别），那么即使在 Spring 中设置了事务隔离级别，也是无效的设置。</p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL系列：备份与恢复</title>
      <link href="/2025/05/02/MySQL%E7%B3%BB%E5%88%97/MySQL%E7%B3%BB%E5%88%97-%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/"/>
      <url>/2025/05/02/MySQL%E7%B3%BB%E5%88%97/MySQL%E7%B3%BB%E5%88%97-%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="1-为什么需要数据库备份"><a href="#1-为什么需要数据库备份" class="headerlink" title="1 为什么需要数据库备份"></a>1 为什么需要数据库备份</h1><ul><li>灾难恢复：当发生数据灾难的时候，需要对损坏的数据进行恢复和还原</li><li>需求的变更或者回滚：当需求发生变更，或者需要回滚到之前的版本时，数据库备份也显得很重要。</li><li>审计：需要知道某一个阶段的数据或者Schema的实际情况</li><li>测试：将实际的生产环境的数据导入到本地备份为测试数据，来验证新功能，可以省去很多麻烦。</li></ul><h1 id="2-备份需要考虑的几个关键点"><a href="#2-备份需要考虑的几个关键点" class="headerlink" title="2 备份需要考虑的几个关键点"></a>2 备份需要考虑的几个关键点</h1><ul><li>恢复点目标（PRO）：可以容忍丢失多少数据</li><li>恢复时间目标（RTO）：需要等待多久将数据恢复</li><li>恢复的时候是需要持续提供服务 还是 停机恢复。</li><li>需要恢复的内容：整个服务器，多库多表，单库单表，或是特定的事务或语句。</li></ul><h1 id="3-备份方案"><a href="#3-备份方案" class="headerlink" title="3 备份方案"></a>3 备份方案</h1><h2 id="3-1-离线备份和在线备份"><a href="#3-1-离线备份和在线备份" class="headerlink" title="3.1 离线备份和在线备份"></a>3.1 离线备份和在线备份</h2><p>离线备份：就是传统意义上的cold backup（冷备份）：需要关闭MySQL服务，读写请求均不允许状态下进行，这种模式下数据损坏和不一致性风险最小。<br>半离线备份：也就是我们说的warm backup（温备份）： MySQL服务不关闭，但只开放了Read操作，关闭了Write操作。<br>在线备份：也就是hot backup（热备份）：在数据备份的同时，MySQL业务持续进行中，仅限于InnoDB引擎。</p><h2 id="3-2-逻辑备份和物理备份"><a href="#3-2-逻辑备份和物理备份" class="headerlink" title="3.2 逻辑备份和物理备份"></a>3.2 逻辑备份和物理备份</h2><h3 id="3-2-1-逻辑备份：导出数据库表的定义和数据"><a href="#3-2-1-逻辑备份：导出数据库表的定义和数据" class="headerlink" title="3.2.1 逻辑备份：导出数据库表的定义和数据"></a>3.2.1 逻辑备份：导出数据库表的定义和数据</h3><p>逻辑备份有如下优点：</p><ul><li>恢复非常简单</li><li>可以通过网络来备份和恢复</li><li>备份的结果为ASCII文件，可以编辑</li><li>与存储引擎无关</li><li>非常灵活，可以使用mysqldump的工具提供很多可选项。</li></ul><p>逻辑备份的缺点：</p><ul><li>必须由数据库服务器来完成备份和恢复过程</li><li>备份结果占据更多的空间：逻辑备份在某些场景下比数据库文件本身还要大</li><li>精度问题，无法保证还原出来的数据强一致</li><li>还原时间长：还原之后，加载注释语句，转换存储格式，重建索引都需要消耗一定时间</li></ul><h3 id="3-2-2-物理备份：直接复制原数据文件"><a href="#3-2-2-物理备份：直接复制原数据文件" class="headerlink" title="3.2.2 物理备份：直接复制原数据文件"></a>3.2.2 物理备份：直接复制原数据文件</h3><p>物理备份的优点：</p><ul><li>备份和恢复操作都比较简单，且能够跨平台，操作系统和MySQL版本。</li><li>恢复速度快，都是基于文件的，复制到对应的目的地即可，InnoDB需要停止数据库服务，有额外的动作。</li><li>步骤更少：不需要执行重新生成数据和重建索引的动作，效率提升。</li></ul><p>物理备份的缺点：</p><ul><li>InnoDB备份的原始文件往往比逻辑备份的大很多，空间要求大。</li></ul><h2 id="3-3-根据要备份的数据集合的范围"><a href="#3-3-根据要备份的数据集合的范围" class="headerlink" title="3.3 根据要备份的数据集合的范围"></a>3.3 根据要备份的数据集合的范围</h2><ul><li>完全备份：full backup，备份整个数据库信息。</li><li>增量备份: incremental backup 上次完全备份或增量备份以来改变了的数据，需与完全备份配合使用。一般来说增量频率高，备份频率也高。</li><li>差异备份：differential backup 上次完全备份以来改变了的数据。</li><li>建议的恢复策略：<ul><li>完全+增量+二进制日志</li><li>完全+差异+二进制日志</li></ul></li></ul><h1 id="4-备份的内容主要有哪些？"><a href="#4-备份的内容主要有哪些？" class="headerlink" title="4 备份的内容主要有哪些？"></a>4 备份的内容主要有哪些？</h1><ul><li>数据：基础数据。</li><li>日志：包含 二进制日志 和 InnoDB事务日志 等。</li><li>配置信息：包括服务器配置 和 复制相关的配置（主从复制中的中继日志和日志索引文件等）。</li><li>代码：存储过程、函数、触发器、视图等</li><li>选定的OS文件：入UNIX服务器上的 cron任务、用户和组的配置、管理的脚本、sudo规则等。</li></ul><h1 id="5-数据备份和数据恢复方案介绍"><a href="#5-数据备份和数据恢复方案介绍" class="headerlink" title="5 数据备份和数据恢复方案介绍"></a>5 数据备份和数据恢复方案介绍</h1><h2 id="5-1-输出outfile文件"><a href="#5-1-输出outfile文件" class="headerlink" title="5.1 输出outfile文件"></a>5.1 输出outfile文件</h2><p>使用 <code>select into outfile</code> 方式实现数据的备份和还原<br>具体的操作步骤如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 选择对应的数据库</span><br><span class="line">mysql&gt; use attend;  </span><br><span class="line">Database changed</span><br><span class="line"></span><br><span class="line"># 查询需要备份的数据</span><br><span class="line">mysql&gt; select * from userinfo where id &lt; 10000;</span><br><span class="line">+----+----------+------------------+---------+</span><br><span class="line">| id | usercode | username         | usersex |</span><br><span class="line">+----+----------+------------------+---------+</span><br><span class="line">|  1 | 374532   | 翁智华_attend    |       1 |</span><br><span class="line">|  2 | 123456   | 小度             |       0 |</span><br><span class="line">+----+----------+------------------+---------+</span><br><span class="line">2 rows in set (0.01 sec)</span><br><span class="line"></span><br><span class="line"># 选择备份的数据（可以精确条件），应该有两条数据，注意备份的地址具备write权限</span><br><span class="line">mysql&gt; select * from userinfo where id &lt; 10000 into outfile &#x27;/Users/Brand/Downloads/tmp/userinfo.txt&#x27; ;</span><br><span class="line"></span><br><span class="line"># 检查文件是否存在</span><br><span class="line">brand@MacBook-Pro ~ %  cd /Users/Brand/Downloads/tmp/</span><br><span class="line"></span><br><span class="line"># 因为它是文本模式，所以我们使用 load data infile 恢复，并且在恢复之前先删除掉要恢复的数据，做个测试</span><br><span class="line">mysql&gt; delete from userinfo where id &lt; 10000;</span><br><span class="line">mysql&gt; load data infile &#x27;/Users/Brand/Downloads/tmp/userinfo.txt&#x27; into table userinfo;</span><br></pre></td></tr></table></figure><h2 id="5-2-使用工具进行备份与还原"><a href="#5-2-使用工具进行备份与还原" class="headerlink" title="5.2 使用工具进行备份与还原"></a>5.2 使用工具进行备份与还原</h2><p>可以使用类似 mysqldump工具 或者 mysqlhotcopy工具对数据进行备份和还原，也可以使用免费的热备份软件 Percona XtraBackup。<br>这边以 mysqldump 为例子演示温备的实现：</p><h3 id="5-2-1-备份基本语法"><a href="#5-2-1-备份基本语法" class="headerlink" title="5.2.1 备份基本语法"></a>5.2.1 备份基本语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -h主机 -P端口 -u用户名  -p密码 param1, param2, param3... &gt; bak_filename.sql</span><br></pre></td></tr></table></figure><p>这边对各个字段坐下说明：</p><ul><li>h：登录用户所在的主机名称</li><li>P：主机端口</li><li>u：登录用户用户名</li><li>p：用户密码</li><li>param：导出参数（库、表、加锁等参数）</li><li>“&gt;”：将备份数据表的定义和数据写入备份文件的定义</li><li>bak_filename.sql：备份的文件名</li></ul><h3 id="5-2-2-导出全部数据库"><a href="#5-2-2-导出全部数据库" class="headerlink" title="5.2.2 导出全部数据库"></a>5.2.2 导出全部数据库</h3><p>–all-databases 或者 -A</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -uroot -p123456  --all-databases  &gt;  /user/brand/db_bak/all.sql</span><br><span class="line">mysqldump -uroot -p123456  -A  &gt; /user/brand/db_bak/all.sql</span><br></pre></td></tr></table></figure><h3 id="5-2-3-导出部分数据表"><a href="#5-2-3-导出部分数据表" class="headerlink" title="5.2.3 导出部分数据表"></a>5.2.3 导出部分数据表</h3><p>-databases [dbname,[dbname…]] –tables [tbname,[tbname…]] ,如果多个表where条件相同，也可以组合在一起使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -uroot -p123456 --databases db1  --tables tb1 --where=&quot;id&gt;1000&quot;  &gt; /user/brand/db_bak/db1_tb1.sql</span><br></pre></td></tr></table></figure><h3 id="5-2-4-创建之前先删库或表"><a href="#5-2-4-创建之前先删库或表" class="headerlink" title="5.2.4 创建之前先删库或表"></a>5.2.4 创建之前先删库或表</h3><p>–add-drop-database 、 –add-drop-table</p><ul><li>在create database 前先 drop database；在create table之前先 drop table</li><li>默认关闭，所以一般在导入时需要保证数据库已存在。。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -uroot -p123456  -A --add-drop-database --skip-add-drop-table &gt;  /user/brand/db_bak/all.sql</span><br></pre></td></tr></table></figure><h3 id="5-2-5-锁表"><a href="#5-2-5-锁表" class="headerlink" title="5.2.5 锁表"></a>5.2.5 锁表</h3><p>–add-locks：备份数据库表时锁定数据库表，默认就是打开的状态，可以使用–skip-add-locks取消</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 不佳参数选项的时候，默认是添加LOCK的</span><br><span class="line">mysqldump -uroot -p123456  -A  &gt;  /user/brand/db_bak/all.sql</span><br><span class="line"></span><br><span class="line"># 取消LOCK的状态</span><br><span class="line">mysqldump -uroot -p123456  -A --skip-add-locks   &gt; /user/brand/db_bak/all_skip_lock.sql</span><br></pre></td></tr></table></figure><h3 id="5-2-6-进行压缩"><a href="#5-2-6-进行压缩" class="headerlink" title="5.2.6 进行压缩"></a>5.2.6 进行压缩</h3><p>–compact：压缩模式，去掉注释、头尾等结构信息，让输出更少</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -uroot -p123456  -A --compact &gt;  /user/brand/db_bak/all_compact.sql</span><br></pre></td></tr></table></figure><h3 id="5-2-7-数据恢复"><a href="#5-2-7-数据恢复" class="headerlink" title="5.2.7 数据恢复"></a>5.2.7 数据恢复</h3><p>使用mysql命令进行恢复，语法如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u user -p pwd [dbname] &lt; bak_filename.sql</span><br></pre></td></tr></table></figure><p>注意箭头方向</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 删除数据库，模拟数据库损坏</span><br><span class="line">mysql&gt; drop database db1;</span><br><span class="line"></span><br><span class="line"># 导入完全备份的文件</span><br><span class="line">mysql &lt; /user/brand/db_bak/all_compact.sql</span><br></pre></td></tr></table></figure><h1 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a>6 总结</h1><p>备份和恢复主要使用在以下几个方面：</p><ul><li>灾难恢复</li><li>需求的变更或者版本回滚</li><li>数据和变更审计</li><li>多版本测试</li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis系列：分布式锁实现</title>
      <link href="/2025/05/01/Redis%E7%B3%BB%E5%88%97/Redis%E7%B3%BB%E5%88%97-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2025/05/01/Redis%E7%B3%BB%E5%88%97/Redis%E7%B3%BB%E5%88%97-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="1-先来了解下分布式锁"><a href="#1-先来了解下分布式锁" class="headerlink" title="1 先来了解下分布式锁"></a>1 先来了解下分布式锁</h1><h2 id="1-1-什么是分布式锁"><a href="#1-1-什么是分布式锁" class="headerlink" title="1.1 什么是分布式锁"></a>1.1 什么是分布式锁</h2><p>分布式锁，即分布式系统中的锁，我们通过锁解决 <strong>控制共享资源访问</strong> 的问题，来保证只有一个线程可以访问被保护的资源。</p><h2 id="1-2-分布式锁的实现方案"><a href="#1-2-分布式锁的实现方案" class="headerlink" title="1.2 分布式锁的实现方案"></a>1.2 分布式锁的实现方案</h2><ul><li>基于数据库实现分布式锁</li><li>基于Zookeeper实现分布式锁</li><li>基于Redis实现分布式锁</li></ul><p>等等，本篇基于Redis角度进行讨论</p><h2 id="1-3-分布式锁满足哪些特性"><a href="#1-3-分布式锁满足哪些特性" class="headerlink" title="1.3 分布式锁满足哪些特性"></a>1.3 分布式锁满足哪些特性</h2><ul><li>互斥性：在分布式系统下，一个事件在同一个时间内只能被一个线程执行，即只能有一个线程持有锁。</li><li>安全性：可以方便的获取锁和释放锁，不产生死锁情况</li><li>过期性：具备锁失效机制，即可以在时效预期外自动解锁，防止死锁</li><li>可重入：具备可重入特性（可理解为重新进入，由多于一个任务并</li><li>高性能：高性能的获取锁与释放锁</li><li>高可用性：高可用的获取锁与释放锁</li></ul><h2 id="1-4-互斥特性"><a href="#1-4-互斥特性" class="headerlink" title="1.4 互斥特性"></a>1.4 互斥特性</h2><h3 id="1-4-1-实现互斥特性"><a href="#1-4-1-实现互斥特性" class="headerlink" title="1.4.1 实现互斥特性"></a>1.4.1 实现互斥特性</h3><h4 id="1-4-1-1-SETNX命令"><a href="#1-4-1-1-SETNX命令" class="headerlink" title="1.4.1.1 SETNX命令"></a>1.4.1.1 SETNX命令</h4><p>SETNX 是 set if not exists 的缩写，当且仅当 key 不存在时，则设置 value 给这个key。若给定的 key 已经存在，则 SETNX 不做任何动作。<br>命令的返回值说明：</p><ul><li>1：说明该进程获得锁，将 key 的值设为 value</li><li>0：说明其他进程已经获得了锁，进程不能进入临界区。</li></ul><p>举例说明：setnx lock.key lock.value</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; SETNX lock.user_063105015 1</span><br><span class="line">(<span class="built_in">integer</span>) 1 <span class="comment"># 获取编号为 063105015 用户成功</span></span><br></pre></td></tr></table></figure><p>如果已经被获取过了，则获取失败</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; SETNX lock.user_063105015 1</span><br><span class="line">(<span class="built_in">integer</span>) 0 <span class="comment"># 获取编号为 063105015 用户失败</span></span><br></pre></td></tr></table></figure><h4 id="1-4-1-2-get命令"><a href="#1-4-1-2-get命令" class="headerlink" title="1.4.1.2 get命令"></a>1.4.1.2 get命令</h4><p>获取key的值，如果存在，则返回；如果不存在，则返回nil</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 获取成功</span></span><br><span class="line">&gt; GET <span class="keyword">lock</span>.user_063105015</span><br><span class="line"><span class="string">&quot;1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 获取失败</span></span><br><span class="line">&gt; GET <span class="keyword">lock</span>.user_123456789</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><h4 id="1-4-1-3-getset命令"><a href="#1-4-1-3-getset命令" class="headerlink" title="1.4.1.3 getset命令"></a>1.4.1.3 getset命令</h4><p>原子的设置值的办法，对key设置newValue这个值，并且返回key原来的旧值。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 重置用户信息</span></span><br><span class="line">&gt; getset <span class="keyword">lock</span>.user_063105015 <span class="number">0</span></span><br><span class="line"><span class="string">&quot;1&quot;</span>  <span class="meta"># 原值为1</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 再次重置</span></span><br><span class="line">&gt; getset <span class="keyword">lock</span>.user_063105015 <span class="number">1</span></span><br><span class="line"><span class="string">&quot;0&quot;</span>  <span class="meta"># 原值为0</span></span><br></pre></td></tr></table></figure><h4 id="1-4-1-4-删除命令，用完之后进行锁释放"><a href="#1-4-1-4-删除命令，用完之后进行锁释放" class="headerlink" title="1.4.1.4 删除命令，用完之后进行锁释放"></a>1.4.1.4 删除命令，用完之后进行锁释放</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; DEL lock.user_063105015</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><p>具体执行流程如下：<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAIBG2lIw5XAy6-ri880_fLMqFM9BEH6AAKKDGsbp6dAVt0cCiM2T_90AQADAgADeQADNgQ.png"></p><h4 id="1-3-1-5-异常导致的锁释放问题"><a href="#1-3-1-5-异常导致的锁释放问题" class="headerlink" title="1.3.1.5 异常导致的锁释放问题"></a>1.3.1.5 异常导致的锁释放问题</h4><p>可能会因为一些场景，造成锁无法释放，如下：</p><ul><li>调用服务或者客户端崩溃，无法正确的处理锁释放的工作。</li><li>业务程序的异常执行，没有操作释放锁的 DEL指令。<br>这种情况下，锁就会一直占用着，不会被释放，其他线程也无法获得。所以必须得有个自动释放锁的过程。</li></ul><h3 id="1-4-2-超时释放"><a href="#1-4-2-超时释放" class="headerlink" title="1.4.2 超时释放"></a>1.4.2 超时释放</h3><p>超时释放其实就是重置，目的是避免因为各种原因导致的锁长时间无法释放。</p><p>做法就是我们给锁加个过期时间（EXPIRE Time）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给用户 063105015 加锁</span></span><br><span class="line">&gt; SETNX lock.user_063105015 1 </span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置过期时间，到时间没删除则自动释放</span></span><br><span class="line">&gt; EXPIRE lock.user_063105015 120 <span class="comment"># 120秒之后自动释放</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><p>为了保证执行时的原子性，Redis 官方扩展了 SET 命令，既能满足获取对象，又能保证设置超时的时间语义。</p><p>避免出现了获取锁完成之后，执行超时设置失败微软无法释放锁的情况。保证要么都成功，要么都不执行。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 示例如下：</span></span><br><span class="line">SET <span class="keyword">lock</span>.user_063105015 <span class="number">1</span>  NX PX <span class="number">60000</span></span><br></pre></td></tr></table></figure><ul><li>NX：就是Not Exist，表示只有用户编号为 063105015 不存在的时候才可以 SET 成功，并且只有单个线程可以获取锁；</li><li>PX 60000：表示对这个锁设置一个60s的过期时间。</li></ul><h3 id="1-4-3-对锁进行唯一标识"><a href="#1-4-3-对锁进行唯一标识" class="headerlink" title="1.4.3 对锁进行唯一标识"></a>1.4.3 对锁进行唯一标识</h3><p>经常会出现一种情况，就是你获取到锁之后，因为各种原因（比如你的服务线程故障、网络抖动 等等），没有执行完成，或者没有释放锁，</p><p>这时候锁也过了 EXPIRE TIME，就自动释放了。当另外一个线程开锁成功，你的线程响应过来了，把人家的锁给释放了，这样就有问题了。</p><p>为了避免这种操作，我们要对同一个的锁做唯一识别码，在释放锁之前，先判断下是不是自己设置的那个锁，如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 设置10086专用值</span></span><br><span class="line">&gt; SET <span class="keyword">lock</span>.user_063105015 <span class="number">10086</span> NX PX <span class="number">60000</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="meta"># 设置成功，获取检查确实是10086</span></span><br><span class="line">&gt; <span class="keyword">get</span> <span class="keyword">lock</span>.user_063105015</span><br><span class="line"><span class="string">&quot;10086&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 伪代码：删除前进项确认是不是自己加的那个锁</span></span><br><span class="line"><span class="keyword">if</span> ( redis.<span class="keyword">get</span>(<span class="string">&quot;lock.user_063105015&quot;</span>).<span class="keyword">equals</span>(<span class="string">&quot;10086&quot;</span>)) &#123;</span><br><span class="line">   redis.del(<span class="string">&quot;lock.user_063105015&quot;</span>);  <span class="comment">// 只有对比成功才进行删除，释放锁</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-4-实现可重入锁"><a href="#1-4-4-实现可重入锁" class="headerlink" title="1.4.4 实现可重入锁"></a>1.4.4 实现可重入锁</h3><p>可重入锁可以理解为重新进入，由多于一个任务并发使用，而不必担心数据错误。</p><ul><li>可重入性就就保证线程能继续执行，防止在同一线程中多次获取锁而导致死锁发生</li><li>不可重入就是需要等待锁释放之后，再次获取锁成功，才能继续往下执行</li></ul><p>这边说说可重入锁，比如你执行线程的方案a获取锁之后，你的a方法后，线程继续执行b方法也需要获取锁，如果这时候不可重入，线程就需要等待锁的释放，进入争抢。</p><p>这边的解法就是对线程加锁的锁值进行增减，同一个线程的方法遇到加锁则锁值+1，遇到退锁则锁值-1，当前仅当锁值&#x3D;0的时候，说明这个锁真正的被释放了。</p><p>Java中的Redisson 类库就是通过 Redis Hash 来实现可重入锁。</p><p><strong>加锁的逻辑</strong><br>我们可以使用 Redis hash 结构实现，key 表示被锁的共享资源， hash 结构的 fieldKey 的 value 则保存加锁的次数。<br><img src="https://img2023.cnblogs.com/blog/167509/202303/167509-20230324160435079-1357450638.png" alt="image"><br>实现如下</p><p>( KEYS1 &#x3D; “lock.user_063105015”, ARGV [10000，uuid)：<br>KEYS[1] &#x3D; key的值<br>ARGV[1]) &#x3D; 持有锁的时间<br>ARGV[2] &#x3D; getLockName(threadId) </p><p>下面id就算系统在启动的时候会全局生成的uuid 来作为当前进程的id，加上线程id就是getLockName(threadId)了，可以理解为：进程ID+系统ID &#x3D; ARGV[2]</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1</span> 为 <span class="literal">true</span></span><br><span class="line"># <span class="number">0</span> 为 <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (redis.<span class="keyword">call</span>(<span class="comment">&#x27;exists&#x27;, KEYS[1]) == 0) then </span></span><br><span class="line">    redis.<span class="keyword">call</span>(<span class="comment">&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); </span></span><br><span class="line">    redis.<span class="keyword">call</span>(<span class="comment">&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); </span></span><br><span class="line">    <span class="keyword">return</span> nil; </span><br><span class="line">    <span class="keyword">end</span>; </span><br><span class="line"><span class="keyword">if</span> (redis.<span class="keyword">call</span>(<span class="comment">&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then </span></span><br><span class="line">    redis.<span class="keyword">call</span>(<span class="comment">&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); </span></span><br><span class="line">    redis.<span class="keyword">call</span>(<span class="comment">&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); </span></span><br><span class="line">    <span class="keyword">return</span> nil; </span><br><span class="line">    <span class="keyword">end</span>; </span><br><span class="line"><span class="keyword">return</span> redis.<span class="keyword">call</span>(<span class="comment">&#x27;pttl&#x27;, KEYS[1]);</span></span><br></pre></td></tr></table></figure><p><strong>参数说明</strong></p><ul><li>hincrby ：将hash中指定域的值增加给定的数字</li><li>pexpire：设置key的有效时间以毫秒为单位</li><li>hexists：判断field是否存在于hash中</li><li>pttl：获取key的有效毫秒数</li></ul><p><strong>程序说明</strong></p><ul><li>Redis exists 命令判断 lock.user_063105015 锁是否存在</li><li>锁不存在，hincrby 创建一个键为 lock.user_063105015 的 hash 表，键为 uuid，初始化值为 0，然后再次加 1，最后设置过期时间。</li><li>锁存在，hexists判断 lock 对应的 hash 表中是否存在 uuid 键，存在则 + 1，并重置过期时间</li><li>不符合以上的条件的都走到默认返回</li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 分布式锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis系列：过期数据的删除策略</title>
      <link href="/2025/05/01/Redis%E7%B3%BB%E5%88%97/Redis%E7%B3%BB%E5%88%97-%E8%BF%87%E6%9C%9F%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5/"/>
      <url>/2025/05/01/Redis%E7%B3%BB%E5%88%97/Redis%E7%B3%BB%E5%88%97-%E8%BF%87%E6%9C%9F%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h1><p>通过前面的章节，我们知道，Redis 是一个kv型数据库，我们所有的数据都是存放在内存中的，但是内存是有大小限制的，不可能无限制的增量。</p><p>想要把不需要的数据清理掉，一种办法是直接删除，这个咱们前面章节有详细说过；另外一种就是设置过期时间，缓存过期后，由Redis系统自行删除。</p><p>这边需要注意的是，缓存过期之后，并不是马上删除的，那Redis是怎么删除过期数据的呢？主要通过两个方式</p><ul><li>惰性删除</li><li>通过定时任务，定期选取部分数据删除</li></ul><h1 id="2-Redis缓存过期命令"><a href="#2-Redis缓存过期命令" class="headerlink" title="2 Redis缓存过期命令"></a>2 Redis缓存过期命令</h1><p>我们通过以下指令给指定key的缓存设置过期时间，如果都没设置过期时间， key 将一直存在，直到我们使用 Del 的命令明确删除掉。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 缓存时间过期命令，参考如下</span></span><br><span class="line">EXPIRE key seconds [ NX | XX | GT | LT] </span><br></pre></td></tr></table></figure><p>Redis 7.0 开始，EXPIRE 添加了 NX、XX和GT、LT 选项，分别代表如下：</p><ul><li>NX：仅当Key没有过期时设置过期时间</li><li>XX：仅当Key已过期时设置过期时间</li><li>GT：仅当新到期时间大于当前到期时间时设置到期时间</li><li>LT：仅当新到期时间小于当前到期时间时设置到期时间</li></ul><p>其中，GT、LT和NX选项是互斥的，下面是官方的测试用例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET mykey &quot;Hello&quot;</span><br><span class="line">&quot;OK&quot;</span><br><span class="line">redis&gt; EXPIRE mykey 10</span><br><span class="line">(integer) 1</span><br><span class="line">redis&gt; TTL mykey</span><br><span class="line">(integer) 10</span><br><span class="line">redis&gt; SET mykey &quot;Hello World&quot;</span><br><span class="line">&quot;OK&quot;</span><br><span class="line">redis&gt; TTL mykey</span><br><span class="line">(integer) -1</span><br><span class="line">redis&gt; EXPIRE mykey 10 XX</span><br><span class="line">(integer) 0</span><br><span class="line">redis&gt; TTL mykey</span><br><span class="line">(integer) -1</span><br><span class="line">redis&gt; EXPIRE mykey 10 NX</span><br><span class="line">(integer) 1</span><br><span class="line">redis&gt; TTL mykey</span><br><span class="line">(integer) 10</span><br></pre></td></tr></table></figure><h1 id="3-两种过期数据的删除方式"><a href="#3-两种过期数据的删除方式" class="headerlink" title="3 两种过期数据的删除方式"></a>3 两种过期数据的删除方式</h1><p>我们前面说过，Redis删除过期数据主要通过以下两个方式，我们一个个来看：</p><ul><li>惰性删除</li><li>通过定时任务，定期选取部分数据删除</li></ul><h2 id="3-1-惰性删除"><a href="#3-1-惰性删除" class="headerlink" title="3.1 惰性删除"></a>3.1 惰性删除</h2><p>惰性删除比较简单，当客户端请求过来查询我们的key的时候，先对key做一下检查，如果没过期则返回缓存数据，如果过期，则删除缓存，重新从数据库中获取数据。</p><p>这样，我们就把删除过期数据的主动权交给了访问请求的客户端，如果客户端一直没请求，那这个过期缓存可能就长时间得不到释放。</p><p>Redis的源码 src&#x2F;db.c 中的 expireIfNeeded 方法 就是实现以上惰性删除逻辑的，我们来看看：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">expireIfNeeded</span><span class="params">(redisDb *db, robj *key, <span class="type">int</span> force_delete_expired)</span> &#123;</span><br><span class="line">    <span class="comment">// 对于未过期的key，直接 return 0</span></span><br><span class="line">    <span class="keyword">if</span> (!keyIsExpired(db,key)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* If we are running in the context of a slave, instead of</span></span><br><span class="line"><span class="comment">     * evicting the expired key from the database, we return ASAP:</span></span><br><span class="line"><span class="comment">     * the slave key expiration is controlled by the master that will</span></span><br><span class="line"><span class="comment">     * send us synthesized DEL operations for expired keys.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Still we try to return the right information to the caller,</span></span><br><span class="line"><span class="comment">     * that is, 0 if we think the key should be still valid, 1 if</span></span><br><span class="line"><span class="comment">     * we think the key is expired at this time. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.masterhost != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (server.current_client == server.master) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!force_delete_expired) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If clients are paused, we keep the current dataset constant,</span></span><br><span class="line"><span class="comment">     * but return to the client what we believe is the right state. Typically,</span></span><br><span class="line"><span class="comment">     * at the end of the pause we will properly expire the key OR we will</span></span><br><span class="line"><span class="comment">     * have failed over and the new primary will send us the expire. */</span></span><br><span class="line">    <span class="keyword">if</span> (checkClientPauseTimeoutAndReturnIfPaused()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Delete the key */</span></span><br><span class="line">    deleteExpiredKeyAndPropagate(db,key);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-定期删除"><a href="#3-2-定期删除" class="headerlink" title="3.2 定期删除"></a>3.2 定期删除</h2><p>刚才前面说过了，仅靠客户端访问来对过期缓存执行删除远远不够，因为有的 key 过期了，但客户端一直没请求，那这个过期缓存可能就长时间甚至永远得不到释放。<br>所以除了惰性删除，Redis 还可以通过定时任务的方式来删除过期的数据。定时任务的发起的频率由redis.conf配置文件中的hz来进行配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 代表每1s 运行 10次</span></span><br><span class="line">hz 10</span><br></pre></td></tr></table></figure><p>Redis 默认每 1 秒运行 10 次，也就是每 100 ms 执行一次，每次随机抽取一些设置了过期时间的 key（这边注意不是检查所有设置过期时间的key，而是随机抽取部分），检查是否过期，如果发现过期了就直接删除。<br>该定时任务的具体流程如下：</p><ol><li>定时serverCron方法去执行清理，执行频率根据redis.conf中的hz配置的值</li><li>执行清理的时候，不是去扫描所有的key，而是去扫描所有设置了过期时间的key（redisDb.expires）</li><li>如果每次去把所有过期的key都拿过来，那么假如过期的key很多，就会很慢，所以也不是一次性拿取所有的key</li><li>根据hash桶的维度去扫描key，扫到20(可配)个key为止。假如第一个桶是15个key ，没有满足20，继续扫描第二个桶，第二个桶20个key，由于是以hash桶的维度扫描的，所以第二个扫到了就会全扫，总共扫描35个key</li><li>找到扫描的key里面过期的key，并进行删除</li><li>删除完检查过期的 key 超过 25%，继续执行4、5步</li></ol><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAIBGGlIv9opqLzvgsIndDzuP5bBuqosAAJpDGsbp6dAVoEQzrzbspNNAQADAgADeAADNgQ.png"></p><p>其他注意点：</p><ul><li>为何不扫描所有key进行过期缓存元素删除：Redis本身就是高速缓存，如果每次检查大量的key，无论在CPU和内存的的使用率上都会特别高，Redis集群越大，风险越大。</li><li>分片模式下的删除同步：无论定时删除还是惰性删除。master 会生成删除的指令记录到 AOF 和 slave 节点。</li></ul><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h1><p>无论是惰性删除还是定期删除，都可能存在删除不尽的情况：无法删除完全，比如每次删除完过期的 key 还是超过 25%，且这些 key 再也不会被客户端访问。</p><p>如果长时间持续下去，可能会导致内存耗尽，为了避免这种糟糕情况，Redis会有一个完善的内存淘汰机制来保障。下一节我们会着重来介绍下内存淘汰机制。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL系列：分库分表</title>
      <link href="/2025/04/29/MySQL%E7%B3%BB%E5%88%97/MySQL%E7%B3%BB%E5%88%97-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
      <url>/2025/04/29/MySQL%E7%B3%BB%E5%88%97/MySQL%E7%B3%BB%E5%88%97-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="1-为什么要分库分表"><a href="#1-为什么要分库分表" class="headerlink" title="1 为什么要分库分表"></a>1 为什么要分库分表</h3><p>物理服务机的CPU、内存、存储设备、连接数等资源有限，某个时段大量连接同时执行操作，会导致数据库在处理上遇到性能瓶颈。为了解决这个问题，行业先驱门充分发扬了分而治之的思想，对大库表进行分割，</p><p>然后实施更好的控制和管理，同时使用多台机器的CPU、内存、存储，提供更好的性能。而分治有两种实现方式：垂直拆分和水平拆分。</p><h3 id="2-垂直拆分（Scale-Up-纵向扩展）"><a href="#2-垂直拆分（Scale-Up-纵向扩展）" class="headerlink" title="2 垂直拆分（Scale Up 纵向扩展）"></a>2 垂直拆分（Scale Up 纵向扩展）</h3><p>垂直拆分分为垂直分库和垂直分表，主要按功能模块拆分，以解决各个库或者各个表之间的资源竞争。比如分为订单库、商品库、用户库…这种方式，多个数据库之间的表结构是不同的。</p><h4 id="2-1-垂直分库"><a href="#2-1-垂直分库" class="headerlink" title="2.1 垂直分库"></a>2.1 垂直分库</h4><p>先说说垂直分库。垂直分库其实是一种简单逻辑分割。比如我们的数据库中有商品表Products、还有对订单表Orders，还有积分表Scores。接下来我们就可以创建三个数据库，一个数据库存放商品，一个数据库存放订单，一个数据库存放积分。</p><p>垂直分库有一个优点，他能够根据业务场景进行孵化，比如某一单一场景只用到某2-3张表，基本上应用和数据库可以拆分出来做成相应的服务。拆分方式如下图所示：</p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAIBAWlH2X-7Bsw0BEnjc4F2WApJiSl0AAITC2sbp6dAVqJstfr6j5H9AQADAgADeAADNgQ.png"></p><h4 id="2-2-垂直分表"><a href="#2-2-垂直分表" class="headerlink" title="2.2 垂直分表"></a>2.2 垂直分表</h4><p>再来说说垂直分表，比较适用于那种字段比较多的表，假设我们一张表有100个字段，我们分析了一下当前业务执行的SQL语句，有20个字段是经常使用的，而另外80个字段使用比较少。</p><p>这样我们就可以把20个字段放在主表里面，我们再创建一个辅助表，存放另外80个字段。当然主表和辅助表都是有主键的，他们通过主键进行关联合并，就可以组合成100个字段的表。拆分方式如下图所示。</p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAIBAAFpR9lU482OY05NIKZfsSKhQmX0_wACEgtrG6enQFZiVZbfhcZc0gEAAwIAA3cAAzYE.png"></p><p> 除了这种访问频率的冷热拆分之外，还可以按照字段类型结构来拆分，比如大文本字段单独放在一个表中，与基础字段隔离，提高基础字段的访问效率。</p><p>也可以将字段按照功能用途来拆分，比如采购的物料表可以按照基本属性、销售属性、采购属性、生产制造属性、财务会计属性等用途垂直拆分。</p><p> 总体来说：垂直拆分有以下优点：</p><ul><li>跟随业务进行分割，类似微服务的分治理念，方便解耦之后的管理及扩展。</li><li>高并发的场景下，垂直拆分使用多台服务器的CPU、I&#x2F;O、内存能提升性能，同时对单机数据库连接数、一些资源限制也得到了提升，能实现冷热数据的分离。</li></ul><p>垂直拆分的缺点：</p><ul><li>部分业务表无法join，应用层需要很大的改造，只能通过聚合的方式来实现。增加了开发的难度。</li><li>单表数据量膨胀的问题依然没有得到有效的解决。分布式事务也是一个难题。</li></ul><h3 id="3-水平拆分（Scale-Out-横向扩展）"><a href="#3-水平拆分（Scale-Out-横向扩展）" class="headerlink" title="3 水平拆分（Scale Out 横向扩展）"></a>3 水平拆分（Scale Out 横向扩展）</h3><p>水平拆分又分为库内分表和分库分表，来解决单表中数据量增长出现的压力，这些数据库中的表结构完全相同。</p><h4 id="3-1-库内分表"><a href="#3-1-库内分表" class="headerlink" title="3.1 库内分表"></a>3.1 库内分表</h4><p>先说说库内分表。假设当我们的Orders表达到了5000万行记录的时候，非常影响数据库的读写效率，怎么办呢？</p><p>我们可以考虑按照订单编号的order_id进行rang分区,就是把订单编号在1-1000万的放在order1表中，将编号在1000万-2000万的放在order2中，以此类推，每个表中存放1000万数据。</p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAP_aUfZIJ7JRizIBcNKUAECTCZNN20AAhELaxunp0BW0d1dkRiry2oBAAMCAAN5AAM2BA.png"></p><p> 关于水平分表的时机，业内的标准不是很统一，阿里的Java 开发手册的标准是当单表行数超过 500万行或者单表容量超过 2 GB时，才推荐进行分库分表。百度的则是1000 W行的进行分表，这个是百度的DBA经过测试推算出的结果。</p><p>但是这边忽略了单表的字段数和字段类型，如果字段数很多，超过50列，对性能影响也是不小的，我们曾经有个业务，表字段是随着业务的增长而自动扩增的，到了后期，字段越来越多，查询性能也越来越慢。</p><p>所以个人觉得不必拘泥于500W 还是1000W，开发人员在使用过程中，如果压测发现因为数据基数变大而导致执行效率慢下来，就可以开始考虑分表了。</p><h4 id="3-2-库内分表的实现策略"><a href="#3-2-库内分表的实现策略" class="headerlink" title="3.2 库内分表的实现策略"></a>3.2 库内分表的实现策略</h4><p>目前在MySql中支持四种表分区的方式，分别为HASH、RANGE、LIST及KEY，当然在其它的类型数据库中，分区的实现方式略有不同，但是分区的思想原理是相同，具体如下：</p><h5 id="3-2-1-HASH（哈希）"><a href="#3-2-1-HASH（哈希）" class="headerlink" title="3.2.1 HASH（哈希）"></a>3.2.1 HASH（哈希）</h5><p>HASH分区主要用来确保数据在预先确定数目的分区中平均分布，而在RANGE和LIST分区中，必须明确指定一个给定的列值或列值集合应该保存在哪个分区中，而在HASH分区中，MySQL自动完成这些工作，</p><p>你所要做的只是基于将要被哈希的列值指定一个列值或表达式，以及指定被分区的表将要被分割成的分区数量。 示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">drop table if EXISTS  `t_userinfo`;</span><br><span class="line">CREATE TABLE `t_userinfo` (</span><br><span class="line">`id` int(10) unsigned NOT NULL,</span><br><span class="line">`personcode` varchar(20) DEFAULT NULL,</span><br><span class="line">`personname` varchar(100) DEFAULT NULL,</span><br><span class="line">`depcode` varchar(100) DEFAULT NULL,</span><br><span class="line">`depname` varchar(500) DEFAULT NULL,</span><br><span class="line">`gwcode` int(11) DEFAULT NULL,</span><br><span class="line">`gwname` varchar(200) DEFAULT NULL,</span><br><span class="line">`gravalue` varchar(20) DEFAULT NULL,</span><br><span class="line">`createtime` DateTime NOT NULL</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8</span><br><span class="line">PARTITION BY HASH(YEAR(createtime))</span><br><span class="line">PARTITIONS 10;</span><br></pre></td></tr></table></figure><p>上面的例子，使用HASH函数对createtime日期进行HASH运算，并根据这个日期来分区数据，这里共分为10个分区。 </p><p>建表语句上添加一个“PARTITION BY HASH (expr)”子句，其中“expr”是一个返回整数的表达式，它可以是字段类型为MySQL 整型的一列的名字，也可以是返回非负数的表达式。</p><p>另外，可能需要在后面再添加一个“PARTITIONS num”子句，其中num 是一个非负的整数，它表示表将要被分割成分区的数量。 </p><h5 id="3-2-2-RANGE（范围）"><a href="#3-2-2-RANGE（范围）" class="headerlink" title="3.2.2 RANGE（范围）"></a>3.2.2 RANGE（范围）</h5><p>基于属于一个给定连续区间的列值，把多行分配给同一个分区，这些区间要连续且不能相互重叠，使用VALUES LESS THAN操作符来进行定义。示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">drop table if EXISTS  `t_userinfo`;</span><br><span class="line">CREATE TABLE `t_userinfo` (</span><br><span class="line">`id` int(10) unsigned NOT NULL,</span><br><span class="line">`personcode` varchar(20) DEFAULT NULL,</span><br><span class="line">`personname` varchar(100) DEFAULT NULL,</span><br><span class="line">`depcode` varchar(100) DEFAULT NULL,</span><br><span class="line">`depname` varchar(500) DEFAULT NULL,</span><br><span class="line">`gwcode` int(11) DEFAULT NULL,</span><br><span class="line">`gwname` varchar(200) DEFAULT NULL,</span><br><span class="line">`gravalue` varchar(20) DEFAULT NULL,</span><br><span class="line">`createtime` DateTime NOT NULL</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8</span><br><span class="line">PARTITION BY RANGE(gwcode) (</span><br><span class="line">PARTITION P0 VALUES LESS THAN(101) ,</span><br><span class="line">PARTITION P1 VALUES LESS THAN(201) ,</span><br><span class="line">PARTITION P2 VALUES LESS THAN(301) ,</span><br><span class="line">PARTITION P3 VALUES LESS THAN MAXVALUE</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上面的示例，使用了范围RANGE函数对岗位编号进行分区，共分为4个分区，</p><p>岗位编号为1<del>100 的对应在分区P0中，101</del>200的编号在分区P1中，依次类推即可。那么类别编号大于300，可以使用MAXVALUE来将大于300的数据统一存放在分区P3中即可。 </p><h5 id="3-2-3-LIST（预定义列表）"><a href="#3-2-3-LIST（预定义列表）" class="headerlink" title="3.2.3 LIST（预定义列表）"></a>3.2.3 LIST（预定义列表）</h5><p>类似于按RANGE分区，区别在于LIST分区是基于列值匹配一个离散值集合中的某个值来进行选择分区的。LIST分区通过使用“PARTITION BY LIST(expr)”来实现，其中“expr” 是某列值或一个基于某个列值、并返回一个整数值的表达式，</p><p>然后通过“VALUES IN (value_list)”的方式来定义每个分区，其中“value_list”是一个通过逗号分隔的整数列表。 示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">drop table if EXISTS  `t_userinfo`;</span><br><span class="line">CREATE TABLE `t_userinfo` (</span><br><span class="line">`id` int(10) unsigned NOT NULL,</span><br><span class="line">`personcode` varchar(20) DEFAULT NULL,</span><br><span class="line">`personname` varchar(100) DEFAULT NULL,</span><br><span class="line">`depcode` varchar(100) DEFAULT NULL,</span><br><span class="line">`depname` varchar(500) DEFAULT NULL,</span><br><span class="line">`gwcode` int(11) DEFAULT NULL,</span><br><span class="line">`gwname` varchar(200) DEFAULT NULL,</span><br><span class="line">`gravalue` varchar(20) DEFAULT NULL,</span><br><span class="line">`createtime` DateTime NOT NULL</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8</span><br><span class="line">PARTITION BY LIST(`gwcode`) (</span><br><span class="line">PARTITION P0 VALUES IN (46,77,89) ,</span><br><span class="line">PARTITION P1 VALUES IN (106,125,177) ,</span><br><span class="line">PARTITION P2 VALUES IN (205,219,289) ,</span><br><span class="line">PARTITION P3 VALUES IN (302,317,458,509,610)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上面的例子，使用了列表匹配LIST函数对员工岗位编号进行分区，共分为4个分区，编号为46,77,89的对应在分区P0中，106,125,177类别在分区P1中，依次类推即可。</p><p>不同于RANGE的是，LIST分区的数据必须匹配列表中的岗位编号才能进行分区，所以这种方式只是适合比较区间值确定并少量的情况。 </p><h5 id="3-2-4-KEY（键值）"><a href="#3-2-4-KEY（键值）" class="headerlink" title="3.2.4 KEY（键值）"></a>3.2.4 KEY（键值）</h5><p>类似于按HASH分区，区别在于KEY分区只支持计算一列或多列，且MySQL 服务器提供其自身的哈希函数。必须有一列或多列包含整数值。 示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">drop table if EXISTS  `t_userinfo`;</span><br><span class="line">CREATE TABLE `t_userinfo` (</span><br><span class="line">`id` int(10) unsigned NOT NULL,</span><br><span class="line">`personcode` varchar(20) DEFAULT NULL,</span><br><span class="line">`personname` varchar(100) DEFAULT NULL,</span><br><span class="line">`depcode` varchar(100) DEFAULT NULL,</span><br><span class="line">`depname` varchar(500) DEFAULT NULL,</span><br><span class="line">`gwcode` int(11) DEFAULT NULL,</span><br><span class="line">`gwname` varchar(200) DEFAULT NULL,</span><br><span class="line">`gravalue` varchar(20) DEFAULT NULL,</span><br><span class="line">`createtime` DateTime NOT NULL</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8</span><br><span class="line">PARTITION BY KEY(gwcode)</span><br><span class="line">PARTITIONS 10;</span><br></pre></td></tr></table></figure><p>注意：此种分区算法目前使用的比较少，使用服务器提供的哈希函数有不确定性，对于后期数据统计、整理存在会更复杂，所以我们更倾向于使用由我们定义表达式的Hash，大家知道其存在和怎么使用即可。 </p><h5 id="3-2-5-Composite（复合模式）"><a href="#3-2-5-Composite（复合模式）" class="headerlink" title="3.2.5 Composite（复合模式）"></a>3.2.5 Composite（复合模式）</h5><p>Composite是上面几种模式的组合使用，比如你在Range的基础上，再进行Hash 哈希分区。</p><h4 id="3-3-分库分表"><a href="#3-3-分库分表" class="headerlink" title="3.3 分库分表"></a>3.3 分库分表</h4><p>库内分表解决了单表数据量过大的瓶颈问题，但使用还是同一主机的CPU、IO、内存，另外单库的连接数也有限制，并不能完全的降低系统的压力。</p><p>此时，我们就要考虑另外一种技术叫分库分表。分库分表在库内分表的基础上，将分的表挪动到不同的主机和数据库上。可以充分的使用其他主机的CPU、内存和IO资源。 拆分方式进一步演进到下面：</p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAP-aUfYniL_hXAAATDwddP1eyhNmcXmAAINC2sbp6dAVjYIcBEtqSufAQADAgADeQADNgQ.png"> </p><h3 id="4-分库分表存在的问题"><a href="#4-分库分表存在的问题" class="headerlink" title="4 分库分表存在的问题"></a>4 分库分表存在的问题</h3><h4 id="4-1-事务问题"><a href="#4-1-事务问题" class="headerlink" title="4.1 事务问题"></a>4.1 事务问题</h4><p>在执行分库分表之后，由于数据存储到了不同的库上，数据库事务管理出现了困难。如果依赖数据库本身的分布式事务管理功能去执行事务，将付出高昂的性能代价；如果由应用程序去协助控制，形成程序逻辑上的事务，又会造成编程方面的负担。</p><h4 id="4-2-跨库跨表的join问题"><a href="#4-2-跨库跨表的join问题" class="headerlink" title="4.2 跨库跨表的join问题"></a>4.2 跨库跨表的join问题</h4><p>在执行了分库分表之后，难以避免会将原本逻辑关联性很强的数据划分到不同的表、不同的库上，这时，表的关联操作将受到限制，我们无法join位于不同分库的表，也无法join分表粒度不同的表，结果原本一次查询能够完成的业务，可能需要多次查询才能完成。 </p><h4 id="4-3-额外的数据管理负担和数据运算压力"><a href="#4-3-额外的数据管理负担和数据运算压力" class="headerlink" title="4.3 额外的数据管理负担和数据运算压力"></a>4.3 额外的数据管理负担和数据运算压力</h4><p>额外的数据管理负担，最显而易见的就是数据的定位问题和数据的增删改查的重复执行问题，这些都可以通过应用程序解决，但必然引起额外的逻辑运算，例如，对于一个记录用户成绩的用户数据表userTable，业务要求查出成绩最好的100位，在进行分表之前，</p><p>只需一个order by语句就可以搞定，但是在进行分表之后，将需要n个order by语句，分别查出每一个分表的前100名用户数据，然后再对这些数据进行合并计算，才能得出结果。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>客户端缓存带来的革命</title>
      <link href="/2025/04/27/%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%80%9D%E7%BB%B4/%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BC%93%E5%AD%98%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%9D%A9%E5%91%BD/"/>
      <url>/2025/04/27/%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%80%9D%E7%BB%B4/%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BC%93%E5%AD%98%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%9D%A9%E5%91%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>2020年5月份，Redis官方推出了令人瞩目的 Redis 6.0，提出很多新特性，包括了客户端缓存 (Client side caching)、ACL、Threaded I&#x2F;O 和 Redis Cluster Proxy 等诸多新特性。如下：<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAIBC2lItpz2_I9jnkTiCwSXKNANhX98AAJRDGsbp6dAVseqUAf1_LO_AQADAgADdwADNgQ.png"><br>我们也专门对 Redis 6.0的 Threaded I&#x2F;O（多线程网络I&#x2F;O 模式）做了很详细的说明，有兴趣的翻到前面一篇。<br>这一篇咱们就来聊下这个Client side caching（客户端缓存)，看看Redis为什么需要客户端缓存、是基于什么原理实现的，以及具体应该怎么使用。</p><h1 id="1-为什么需要客户端缓存"><a href="#1-为什么需要客户端缓存" class="headerlink" title="1 为什么需要客户端缓存"></a>1 为什么需要客户端缓存</h1><h2 id="1-1-缓存服务的目的"><a href="#1-1-缓存服务的目的" class="headerlink" title="1.1 缓存服务的目的"></a>1.1 缓存服务的目的</h2><p>回顾一下我们 在第一篇 《<a href="https://yeoh.qzz.io/2025/03/11/Redis%E7%B3%BB%E5%88%97/Redis%E7%B3%BB%E5%88%971-%E6%B7%B1%E5%88%BB%E7%90%86%E8%A7%A3%E9%AB%98%E6%80%A7%E8%83%BDRedis%E7%9A%84%E6%9C%AC%E8%B4%A8/">Redis系列1：深刻理解高性能Redis的本质 | 数根朽木，</a>)》中说过的，Redis的读写操作都是在内存中实现了，相对其他的持久化存储（如MySQL、File等，数据持久化在磁盘上），性能会高很多。因为我们在操作数据的时候，需要通过 IO 操作先将数据读取到内存里，增加工作成本。<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAIBDGlItyUwZY7fgSIpMMHg7Q3aMGJEAAJSDGsbp6dAVlyoJDK-kGzgAQADAgADeQADNgQ.png"><br>上面那张图来源于网络，可以看看他的金字塔模型，越往上执行效率越高，价格也就越贵。下面给出每一层的执行耗时对比：</p><ul><li><p>寄存器：0.3 ns</p></li><li><p>L1高速缓存：0.9 ns</p></li><li><p>L2高速缓存：2.8 ns</p></li><li><p>L3高速缓存：12.9 ns</p></li><li><p>主存：120 ns</p></li><li><p>本地二级存储（SSD）：50~150 us</p></li><li><p>远程二级存储：30 ms</p><p>我们举个L1和SSD的直观对比，如果L1耗时1s的话，SSD中差不多要15~45小时，所以内存层面的访问效率远远比磁盘层面的访问效率高很多。</p></li></ul><p>总之，缓存的目的是基于对持久化在磁盘的数据（比如MySQL数据、文件数据等）的高效访问，为了提升效率而实现的。《Redis in Action》中也提到， Redis 能够提升普通关系型数据库的 10 ~ 100 倍的性能。</p><p>数据访问过程如下图，Redis 存储了热点数据，当天我们请求一个数据时，先去访问缓存层，如果不存在再去访问数据库，这样可以解决大部分高效读取数据的业务场景，性能是缓存最重要的价值之一。<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAIBDWlIt0UDuAzGbHnejSqK0i5CvgEfAAJTDGsbp6dAVu007oSuyo0iAQADAgADeAADNgQ.png"></p><h2 id="1-2-存在的问题"><a href="#1-2-存在的问题" class="headerlink" title="1.2 存在的问题"></a>1.2 存在的问题</h2><p>虽然我们使用Redis提升了数据的访问效率，但是依然存在一些问题。基于分布式访问的缓存服务是一个独立的服务存在，一般情况下访问它需要经过这几个步骤：</p><ul><li>连接缓存服务（一般不会跟计算服务在一个实例上）</li><li>查找并读取数据（I&#x2F;O操作）</li><li>网络传输</li><li>数据序列化反序列化</li></ul><p>这些操作一样的是对性能有影响的，随着互联网的发展，流量不断的膨胀，很容易达到 Redis 的性能上限。<br>所以，我们经常会使用进程缓存（本地缓存），来辅助处理，将一些高频读低频写的数据暂存在本地，读取数据的时候，先检查本地缓存是否存在，不存在再访问远端缓存服务的数据，进一步提高访问效率。</p><p>如果Redis也不存在，就只能去 数据库 中查询，查到的数据再设置到 Redis 和 本地缓存中，这样后续的请求就不用再走到数据库中了。<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAIBCmlItiOaRxopkiXnIHpovyJMiBgWAAJPDGsbp6dAVpLv560RB0nBAQADAgADeAADNgQ.png"></p><p>一般我们会使用Memcachced、Guava Cache 等来做第一级别缓存（本地缓存），使用Redis作为第二级缓存（缓存服务)，本地内存避免了 连接、查询、网络传输、序列化等操作，性能比缓存服务快很多，这种模式大大减少数据延迟。</p><h1 id="2-客户端缓存实现原理"><a href="#2-客户端缓存实现原理" class="headerlink" title="2 客户端缓存实现原理"></a>2 客户端缓存实现原理</h1><p>Redis自己实现了一个客户端缓存，用以协助服务端Redis的操作，叫做<code>tracking</code>。<br>我们可以通过命令来配置它：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLIENT TRACKING ON|OFF [REDIRECT client-id] [PREFIX prefix] [BCAST] [OPTIN] [OPTOUT] [NOLOOP]</span><br></pre></td></tr></table></figure><p>客户端缓存最核心的问题就是当Redis中的缓存变更或者失效了之后，如果能够及时有效的通知到客户端缓存，来保证数据的一致性。</p><p>Redis 6.0 实现 Tracking 功能，这个功能提供了两种方案来实现数据的一致性保证：</p><ul><li>RESP2 协议版本的转发模式</li><li>RESP3 协议版本的普通模式和广播模式<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAIBD2lIt3Lf3CRLVucwRriu7SrI-zgBAAJUDGsbp6dAViJk-wEtjFcAAQEAAwIAA3gAAzYE.png"><br>接下来我们一个个来分析。</li></ul><h2 id="2-1-普通模式"><a href="#2-1-普通模式" class="headerlink" title="2.1 普通模式"></a>2.1 普通模式</h2><p>Redis使用 TrackingTable 来存储普通模式的客户端数据，它的数据类型是基数树 ( radix tree)。</p><p>radix tree是针对稀疏的长整型数据查找的多叉搜索树，能快速且节省空间的完映射，想深入了解的可以看<a href="https://wenku.baidu.com/view/b979eee0a900b52acfc789eb172ded630b1c988f.html">这篇介绍</a>。<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAIBEGlIt4gn1EKIzbUeiX3DMLQvhxPMAAJVDGsbp6dAVhSqofM_q0mbAQADAgADeQADNgQ.png"><br>如图中，客户端ID列表与Redis存储键的指针具有映射关系。而Redis键对象的指针对应的就是内存地址，数据结构是Long。<br>当开启了track 功能之后，操作具有以下特性：</p><ul><li>当Redis获取一个键值信息时，radix tree 会调用 enableTracking 方法记录 key 和 clientId 的映射关系，记录到 TrackingTable 中。</li><li>当Redis删除或者修改一个键值信息时<ul><li>radix tree 根据key调用 trackingInvalidateKey 方法查找对应的 Clinet ID</li><li>调用 sendTrackingMessage 方法把失效的键值信息（invalidate 消息） 发送给这些 Clinet ID。</li><li>发送完成之后从TrackingTable中删除映射关系。</li></ul></li><li>Client关闭 track 功能后，遇到大量删除操的时候，一般是懒删除，只将 CLIENT_TRACKING 标志位删除。</li><li>默认 track 模式是不开启，需要通过命令开启，参考如下：</li></ul><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CLIENT TRACKING <span class="keyword">ON</span>|<span class="keyword">OFF</span></span><br><span class="line">+OK</span><br><span class="line"><span class="keyword">GET</span> test</span><br><span class="line">$<span class="number">7</span></span><br><span class="line">archite</span><br></pre></td></tr></table></figure><h2 id="2-2-广播模式-BCAST"><a href="#2-2-广播模式-BCAST" class="headerlink" title="2.2 广播模式(BCAST)"></a>2.2 广播模式(BCAST)</h2><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAIBEWlIt6j21NwlVX-E2bo6hCE8EnUGAAJWDGsbp6dAVoScejMbPwrHAQADAgADeQADNgQ.png"><br>广播模式与普通模式类似，也是采用映射关系来对照，但实现过程还是有区别的：</p><ul><li>存储的内容不一样：如图，采用Prefix Table 来存储客户端数据，存储的是 <strong>前缀字符串指针 和 客户端数据（客户端ID列表 + 需通知的key值列表）</strong> 的映射关系。</li><li>删除键值的时机不一样：<ul><li>radix tree 根据key调用 trackingInvalidateKey 方法查找PrefixTable。</li><li>判断是否为空，不为空则 调用 trackingRememberKeyToBroadcast 对键列表进行进行遍历，找到符合前缀匹配规则的，并记录位置。</li><li>在事件处理周期函数 beforeSleep 中 调用 trackingBroadcastInvalidationMessages 函数来发送消息。</li><li>发送完成之后从 PrefixTable 中删除映射关系。</li></ul></li></ul><h2 id="2-3-转发模式"><a href="#2-3-转发模式" class="headerlink" title="2.3 转发模式"></a>2.3 转发模式</h2><p>RESP 3 协议 是 Redis 6.0 新启用的协议，使用普通模式或者广播模式需要依赖这种协议，这样对于RESP 2 协议的客户端来说就会有问题。所以衍生除了另一种模式：重定向（redirect）。</p><ul><li>RESP 2 无法直接 PUSH 失效消息，所以不能直接获取到失效数据（Redis Client 2）。</li><li>支持 RESP 3 协议的客户端（Redis Clinet 1） 告诉 Server 将失效消息通过 Pus&#x2F;Sub 通知给 RESP 2 客户端。</li><li>而Redis Client 2 （RESP 2 ）是通过订阅命令 SUBSCRIBE，专门订阅用于发送失效消息的频道 <em>redis</em>:invalidate。<br><img src="https://img2022.cnblogs.com/blog/167509/202209/167509-20220922123030401-37890328.png" alt="image"></li></ul><p>如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Redis Client 2 （支持RESP 2）执行订阅 </span><br><span class="line">client id : 888</span><br><span class="line">subscribe _redis_:invalidate</span><br><span class="line"></span><br><span class="line"># Redis Client 1（支持RESP 3），转发给 2</span><br><span class="line">client tracking on bcast redirect 888</span><br></pre></td></tr></table></figure><h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h1><h2 id="3-1-默认模式（普通模式）"><a href="#3-1-默认模式（普通模式）" class="headerlink" title="3.1 默认模式（普通模式）"></a>3.1 默认模式（普通模式）</h2><ul><li>服务端记录客户端操作过的 key，key 对应的值发生变化时，会发送 Invalidation Messages 给Redis 客户端。</li><li>服务端记录key信息会消耗一些内存，但是发送失效消息的范围，限制在存储的key范围内，计算和网络传输变的轻量。</li><li>优点是节省 CPU 以及流量带宽，但是会占用一些内存。</li></ul><h2 id="3-2-广播模式"><a href="#3-2-广播模式" class="headerlink" title="3.2 广播模式"></a>3.2 广播模式</h2><ul><li>服务端不记录 key，而是订阅 key 的特定前缀，当匹配前缀的 key 的值改变时，发送 Invalidation Messages 给 Redis客户端。</li><li>优点是服务端的内存消耗少，但是会损耗更多的 CPU 去做前缀匹配的计算。</li></ul><h2 id="3-3-转发模式"><a href="#3-3-转发模式" class="headerlink" title="3.3 转发模式"></a>3.3 转发模式</h2><ul><li>为了兼容 resp2 协议的一种过渡模式</li><li>优点是占用内存少，CPU占用多</li></ul><h2 id="客户端的缓存"><a href="#客户端的缓存" class="headerlink" title="客户端的缓存"></a>客户端的缓存</h2><p>客户端缓存，需要业务侧自己实现，Redis 服务端只负责通知你key 的变动（删除、新增）。</p>]]></content>
      
      
      <categories>
          
          <category> 架构与思维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis缓存 </tag>
            
            <tag> 缓存击穿 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>架构与思维-一次缓存雪崩的灾难复盘-转载</title>
      <link href="/2025/04/26/%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%80%9D%E7%BB%B4/%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%80%9D%E7%BB%B4-%E4%B8%80%E6%AC%A1%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E7%9A%84%E7%81%BE%E9%9A%BE%E5%A4%8D%E7%9B%98/"/>
      <url>/2025/04/26/%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%80%9D%E7%BB%B4/%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%80%9D%E7%BB%B4-%E4%B8%80%E6%AC%A1%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E7%9A%84%E7%81%BE%E9%9A%BE%E5%A4%8D%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<h3 id="1-真实案例"><a href="#1-真实案例" class="headerlink" title="1 真实案例"></a>1 真实案例</h3><p>云办公系统用户实时信息查询功能优化发布之后，系统发生宕机事件（系统挂起，页面无法加载）。</p><h4 id="1-1-背景"><a href="#1-1-背景" class="headerlink" title="1.1 背景"></a>1.1 背景</h4><p>我们IM原有的一个功能，当鼠标移动到用户头像的时候，会显示出用户的基本信息。信息比较简单，只包含简单的用户名、昵称、性别、邮箱、电话等基本数据，</p><p>这是一个典型的数据查询，大概过程如下左侧，访问用户基本信息的时候会先去Redis中查一下，如果不存在，就把大约2W左右的用户数据一次性取出来，保存在Redis中，因为用户基本信息在同一张表上，用户信息表的数据量也很少，所以一直也没什么问题。</p><p>过程如下图左侧所示。</p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAOSaUNrStEM8GAZEw1aXHsLidz7AAEdAAKFC2sb74wYVpM-hgZIuF_XAQADAgADeQADNgQ.png" alt="点击查看大图"> </p><p>后续对功能做了优化，原有采集的信息除了用户的基本信息之外，还采集了教育经历、工作经历、所获勋章等。</p><p>这些信息存储在不同的表里面，所以采集过程是一个复杂的联表查询，特别是有些基础表数据量比较大，执行效率也是比较慢的。</p><p>如果把所有用户全部取出来并存储在一个Redis节点中，明显已经不适用，一个是批量查询导致数据库执行效率慢，一个是Redis单节点数据太大。</p><p>所以开发同学做了下优化，每次只取单个用户的综合信息存在Redis中，一个用户建一个缓存，如上图右侧所示。 </p><h4 id="1-2-问题处理"><a href="#1-2-问题处理" class="headerlink" title="1.2 问题处理"></a>1.2 问题处理</h4><p>这种做法看着没啥问题，当晚发布后，在第二天的上午10点~11点就发生了系统瓶颈卡顿，最后挂起的情况，数据库的内存、CPU全部飙上去了。</p><p>第一时间的处理方法是降级，程序回滚到之前只提供基本信息的阶段，其他的前端默认显示空信息。接着就是对问题进行分析了，后确认原因是产生了 缓存雪崩了。</p><p>新发布的系统，缓存池是空的，在早上10点高峰期的时候，大量的人员到IM上进行访问，系统开始初次建立每个人的缓存信息，大量的请求查询不到缓存，直接透过缓存池投向数据库，造成瞬时DB请求量井喷。这是典型的缓存雪崩了。 </p><p>同时因为，失效时间相近（8小时失效），所以也有潜在的缓存雪崩。</p><p>应急处理方案：适当处理缓存的机制，采用布隆过滤器、空初始值、随机缓存失效时间方式来预防缓存击穿和缓存雪崩的产生。</p><p>最终解决方案：改回原来缓存全公司员工信息的方式，根据执行计划和SlowLog，优化获取员工信息的SQL脚本，去掉不需要的字段和无意义的连接。  </p><h3 id="2-缓存雪崩"><a href="#2-缓存雪崩" class="headerlink" title="2 缓存雪崩"></a>2 缓存雪崩</h3><h4 id="2-1-概念"><a href="#2-1-概念" class="headerlink" title="2.1 概念"></a>2.1 概念</h4><p>缓存雪崩是指大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。</p><p>上面的哪个问题，初次访问的数据都是未建立缓存的，跟同时失效的情况一样，当峰值期到来的时候，会大量的请求查询不到缓存，直接透过缓存池投向数据库，造成瞬时DB请求量井喷。</p><h4 id="2-2-解决方案分析"><a href="#2-2-解决方案分析" class="headerlink" title="2.2 解决方案分析"></a>2.2 解决方案分析</h4><h5 id="2-2-1-缓存集群-数据库集群"><a href="#2-2-1-缓存集群-数据库集群" class="headerlink" title="2.2.1 缓存集群+数据库集群"></a>2.2.1 缓存集群+数据库集群</h5><p>在系统容量设计的时候，应该能够预见后期会有大量的请求，所以在发生雪崩前对缓存集群实现高可用，如果是使用 Redis，可以使用 主从+哨兵 ，Redis Cluster 来避免 Redis 全盘崩溃的情况。</p><p>同样的，也需要对数据库进行高可用保障，因为透过缓存之后，真正考验的是数据库的抗压能力。所以 1主N从 甚至 数据库集群 是我们需要重点去考虑的。</p><h5 id="2-2-2-适当的限流、降级"><a href="#2-2-2-适当的限流、降级" class="headerlink" title="2.2.2 适当的限流、降级"></a>2.2.2 适当的限流、降级</h5><p>可以使用 Hystrix进行限流 + 降级 ，比如像上面那种情况，一下子来了1W个请求，不是当前系统的吞吐能力能够承受的，假设单秒TPS的能力只能是 5000个，那么剩余的 5000 请求就可以走限流逻辑。</p><p>可以设置一些默认值，然后调用我们自己降级逻辑去FallBack，保护最后的 MySQL 不会被大量的请求挂起。 除了Hystrix之外，阿里的Sentinel 和 Google的RateLimiter 都是不错的选择。</p><p>Sentinel 漏桶算法</p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAORaUNo2vGaEIssuWq0s3YTfWIgg7IAAoELaxvvjBhWeZNiSpfK6CMBAAMCAAN4AAM2BA.png" alt="漏桶算法示意图"></p><p>RateLimiter 令牌桶算法</p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAOQaUNo0Kyo6SNINz3yCJwE49w_YHQAAoALaxvvjBhWf9cbHvF-SrYBAAMCAAN4AAM2BA.png" alt="令牌桶算法"> </p><p>另外可以考虑使用用本地缓存来进行缓冲，在 Redis Cluster 不可用的时候，不至于全线崩溃。</p><h5 id="2-2-3-随机过期时间"><a href="#2-2-3-随机过期时间" class="headerlink" title="2.2.3 随机过期时间"></a>2.2.3 随机过期时间</h5><p>可以给缓存设置过期时间时加上一个随机值时间，使得每个key的过期时间分布开来，不会集中在同一时刻失效。</p><p>随机值我们团队的做法是：n * 3&#x2F;4 + n * random() 。所以，比如你原本计划对一个缓存建立的过期时间为8小时，那就是6小时 + 0~2小时的随机值。</p><p>这样保证了均匀分布在 6~8小时之间。如图： </p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAOPaUNosuZTM5re2ZEgCalk6Tr-h2kAAn8LaxvvjBhWkQxl3WUd_04BAAMCAAN5AAM2BA.png"> </p><h5 id="2-2-4-缓存预热"><a href="#2-2-4-缓存预热" class="headerlink" title="2.2.4 缓存预热"></a>2.2.4 缓存预热</h5><p>类似上面的那个案例，并不是还没过期，而是新功能发布，压根还没建设过缓存，所以可以在峰值期之前先做好部分缓存，避免瞬时压力太大。</p><p>所以如果10点是峰值期，那么可以预先在8~10点期间，可以逐渐的把大部分缓存建立起来。如图：</p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAOOaUNoMFfGNqeYWe_ajj1hCecCLvEAAn4LaxvvjBhWV8TGUBYzJQABAQADAgADeQADNgQ.png" alt="缓存预热"></p><h3 id="3-缓存穿透"><a href="#3-缓存穿透" class="headerlink" title="3 缓存穿透"></a>3 缓存穿透</h3><h4 id="3-1-概念"><a href="#3-1-概念" class="headerlink" title="3.1 概念"></a>3.1 概念</h4><p>缓存穿透是指访问一个不存在的key，缓存不起作用，请求会穿透到DB，流量井喷时会导致DB挂掉。</p><p>比如 我们查询用户的信息，程序会根据用户的编号去缓存中检索，如果找不到，再到数据库中搜索。如果你给了一个不存在的编号：XXXXXXXX，那么每次都比对不到，就透过缓存进入数据库。</p><p>这样风险很大，如果因为某些原因导致大量不存在的编号被查询，甚至被恶意伪造编号进行攻击，那将是灾难。</p><h4 id="3-2-解决方案分析"><a href="#3-2-解决方案分析" class="headerlink" title="3.2 解决方案分析"></a>3.2 解决方案分析</h4><h5 id="3-2-1-缓存空值"><a href="#3-2-1-缓存空值" class="headerlink" title="3.2.1 缓存空值"></a>3.2.1 缓存空值</h5><p>发生穿透的原因是缓存中没有存储这些空数据的key，或者压根这个数据的key是不会存在的，从而导致每次查询都进入数据库中。</p><p>我们就可以将这些key的值设置为null，并写到缓存池中。后面再出现查询这个key 的请求的时候，直接返回null，这样就在缓存池中就被判断返回了，压力在缓存层中，不会转移到数据库上。</p><h5 id="3-2-2-BloomFilter"><a href="#3-2-2-BloomFilter" class="headerlink" title="3.2.2 BloomFilter"></a>3.2.2 BloomFilter</h5><p>我们称作布隆过滤器，BloomFilter 类似于一个hbase set 用来判断某个元素（key）是否存在于某个集合中。</p><p>这种方式在大数据场景应用比较多，比如 Hbase 中使用它去判断数据是否在磁盘上。还有在爬虫场景判断url 是否已经被爬取过。</p><p>这种方案可以加在第一种方案中，在缓存之前在加一层 BloomFilter ，把存在的key记录在BloomFilter中，在查询的时候先去 BloomFilter 去查询 key 是否存在，如果不存在就直接返回，存在再走查缓存 ，投入数据库去查询，这样减轻了数据库的压力。</p><p>流程图如下：</p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAONaUNn-RoiZBilZC2JiE4w-2KQuVAAAn0LaxvvjBhW7zzsEn3GhWIBAAMCAAN5AAM2BA.png" alt="布隆过滤器"></p><h5 id="3-2-3-两种方案的选择判断"><a href="#3-2-3-两种方案的选择判断" class="headerlink" title="3.2.3 两种方案的选择判断"></a>3.2.3 两种方案的选择判断</h5><p>前面说过，可能会存在一些恶意攻击，伪造出大量不存在的key ，这种情况下如果我们如果采用缓存空值的办法，就会产生大量不存在key的null数据。显然是不合适的，这时我们完全可以使用第二种方案进行过滤掉这些key。</p><p>所以，判断的依据是：</p><ul><li>针对key非常多、请求重复率比较低的数据，我们就没有必要进行缓存，使用 BloomFilter 直接过滤掉。</li><li>而对于空数据的key有限的，重复率比较高的，我们则可以采用 缓存空值的办法 进行处理。</li></ul><h3 id="4-缓存击穿"><a href="#4-缓存击穿" class="headerlink" title="4 缓存击穿"></a>4 缓存击穿</h3><h4 id="4-1-概念"><a href="#4-1-概念" class="headerlink" title="4.1 概念"></a>4.1 概念</h4><p>一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到DB，造成瞬时DB请求量大、压力骤增。（注意跟上面两种的区别）</p><h4 id="4-2-解决方案"><a href="#4-2-解决方案" class="headerlink" title="4.2 解决方案"></a>4.2 解决方案</h4><h5 id="4-2-1-锁的方式"><a href="#4-2-1-锁的方式" class="headerlink" title="4.2.1 锁的方式"></a>4.2.1 锁的方式</h5><p>分布式锁场景，在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。</p><p>这种现象是多个线程同时去查询数据库的这条数据，那么我们可以在第一个查询数据的请求上使用一个 互斥锁来锁住它。</p><p>其他的线程走到这一步拿不到锁就等着，等第一个线程查询到了数据，然后做缓存。后面的线程进来发现已经有缓存了，就直接走缓存。</p><p>锁不好的地方就是在其他线程在拿不到锁的时候就等待，这个会造成系统整体吞吐量降低，用户体验度也不好。</p><h5 id="4-2-2-空初始值"><a href="#4-2-2-空初始值" class="headerlink" title="4.2.2 空初始值"></a>4.2.2 空初始值</h5><p>这是一种短暂降级的方式：</p><p>如果一个缓存失效的时候，有无数个请求狂奔而来，而第一个请求从进入缓存池，判空，再到数据库检索，再查询出结果并返回设置缓存的这个过程里，缓存是不存在的。</p><p>这个就很危险，超高并发下这个短暂的过程足已让千千万万请求投向数据库。更别提这可能是个慢查询，整个过程可能长达2s以上，那对数据库是一种非常大的伤害。</p><p>业内有一种做法叫<strong>做空初始值</strong>，短暂的局部降级来保证整个数据库系统不被击穿。大概流程如下：</p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAOMaUNnx-aLS7RqNCWuzgeYFQ5SINEAAnwLaxvvjBhWYxUFS6a-V9MBAAMCAAN3AAM2BA.png" alt="空初始值"> </p><p>可以看出，整个过程中我们牺牲了A、B、C、D的请求，他们拿回了一个空值或者默认值，但是这局部的降级却保证整个数据库系统不被拥堵的请求击穿。</p>]]></content>
      
      
      <categories>
          
          <category> 架构与思维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维调优 </tag>
            
            <tag> Redis缓存 </tag>
            
            <tag> 缓存雪崩 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>架构与思维：再聊缓存击穿，面试是一场博弈</title>
      <link href="/2025/04/26/%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%80%9D%E7%BB%B4/%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%80%9D%E7%BB%B4-%E5%86%8D%E8%81%8A%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%EF%BC%8C%E9%9D%A2%E8%AF%95%E6%98%AF%E4%B8%80%E5%9C%BA%E5%8D%9A%E5%BC%88/"/>
      <url>/2025/04/26/%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%80%9D%E7%BB%B4/%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%80%9D%E7%BB%B4-%E5%86%8D%E8%81%8A%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%EF%BC%8C%E9%9D%A2%E8%AF%95%E6%98%AF%E4%B8%80%E5%9C%BA%E5%8D%9A%E5%BC%88/</url>
      
        <content type="html"><![CDATA[<h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h1><p>在之前的一篇文章《<a href="https://yeoh.qzz.io/2025/03/20/%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%80%9D%E7%BB%B4/%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%80%9D%E7%BB%B4%E4%B8%80%E6%AC%A1%E9%9B%AA%E5%B4%A9%E7%9A%84%E7%81%BE%E9%9A%BE%E5%A4%8D%E7%9B%98/">架构与思维-一次雪崩的灾难复盘-转载 | 数根朽木，</a>》中，我们比较清晰的描述了缓存雪崩、穿透、击穿的各自特征和解决方案，想详细了解的可以移步。</p><p>最近在配合HR筛选候选人，作为大厂的业务方向负责人，招人主要也是我们自己团队在用，而缓存是必不可少的面试选项之一。下面我们就来聊一聊在特定业务场景下缓存击穿和雪崩的应对场景！</p><h1 id="2-问题背景"><a href="#2-问题背景" class="headerlink" title="2 问题背景"></a>2 问题背景</h1><ul><li>一个核心的应用或者服务（比如微信、钉钉、百度APP），高峰QPS是百万甚至是千万</li></ul><hr><p>★ 分析：上述类型的应用具有很明显的峰值 高斯分布的特征，就是9~10点是用户早高峰。微信是，百度APP是，钉钉也是，钉钉一般给政企、教学等使用，通用是10点左右峰值期，每天的峰值如下：<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAIBEmlIuRCM4JBQZHj9PoY3d6vSh0guAAJZDGsbp6dAVi5JVrusEjMXAQADAgADdwADNgQ.png"></p><hr><ul><li>应用缓存了用户的基本信息，如（姓名、性别、职业、地址等），假设以为用户Id为Cache的key，那每个用户都有一个基础信息的缓存。</li><li>因为不知名的原因，导致缓存都丢了（可能是缓存集体过期、故障导致缓存失效、程序bug导致缓存误删、服务器重启导致内存清理）。</li><li>恰巧是访问高峰期（比如9点早高峰），千百万的请求狂奔而来，查不到缓存，透过缓存层直接投入数据库。</li><li>基于磁盘的数据库的访问效率，性能，抗击打能力远逊于高速缓存，数据库很容易被打垮，造成服务雪崩。</li></ul><h1 id="4-候选人的各种答案（综合整理）"><a href="#4-候选人的各种答案（综合整理）" class="headerlink" title="4 候选人的各种答案（综合整理）"></a>4 候选人的各种答案（综合整理）</h1><h2 id="4-1-缓存预热"><a href="#4-1-缓存预热" class="headerlink" title="4.1 缓存预热"></a>4.1 缓存预热</h2><p>既然是可预见的峰值期，那么缓存预热是一个好办法，比如在9 ~ 10点是高峰期，在7 ~ 9点这两个小时中，可以均匀的把部分缓存做上。<br><img src="https://img2023.cnblogs.com/blog/167509/202212/167509-20221203171638611-1566747048.png" alt="image"></p><p>缺点：这种仅仅只能解决可预见的缓存失效情况。如果是突发缓存失效情况，假设在10点高峰期因为某些原因（比如上面说的 故障导致缓存失效、程序bug导致缓存误删、服务器重启导致内存清理）是没有效果的。</p><h2 id="4-2-非一致的过期时间"><a href="#4-2-非一致的过期时间" class="headerlink" title="4.2 非一致的过期时间"></a>4.2 非一致的过期时间</h2><p>缓存既然大部分是在高峰期（9~10点）创建的（假设Cache的Expire Time都一样，比如8h），那很有可能失效时间会很接近。几乎同一时间一起失效，这样确实也会引起群起创建的情况，也会导致上面说的击穿的情况发生。</p><p>我们在创建同一类型的批次缓存的时候，会采用3-4-3 分布原则。比如一个缓存的Expire Time 是 10H，<br>那么就是3H + 4H * random() + 3h ,来进行错开！<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAIBE2lIuUP299AsOMgnCYm3s98t4NKVAAJaDGsbp6dAVslhFQ3NZtIoAQADAgADeQADNgQ.png"></p><p>缺点：同4.1类似，仅仅解决可预见的问题，对突发故障导致的无预期的缓存失效毫无办法。</p><h2 id="4-3-消息聚合缓存"><a href="#4-3-消息聚合缓存" class="headerlink" title="4.3 消息聚合缓存"></a>4.3 消息聚合缓存</h2><p>为什么每个用户的基本信息都独立存储一个缓存呢？可不可以按照用户类型分片，一类的用户合在一起不是只要查询一次，不会出现峰值期群起攻击数据库的情况。</p><p>说明：只有信息修改率非常低的缓存才适合聚合在一个缓存值中，大部分情况下不会这么做。比如你的缓存中聚合了1W个人的信息，Value非常大，但凡其中一个信息修改，那么这个缓存就要更新，不然应用读取到的信息就没有时效性，大Value的缓存频繁的存取是一个很不友好的事情。</p><p>用户信息还算修改频率比较低的，你的积分信息，购物车可是很高频变动的，这种的就不能这么干了。</p><h2 id="4-4-削峰、加锁、限流"><a href="#4-4-削峰、加锁、限流" class="headerlink" title="4.4 削峰、加锁、限流"></a>4.4 削峰、加锁、限流</h2><h3 id="4-4-1-削峰"><a href="#4-4-1-削峰" class="headerlink" title="4.4.1 削峰"></a>4.4.1 削峰</h3><p>引进消息队列之类的中间件，将用户的请求放入队列，逐一执行，避免拥挤请求！</p><h3 id="4-4-2-加锁"><a href="#4-4-2-加锁" class="headerlink" title="4.4.2 加锁"></a>4.4.2 加锁</h3><p>同一个用户的信息查询只让第一个请求进入，进入之后加锁，在获取到数据库信息并更新缓存之后释放锁，<br>这样单一个信息只请求一次！</p><h3 id="4-4-3-限流"><a href="#4-4-3-限流" class="headerlink" title="4.4.3 限流"></a>4.4.3 限流</h3><p>为了避免把服务端打挂，在上线前做一次无缓存压测，看数据库与服务端能支撑的最大值。并设置成限流的阈值，保证不会超过服务所能承载的压力，避免过载！</p><p>缺点：</p><ul><li>但凡用锁，排队之类的方案，无一例外的会大幅度降低服务的吞吐率，造成用户长时间等待，体验感下降，这在各大型APP（淘宝、微信、百度APP）上是完全不允许的，也不会这么干。</li><li>限流也是一样的道理，限流一般是对服务的限流，而难以细粒度到只对某个信息类型的限流。而服务级别限流会误伤其他操作，比如获取排班、排课、获取购物车等非瓶颈的宽松的查询也被限了。当然，现在的限流也可以细粒度到某个或者某几个接口，所以可以将查询用户信息合在一个接口里做一下限流。但是限流也代表部分用户拿不到正确的信息，是一种降级的行为。</li></ul><p>备注：数据库也有限流方案，细粒度到这个层级更好</p><h2 id="4-5-短暂降级之备选缓存"><a href="#4-5-短暂降级之备选缓存" class="headerlink" title="4.5 短暂降级之备选缓存"></a>4.5 短暂降级之备选缓存</h2><p>你的缓存层存在主备场景，他们之间定时异步同步，所以存在短暂数据不一致。</p><p>当你的主服务挂了之后，降级去读备服务，数据时效性没那么高，但是也避免了数据库被打穿的情况发生。<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAIBFGlIuV-xE_JI58QmvgqbVE74ae6CAAJbDGsbp6dAVv_wYZ85b3WpAQADAgADeQADNgQ.png"></p><h2 id="4-6-短暂降级值客户端缓存（Redis-6-0）"><a href="#4-6-短暂降级值客户端缓存（Redis-6-0）" class="headerlink" title="4.6 短暂降级值客户端缓存（Redis 6.0）"></a>4.6 短暂降级值客户端缓存（Redis 6.0）</h2><p>参考Redis 6.0的 Client Side Cache，看我这篇《<a href="https://yeoh.qzz.io/2025/04/20/%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%80%9D%E7%BB%B4/%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BC%93%E5%AD%98%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%9D%A9%E5%91%BD/">客户端缓存带来的革命 | 数根朽木，</a>》。</p><p>类似4.5做法，客户端缓存时效性会差一点，毕竟存在订阅跟同步的过程，数据没那么新。但是避免大量的请求直接上缓存服务，又因无效的缓存服务有把压力转移给数据库。<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAIBCmlItiOaRxopkiXnIHpovyJMiBgWAAJPDGsbp6dAVpLv560RB0nBAQADAgADeAADNgQ.png"></p><h2 id="4-7-短暂降级之空初始值"><a href="#4-7-短暂降级之空初始值" class="headerlink" title="4.7 短暂降级之空初始值"></a>4.7 短暂降级之空初始值</h2><p>这是一种短暂降级的方式，大概流程如下：<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAIBCWlItgI7jEh-Gv5RHqNBkt0hy4jCAAJODGsbp6dAVjLLJs8fSmVxAQADAgADdwADNgQ.png"></p><p>可以看出，整个过程中我们牺牲了A、B、C、D的请求，他们拿回了一个空值或者默认值，但是这局部的降级却保证整个数据库系统不被拥堵的请求击穿。</p><h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h1><p>在不同的场景下各种方法都有各自的优缺点，我们要做的就是根据实际的应用场景来判断和抉择。</p>]]></content>
      
      
      <categories>
          
          <category> 架构与思维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis缓存 </tag>
            
            <tag> 缓存击穿 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL系列：主从复制的原理和实践</title>
      <link href="/2025/04/25/MySQL%E7%B3%BB%E5%88%97/MySQL%E7%B3%BB%E5%88%97-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E8%B7%B5/"/>
      <url>/2025/04/25/MySQL%E7%B3%BB%E5%88%97/MySQL%E7%B3%BB%E5%88%97-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>主从复制，是指建立一个和主数据库完全一样的数据库环境（称为从数据库），并将主库的操作行为进行复制的过程：将主数据库的DDL和DML的操作日志同步到从数据库上，</p><p>然后在从数据库上对这些日志进行重新执行，来保证从数据库和主数据库的数据的一致性。</p><h3 id="为什么要做主从复制"><a href="#为什么要做主从复制" class="headerlink" title="为什么要做主从复制"></a>为什么要做主从复制</h3><p>1、在复杂的业务操作中，经常会有操作导致锁行甚至锁表的情况，如果读写不解耦，会很影响运行中的业务，使用主从复制，让主库负责写，从库负责读。</p><p>即使主库出现了锁表的情景，通过读从库也可以保证业务的正常运行。</p><p>2、保证数据的热备份，主库宕机后能够及时替换主库，保障业务可用性。</p><p>3、架构的演进：业务量扩大，I&#x2F;O访问频率增高，单机无法满足，主从复制可以做多库方案，降低磁盘I&#x2F;O访问的频率，提高单机的I&#x2F;O性能。</p><p>4、本质上也是分治理念，主从复制、读写分离即是压力分拆的过程。</p><p>5、读写比也影响整个拆分方式，读写比越高，主从库比例应越高，才能保证读写的均衡，才能保证较好的运行性能。读写比下的主从分配方法下：</p><table><thead><tr><th>读写比</th><th>主库</th><th>从库</th></tr></thead><tbody><tr><td>50：50</td><td>1</td><td>1</td></tr><tr><td>66.6：33.3</td><td>1</td><td>2</td></tr><tr><td>80：20</td><td>1</td><td>4</td></tr><tr><td>– –</td><td>– –</td><td>– –</td></tr></tbody></table><h3 id="主从复制的原理"><a href="#主从复制的原理" class="headerlink" title="主从复制的原理"></a>主从复制的原理</h3><p>当在从库上启动复制时，首先创建I&#x2F;O线程连接主库，主库随后创建Binlog Dump线程读取数据库事件并发送给I&#x2F;O线程，I&#x2F;O线程获取到事件数据后更新到从库的中继日志Relay Log中去，之后从库上的SQL线程读取中继日志Relay Log中更新的数据库事件并应用，</p><p>如下图所示：</p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAP1aUfWTcAYWYglr2mNtZ0znzK0-HYAAgELaxunp0BWMU5Y-2NUp0EBAAMCAAN4AAM2BA.png"></p><p>细化一下有如下几个步骤：</p><p>1、MySQL主库在事务提交时把数据变更（insert、delet、update）作为事件日志记录在二进制日志表（binlog）里面。</p><p>2、主库上有一个工作线程 binlog dump thread，把binlog的内容发送到从库的中继日志relay log中。</p><p>3、从库根据中继日志relay log重做数据变更操作，通过逻辑复制来达到主库和从库的数据一致性。</p><p>4、MySQL通过三个线程来完成主从库间的数据复制，其中binlog dump线程跑在主库上，I&#x2F;O线程和SQL线程跑在从库上。拥有多个从库的主库会为每一个连接到主库的从库创建一个binlog dump线程。 </p><h2 id="搭建主从实例"><a href="#搭建主从实例" class="headerlink" title="搭建主从实例"></a>搭建主从实例</h2><p>我们这边在个人PC机上进行MySQL主从复制的搭建测试，所以使用Docker会更方便。有如下优势：</p><p>1、可以节省资源。</p><p>2、相对于Docker来说，虚拟机搭建对机器配置有要求，且安装MySQL步骤繁琐。</p><p>3、一台机器上可以运行多个Docker容器，所以我们可以部署多个MySQL服务。</p><p>4、Docker容器之间相互独立，有独立ip，互不冲突</p><p>5、Docker使用步骤简便，启动容器在秒级别。</p><h3 id="Daocker安装"><a href="#Daocker安装" class="headerlink" title="Daocker安装"></a>Daocker安装</h3><p>我这边是mac机，以此作为示范。可以用Homebrew 进行安装，也可以手动下载安装。</p><p>手动下载的话可以点击以下链接下载 <a href="https://download.docker.com/mac/edge/Docker.dmg">Edge</a> Docker for Mac。</p><p>如同Mac OS 其它软件一样，安装也非常简单，双击下载的 .dmg 文件，然后将鲸鱼图标拖拽到 Application 文件夹即可。 </p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAP2aUfWY5HrfSRnmjk4Um1fYeGDvfEAAgILaxunp0BW21td2Mz9FrQBAAMCAAN3AAM2BA.png"></p><p>从应用中找到 Docker 图标并点击运行。去Docker Hub上去注册一个Docker ID，进行登录即可。</p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAP3aUfWceMxMGoHUFdyBP2OKhxvOUIAAgMLaxunp0BW6D2X2N5ksVUBAAMCAAN3AAM2BA.png"></p><p>打开终端，可以查看Docker相关的版本及相关信息。可以输入如下信息：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="comment"># 查看docker版本</span></span><br><span class="line"><span class="number">2</span> docker --version</span><br><span class="line"><span class="number">3</span> <span class="comment"># 查看docker基本信息</span></span><br><span class="line"><span class="number">4</span> docker info </span><br></pre></td></tr></table></figure><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAP4aUfWfNtVlTvS0eOBaBP_BPtYBTIAAgQLaxunp0BWoMUf6pKGthABAAMCAAN4AAM2BA.png"></p><h3 id="搭建主从服务器"><a href="#搭建主从服务器" class="headerlink" title="搭建主从服务器"></a>搭建主从服务器</h3><p>1、拉取docker的MySQL镜像，这边以5.7的版本为准：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> docker pull mysql:<span class="number">5.7</span>    </span><br></pre></td></tr></table></figure><p>2、使用此镜像启动主库容器：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> docker <span class="keyword">run</span><span class="language-bash"> -p 3307:3306 --name master -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7 </span></span><br></pre></td></tr></table></figure><p>从这边可以看出，Master主库容器对外映射的端口是3307，账号默认root，密码是123456，执行完之后，docker中运行了一个名为master的MySQL实例。</p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAP5aUfWi8_TDkwpgAvcRhiLkJojoiwAAgULaxunp0BWhe9JsqXtFXwBAAMCAAN5AAM2BA.png"></p><p>docker容器是相互独立的，每个容器有其独立的ip，所以不同容器使用相同的端口并不会冲突。这里我们应该尽量使用mysql默认的3306端口，否则可能会出现无法通过ip连接docker容器内mysql的问题。</p><p>因为容器内的3306端口映射的对外端口是3307，所以外部主机可以通过 宿主机ip:3307 访问到MySQL的服务，而实际是访问容器内MySQL的3306端口，密码就是我们前面设置好的123456。</p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAP6aUfWlGmlgl1ZCpRUCuDviJbEWkwAAgYLaxunp0BW5UMh2TQDbRQBAAMCAAN4AAM2BA.png"></p><p>登录完之后可以看到一个空库，这个就是我们在docker里面拉的MySQL镜像。</p><p>3、同样的道理，我们继续建一个slave（从库）的MySQL实例。注意名称为slave，端口为3308</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> docker <span class="keyword">run</span><span class="language-bash"> -p 3308:3306 --name slave -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7 </span></span><br></pre></td></tr></table></figure><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAP7aUfWoOaN3sseqZV56cLN8Qhh62wAAgcLaxunp0BWkD7_xGURL18BAAMCAAN5AAM2BA.png"></p><p>4、主从都搭建完成之后，我们可以使用  docker ps 来查看当前运行的容器信息，如下：</p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAP8aUfWqYgei8JGioHpna_AdSrc6UQAAggLaxunp0BWWtXaZ1WSk7MBAAMCAAN5AAM2BA.png"></p><p>注意下第一个参数为 container id，是我们后续进入服务进行配置的容器识别编号。 </p><h3 id="配置主服务器（Master）"><a href="#配置主服务器（Master）" class="headerlink" title="配置主服务器（Master）"></a>配置主服务器（Master）</h3><p>首先，进入到 Master 服务器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 wengzhihua@B000000147796DS ~ % docker exec -it 777fe9ce7f9d /bin/bash</span><br><span class="line">2 root@777fe9ce7f9d:/# </span><br></pre></td></tr></table></figure><p>这边注意：777fe9ce7f9d 是 master 的 container id，然后查看MySQL的状态。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 root@777fe9ce7f9d:/# service mysql status</span><br><span class="line">2 [info] MySQL Community Server 5.7.35 is running.</span><br></pre></td></tr></table></figure><p>然后到MySQL的目录下去修改配置，切换到&#x2F;etc&#x2F;mysql目录下，然后 vi my.cnf 对my.cnf进行编辑：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 root@777fe9ce7f9d:/# cd /etc/mysql</span><br><span class="line">2 root@777fe9ce7f9d:/etc/mysql# vi my.cnf</span><br><span class="line">3 bash: vi: command not found </span><br></pre></td></tr></table></figure><p>此时会报出 bash: vi: command not found ，需要我们在docker容器内部自行安装vim。我们使用 apt-get install vim 命令来安装vim</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 root@777fe9ce7f9d:/etc/mysql# apt-get install vim</span><br><span class="line">2 Reading package lists... Done</span><br><span class="line">3 Building dependency tree       </span><br><span class="line">4 Reading state information... Done</span><br><span class="line">5 E: Unable to locate package vim </span><br></pre></td></tr></table></figure><p>这边又提示 Unable to locate package vim。</p><p>执行 apt-get update ，然后再次执行 apt-get install vim 即可成功安装vim。</p><p>然后我们就可以使用vim编辑my.cnf，在my.cnf中添加如下配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> 1 [mysqld]</span><br><span class="line"> 2 ## 设置server_id，一般设置为IP，同一局域网内使用唯一值即可，注意要保证唯一，这边我们暂且使用主库的映射端口，方便识别</span><br><span class="line"> 3 server_id=3307  </span><br><span class="line"> 4 ## 复制过滤：也就是指定哪个数据库不用同步（mysql库一般不同步）</span><br><span class="line"> 5 binlog-ignore-db=mysql  </span><br><span class="line"> 6 ## 开启二进制日志功能，可以随便取，最好有含义（关键就是这里了）</span><br><span class="line"> 7 log-bin=test-mysql-bin  </span><br><span class="line"> 8 ## 为每个session 分配的内存，在事务过程中用来存储二进制日志的缓存</span><br><span class="line"> 9 binlog_cache_size=1M  </span><br><span class="line">10 ## 主从复制的格式（mixed,statement,row，默认格式是statement）</span><br><span class="line">11 binlog_format=mixed  </span><br><span class="line">12 ## 二进制日志自动删除/过期的天数。默认值为0，表示不自动删除。</span><br><span class="line">13 expire_logs_days=7  </span><br><span class="line">14 ## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。</span><br><span class="line">15 ## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致</span><br><span class="line">16 slave_skip_errors=1062   </span><br></pre></td></tr></table></figure><p>配置完成之后重启服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 service mysql restart </span><br></pre></td></tr></table></figure><p>这个命令会使得容器停止，重新启动就可以了。<br>接下来创建数据同步用户：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">root@777fe9ce7f9d:/etc/mysql# mysql -u root -p</span><br><span class="line">Enter password:</span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 2</span><br><span class="line">Server version: 5.7.35-log MySQL Community Server (GPL)</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2021, Oracle and/or its affiliates.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type &#x27;help;&#x27; or &#x27;\h&#x27; for help. Type &#x27;\c&#x27; to clear the current input statement.</span><br><span class="line"></span><br><span class="line">mysql&gt; CREATE USER &#x27;slave&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;123456&#x27;;</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO &#x27;slave&#x27;@&#x27;%&#x27;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure><p>这里主要是要授予用户 slave，REPLICATION SLAVE权限和REPLICATION CLIENT权限，用于同步数据。</p><h3 id="配置从服务器（Slave）"><a href="#配置从服务器（Slave）" class="headerlink" title="配置从服务器（Slave）"></a>配置从服务器（Slave）</h3><p>同主服务器一样的操作方式，先进入MySQL配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 wengzhihua@B000000147796DS ~ % docker exec -it d4ba5e063deb /bin/bash</span><br><span class="line">2 root@d4ba5e063deb:/# cd etc/mysql</span><br><span class="line">3 root@d4ba5e063deb:/etc/mysql# vi my.cnf  </span><br></pre></td></tr></table></figure><p>然后配置从库的信息： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">## 设置server_id，一般设置为IP,注意要唯一，这边我们使用从库的映射端口，方便识别</span><br><span class="line">server_id=3308</span><br><span class="line">## 复制过滤：也就是指定哪个数据库不用同步（mysql库一般不同步）</span><br><span class="line">binlog-ignore-db=mysql</span><br><span class="line">## 开启二进制日志功能，以备Slave作为其它Slave的Master时使用</span><br><span class="line">log-bin=test-mysql-slave1-bin</span><br><span class="line">## 为每个session 分配的内存，在事务过程中用来存储二进制日志的缓存</span><br><span class="line">binlog_cache_size=1M</span><br><span class="line">## 主从复制的格式（mixed,statement,row，默认格式是statement）</span><br><span class="line">binlog_format=mixed</span><br><span class="line">## 二进制日志自动删除/过期的天数。默认值为0，表示不自动删除。</span><br><span class="line">expire_logs_days=7</span><br><span class="line">## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。</span><br><span class="line">## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致</span><br><span class="line">slave_skip_errors=1062</span><br><span class="line">## relay_log配置中继日志</span><br><span class="line">relay_log=edu-mysql-relay-bin</span><br><span class="line">## log_slave_updates表示slave将复制事件写进自己的二进制日志</span><br><span class="line">log_slave_updates=1</span><br><span class="line">## 防止改变数据(除了特殊的线程)</span><br><span class="line">read_only=1</span><br></pre></td></tr></table></figure><p>配置完成之后重启服务  service mysql restart ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 root@d4ba5e063deb:/etc/mysql# service mysql restart</span><br><span class="line">2 [info] Stopping MySQL Community Server 5.7.35.</span><br><span class="line">3 ...</span><br><span class="line">4 [info] MySQL Community Server 5.7.35 is stopped.</span><br><span class="line">5 [info] Re-starting MySQL Community Server 5.7.35. </span><br></pre></td></tr></table></figure><p>跟上面一样，这个命令会使得容器停止，重新启动就可以了。 </p><h3 id="完成Master和Slave的连接"><a href="#完成Master和Slave的连接" class="headerlink" title="完成Master和Slave的连接"></a>完成Master和Slave的连接</h3><p>注意，需要保证 Master 和 Slave 除了不同步的数据库，其他数据库的数据要一致。<br>1、在 Master 进入 MySQL， 然后执行命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show master status;</span><br><span class="line">+----------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">| File                 | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |</span><br><span class="line">+----------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">| test-mysql-bin.000001 |      617 |              | mysql            |                   |</span><br><span class="line">+----------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>记录下 File 和 Position 字段的值，后面会用到。</p><p>2、然后再查询一下主从两个容器所对应的IP，主库对应 172.17.0.2，从库对应172.17.0.3：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wengzhihua@B000000147796DS ~ % docker ps</span><br><span class="line">CONTAINER ID   IMAGE       COMMAND                  CREATED       STATUS          PORTS                                                  NAMES</span><br><span class="line">d4ba5e063deb   mysql:5.7   &quot;docker-entrypoint.s…&quot;   5 hours ago   Up 19 minutes   33060/tcp, 0.0.0.0:3308-&gt;3306/tcp, :::3308-&gt;3306/tcp   slave</span><br><span class="line">777fe9ce7f9d   mysql:5.7   &quot;docker-entrypoint.s…&quot;   5 hours ago   Up 51 minutes   33060/tcp, 0.0.0.0:3307-&gt;3306/tcp, :::3307-&gt;3306/tcp   master</span><br><span class="line">wengzhihua@B000000147796DS ~ % docker inspect --format=&#x27;&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;&#x27; 777fe9ce7f9d</span><br><span class="line">172.17.0.2</span><br><span class="line">wengzhihua@B000000147796DS ~ % docker inspect --format=&#x27;&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;&#x27; d4ba5e063deb</span><br><span class="line">172.17.0.3</span><br></pre></td></tr></table></figure><p>3、然后到 Slave 中进入 mysql，执行命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; change master to master_host=&#x27;172.17.0.2&#x27;, master_user=&#x27;slave&#x27;, master_password=&#x27;123456&#x27;, master_port=3306, master_log_file=&#x27;test-mysql-bin.000001&#x27;, master_log_pos=617, master_connect_retry=30;  </span><br><span class="line">Query OK, 0 rows affected, 2 warnings (0.02 sec)</span><br></pre></td></tr></table></figure><p>大意就是在从库使用什么账号（slave）进行同步，同步的主库的IP（master_host）、密码（master_password）、端口（master_port）、binlog日志文件（master_log_file）以及其实同步的位置（master_log_pos）等，</p><p>理解下这个命令的各个参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">master_host: Master 的IP地址</span><br><span class="line">master_user: 在 Master 中授权的用于数据同步的用户，就我们之前在主库容器里创建的哪个slave用户</span><br><span class="line">master_password: 同步数据的用户的密码</span><br><span class="line">master_port: Master 的数据库的端口号，注意，这边是3306，不是3307，3307是映射外部宿主主机的，写成3307，会造成 Slave_IO_Running 一直是 Connecting 状态，在这边踩坑了</span><br><span class="line">master_log_file: 指定 Slave 从哪个日志文件开始复制数据，即上文中提到的 File 字段的值</span><br><span class="line">master_log_pos: 从哪个 Position 开始读，即上文中提到的 Position 字段的值</span><br><span class="line">master_connect_retry: 当重新建立主从连接时，如果连接失败，重试的时间间隔，单位是秒，默认是60秒。</span><br></pre></td></tr></table></figure><p>在 Slave 的 MySQL 终端执行查看主从同步状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show slave status \G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">               Slave_IO_State:</span><br><span class="line">                  Master_Host: 172.17.0.2</span><br><span class="line">                  Master_User: slave</span><br><span class="line">                  Master_Port: 3307</span><br><span class="line">                Connect_Retry: 30</span><br><span class="line">              Master_Log_File: edu-mysql-bin.000001</span><br><span class="line">          Read_Master_Log_Pos: 617</span><br><span class="line">               Relay_Log_File: edu-mysql-relay-bin.000001</span><br><span class="line">                Relay_Log_Pos: 4</span><br><span class="line">        Relay_Master_Log_File: edu-mysql-bin.000001</span><br><span class="line">             Slave_IO_Running: No</span><br><span class="line">            Slave_SQL_Running: No</span><br><span class="line">              Replicate_Do_DB:</span><br><span class="line">          Replicate_Ignore_DB:</span><br><span class="line">           Replicate_Do_Table:</span><br><span class="line">       Replicate_Ignore_Table:</span><br><span class="line">      Replicate_Wild_Do_Table:</span><br><span class="line">  Replicate_Wild_Ignore_Table:</span><br><span class="line">                   Last_Errno: 0</span><br><span class="line">                   Last_Error:</span><br><span class="line">                 Skip_Counter: 0</span><br><span class="line">          Exec_Master_Log_Pos: 617</span><br><span class="line">              Relay_Log_Space: 154</span><br><span class="line">              Until_Condition: None</span><br><span class="line">               Until_Log_File:</span><br><span class="line">                Until_Log_Pos: 0</span><br><span class="line">           Master_SSL_Allowed: No</span><br></pre></td></tr></table></figure><p>SlaveIORunning 和 SlaveSQLRunning 是No，表明 Slave 还没有开始复制过程。相反 SlaveIORunning 和 SlaveSQLRunning 是Yes表明已经开始工作了。</p><p>执行一下命令，开始启动主从同步,  Slave_IO_Running: Connecting, Slave_SQL_Running: Yes 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start slave; </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show slave status \G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">               Slave_IO_State: Waiting for master to send event</span><br><span class="line">                  Master_Host: 172.17.0.2</span><br><span class="line">                  Master_User: slave</span><br><span class="line">                  Master_Port: 3306</span><br><span class="line">                Connect_Retry: 30</span><br><span class="line">              Master_Log_File: edu-mysql-bin.000001</span><br><span class="line">          Read_Master_Log_Pos: 2351</span><br><span class="line">               Relay_Log_File: edu-mysql-relay-bin.000006</span><br><span class="line">                Relay_Log_Pos: 1259</span><br><span class="line">        Relay_Master_Log_File: edu-mysql-bin.000001</span><br><span class="line">             Slave_IO_Running: Yes</span><br><span class="line">            Slave_SQL_Running: Yes</span><br><span class="line">              Replicate_Do_DB:</span><br><span class="line">          Replicate_Ignore_DB:</span><br><span class="line">           Replicate_Do_Table:</span><br><span class="line">       Replicate_Ignore_Table:</span><br><span class="line">      Replicate_Wild_Do_Table:</span><br><span class="line">  Replicate_Wild_Ignore_Table:</span><br><span class="line">                   Last_Errno: 0</span><br><span class="line">                   Last_Error:</span><br><span class="line">                 Skip_Counter: 0</span><br><span class="line">          Exec_Master_Log_Pos: 2351</span><br><span class="line">              Relay_Log_Space: 1640</span><br><span class="line">              Until_Condition: None</span><br></pre></td></tr></table></figure><h3 id="验证同步是否成功："><a href="#验证同步是否成功：" class="headerlink" title="验证同步是否成功："></a>验证同步是否成功：</h3><p>1、我们在主服务这边创建一个test库，库下面创建了一个person表，并增加了一条数据。</p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAP0aUfVp_XS7pGNxW9zAAGqhNdwj83VAAKNDGsbp6c4ViCQOIncRFq0AQADAgADeAADNgQ.png"> </p><p>2、转到从库这边，马上就查询到数据了 </p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAPzaUfVnLp99ll36WFhYYjy9_wN-q8AAowMaxunpzhWo-EqQbVrpOMBAAMCAAN4AAM2BA.png"></p><h2 id="主从同步延迟解决方案"><a href="#主从同步延迟解决方案" class="headerlink" title="主从同步延迟解决方案"></a>主从同步延迟解决方案</h2><p>最近部门在招人，面试Java程序员的时候在数据库部分问的最频繁的问题就是这个，问题不难，不过很多候选人同学没办法比较完整的回答，跟今天的标题有点相关，我就放上来。</p><p>按照我们这边的要求，主从库同步应该是近实时的，极端情况下也不应该超过8s，如果超过，我们认为是有问题的。</p><ul><li>保证数据库处在最有状态下：优化系统配置（链接层或者存储引擎层）：最大连接数、允许错误数、允许超时时间、pool_size、log_size，保证内存、CPU、存储空间的扩容（硬件部分）。</li><li>业务量不多的情况下，不做读写分离。既然主从延迟是由于从库同步写库不及时引起的，那我们也可以在有主从延迟的地方改变读库方式，由原来的读从库改为读主库。当然这也会增加代码的一些逻辑复杂性。（部分业务读主库）</li><li>假如你的业务时间允许，你可以在写入主库的时候，确保数据都同步到从库了之后才返回这条数据写入成功，当然如果有多个从库，你也必须确保每个从库都写入成功。显然，这个方案对性能和时间的消耗是极大的，不推荐。</li><li>可以引入redis或者其他nosql数据库来存储我们经常会产生主从延迟的业务数据。当我在写入数据库的同时，我再写入一份到redis中。我们可以先去查看redis中是否有这个数据，如果有我们就可以直接从redis中读取这个数据。当数据真正同步到数据库中的时候，再从redis中把数据删除。</li><li>任何的服务器都是有吞吐量的限制的，没有任何一个方案可以无限制的承载用户的大量流量。所以我们必须估算好我们的服务器能够承载的流量上限是多少。达到这个上限之后，就要采取缓存，限流，降级的方式来应对我们的流量。这也是应对主从延迟的根本处理办法。</li><li>如果系统流量确实庞大，单纯的读写分离已经无法解决问题了，那么就应该对数据库进一步治理，垂直分区和水平分区是不错的方式，下一章我们会详细说说。</li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL系列：代码评审中的MySQL（团队规范）</title>
      <link href="/2025/04/25/MySQL%E7%B3%BB%E5%88%97/MySQL%E7%B3%BB%E5%88%97-%E4%BB%A3%E7%A0%81%E8%AF%84%E5%AE%A1%E4%B8%AD%E7%9A%84MySQL%EF%BC%88%E5%9B%A2%E9%98%9F%E8%A7%84%E8%8C%83%EF%BC%89/"/>
      <url>/2025/04/25/MySQL%E7%B3%BB%E5%88%97/MySQL%E7%B3%BB%E5%88%97-%E4%BB%A3%E7%A0%81%E8%AF%84%E5%AE%A1%E4%B8%AD%E7%9A%84MySQL%EF%BC%88%E5%9B%A2%E9%98%9F%E8%A7%84%E8%8C%83%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="数据库对象命名规范"><a href="#数据库对象命名规范" class="headerlink" title="数据库对象命名规范"></a>数据库对象命名规范</h2><h3 id="数据库对象"><a href="#数据库对象" class="headerlink" title="数据库对象"></a>数据库对象</h3><p>数据库对象是数据库的组成部分，常见的有以下几种： 表（Table ）、索引（Index）、视图（View）、图表（Diagram）、缺省值（Default）、规则（Rule）、触发器（Trigger）、存储过程（Stored Procedure）、 用户（User）等。 命名规范是指数据库对象如数据库（SCHEMA）、表（TABLE）、索引（INDEX）、约束（CONSTRAINTS）等的命名约定。</p><h3 id="数据库对象全局命名规范"><a href="#数据库对象全局命名规范" class="headerlink" title="数据库对象全局命名规范"></a>数据库对象全局命名规范</h3><p>1、命名使用具有意义的英文词汇，词汇中间以下划线分隔</p><p>2、命名只能使用英文字母、数字、下划线，以英文字母开头</p><p>3、避免用MySQL的保留字如：backup、call、group等，<a href="http://dev.mysql.com/doc/refman/5.7/en/keywords.html">参考MySQL 5.7+的关键字和保留字</a>。</p><p>4、所有数据库对象使用小写字母，实际上MySQL中是可以设置大小写是否敏感的，为了保证统一性，我们这边规范全部小写表示。</p><h3 id="数据库命名规范"><a href="#数据库命名规范" class="headerlink" title="数据库命名规范"></a>数据库命名规范</h3><p>1、数据库命名尽量不超过30个字符。</p><p>2、数据库命名一般为项目名称+代表库含义的简写，比如IM项目的工作流数据库，可以是 im_flow。</p><p>3、数据库创建时必须添加默认字符集和校对规则子句。默认字符集为UTF8（已迁移dumbo的使用utf8mb4）</p><p>4、命名应使用小写。</p><h3 id="表命名规范"><a href="#表命名规范" class="headerlink" title="表命名规范"></a>表命名规范</h3><p>1、常规表表名以t_开头，t代表table的意思，命名规则即 t + 模块（包含模块含义的简写）+ 表（包含表含义的简写），比如用户模块的教育信息表：t_user_eduinfo。</p><p>2、临时表（RD、QA或DBA同学用于数据临时处理的表），命名规则：temp前缀+模块+表+日期后缀：temp_user_eduinfo_20210719</p><p>3、备份表（用于保存和归档历史数据或者作为灾备恢复的数据）命名规则，bak前缀+模块+表+日期后缀：bak_user_eduinfo_20210719</p><p>4、同一个模块的表尽可能使用相同的前缀，表名称尽可能表达含义</p><p>5、多个单词以下划线 _ 分隔</p><p>6、常规表表名尽量不超过30个字符，temp表和bak表视情况而定，也尽量简短为宜，命名应使用小写</p><h3 id="字段命名规范"><a href="#字段命名规范" class="headerlink" title="字段命名规范"></a>字段命名规范</h3><p>1、字段命名需要表示其实际含义的英文单词或简写，单词之间用下划线 _ 进行连接，如 service_ip、service_port。</p><p>2、各表之间相同意义的字段必须同名，比如a表和b表都有创建时间，应该统一为create_time，不一致会很混乱。</p><p>3、多个单词以下划线 _ 分隔</p><p>4、字段名尽量不超过30个字符，命名应该使用小写</p><h3 id="索引命名规范"><a href="#索引命名规范" class="headerlink" title="索引命名规范"></a>索引命名规范</h3><p>1、唯一索引使用uni + 字段名 来命名： create unique index uni_uid on t_user_basic(uid) 。</p><p>2、非唯一索引使用idx + 字段名 来命名： create index idx_uname_mobile on t_user_basic(uname,mobile) 。</p><p>3、多个单词以下划线 _ 分隔。</p><p>4、索引名尽量不超过50个字符，命名应该使用小写，组合索引的字段不宜太多，不然也不利于查询效率的提升。</p><p>5、多单词组成的列名，取尽可能代表意义的缩写，如 test_contact表member_id和friend_id上的组合索引：idx_mid_fid。</p><p>6、理解组合索引最左前缀原则，避免重复建设索引，如果建立了(a,b,c)，相当于建立了(a), (a,b), (a,b,c)。 </p><h3 id="视图命名规范"><a href="#视图命名规范" class="headerlink" title="视图命名规范"></a>视图命名规范</h3><p>1、视图名以v开头，表示view，完整结构是v+视图内容含义缩写。</p><p>2、如果视图只来源单个表，则为v+表名。如果视图由几个表关联产生就用v+下划线（_）连接几个表名，视图名尽量不超过30个字符。如超过30个字符则取简写。</p><p>3、如无特殊需要，严禁开发人员创建视图。</p><p>4、命名应使用小写。 </p><h3 id="存储过程命名规范"><a href="#存储过程命名规范" class="headerlink" title="存储过程命名规范"></a>存储过程命名规范</h3><p>1、存储过程名以sp开头，表示存储过程（storage procedure）。之后多个单词以下划线（_）进行连接。存储过程命名中应体现其功能。存储过程名尽量不能超过30个字符。</p><p>2、存储过程中的输入参数以i_开头，输出参数以o_开头。</p><p>3、命名应使用小写。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create procedure sp_multi_param(in i_id bigint,in i_name varchar(32),out o_memo varchar(100))  </span><br></pre></td></tr></table></figure><h3 id="函数命名规范"><a href="#函数命名规范" class="headerlink" title="函数命名规范"></a>函数命名规范</h3><p>1、函数名以func开始，表示function。之后多个单词以下划线（_）进行连接，函数命名中应体现其功能。函数名尽量不超过30个字符。</p><p>2、命名应使用小写。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create function func_format_date(ctime datetime)</span><br></pre></td></tr></table></figure><h3 id="触发器命名规范"><a href="#触发器命名规范" class="headerlink" title="触发器命名规范"></a>触发器命名规范</h3><p>1、触发器以trig开头，表示trigger 触发器。</p><p>2、基本部分，描述触发器所加的表，触发器名尽量不超过30个字符。</p><p>3、后缀（_i,_u,_d）,表示触发条件的触发方式（insert,update或delete）。</p><p>4、命名应使用小写。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DROP TRIGGER IF EXISTS trig_attach_log_d;</span><br><span class="line">CREATE TRIGGER trig_attach_log_d AFTER DELETE ON t_dept FOR EACH ROW; </span><br></pre></td></tr></table></figure><h3 id="约束命名规范"><a href="#约束命名规范" class="headerlink" title="约束命名规范"></a>约束命名规范</h3><p>1、唯一约束：uk_表名称_字段名。uk是UNIQUE KEY的缩写。比如给一个部门的部门名称加上唯一约束，来保证不重名，如下：ALTER TABLE t_dept ADD CONSTRAINT un_name UNIQUE(name); </p><p>2、外键约束：fk_表名，后面紧跟该外键所在的表名和对应的主表名（不含t_）。子表名和父表名用下划线(_)分隔。如下： ALTER TABLE t_user ADD CONSTRAINT fk_user_dept FOREIGN KEY(depno) REFERENCES t_dept (id); </p><p>3、非空约束：如无特殊需要，建议所有字段默认非空(not null)，不同数据类型必须给出默认值(default)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">`id` int(11) NOT NULL,</span><br><span class="line">`name` varchar(30) DEFAULT &#x27;&#x27;,</span><br><span class="line">`deptId` int(11) DEFAULT 0,</span><br><span class="line">`salary` float DEFAULT NULL, </span><br></pre></td></tr></table></figure><p>4、出于性能考虑，如无特殊需要，建议不使用外键。参照完整性由代码控制。这个也是我们普遍的做法，从程序角度进行完整性控制，但是如果不注意，也会产生脏数据。</p><p>5、命名应使用小写。 </p><h3 id="用户命名规范"><a href="#用户命名规范" class="headerlink" title="用户命名规范"></a>用户命名规范</h3><p>1、 生产使用的用户命名格式为 code_应用</p><p>2、 只读用户命名规则为 read_应用</p><h2 id="数据库对象设计规范"><a href="#数据库对象设计规范" class="headerlink" title="数据库对象设计规范"></a>数据库对象设计规范</h2><h3 id="存储引擎的选择"><a href="#存储引擎的选择" class="headerlink" title="存储引擎的选择"></a>存储引擎的选择</h3><p>1、如无特殊需求，必须使用innodb存储引擎。</p><p>可以通过 show variables like ‘default_storage_engine’ 来查看当前默认引擎。主要有MyISAM 和 InnoDB，从5.5版本开始默认使用 InnoDB 引擎。</p><p>基本的差别为：MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持。MyISAM类型的表强调的是性能，其执行速度比InnoDB类型更快，但是不提供事务支持，而InnoDB提供事务支持以及外部键等高级数据库功能。</p><h3 id="字符集的选择"><a href="#字符集的选择" class="headerlink" title="字符集的选择"></a>字符集的选择</h3><p>1、如无特殊要求，必须使用utf8或utf8mb4。</p><p>在国内，选择对中文和各语言支持都非常完善的<code>utf8</code>格式是最好的方式，MySQL在5.5之后增加utf8mb4编码，mb4就是most bytes 4的意思，专门用来兼容四字节的unicode。</p><p>所以utf8mb4是utf8的超集，除了将编码改为utf8mb4外不需要做其他转换。当然，为了节省空间，一般情况下使用utf8也就够了。</p><p>可以使用如下脚本来查看数据库的编码格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES WHERE Variable_name LIKE &#x27;character_set_%&#x27; OR Variable_name LIKE &#x27;collation%&#x27;;</span><br><span class="line">-- 或</span><br><span class="line">SHOW VARIABLES Like &#x27;%char%&#x27;;  </span><br></pre></td></tr></table></figure><h3 id="表设计规范"><a href="#表设计规范" class="headerlink" title="表设计规范"></a>表设计规范</h3><p>1、不同应用间所对应的数据库表之间的关联应尽可能减少，不允许使用外键对表之间进行关联，确保组件对应的表之间的独立性，为系统或表结构的重构提供可能性。目前业内的做法一般 由程序控制参照完整性。</p><p>2、表设计的角度不应该针对整个系统进行数据库设计，而应该根据系统架构中组件划分，针对每个组件所处理的业务进行数据库设计。</p><p>3、表必须要有PK，主键的优势是唯一标识、有效引用、高效检索，所以一般情况下尽量有主键字段。</p><p>4、一个字段只表示一个含义。</p><p>5、表不应该有重复列。</p><p>6、禁止使用复杂数据类型(数组,自定义等)，Json类型的使用视情况而定。</p><p>7、需要join的字段(连接键)，数据类型必须保持绝对一致，避免隐式转换。比如关联的字段都是int类型。</p><p>8、设计应至少满足第三范式,尽量减少数据冗余。一些特殊场景允许反范式化设计，但在项目评审时需要对冗余字段的设计给出解释。</p><p>9、TEXT字段作为大体量文本存储，必须放在独立的表中 , 用PK与主表关联。如无特殊需要，禁止使用TEXT、BLOB字段。</p><p>10、需要定期删除(或者转移)过期数据的表，通过分表解决，我们的做法是按照2&#x2F;8法则将操作频率较低的历史数据迁移到历史表中，按照时间或者则曾Id做切割点。</p><p>11、单表字段数不要太多，建议最多不要大于50个。过度的宽表对性能也是很大的影响。</p><p>12、MySQL在处理大表时，性能就开始明显降低，所以建议单表物理大小限制在16GB，表中数据行数控制在2000W内。</p><p>业内的规则是超过2000W性能开始明显降低。但是这个值是灵活的，你可以根据实际情况进行测试来判断，比如阿里的标准就是500W，百度的确是2000W。实际上是否宽表，单行数据所占用的空间都有起到作用的。</p><p>13、如果数据量或数据增长在前期规划时就较大，那么在设计评审时就应加入分表策略，后续会有专门的文章来分析数据拆分的做法：垂直拆分（垂直分库和垂直分表）、水平拆分（分库分表和库内分表）；</p><p>14、无特殊需求，严禁使用分区表</p><h3 id="字段设计规范"><a href="#字段设计规范" class="headerlink" title="字段设计规范"></a>字段设计规范</h3><p>1、INT：如无特殊需要，存放整型数字使用UNSIGNED INT型，整型字段后的数字代表显示长度。比如 <code>id</code> int(11) NOT NULL </p><p>2、DATETIME：所有需要精确到时间(时分秒)的字段均使用DATETIME,不要使用TIMESTAMP类型。</p><p>对于TIMESTAMP，它把写入的时间从当前时区转化为UTC（世界标准时间）进行存储。查询时，将其又转化为客户端当前时区进行返回。而对于DATETIME，不做任何改变，基本上是原样输入和输出。</p><p>另外DATETIME存储的范围也比较大：</p><p>timestamp所能存储的时间范围为：’1970-01-01 00:00:01.000000’ 到 ‘2038-01-19 03:14:07.999999’。</p><p>datetime所能存储的时间范围为：’1000-01-01 00:00:00.000000’ 到 ‘9999-12-31 23:59:59.999999’。</p><p>但是特殊情况，对于跨时区的业务，TIMESTAMP更为合适。</p><p>3、VARCHAR：所有动态长度字符串 全部使用VARCHAR类型,类似于状态等有限类别的字段,也使用可以比较明显表示出实际意义的字符串,而不应该使用INT之类的数字来代替；VARCHAR(N)，</p><p>N表示的是字符数而不是字节数。比如VARCHAR(255)，可以最大可存储255个字符（字符包括英文字母，汉字，特殊字符等）。但N应尽可能小，因为MySQL一个表中所有的VARCHAR字段最大长度是65535个字节，且存储字符个数由所选字符集决定。</p><p>如UTF8存储一个字符最大要3个字节，那么varchar在存放占用3个字节长度的字符时不应超过21845个字符。同时，在进行排序和创建临时表一类的内存操作时，会使用N的长度申请内存。(如无特殊需要，原则上单个varchar型字段不允许超过255个字符)</p><p>4、TEXT：仅仅当字符数量可能超过20000个的时候,才可以使用TEXT类型来存放字符类数据,因为所有MySQL数据库都会使用UTF8字符集。</p><p>所有使用TEXT类型的字段必须和原表进行分拆，与原表主键单独组成另外一个表进行存放，与大文本字段的隔离，目的是。如无特殊需要，不使用MEDIUMTEXT、TEXT、LONGTEXT类型</p><p>5、对于精确浮点型数据存储，需要使用DECIMAL，严禁使用FLOAT和DOUBLE。</p><p>6、如无特殊需要，尽量不使用BLOB类型</p><p>7、如无特殊需要，字段建议使用NOT NULL属性，可用默认值代替NULL</p><p>8、自增字段类型必须是整型且必须为UNSIGNED，推荐类型为INT或BIGINT，并且自增字段必须是主键或者主键的一部分。</p><h3 id="索引设计规范"><a href="#索引设计规范" class="headerlink" title="索引设计规范"></a>索引设计规范</h3><p>建议学习索引设计规范跟之前先看本人的的另外一篇文章，都是索引的使用策略:MySQL系列：<a href="https://yeoh.qzz.io/2025/04/15/MySQL%E7%B3%BB%E5%88%97-%E6%9E%84%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%B4%A2%E5%BC%95%EF%BC%88%E7%AD%96%E7%95%A5%E7%AF%87%EF%BC%89/">构建高性能索引（策略篇） | 数根朽木，</a></p><p>1、索引区分度</p><p>索引必须创建在索引选择性（区分度）较高的列上，选择性的计算方式为:  selecttivity &#x3D; count(distinct c_name)&#x2F;count(*) ; 如果区分度结果小于0.2，则不建议在此列上创建索引，否则大概率会拖慢SQL执行</p><p>2、遵循最左前缀</p><p>对于确定需要组成组合索引的多个字段，设计时建议将选择性高的字段靠前放。使用时，组合索引的首字段，必须在where条件中，且需要按照最左前缀规则去匹配。</p><p>3、禁止使用外键，可以在程序级别来约束完整性</p><p>4、Text类型字段如果需要创建索引，必须使用前缀索引</p><p>5、单张表的索引数量理论上应控制在5个以内。经常有大批量插入、更新操作表，应尽量少建索引，索引建立的原则理论上是多读少写的场景。</p><p>6、ORDER BY，GROUP BY，DISTINCT的字段需要添加在索引的后面，形成覆盖索引</p><p>7、正确理解和计算索引字段的区分度，文中有计算规则，区分度高的索引，可以快速得定位数据，区分度太低，无法有效的利用索引，可能需要扫描大量数据页，和不使用索引没什么差别。</p><p>8、正确理解和计算前缀索引的字段长度，文中有判断规则，合适的长度要保证高的区分度和最恰当的索引存储容量，只有达到最佳状态，才是保证高效率的索引。</p><p>9、联合索引注意最左匹配原则：必须按照从左到右的顺序匹配，MySQL会一直向右匹配索引直到遇到范围查询(&gt;、&lt;、between、like)然后停止匹配。</p><p>如：depno&#x3D;1 and empname&gt;’’ and job&#x3D;1 如果建立(depno,empname,job)顺序的索引，job是用不到索引的。</p><p>10、应需而取策略，查询记录的时候，不要一上来就使用*，只取需要的数据，可能的话尽量只利用索引覆盖，可以减少回表操作，提升效率。 </p><p>11、正确判断是否使用联合索引（上面联合索引的使用那一小节有说明判断规则），也可以进一步分析到索引下推（IPC），减少回表操作，提升效率。</p><p>12、避免索引失效的原则：禁止对索引字段使用函数、运算符操作，会使索引失效。这是实际上就是需要保证索引所对应字段的”干净度“。</p><p>13、避免非必要的类型转换，字符串字段使用数值进行比较的时候会导致索引无效。</p><p>14、模糊查询’%value%’会使索引无效，变为全表扫描，因为无法判断扫描的区间，但是’value%’是可以有效利用索引。</p><p>15、索引覆盖排序字段，这样可以减少排序步骤，提升查询效率 </p><p>16、尽量的扩展索引，非必要不新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</p><p>举例子： 比如一个品牌表，建立的的索引如下，一个主键索引，一个唯一索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PRIMARY KEY (`id`),</span><br><span class="line">UNIQUE KEY `uni_brand_define` (`app_id`,`define_id`)</span><br></pre></td></tr></table></figure><p> 当你同事业务代码中的检索语句如下的时候，应该立即警告了，即没有覆盖索引，也没按照最左前缀原则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select brand_id,brand_name from  ds_brand_system where status=?  and define_id=?  and app_id=?</span><br></pre></td></tr></table></figure><p> 建议改成如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select brand_id,brand_name from  ds_brand_system where app_id=? and define_id=?  and  status=? </span><br></pre></td></tr></table></figure><h3 id="约束设计规范"><a href="#约束设计规范" class="headerlink" title="约束设计规范"></a>约束设计规范</h3><p>1、PK应该是有序并且无意义的，由开发人员自定义，尽可能简短，并且是自增序列。</p><p>2、表中除PK以外,还存在唯一性约束的,可以在数据库中创建以“uk_”作为前缀的唯一约束索引。</p><p>3、PK字段不允许更新。</p><p>4、禁止创建外键约束，外键约束由程序控制。</p><p>5、如无特殊需要，所有字段必须添加非空约束，即not null。</p><p>6、如无特殊需要，所有字段必须有默认值。</p><h2 id="SQL使用规范"><a href="#SQL使用规范" class="headerlink" title="SQL使用规范"></a>SQL使用规范</h2><h3 id="select-检索的规范性"><a href="#select-检索的规范性" class="headerlink" title="select 检索的规范性"></a><strong>select 检索的规范性</strong></h3><p>1、尽量避免使用<code>select *</code>，join语句使用<code>select * </code>可能导致只需要访问索引即可完成的查询需要回表取数。</p><p>一种是可能取出很多不需要的数据，对于宽表来说，这是灾难；一种是尽可能避免回表，因为取一些根本不需要的数据而回表导致性能低下，是很不合算。</p><p>2、严禁使用 select * from t_name ，而不加任何where条件，道理一样，这样会变成全表全字段扫描。</p><p>3、MySQL中的text类型字段存储：</p><p>  3.1、不与其他普通字段存放在一起,因为读取效率低，也会影响其他轻量字段存取效率。</p><p>  3.2、如果不需要text类型字段，又使用了select *，会让该执行消耗大量io，效率也很低下</p><p>4、在取出字段上可以使用相关函数，但应尽可能避免出现 now() , rand() , sysdate() 等不确定结果的函数，在Where条件中的过滤条件字段上严禁使用任何函数，包括数据类型转换函数。大量的计算和转换会造成效率低下，这个在索引那边也描述过了。</p><p>5、分页查询语句全部都需要带有排序条件 , 否则很容易引起乱序</p><p>6、用in()&#x2F;union替换or，效率会好一些，并注意in的个数小于300</p><p>7、严禁使用%前缀进行模糊前缀查询:如： select a,b,c from t_name where a like ‘%name’; 可以使用%模糊后缀查询如： select a,b from t_name where a like ‘name%’; </p><p>8、避免使用子查询，可以把子查询优化为join操作</p><p>通常子查询在in子句中，且子查询中为简单SQL(不包含union、group by、order by、limit从句)时，才可以把子查询转化为关联查询进行优化。</p><p>子查询性能差的原因：</p><p><strong>·</strong> 子查询的结果集无法使用索引，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能 会受到一定的影响；</p><p><strong>·</strong> 特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大；</p><p><strong>·</strong> 由于子查询会产生大量的临时表也没有索引，所以会消耗过多的CPU和IO资源，产生大量的慢查询。</p><h3 id="操作的规范性"><a href="#操作的规范性" class="headerlink" title="操作的规范性"></a><strong>操作的规范性</strong></h3><p>1、禁止使用不含字段列表的INSERT语句</p><p>如： insert into values (‘a’,’b’,’c’);  应使用  insert into t_name(c1,c2,c3) values (‘a’,’b’,’c’); 。</p><p>2、大批量写操作（UPDATE、DELETE、INSERT），需要分批多次进行操作</p><p><strong>·</strong> 大批量操作可能会造成严重的主从延迟，特别是主从模式下，大批量操作可能会造成严重的主从延迟，因为需要slave从master的binlog中读取日志来进行数据同步。</p><p><strong>·</strong> binlog日志为row格式时会产生大量的日志</p><h2 id="程序上的约束"><a href="#程序上的约束" class="headerlink" title="程序上的约束"></a>程序上的约束</h2><p>后续我们团队的目标是研发评审工具对开发同学提交的建库、建表、刷数据、查询的语句进行分析，看看是否符合应有的规范。如果不符合，驳回修改。</p><p>评审工具建设完毕，会尽量开源。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL系列：构建高性能索引（策略篇）</title>
      <link href="/2025/04/20/MySQL%E7%B3%BB%E5%88%97/MySQL%E7%B3%BB%E5%88%97-%E6%9E%84%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%B4%A2%E5%BC%95%EF%BC%88%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E7%AF%87%EF%BC%89/"/>
      <url>/2025/04/20/MySQL%E7%B3%BB%E5%88%97/MySQL%E7%B3%BB%E5%88%97-%E6%9E%84%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%B4%A2%E5%BC%95%EF%BC%88%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E7%AF%87%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="索引的十大原则"><a href="#索引的十大原则" class="headerlink" title="索引的十大原则"></a>索引的十大原则</h3><p>1、正确理解和计算索引字段的区分度，文中有计算规则，区分度高的索引，可以快速得定位数据，区分度太低，无法有效的利用索引，可能需要扫描大量数据页，和不使用索引没什么差别。</p><p>2、正确理解和计算前缀索引的字段长度，文中有判断规则，合适的长度要保证高的区分度和最恰当的索引存储容量，只有达到最佳状态，才是保证高效率的索引。</p><p>3、联合索引注意最左匹配原则：必须按照从左到右的顺序匹配，MySQL会一直向右匹配索引直到遇到范围查询(&gt;、&lt;、between、like)然后停止匹配。</p><p>如  depno&#x3D;1 and empname&gt;’’ and job&#x3D;1 ，如果建立(depno,empname,job)顺序的索引，job是用不到索引的。</p><p>4、应需而取策略，查询记录的时候，不要一上来就使用*，只取需要的数据，可能的话尽量只利用索引覆盖，可以减少回表操作，提升效率。 </p><p>5、正确判断是否使用联合索引（上面联合索引的使用那一小节有说明判断规则），也可以进一步分析到索引下推（IPC），减少回表操作，提升效率。</p><p>6、避免索引失效的原则：禁止对索引字段使用函数、运算符操作，会使索引失效。这是实际上就是需要保证索引所对应字段的”干净度“。</p><p>7、避免非必要的类型转换，字符串字段使用数值进行比较的时候会导致索引无效。</p><p>8、模糊查询’%value%’会使索引无效，变为全表扫描，因为无法判断扫描的区间，但是’value%’是可以有效利用索引。</p><p>9、索引覆盖排序字段，这样可以减少排序步骤，提升查询效率 </p><p>10、尽量的扩展索引，非必要不新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</p><h3 id="查询优化分析器-explain"><a href="#查询优化分析器-explain" class="headerlink" title="查询优化分析器 - explain"></a>查询优化分析器 - explain</h3><p>explain命令大家应该很熟悉，具体用法和字段含义可以参考官网<a href="http://dev.mysql.com/doc/refman/5.5/en/explain-output.html">explain-output</a>，这里需要强调rows是核心指标，绝大部分rows小的语句执行一定很快，因为扫描的内容基数小。</p><p>所以优化语句基本上都是在优化降低rows值。</p><h3 id="慢查询优化基本步骤"><a href="#慢查询优化基本步骤" class="headerlink" title="慢查询优化基本步骤"></a>慢查询优化基本步骤</h3><p>1.先运行查看实际耗时，判断是否真的很慢（注意设置SQL_NO_CACHE）。</p><p>2.高区分度优先策略：where条件单表查，锁定最小返回记录表的条件。</p><p>就是查询语句的where都应用到表中返回的记录数最小的表开始查起，单表每个字段分别查询，看哪个字段的区分度最高。区分度高的字段往前排。</p><p>3.explain查看执行计划，是否与1预期一致（从锁定记录较少的表开始查询）</p><p>4.order by limit 形式的sql语句让排序的表优先查</p><p>5.了解业务方的使用场景，根据使用场景适时调整。</p><p>6.加索引时参照建上面索引的十大原则</p><p>7.观察结果，不符合预期继续从第一步开始分析</p><h3 id="查询案例分析"><a href="#查询案例分析" class="headerlink" title="查询案例分析"></a>查询案例分析</h3><p>下面几个例子详细解释了如何分析和优化慢查询。</p><h4 id="复杂查询条件的分析"><a href="#复杂查询条件的分析" class="headerlink" title="复杂查询条件的分析"></a>复杂查询条件的分析</h4><p>一般来说我们编写SQL的方式是为了 是实现功能，在实现功能的基础上保证MySQL的执行效率也是非常重要的，这要求我们对MySQL的执行计划和索引规则有非常清晰的理解，分析下面的案例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select a.*,b.depname,b.memo from emp a left join</span><br><span class="line">dep b on a.depno = b.depno where sal&gt;100 and a.empname like &#x27;ab%&#x27;  and a.depno=106 order by a.hiredate desc ;</span><br><span class="line">+---------+---------+---------+---------+-----+---------------------+------+------+-------+------------+----------+</span><br><span class="line">| id      | empno   | empname | job     | mgr | hiredate            | sal  | comn | depno | depname    | memo     |</span><br><span class="line">+---------+---------+---------+---------+-----+---------------------+------+------+-------+------------+----------+</span><br><span class="line">| 4976754 | 4976754 | ABijwE  | SALEMAN |   1 | 2021-01-23 16:46:24 | 2000 | 400  |   106 | kDpNWugzcQ | TYlrVEkm |</span><br><span class="line">......</span><br><span class="line">+---------+---------+---------+---------+-----+---------------------+------+------+-------+------------+----------+</span><br><span class="line">744 rows in set  (4.958 sec)</span><br></pre></td></tr></table></figure><p>总共就查询了744条数据，却耗费了4.958的时间，我们看一下目前表中现存的索引以及索引使用的情况分析</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show index from emp;</span><br><span class="line">+-------+------------+---------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">| Table | Non_unique | Key_name   | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |</span><br><span class="line">+-------+------------+---------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">| emp   |          0 | PRIMARY    |            1 | id          | A         |     4952492 | NULL     | NULL   |      | BTREE      |         |               |</span><br><span class="line">| emp   |          1 | idx_emo_depno |            1 | depno       | A         |          18 | NULL     | NULL   |      | BTREE      |         |               |</span><br><span class="line">+-------+------------+---------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">2 rows in set</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select a.*,b.depname,b.memo from emp a left join</span><br><span class="line">dep b on a.depno = b.depno where sal&gt;100 and a.empname like &#x27;ab%&#x27;  and a.depno=106 order by a.hiredate desc ;</span><br><span class="line">+----+-------------+-------+------+---------------+---------------+---------+-------+--------+-----------------------------+</span><br><span class="line">| id | select_type | table | type | possible_keys | key           | key_len | ref   | rows   | Extra                       |</span><br><span class="line">+----+-------------+-------+------+---------------+---------------+---------+-------+--------+-----------------------------+</span><br><span class="line">|  1 | SIMPLE      | a     | ref  | idx_emo_depno | idx_emo_depno | 3       | const | 974898 | Using where; Using filesort |</span><br><span class="line">|  1 | SIMPLE      | b     | ref  | idx_dep_depno | idx_dep_depno | 3       | const |      1 | NULL                        |</span><br><span class="line">+----+-------------+-------+------+---------------+---------------+---------+-------+--------+-----------------------------+</span><br><span class="line">2 rows in set</span><br></pre></td></tr></table></figure><p>可以看出，目前在emp表上除了主键只存在一个索引 idx_emo_depno ，作用在部门编号字段上，该索引的目标是过滤出具体部门编号下的数据。</p><p>通过explain 分析器可以看到 where条件后面是走了  idx_emo_depno 索引，但是也比较了 97W的数据，说明该字段的区分度并不高，根据高区分度优先原则，我们对这个表的三个查询字段分别进行区分度计算。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select count(distinct empname)/count(*),count(distinct depno)/count(*),count(distinct sal)/count(*) from emp;</span><br><span class="line">+----------------------------------+--------------------------------+------------------------------+</span><br><span class="line">| count(distinct empname)/count(*) | count(distinct depno)/count(*) | count(distinct sal)/count(*) |</span><br><span class="line">+----------------------------------+--------------------------------+------------------------------+</span><br><span class="line">| 0.1713                           | 0.0000                         | 0.0000                       |</span><br><span class="line">+----------------------------------+--------------------------------+------------------------------+</span><br><span class="line">1 row in set</span><br></pre></td></tr></table></figure><p>这是计算结果，empname的区分度最高，所以合理上是可以建立一个包含这三个字段的联合索引，顺序如下：empname、depno、sal；</p><p>并且查询条件重新调整了顺序，符合最左匹配原则；另一方面根据应需而取的策略，把b.memo字段去掉了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select a.*,b.depname from emp a left join</span><br><span class="line">dep b on a.depno = b.depno where  a.empname like &#x27;ab%&#x27;  and a.depno=106 and a.sal&gt;100 order by a.hiredate desc ;</span><br><span class="line">+---------+---------+---------+---------+-----+---------------------+------+------+-------+------------+</span><br><span class="line">| id      | empno   | empname | job     | mgr | hiredate            | sal  | comn | depno | depname    |</span><br><span class="line">+---------+---------+---------+---------+-----+---------------------+------+------+-------+------------+</span><br><span class="line">| 4976754 | 4976754 | ABijwE  | SALEMAN |   1 | 2021-01-23 16:46:24 | 2000 | 400  |   106 | kDpNWugzcQ |</span><br><span class="line">......</span><br><span class="line">+---------+---------+---------+---------+-----+---------------------+------+------+-------+------------+</span><br><span class="line">744 rows in set  (0.006 sec)</span><br></pre></td></tr></table></figure><p>这边还有一个问题，那就是联合索引根据最左匹配原则：必须按照从左到右的顺序匹配，MySQL会一直向右匹配索引直到遇到范围查询(&gt;、&lt;、between、like)然后停止匹配。</p><p>所以语句中 执行到a.empname 字段，因为使用了like，后面就不再走索引了。在这个场景中， 独立的empname字段上的索引和这个联合索引效率是差不多的。</p><p>另外排序字段hiredate也可以考虑到覆盖到索引中，会相应的提高效率。</p><h4 id="无效索引的分析"><a href="#无效索引的分析" class="headerlink" title="无效索引的分析"></a>无效索引的分析</h4><p>有一个需求，使用到了用户表  userinfo 和消费明细表 salinvest ，目的想把2020年每个用户在四个品类等级（A1、A2、A3、A4）上的消费额度进行统计，所以便下了如下的脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">select (@rowNO := @rowNo+1) AS id,bdata.* from</span><br><span class="line">(</span><br><span class="line">select distinct a.usercode,a.username,</span><br><span class="line">@A1:=IFNULL((select sum(c.ltimenum) from `salinvest` c where c.usercode=a.usercode AND c.gravalue=&#x27;A1&#x27;</span><br><span class="line">and c.logdate between &#x27;2020-01-01&#x27; and &#x27;2020-12-31&#x27;),0) as A1,</span><br><span class="line">@A2:=IFNULL((select sum(c.ltimenum) from `salinvest` c where c.usercode=a.usercode AND c.gravalue=&#x27;A2&#x27;</span><br><span class="line">and c.logdate between &#x27;2020-01-01&#x27; and &#x27;2020-12-31&#x27;),0) as A2,</span><br><span class="line">@A3:=IFNULL((select sum(c.ltimenum) from `salinvest` c where c.usercode=a.usercode AND c.gravalue=&#x27;A3&#x27;</span><br><span class="line">and c.logdate between &#x27;2020-01-01&#x27; and &#x27;2020-12-31&#x27;),0) as A3,</span><br><span class="line">@A4:=IFNULL((select sum(c.ltimenum) from `salinvest` c where c.usercode=a.usercode AND c.gravalue=&#x27;A4&#x27;</span><br><span class="line">and c.logdate between &#x27;2020-01-01&#x27; and &#x27;2020-12-31&#x27;),0) as A4,</span><br><span class="line">,(@A1+@A2+@A3+@A4) as allnum</span><br><span class="line">from userinfo a</span><br><span class="line">inner JOIN `salinvest` b on a.usercode = b.usercode</span><br><span class="line">where b.logdate between &#x27;2020-01-01&#x27; and &#x27;2020-12-31&#x27;</span><br><span class="line">order by allnum desc</span><br><span class="line">) as bdata,(SELECT @rowNO:=0) b;</span><br></pre></td></tr></table></figure><p>这个查询看起来貌似没什么问题 ，虽然用到了复合查询、子查询，但是如果索引做的正确，也不会有什么问题。那我们来看看索引，有一个联合索引，符合我们最左匹配原则和高区分度优先原则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show index from salinvest;</span><br><span class="line">+------------+------------+------------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">| Table      | Non_unique | Key_name               | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |</span><br><span class="line">+------------+------------+------------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">| lnuminvest |          0 | PRIMARY                |            1 | autocode    | A         |           5 | NULL     | NULL   |      | BTREE      |         |               |</span><br><span class="line">| lnuminvest |          1 | idx_salinvest_complex |            1 | usercode      | A         |           2 | NULL     | NULL   | YES  | BTREE      |         |               |</span><br><span class="line">| lnuminvest |          1 | idx_salinvest_complex |            2 | gravalue    | A         |           2 | NULL     | NULL   | YES  | BTREE      |         |               |</span><br><span class="line">| lnuminvest |          1 | idx_salinvest_complex |            3 | logdate     | A         |           2 | NULL     | NULL   | YES  | BTREE      |         |               |</span><br><span class="line">+------------+------------+------------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">4 rows in set</span><br></pre></td></tr></table></figure><p>那我们来看看它的执行效率：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select (@rowNO := @rowNo+1) AS id,bdata.* from </span><br><span class="line">(</span><br><span class="line">select (@rowNO := @rowNo+1) AS id,bdata.* from </span><br><span class="line">(</span><br><span class="line">select distinct a.usercode,a.username,</span><br><span class="line">@A1:=IFNULL((select sum(c.ltimenum) from `salinvest` c where c.usercode=a.usercode AND c.gravalue=&#x27;A1&#x27; </span><br><span class="line">and c.logdate between &#x27;2020-01-01&#x27; and &#x27;2020-12-31&#x27;),0) as A1,</span><br><span class="line">@A2:=IFNULL((select sum(c.ltimenum) from `salinvest` c where c.usercode=a.usercode AND c.gravalue=&#x27;A2&#x27; </span><br><span class="line">and c.logdate between &#x27;2020-01-01&#x27; and &#x27;2020-12-31&#x27;),0) as A2,</span><br><span class="line">@A3:=IFNULL((select sum(c.ltimenum) from `salinvest` c where c.usercode=a.usercode AND c.gravalue=&#x27;A3&#x27; </span><br><span class="line">and c.logdate between &#x27;2020-01-01&#x27; and &#x27;2020-12-31&#x27;),0) as A3,</span><br><span class="line">@A4:=IFNULL((select sum(c.ltimenum) from `salinvest` c where c.usercode=a.usercode AND c.gravalue=&#x27;A4&#x27; </span><br><span class="line">and c.logdate between &#x27;2020-01-01&#x27; and &#x27;2020-12-31&#x27;),0) as A4,</span><br><span class="line">,(@A1+@A2+@A3+@A4) as allnum </span><br><span class="line">from userinfo a </span><br><span class="line">inner JOIN `salinvest` b on a.usercode = b.usercode  </span><br><span class="line">where b.logdate between &#x27;2020-01-01&#x27; and &#x27;2020-12-31&#x27;</span><br><span class="line">order by allnum desc</span><br><span class="line">) as bdata,(SELECT @rowNO:=0) b;</span><br><span class="line">+----+------------+---------+------+------+------+------+------+--------+</span><br><span class="line">| id | usercode     | username | A1     | A2   | A3   | A4   |allnum</span><br><span class="line">+----+------------+---------+------+------+------+------+------+--------+</span><br><span class="line">|  1 | 063105015    | brand    | 789.00 | 1074.50 | 998.00 | 850.00 |  </span><br><span class="line">......</span><br><span class="line">+----+------------+---------+------+------+------+------+------+--------+</span><br><span class="line">6217 rows in set  (12.745 sec) </span><br></pre></td></tr></table></figure><p>我这边省略了查询结果，实际上结果输出6000多条数据，在约50W的数据中进行统计与合并，输出6000多条数据，花费了将近13秒，这明显是不合理的。</p><p>我们来分析下是什么原因：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select (@rowNO := @rowNo+1) AS id,bdata.* from</span><br><span class="line">(</span><br><span class="line">select distinct a.usercode,a.username,</span><br><span class="line">@A1:=IFNULL((select sum(c.ltimenum) from `salinvest` c where c.usercode=a.usercode AND c.gravalue=&#x27;A1&#x27;</span><br><span class="line">and c.logdate between &#x27;2020-01-01&#x27; and &#x27;2020-12-31&#x27;),0) as A1,</span><br><span class="line">@A2:=IFNULL((select sum(c.ltimenum) from `salinvest` c where c.usercode=a.usercode AND c.gravalue=&#x27;A2&#x27;</span><br><span class="line">and c.logdate between &#x27;2020-01-01&#x27; and &#x27;2020-12-31&#x27;),0) as A2,</span><br><span class="line">@A3:=IFNULL((select sum(c.ltimenum) from `salinvest` c where c.usercode=a.usercode AND c.gravalue=&#x27;A3&#x27;</span><br><span class="line">and c.logdate between &#x27;2020-01-01&#x27; and &#x27;2020-12-31&#x27;),0) as A3,</span><br><span class="line">@A4:=IFNULL((select sum(c.ltimenum) from `salinvest` c where c.usercode=a.usercode AND c.gravalue=&#x27;A4&#x27;</span><br><span class="line">and c.logdate between &#x27;2020-01-01&#x27; and &#x27;2020-12-31&#x27;),0) as A4,</span><br><span class="line">,(@A1+@A2+@A3+@A4) as allnum</span><br><span class="line">from userinfo a</span><br><span class="line">inner JOIN `salinvest` b on a.usercode = b.usercode</span><br><span class="line">where b.logdate between &#x27;2020-01-01&#x27; and &#x27;2020-12-31&#x27;</span><br><span class="line">order by allnum desc</span><br><span class="line">) as bdata,(SELECT @rowNO:=0) b;</span><br><span class="line">+----+--------------------+------------+------------+--------+------------------------+------------------------+---------+-----------------------+------+----------+-----------------------------------------------------------+</span><br><span class="line">| id | select_type        | table      | partitions | type   | possible_keys          | key                    | key_len | ref                   | rows | filtered | Extra                                                     |</span><br><span class="line">+----+--------------------+------------+------------+--------+------------------------+------------------------+---------+-----------------------+------+----------+-----------------------------------------------------------+</span><br><span class="line">|  1 | PRIMARY            | &lt;derived8&gt; | NULL       | system | NULL                   | NULL                   | NULL    | NULL                  |    1 |      100 | NULL                                                      |</span><br><span class="line">|  1 | PRIMARY            | &lt;derived2&gt; | NULL       | ALL    | NULL                   | NULL                   | NULL    | NULL                  |    2 |      100 | NULL                                                      |</span><br><span class="line">|  8 | DERIVED            | NULL       | NULL       | NULL   | NULL                   | NULL                   | NULL    | NULL                  | NULL | NULL     | No tables used                                            |</span><br><span class="line">|  2 | DERIVED            | b          | NULL       | index  | idx_salinvest_complex | idx_salinvest_complex | 170     | NULL                  |    5 |       20 | Using where; Using index; Using temporary; Using filesort |</span><br><span class="line">|  7 | DEPENDENT SUBQUERY | c          | NULL       | ALL    | idx_salinvest_complex | NULL                   | NULL    | NULL                  |    5 |       20 | Using where                                               |</span><br><span class="line">|  6 | DEPENDENT SUBQUERY | c          | NULL       | ALL    | idx_salinvest_complex | NULL                   | NULL    | NULL                  |    5 |       20 | Using where                                               |</span><br><span class="line">|  5 | DEPENDENT SUBQUERY | c          | NULL       | ALL    | idx_salinvest_complex | NULL                   | NULL    | NULL                  |    5 |       20 | Using where                                               |</span><br><span class="line">|  4 | DEPENDENT SUBQUERY | c          | NULL       | ALL    | idx_salinvest_complex | NULL                   | NULL    | NULL                  |    5 |       20 | Using where                                               |</span><br><span class="line">+----+--------------------+------------+------------+--------+------------------------+------------------------+---------+-----------------------+------+----------+-----------------------------------------------------------+</span><br><span class="line">9 rows in set</span><br></pre></td></tr></table></figure><p>看最后四条数据，看他的possible_key和 实际的key，预估是走 idx_salinvest_complex 索引，实际是走了空索引，这个是为什么呢？ 看前面的select_type 字段，值是 DEPENDENT SUBQUERY，了然了。</p><p>官方对 DEPENDENT SUBQUERY 的说明：子查询中的第一个SELECT， <strong>取决于外面的查询</strong> 。</p><p>什么意思呢？它意味着两步：</p><p>第一步，MySQL 根据 select distinct a.usercode,a.username 得到一个大结果集 t1，这就是我们上图提示的6000用户。</p><p>第二步，上面的大结果集 t1 中的每一条记录，等同于与子查询 SQL 组成新的查询语句： select sum(c.ltimenum) from <code>salinvest</code> c where c.usercode in (select distinct a.usercode from userinfo a) 。</p><p>也就是说， <strong>每个子查询要比较6000次，几十万的数据啊</strong>……即使这两步骤查询都用到了索引，但还是会很慢。</p><p>这种情况下， <strong>子查询的执行效率受制于外层查询的记录数，还不如拆成两个独立查询顺序执行呢</strong>。</p><p>这种慢查询的解决办法，网上有很多方案，最常用的办法是用联合查询代替子查询，可以自己去查一下。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>上面给出了两种典型的问题，一种是没有使用索引使用原则进行索引构建，一种是遇到坑导致索引无效。我们在实际的应用中遇到过很多问题。比如：</p><p>1、不多的数据结果集，但是涉及到超多个表join的低效脚本。</p><p>2、无效的联表查询，就是其中一张联表没有任何使用，但是数据基数极大。（这也可能是某个时候业务变更导致的sql脚本忘了调整）。</p><p>3、varchar类型字段等值比较没有写单引号，巨量基数笛卡尔积查询直接把从库搞死，在索引字段上做计算导致索引失效的。</p><p>所有的这些案例都只是一些经验积累，只有熟悉查询优化器、索引的内部原理，了解索引优化的策略，才能定位这些问题的原因并加以解决。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis系列：使用规范</title>
      <link href="/2025/04/16/Redis%E7%B3%BB%E5%88%97/Redis%E7%B3%BB%E5%88%97-%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83/"/>
      <url>/2025/04/16/Redis%E7%B3%BB%E5%88%97/Redis%E7%B3%BB%E5%88%97-%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Redis-操作规范"><a href="#1-Redis-操作规范" class="headerlink" title="1 Redis 操作规范"></a>1 Redis 操作规范</h1><h2 id="1-1-缓存的使用时机判断"><a href="#1-1-缓存的使用时机判断" class="headerlink" title="1.1 缓存的使用时机判断"></a>1.1 缓存的使用时机判断</h2><ol><li>【建议】系统为单体系统，整体QPS小于200的，不建议草率引入缓存，应该有更多的办法进行效率提升<br>缓存的引入根据系统的业务流量、应用规模而定，对于系统规模小低并发低流量的应用而言，引入缓存并不会带来性能的显著提升，反而会带来应用的复杂度以及较高的运维成本。</li><li>【建议】响应能力，数据响应的正常容忍度为0.5s，临界容忍度为2s，当我们发现响应时间超建议值，并没有太大优化空间的时候，可以考虑加入缓存。<br>说明：建立在对数据具有高效响应的需求的时候，缓存是基于内存映射的，相对于磁盘存取来说会快很多。</li><li>【建议】热点数据，这边指的是同一个系统中的相对热点数据，20%的数据占据了整个请求周期（比如24小时）的80%的流量，那就建议在这20%的流量上做缓存。<br>对于热点信息被频繁读取，为避免数据库超载的IO操作的情况下，可以适当使用缓存进行缓冲。</li><li>【建议】读写比例，缓存应该建立在多读少写（高频读取、低频修改）的业务场景中。<br>一般读写比要达到 9 : 1，读比例越高越好，这样建立缓存的价值比较大。</li></ol><h2 id="1-2-缓存类型的使用建议"><a href="#1-2-缓存类型的使用建议" class="headerlink" title="1.2 缓存类型的使用建议"></a>1.2 缓存类型的使用建议</h2><h3 id="1-2-1-数据类型"><a href="#1-2-1-数据类型" class="headerlink" title="1.2.1 数据类型"></a>1.2.1 数据类型</h3><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAIBBWlIrMak_cOgT_lX6Niv40cC81qAAALvC2sbp6dAVhH3MAOUNCLvAQADAgADeAADNgQ.png"><br>1.2.2 字符文本（REDIS_STRING) 适用场景建议</p><ol><li>【建议】选型为简易文本类缓存 ：比如普通的字符、文本、Json结构 ，通常能起到加速读写和降低后端压力的作用。</li><li>【建议】计数场景：用于对数值进行增减，同样适用于分布式系统的增量和减量计算<ul><li>incr&#x2F;decr key &#x2F;&#x2F; 自增1</li><li>incrby&#x2F;decrby key increment &#x2F;&#x2F; 增加指定数值</li><li>incrbyfloat&#x2F;decrbyfloat key increment &#x2F;&#x2F; 增加一个浮点数</li></ul></li><li>【建议】共享Session：在分布式系统中，用户的每次请求会访问到不同的服务器，这就会导致 session 不同步的问题。</li></ol><h3 id="1-2-3-列表（REDIS-LIST）适用场景建议"><a href="#1-2-3-列表（REDIS-LIST）适用场景建议" class="headerlink" title="1.2.3 列表（REDIS_LIST）适用场景建议"></a>1.2.3 列表（REDIS_LIST）适用场景建议</h3><ol><li>【建议】消息队列：列表用来存储多个有序的字符串，既然是有序的，那么就满足消息队列的特点。使用lpush+rpop或者rpush+lpop实现消息队列。</li><li>【建议】栈：由于列表存储的是有序字符串，满足队列的特点，也就能满足栈先进后出的特点，使用lpush+lpop或者rpush+rpop实现栈。</li><li>【建议】有序的对象列表：列表的元素不但是有序的，而且还支持按照索引范围获取元素。比如我们可以使用命令<code>lrange key 0 9</code>分页获取文章列表。<br>说明：朋友圈的点赞列表、评论列表、排行榜：lpush命令和lrange命令能实现最新列表的功能，每次通过lpush命令往列表里插入新的元素，然后通过lrange命令读取最新的元素列表。</li></ol><h3 id="1-2-4-哈希表（REDIS-HASH）适用场景建议"><a href="#1-2-4-哈希表（REDIS-HASH）适用场景建议" class="headerlink" title="1.2.4 哈希表（REDIS_HASH）适用场景建议"></a>1.2.4 哈希表（REDIS_HASH）适用场景建议</h3><ol><li>【建议】key、field、value结构场景，如购物车：<code>hset [key] [field] [value]</code> 命令， 可以实现以用户Id，商品Id为field，商品数量为value，恰好构成了购物车的3个要素。</li><li>【建议】对象存储场景：hash类型的(key, field, value)的结构与对象的(对象id, 属性, 值)的结构相似，也可以用来存储对象。<br>说明：Redis 中的Hash和 Java 的HashMap更加相似，是数组+链表的结构，当发生 hash 碰撞时将会把元素追加到链表上，值得注意的是在Redis的Hash中value只能是字符串。</li></ol><h3 id="1-2-5-集合（REDIS-SET）适用场景建议"><a href="#1-2-5-集合（REDIS-SET）适用场景建议" class="headerlink" title="1.2.5 集合（REDIS_SET）适用场景建议"></a>1.2.5 集合（REDIS_SET）适用场景建议</h3><p>说明：Redis 中的 Set和Java中的HashSet 类似，内部的键值对是无序、唯一 的。相当于一个特殊的字典，字典中所有的value默认都是一个NULL值。当集合中最后一个元素被移除之后，数据结构被自动删除，内存被回收。</p><ol><li><p>【建议】通用的HashSet 集合使用场景，对于Set中的取值、判断、统计，添加跟移出都有很便利的支持。</p><p>比如社交领域的 好友、关注、粉丝、感兴趣的人 等场景：</p><ul><li>sinter 命令可以获得A和B两个用户的共同好友；</li><li>sismember 命令可以判断A是否是B的好友；</li><li>scard 命令可以获取好友数量；</li><li>关注时，smove 命令可以将B从A的粉丝集合转移到A的好友集合</li></ul></li><li><p>【建议】Set具备随机获取能力，建议在一些对集合值随机取数场景使用。<br>类似首页展示随机：美团首页有很多推荐商家，但是并不能全部展示，set类型适合存放所有需要展示的内容，而 srandmember 命令则可以从中随机获取几个。</p></li><li><p>【建议】Set具备Single能力，建议在一些对集合值需要去重的场景中使用。<br>类似存储某活动中中奖的用户ID ，因为有去重功能，可以保证同一个用户不会中奖两次。</p></li></ol><h3 id="1-2-6-有序集合（REDIS-ZSET）适用场景建议"><a href="#1-2-6-有序集合（REDIS-ZSET）适用场景建议" class="headerlink" title="1.2.6 有序集合（REDIS_ZSET）适用场景建议"></a>1.2.6 有序集合（REDIS_ZSET）适用场景建议</h3><p>说明：zset也叫SortedSet，一方面保证了内部 value 的唯一性，另方面它可以给每个 value 赋予一个score，代表这个value的排序权重，所以又具备排序功能。</p><ol><li>【建议】带排序条件的列表集合，比如排行榜场景，但是和list不同的是zset它能够实现动态的排序，例如： 可以用来存储粉丝列表，value 值是粉丝的用户 ID，score 是关注时间，我们可以对粉丝列表按关注时间进行排序。<br>另外如 存储学生的成绩， value 值是学生的 ID, score 是他的考试成绩。 我们对成绩按分数进行排序就可以得到他的名次。</li></ol><h2 id="1-3-缓存的定义和使用规范"><a href="#1-3-缓存的定义和使用规范" class="headerlink" title="1.3 缓存的定义和使用规范"></a>1.3 缓存的定义和使用规范</h2><h3 id="1-3-1-Key-定义规范"><a href="#1-3-1-Key-定义规范" class="headerlink" title="1.3.1 Key 定义规范"></a>1.3.1 Key 定义规范</h3><ol><li>【必须】key的命名需遵循小写原则，且不允许重复key，否则会产生覆盖情况。</li><li>【必须】建议使用 “平台缩写“+“<em>”+“项目名”+“</em>”+“业务含义” 的英文作为key的前缀，防止key冲突，用下划线”_” 、”:” 或 “.” 作为间隔，字符包含A-Z,a-z,0-9,提高可读性和可维护性。<br>如 <code>mt_shop_order</code>、<code>bidu_istio_userinfo</code></li><li>【必须】禁止使用redis保留字命名key。<a href="http://redisdoc.com/">参考这边</a></li><li>【建议】合理控制key的长度，避免使用过长的key或者过简单的key，减少内存消耗并增加易读性，一般key长度不建议超过30字符;</li><li>【必须】禁止使用特殊字符：如空格、换行符、单双引号及其他转义字符等;</li><li>【建议】避免使用超大field的复杂类型对象，超大类型的field需要进行切割;</li></ol><h3 id="1-3-2-Value-使用规范"><a href="#1-3-2-Value-使用规范" class="headerlink" title="1.3.2 Value 使用规范"></a>1.3.2 Value 使用规范</h3><ol><li>【必须】禁止使用bigkey，防止网卡流量过载和慢查询,如：string类型控制在10KB以内，hash、list、set、zset 元素个数不要超过5000;</li><li>【建议】非字符串的bigkey，尽量避免使用整体 del删除，使用hscan、sscan、zscan方式渐进式删除，可pipeline加速，同时要注意防止bigkey过期时间自动删除问题导致的性能损耗;</li><li>【建议】选择合适的数据类型，节省内存，提高性能; 我们在数据类型的使用规范建议那边有提出了建议。</li></ol><h3 id="1-3-3-实例及资源使用规范"><a href="#1-3-3-实例及资源使用规范" class="headerlink" title="1.3.3 实例及资源使用规范"></a>1.3.3 实例及资源使用规范</h3><ol><li>【建议】单一职责原则：一个业务使用一个实例，避免多个业务共用一个实例;<br>这个是指做Redis实例拆分的时候，尽量按照业务领域去拆分。并不是指一个业务程序只能调用一个缓存实例。<br>做隔离一方面是避免业务相互影响，另一方面避免单实例膨胀，并能在故障时降低影响面，快速恢复。</li><li>【建议】单个实例最大内存占用率使用不能超过实体机的80% 。 指标：保证 ≤ 80%， ≤ 50% 优</li><li>【建议】单个实例最大CPU占用率使用不能超过实体机的70% 。指标：保证 ≤ 70%以内，≤ 50 % 优</li><li>【建议】按业务线合理预估内存使用大小(一般为6个月 - 24个月);</li><li>【建议】分析缓存命中率，缓存的命中率应该高达80%以上，至少不低于 60%，否则需检查是否有不合理的缓存使用。</li><li>【建议】为缓存实例指定对应的服务应用，同一个服务下的不同实例可以直连访问。其它服务需要访问则要通过接口进行访问。</li></ol><h3 id="1-3-4-垃圾回收及失效规范"><a href="#1-3-4-垃圾回收及失效规范" class="headerlink" title="1.3.4 垃圾回收及失效规范"></a>1.3.4 垃圾回收及失效规范</h3><ol><li>【必须】提前评估数据的生命周期，合理设置数据过期时间和实效策略，如无特殊情况，所有key必须均设置过期时间;</li><li>【必须】避免使用系统自带的自动过期时间机制;</li><li>【建议】定期手动清理数据空间，避免僵尸缓存占用空间;</li><li>【建议】批量建立的缓存需要打散过期时间，防止集中过期导致数据不可恢复带来的影响; 一般我们采用 n * 3&#x2F;4 + n * random() 。所以，如果是8小时，就是6小时 + 0~2小时的随机值。<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAOPaUNosuZTM5re2ZEgCalk6Tr-h2kAAn8LaxvvjBhWkQxl3WUd_04BAAMCAAN5AAM2BA.png" alt="image"></li><li>【必须】尽量避免将缓存持久化，这也是Redis官方的建议，需要将缓存持久化的项（无论是AOF还是RDB）或者无过期时间的项，均需严格报备评审并做记录，无用时需严格销毁。</li></ol><h3 id="1-3-5-命令使用规范"><a href="#1-3-5-命令使用规范" class="headerlink" title="1.3.5 命令使用规范"></a>1.3.5 命令使用规范</h3><ol><li>【建议】控制列表长度N的数量，一般控制在1W以内，有遍历的需求可以使用hscan、sscan、zscan代替;<br>一个列表最多可以包含 2^32 - 1 个元素 (4294967295, 每个列表超过40亿个元素)，但是如果列表太长，就跟它高速缓存的目标相悖</li><li>【必须】禁止使用keys、flushall、flushdb等操作;<ul><li>KEYS：该命令需要对 Redis 的全局哈希表进行全表扫描，严重阻塞 Redis 主线程；（应该使用 scan 来代替，分批返回符合条件的键值对，避免主线程阻塞）</li><li>FLUSHALL：删除 Redis 实例上的所有数据，如果数据量很大，会严重阻塞 Redis 主线程；</li><li>FLUSHDB，删除当前数据库中的数据，如果数据量很大，同样会阻塞 Redis 主线程。（加上 ASYNC 选项，让 FLUSHALL，FLUSHDB 异步执行）</li></ul></li><li>【建议】使用批量操作，提高效率，控制一次性操作元素个数，建议为500;<br>说明：获取集合中的元素（HASH 类型的 hgetall、List 类型的 lrange、Set 类型的 smembers、zrange 等命令）。如果全量或大量操作会对整个底层数据结构进行全量扫描 ，导致阻塞 Redis 主线程。</li><li>【建议】减少事务的使用(redis暂时不支持事务回滚)；</li><li>【必须】扫描涉及元素数量比较大且设置过期时间的禁止使用scan;</li></ol><h1 id="2-Redis-高可用操作规范"><a href="#2-Redis-高可用操作规范" class="headerlink" title="2 Redis 高可用操作规范"></a>2 Redis 高可用操作规范</h1><p>说明：本标准以业内现有的主流分布式数据存储服务能力 为参考，建议读者在设计具备高可用缓存服务的时候，可以通过以下几个部分进行衡量。</p><h2 id="2-1-高可用集群模式设计"><a href="#2-1-高可用集群模式设计" class="headerlink" title="2.1 高可用集群模式设计"></a>2.1 高可用集群模式设计</h2><p>主要包含三种模式：常规的主从模式，哨兵模式，和高扩展的分布式集群，配合使用。读者在在设计的时候，根据业务规模和具体实现情况进行选择。</p><ol><li>【必须】最低要求，主从集群模式下，需保证如果主库发生故障，能够识别到即对主从进行切换，并利用心跳包进行探活并恢复。</li><li>【建议】尽量满足，哨兵模式下，会有对应的竞选机制，对故障进行下线，对新主机进行竞选。</li><li>【建议】尽量满足，分布式集群下，支持对集群的 负载均衡、强事务、故障离群和恢复能力。<br>★设计建议参考业内竞品作为准入标准，如DBProxy 包含 Sentinal进程，为探活、故障离群和故障恢复提供很好的帮助。</li></ol><h2 id="2-2-安全建设能力设计"><a href="#2-2-安全建设能力设计" class="headerlink" title="2.2 安全建设能力设计"></a>2.2 安全建设能力设计</h2><p>设计时需要保证如下基本要求：</p><ol><li>【必须】对于敏感数据进行加密，如身份证、电话、用户住址等，密码类需保证不可逆。</li><li>【必须】支持IP黑白名单配置，避免非法IP的恶意访问。</li><li>【必须】对于SQL入侵、注入有比较好的检测和隔离，非法字符的过滤和转义，这个需要武装到程序级别上，业内已经有很标准的方案了。<br>准入的标准就是拦截率超过 95%，准确率99.9%（需避免误拦截正确的请求）以上。</li><li>【必须】核心模块有标准的操作记录（如 操作模块、操作人员、操作时间、数据变动、说明），支持SQL安全审计。</li></ol><h2 id="2-3-备份与恢复能力设计"><a href="#2-3-备份与恢复能力设计" class="headerlink" title="2.3 备份与恢复能力设计"></a>2.3 备份与恢复能力设计</h2><ol><li>【必须】支持定时自动备份（编写备份脚本自动执行 或者 任务服务去定时执行）和手动备份</li><li>【必须】支持定期的全量备份 Week级别、Month级别 ，和定期 Day级别 的增量备份</li><li>【必须】有完整的灾备恢复操作文档 和 定期演练机制，保证 恢复速度10G&#x2F;min ，数据完整性99.99%，恢复成功率：99.99%。</li></ol><h2 id="2-4-高可用架构-异地多活"><a href="#2-4-高可用架构-异地多活" class="headerlink" title="2.4 高可用架构-异地多活"></a>2.4 高可用架构-异地多活</h2><p>异地多活</p><ol><li>【建议】异地多活，多IDC，能保证非强同步（即异步同步），也就是说数据保持最终一致性，并非强一致性。</li><li>【建议】多主之间需保证支持至少 1W TPS传输峰值达到 10M&#x2F;s。</li><li>【建议】机房具备容灾：建议多IDC部署，避免单个机房掉电、火灾、网络故障 导致整个系统不可用。</li><li>【建议】需保证单机房异交换机部署方式，具备一定的高可用能力。可以部署多个节点，部分节点挂掉后不影响业务；<br>数据节点支持多副本，单节点挂掉后，不影响业务，管理节点具备高可用性，支持多个节点部署。</li><li>【建议】异地机房如果只是用作备服，异步同步可以允许有些许数据延迟，延迟时间不应超过5分钟。<br>异地的数据中心 主 - 主 同步采用的是异步同步，如下图所示，是异步获取的，会因为延迟导致的数据暂时不一致性。<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAIBBmlIruitPaHN93gs6sQBTGnrBIVKAAIGDGsbp6dAVp53vsuevk8XAQADAgADeAADNgQ.png"></li></ol><h2 id="2-5-缓存击穿、缓存雪崩、缓存穿透预防设计"><a href="#2-5-缓存击穿、缓存雪崩、缓存穿透预防设计" class="headerlink" title="2.5 缓存击穿、缓存雪崩、缓存穿透预防设计"></a>2.5 缓存击穿、缓存雪崩、缓存穿透预防设计</h2><h3 id="2-5-1-随机过期时间（参考1-3-4-第-4点做法）"><a href="#2-5-1-随机过期时间（参考1-3-4-第-4点做法）" class="headerlink" title="2.5.1 随机过期时间（参考1.3.4 第 4点做法）"></a>2.5.1 随机过期时间（参考1.3.4 第 4点做法）</h3><h3 id="2-5-2-大数据集合场景启用BloomFilter"><a href="#2-5-2-大数据集合场景启用BloomFilter" class="headerlink" title="2.5.2 大数据集合场景启用BloomFilter"></a>2.5.2 大数据集合场景启用BloomFilter</h3><p>参考这篇：<a href="https://yeoh.qzz.io/2025/03/20/Redis%E7%B3%BB%E5%88%97/Redis%E7%B3%BB%E5%88%97-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/">Redis系列：聊聊布隆过滤器 | 数根朽木，</a></p><h3 id="2-5-3-短暂降级：空初始值"><a href="#2-5-3-短暂降级：空初始值" class="headerlink" title="2.5.3 短暂降级：空初始值"></a>2.5.3 短暂降级：空初始值</h3><p>参考这篇：<a href="https://yeoh.qzz.io/2025/04/19/%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%80%9D%E7%BB%B4/%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%80%9D%E7%BB%B4-%E5%86%8D%E8%81%8A%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%EF%BC%8C%E9%9D%A2%E8%AF%95%E6%98%AF%E4%B8%80%E5%9C%BA%E5%8D%9A%E5%BC%88/">架构与思维：再聊缓存击穿，面试是一场博弈 | 数根朽木，</a></p><h3 id="2-5-4-计算服务层或数据服务层降级、限流"><a href="#2-5-4-计算服务层或数据服务层降级、限流" class="headerlink" title="2.5.4 计算服务层或数据服务层降级、限流"></a>2.5.4 计算服务层或数据服务层降级、限流</h3><p>完整策略参考这篇：<a href="https://yeoh.qzz.io/2025/03/20/%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%80%9D%E7%BB%B4/%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%80%9D%E7%BB%B4-%E4%B8%80%E6%AC%A1%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E7%9A%84%E7%81%BE%E9%9A%BE%E5%A4%8D%E7%9B%98/">缓存雪崩的预防设计</a></p><h1 id="3-流程上的约束"><a href="#3-流程上的约束" class="headerlink" title="3 流程上的约束"></a>3 流程上的约束</h1><ol><li>建立严格的代码评审机制和刷库评审机制。操作Redis的代码提交合并或者脚本提交刷库执行之前需要上级评审&#x2F;交叉评审。</li><li>引入开源评审工具。增加扫描工具、脚本进行定期检查MySQL、Redis。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL系列：一次深夜优化亿级数据分页的奇妙经历(转载)</title>
      <link href="/2025/04/15/MySQL%E7%B3%BB%E5%88%97/MySQL%E7%B3%BB%E5%88%97-%E4%B8%80%E6%AC%A1%E6%B7%B1%E5%A4%9C%E4%BC%98%E5%8C%96%E4%BA%BF%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%88%86%E9%A1%B5%E7%9A%84%E5%A5%87%E5%A6%99%E7%BB%8F%E5%8E%86%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/"/>
      <url>/2025/04/15/MySQL%E7%B3%BB%E5%88%97/MySQL%E7%B3%BB%E5%88%97-%E4%B8%80%E6%AC%A1%E6%B7%B1%E5%A4%9C%E4%BC%98%E5%8C%96%E4%BA%BF%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%88%86%E9%A1%B5%E7%9A%84%E5%A5%87%E5%A6%99%E7%BB%8F%E5%8E%86%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>某天晚上10点半，下班后愉快的坐在在回家的地铁上，心里想着周末的生活怎么安排。</p><p>突然电话响了起来，一看是我们的一个开发同学，顿时紧张了起来，本周的版本已经发布过了，这时候打电话一般来说是线上出问题了。</p><p>果然，沟通的情况是线上的一个查询数据的接口被疯狂的失去理智般的调用，这个操作直接导致线上的MySql集群被拖慢了。</p><p>好吧，这问题算是严重了，下了地铁匆匆赶到家，开电脑，跟同事把Pinpoint上的慢查询日志捞出来。看到一个很奇怪的查询，如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST  domain/v1.0/module/method?order=condition&amp;orderType=desc&amp;offset=1800000&amp;limit=500</span><br></pre></td></tr></table></figure><p>domain、module 和 method 都是化名，代表接口的域、模块和实例方法名，后面的offset和limit代表<strong>分页操作</strong>的<strong>偏移量</strong>和每页的<strong>数量</strong>，也就是说该同学是在 翻第（1800000&#x2F;500+1&#x3D;3601）页。初步捞了一下日志，发现 有8000多次这样调用。</p><p>这太神奇了，而且我们页面上的分页单页数量也不是500，而是 25条每页，这个绝对不是人为的在功能页面上进行一页一页的翻页操作，而是数据被刷了（说明下，我们生产环境数据有1亿+）。 详细对比日志发现，很多分页的时间是重叠的，对方应该是多线程调用。</p><p>通过对鉴权的Token的分析，基本定位了请求是来自一个叫做ApiAutotest的客户端程序在做这个操作，也定位了生成鉴权Token的账号来自一个QA的同学。立马打电话给同学，进行了沟通和处理。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>其实对于我们的MySQL查询语句来说，整体效率还是可以的，该有的联表查询优化都有，该简略的查询内容也有，关键条件字段和排序字段该有的索引也都在，问题在于他一页一页的分页去查询，查到越后面的页数，扫描到的数据越多，也就越慢。</p><p>我们在查看前几页的时候，发现速度非常快，比如  limit 200,25，瞬间就出来了。但是越往后，速度就越慢，特别是百万条之后，卡到不行，那这个是什么原理呢。先看一下我们翻页翻到后面时，查询的sql是怎样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t_name where c_name1=&#x27;xxx&#x27; order by c_name2 limit 2000000,25;</span><br></pre></td></tr></table></figure><p>这种查询的慢，其实是因为limit后面的偏移量太大导致的。比如像上面的 limit 2000000,25 ，这个等同于数据库要扫描出 2000025条数据，然后再丢弃前面的 20000000条数据，返回剩下25条数据给用户，这种取法明显不合理。</p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAPXaUe1ggABoBYo8n2-fgSCIap5tuXcAAITDGsbp6c4Vjnq_IYqESiEAQADAgADeAADNgQ.png"> </p><p>大家翻看《高性能MySQL》第六章：查询性能优化，对这个问题有过说明： </p><p>分页操作通常会使用limit加上偏移量的办法实现，同时再加上合适的order by子句。但这会出现一个常见问题：当偏移量非常大的时候，它会导致MySQL扫描大量不需要的行然后再抛弃掉。 </p><h3 id="数据模拟"><a href="#数据模拟" class="headerlink" title="数据模拟"></a>数据模拟</h3><p>那好，了解了问题的原理，那就要试着解决它了。涉及数据敏感性，我们这边模拟一下这种情况，构造一些数据来做测试。</p><p>1、创建两个表：员工表和部门表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/*部门表,存在则进行删除 */</span><br><span class="line">drop table if EXISTS dep;</span><br><span class="line">create table dep(</span><br><span class="line">    id int unsigned primary key auto_increment,</span><br><span class="line">    depno mediumint unsigned not null default 0,</span><br><span class="line">    depname varchar(20) not null default &quot;&quot;,</span><br><span class="line">    memo varchar(200) not null default &quot;&quot;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">/*员工表,存在则进行删除*/</span><br><span class="line">drop table if EXISTS emp;</span><br><span class="line">create table emp(</span><br><span class="line">    id int unsigned primary key auto_increment,</span><br><span class="line">    empno mediumint unsigned not null default 0,</span><br><span class="line">    empname varchar(20) not null default &quot;&quot;,</span><br><span class="line">    job varchar(9) not null default &quot;&quot;,</span><br><span class="line">    mgr mediumint unsigned not null default 0,</span><br><span class="line">    hiredate datetime not null,</span><br><span class="line">    sal decimal(7,2) not null,</span><br><span class="line">    comn decimal(7,2) not null,</span><br><span class="line">    depno mediumint unsigned not null default 0</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>2、创建两个函数：生成随机字符串和随机编号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/* 产生随机字符串的函数*/</span><br><span class="line">DELIMITER $</span><br><span class="line">drop FUNCTION if EXISTS rand_string;</span><br><span class="line">CREATE FUNCTION rand_string(n INT) RETURNS VARCHAR(255)</span><br><span class="line">BEGIN</span><br><span class="line">    DECLARE chars_str VARCHAR(100) DEFAULT &#x27;abcdefghijklmlopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;;</span><br><span class="line">    DECLARE return_str VARCHAR(255) DEFAULT &#x27;&#x27;;</span><br><span class="line">    DECLARE i INT DEFAULT 0;</span><br><span class="line">    WHILE i &lt; n DO</span><br><span class="line">    SET return_str = CONCAT(return_str,SUBSTRING(chars_str,FLOOR(1+RAND()*52),1));</span><br><span class="line">    SET i = i+1;</span><br><span class="line">    END WHILE;</span><br><span class="line">    RETURN return_str;</span><br><span class="line">END $</span><br><span class="line">DELIMITER;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*产生随机部门编号的函数*/</span><br><span class="line">DELIMITER $</span><br><span class="line">drop FUNCTION if EXISTS rand_num;</span><br><span class="line">CREATE FUNCTION rand_num() RETURNS INT(5)</span><br><span class="line">BEGIN</span><br><span class="line">    DECLARE i INT DEFAULT 0;</span><br><span class="line">    SET i = FLOOR(100+RAND()*10);</span><br><span class="line">    RETURN i;</span><br><span class="line">END $</span><br><span class="line">DELIMITER;</span><br></pre></td></tr></table></figure><p>3、编写存储过程，模拟500W的员工数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/*建立存储过程：往emp表中插入数据*/</span><br><span class="line">DELIMITER $</span><br><span class="line">drop PROCEDURE if EXISTS insert_emp;</span><br><span class="line">CREATE PROCEDURE insert_emp(IN START INT(10),IN max_num INT(10))</span><br><span class="line">BEGIN</span><br><span class="line">    DECLARE i INT DEFAULT 0;</span><br><span class="line">    /*set autocommit =0 把autocommit设置成0，把默认提交关闭*/</span><br><span class="line">    SET autocommit = 0;</span><br><span class="line">    REPEAT</span><br><span class="line">    SET i = i + 1;</span><br><span class="line">    INSERT INTO emp(empno,empname,job,mgr,hiredate,sal,comn,depno) VALUES ((START+i),rand_string(6),&#x27;SALEMAN&#x27;,0001,now(),2000,400,rand_num());</span><br><span class="line">    UNTIL i = max_num</span><br><span class="line">    END REPEAT;</span><br><span class="line">    COMMIT;</span><br><span class="line">END $</span><br><span class="line">DELIMITER;</span><br><span class="line">/*插入500W条数据*/</span><br><span class="line">call insert_emp(0,5000000);</span><br></pre></td></tr></table></figure><p>4、编写存储过程，模拟120的部门数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/*建立存储过程：往dep表中插入数据*/</span><br><span class="line">DELIMITER $</span><br><span class="line">drop PROCEDURE if EXISTS insert_dept;</span><br><span class="line">CREATE PROCEDURE insert_dept(IN START INT(10),IN max_num INT(10))</span><br><span class="line">BEGIN</span><br><span class="line">    DECLARE i INT DEFAULT 0;</span><br><span class="line">    SET autocommit = 0;</span><br><span class="line">    REPEAT</span><br><span class="line">    SET i = i+1;</span><br><span class="line">    INSERT  INTO dep( depno,depname,memo) VALUES((START+i),rand_string(10),rand_string(8));</span><br><span class="line">    UNTIL i = max_num</span><br><span class="line">    END REPEAT;</span><br><span class="line">    COMMIT;</span><br><span class="line">END $</span><br><span class="line">DELIMITER;</span><br><span class="line">/*插入120条数据*/</span><br><span class="line">call insert_dept(1,120);</span><br></pre></td></tr></table></figure><p> 5、建立关键字段的索引，这边是跑完数据之后再建索引，会导致建索引耗时长，但是跑数据就会快一些。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/*建立关键字段的索引:排序、条件*/</span><br><span class="line">CREATE INDEX idx_emp_id ON emp(id);</span><br><span class="line">CREATE INDEX idx_emp_depno ON emp(depno);</span><br><span class="line">CREATE INDEX idx_dep_depno ON dep(depno); </span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>测试数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/*偏移量为100，取25*/</span><br><span class="line">SELECT a.empno,a.empname,a.job,a.sal,b.depno,b.depname</span><br><span class="line">from emp a left join dep b on a.depno = b.depno order by a.id desc limit 100,25;</span><br><span class="line">/*偏移量为4800000，取25*/</span><br><span class="line">SELECT a.empno,a.empname,a.job,a.sal,b.depno,b.depname</span><br><span class="line">from emp a left join dep b on a.depno = b.depno order by a.id desc limit 4800000,25; </span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[SQL]</span><br><span class="line">SELECT a.empno,a.empname,a.job,a.sal,b.depno,b.depname</span><br><span class="line">from emp a left join dep b on a.depno = b.depno order by a.id desc limit 100,25;</span><br><span class="line">受影响的行: 0</span><br><span class="line">时间: 0.001s</span><br><span class="line">[SQL]</span><br><span class="line">SELECT a.empno,a.empname,a.job,a.sal,b.depno,b.depname</span><br><span class="line">from emp a left join dep b on a.depno = b.depno order by a.id desc limit 4800000,25;</span><br><span class="line">受影响的行: 0</span><br><span class="line">时间: 12.275s</span><br></pre></td></tr></table></figure><p>因为扫描的数据多，所以这个明显不是一个量级上的耗时。 </p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="1、使用索引覆盖-子查询优化"><a href="#1、使用索引覆盖-子查询优化" class="headerlink" title="1、使用索引覆盖+子查询优化"></a>1、使用索引覆盖+子查询优化</h4><p>因为我们有主键id，并且在上面建了索引，所以可以先在索引树中找到开始位置的 id值，再根据找到的id值查询行数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/*子查询获取偏移100条的位置的id，在这个位置上往后取25*/</span><br><span class="line">SELECT a.empno,a.empname,a.job,a.sal,b.depno,b.depname</span><br><span class="line">from emp a left join dep b on a.depno = b.depno</span><br><span class="line">where a.id &gt;= (select id from emp order by id limit 100,1)</span><br><span class="line">order by a.id limit 25;</span><br><span class="line"></span><br><span class="line">/*子查询获取偏移4800000条的位置的id，在这个位置上往后取25*/</span><br><span class="line">SELECT a.empno,a.empname,a.job,a.sal,b.depno,b.depname</span><br><span class="line">from emp a left join dep b on a.depno = b.depno</span><br><span class="line">where a.id &gt;= (select id from emp order by id limit 4800000,1)</span><br><span class="line">order by a.id limit 25;</span><br></pre></td></tr></table></figure><p> 执行结果</p><p>执行效率相比之前有大幅的提升：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[SQL]</span><br><span class="line">SELECT a.empno,a.empname,a.job,a.sal,b.depno,b.depname</span><br><span class="line">from emp a left join dep b on a.depno = b.depno</span><br><span class="line">where a.id &gt;= (select id from emp order by id limit 100,1)</span><br><span class="line">order by a.id limit 25;</span><br><span class="line">受影响的行: 0</span><br><span class="line">时间: 0.106s</span><br><span class="line"></span><br><span class="line">[SQL]</span><br><span class="line">SELECT a.empno,a.empname,a.job,a.sal,b.depno,b.depname</span><br><span class="line">from emp a left join dep b on a.depno = b.depno</span><br><span class="line">where a.id &gt;= (select id from emp order by id limit 4800000,1)</span><br><span class="line">order by a.id limit 25;</span><br><span class="line">受影响的行: 0</span><br><span class="line">时间: 1.541s</span><br></pre></td></tr></table></figure><h4 id="2、起始位置重定义"><a href="#2、起始位置重定义" class="headerlink" title="2、起始位置重定义"></a>2、起始位置重定义</h4><p>记住上次查找结果的主键位置，避免使用偏移量 offset</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[SQL]</span><br><span class="line">SELECT a.empno,a.empname,a.job,a.sal,b.depno,b.depname</span><br><span class="line">from emp a left join dep b on a.depno = b.depno</span><br><span class="line">where a.id &gt;= (select id from emp order by id limit 100,1)</span><br><span class="line">order by a.id limit 25;</span><br><span class="line">受影响的行: 0</span><br><span class="line">时间: 0.106s</span><br><span class="line"></span><br><span class="line">[SQL]</span><br><span class="line">SELECT a.empno,a.empname,a.job,a.sal,b.depno,b.depname</span><br><span class="line">from emp a left join dep b on a.depno = b.depno</span><br><span class="line">where a.id &gt;= (select id from emp order by id limit 4800000,1)</span><br><span class="line">order by a.id limit 25;</span><br><span class="line">受影响的行: 0</span><br><span class="line">时间: 1.541s</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[SQL]</span><br><span class="line">SELECT a.id,a.empno,a.empname,a.job,a.sal,b.depno,b.depname</span><br><span class="line">from emp a left join dep b on a.depno = b.depno</span><br><span class="line">where a.id &gt; 100 order by a.id limit 25;</span><br><span class="line">受影响的行: 0</span><br><span class="line">时间: 0.001s</span><br><span class="line"></span><br><span class="line">[SQL]</span><br><span class="line">SELECT a.id,a.empno,a.empname,a.job,a.sal,b.depno,b.depname</span><br><span class="line">from emp a left join dep b on a.depno = b.depno</span><br><span class="line">where a.id &gt; 4800000</span><br><span class="line">order by a.id limit 25;</span><br><span class="line">受影响的行: 0</span><br><span class="line">时间: 0.000s</span><br></pre></td></tr></table></figure><p>这个效率是最好的，无论怎么分页，耗时基本都是一致的，因为他执行完条件之后，都只扫描了25条数据。</p><p>但是有个问题，只适合一页一页的分页，这样才能记住前一个分页的最后Id。如果用户跳着分页就有问题了，比如刚刚刷完第25页，马上跳到35页，数据就会不对。</p><p>这种的适合场景是类似百度搜索或者腾讯新闻那种滚轮往下拉，不断拉取不断加载的情况。这种延迟加载会保证数据不会跳跃着获取。</p><h4 id="3、降级策略"><a href="#3、降级策略" class="headerlink" title="3、降级策略"></a>3、降级策略</h4><p>看了网上一个阿里的dba同学分享的方案：配置limit的偏移量和获取数一个最大值，超过这个最大值，就返回空数据。</p><p>因为他觉得超过这个值你已经不是在分页了，而是在刷数据了，如果确认要找数据，应该输入合适条件来缩小范围，而不是一页一页分页。</p><p>这个跟我同事的想法大致一样：request的时候 如果offset大于某个数值就先返回一个4xx的错误。 </p><h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><p>当晚我们应用上述第三个方案，对offset做一下限流，超过某个值，就返回空值。第二天使用第一种和第二种配合使用的方案对程序和数据库脚本进一步做了优化。</p><p>合理来说做任何功能都应该考虑极端情况，设计容量都应该涵盖极端边界测试。</p><p>另外，该有的限流、降级也应该考虑进去。比如工具多线程调用，在短时间频率内8000次调用，可以使用计数服务判断并反馈用户调用过于频繁，直接给予断掉。</p><p>哎，大意了啊，搞了半夜，QA同学不讲武德。不过这是很美好的经历了。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL系列：构建高性能索引（策略篇）</title>
      <link href="/2025/04/15/MySQL%E7%B3%BB%E5%88%97/MySQL%E7%B3%BB%E5%88%97-%E6%9E%84%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%B4%A2%E5%BC%95%EF%BC%88%E7%AD%96%E7%95%A5%E7%AF%87%EF%BC%89/"/>
      <url>/2025/04/15/MySQL%E7%B3%BB%E5%88%97/MySQL%E7%B3%BB%E5%88%97-%E6%9E%84%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%B4%A2%E5%BC%95%EF%BC%88%E7%AD%96%E7%95%A5%E7%AF%87%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>学习如果构建高性能的索引之前，我们先来了解下之前的知识，以下两篇是基础原理，了解之后，对面后续索引构建的原则和优化方法会有更清晰的理解：</p><p><a href="https://yeoh.qzz.io/2025/04/15/MySQL%E7%B3%BB%E5%88%97-%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">MySQL系列：MySQl索引的介绍和原理分析 | 数根朽木，</a></p><p><a href="https://yeoh.qzz.io/2025/04/15/MySQL%E7%B3%BB%E5%88%97-%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">MySQL系列：MySQl索引的介绍和原理分析 | 数根朽木，</a></p><p>我们编写索引的目的是什么？就是使我们的sql语句执行得更加高效，更快的获取或者处理数据，这个也是建设高性能Web的必要条件。</p><p>只有我们深刻理解了索引的原理和执行过程，才能知道怎么恰当地使用索引，以及怎么达到最优的查询。</p><h3 id="知识回顾"><a href="#知识回顾" class="headerlink" title="知识回顾"></a>知识回顾</h3><p>innodb是MySQL默认的存储引擎，使用范围也较广，我们就以innodb存储引擎为例来进行下面方案的说明。</p><h4 id="b-树存储结构"><a href="#b-树存储结构" class="headerlink" title="b+树存储结构"></a>b+树存储结构</h4><p>MySQL采用b+树的方式存储索引信息。b+树图例如下：</p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAPpaUfJ6w-FBvI6v1pnWhFJvkY1a6oAAksMaxunpzhWdhCIixZeiOMBAAMCAAN3AAM2BA.png"></p><h4 id="b-树结构特点"><a href="#b-树结构特点" class="headerlink" title="b+树结构特点"></a>b+树结构特点</h4><p>1、叶子节点存储关键字（索引字段的值）信息及对应的值（完整记录）。</p><p>2、其他非叶子节点只存储键值信息及子节点的链指针</p><p>3、每个叶子节点相当于MySQL中的一页，同层级的叶子节点以双向链表的形式相连</p><p>4、每个节点（页）中存储了多条记录，记录之间用单链表的形式连接组成了一条有序的链表，顺序是按照索引字段排序的</p><p>5、b+树中检索数据时：每次检索都是从根节点开始，一直需要搜索到叶子节点，如图中所示.</p><p>InnoDB 的数据是按数据页为单位来读写的。也就是说，当需要读取一条记录的时候，并不是将这个记录本身从磁盘读取出来，而是以页为单位，将整个也加载到内存中，一个页中可能有很多记录，然后在内存中对页进行检索。</p><p>在innodb中，每个页的大小默认是16kb。</p><h4 id="Mysql中索引包含"><a href="#Mysql中索引包含" class="headerlink" title="Mysql中索引包含"></a>Mysql中索引包含</h4><h5 id="聚集索引（主键索引）"><a href="#聚集索引（主键索引）" class="headerlink" title="聚集索引（主键索引）"></a>聚集索引（主键索引）</h5><p>每个表一定会有一个聚集索引（即主键索引），而表中的数据以b+树的方式存储，b+树叶子节点中的key为主键值，data为完整记录的信息，非叶子节点存储的是主键的值。</p><p>通过聚集索引检索数据只需要按照b+树的搜索过程，即可以检索到对应的记录。</p><h5 id="非聚集索引（辅助索引）"><a href="#非聚集索引（辅助索引）" class="headerlink" title="非聚集索引（辅助索引）"></a>非聚集索引（辅助索引）</h5><p>每个表可以有多个非聚集索引，b+树结构，叶子节点的key为索引字段字段的值，data为主键的值，非叶子节点只存储索引字段的值。</p><p>通过非聚集索引检索记录的时候，需要2次操作，先在非聚集索引中检索出主键，然后再到聚集索引中检索出主键对应的记录，这个过程叫做回表，比聚集索引多了一次操作。</p><h4 id="保证索引有效使用"><a href="#保证索引有效使用" class="headerlink" title="保证索引有效使用"></a>保证索引有效使用</h4><p>有效索引是指我们的某些字段上建立了索引，并且在对该字段进行检索过程中，能够快速定位到目标数据所在的页，有效的降低页的io操作，而不是去扫描所有的数据页，这样才算有效的利用索引，</p><p>保证了检索是有效使用索引的（俗称检索走了索引）。但如果检索过程不能够确定数据在某些页中，而进行了大量的数据页扫描，我们则认为这种情况下索引对查询是无效的。 </p><h4 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h4><p>1、索引大大减少了服务器需要扫描的数据量</p><p>2、索引可以帮助服务器避免排序和临时表</p><p>3、索引可以将随机I&#x2F;O变为顺序I&#x2F;O</p><h3 id="b-树中数据执行过程"><a href="#b-树中数据执行过程" class="headerlink" title="b+树中数据执行过程"></a>b+树中数据执行过程</h3><h4 id="唯一记录定位"><a href="#唯一记录定位" class="headerlink" title="唯一记录定位"></a>唯一记录定位</h4><p> <img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAPqaUfKF_kZSCW1EMsYy-N29QriGwYAAkwMaxunpzhW0KKRUr6EUaUBAAMCAAN3AAM2BA.png"></p><p>上图中所有的数据都是唯一的，查询306的记录，过程如下：</p><p>1、将Disk1页加载到内存</p><p>2、在内存中采用二分法查找，可以确定306位于[300,350)中间，所以我们需要去加载100关联Disk5</p><p>3、将Disk5加载到内存中，采用二分法找到306的记录</p><h4 id="查询所有同值记录"><a href="#查询所有同值记录" class="headerlink" title="查询所有同值记录"></a>查询所有同值记录</h4><p> <img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAPraUfKafplSSE_FIXGGkFipCyTtfMAAlgMaxunpzhWKrO1ma0xMUQBAAMCAAN3AAM2BA.png"></p><p>上图中306有多条记录，我们查询306的所有记录步骤如下：</p><p>1、将Disk1页加载到内存</p><p>2、在内存中采用二分法查找，可以确定306位于[300,350)中间，所以我们需要去加载100关联Disk5</p><p>3、将Disk5加载到内存中，采用二分法找到第一个小于306的记录，即300，从300这个点按照链表向后访问，找到所有的306记录，遇到大于306的停止</p><h4 id="范围查找"><a href="#范围查找" class="headerlink" title="范围查找"></a>范围查找</h4><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAPsaUfKm3EGSqX8F1d7SKYy9XDCoaYAAlkMaxunpzhWySBxcMo8CqgBAAMCAAN3AAM2BA.png"> </p><p>数据如上图，查询[255,355]所有记录，因为Page和Page之间是双向链表并且是ASC顺序结构，页内部的数据是单项ASC顺序链表结构，所以只用找到范围的起始值所在的位置，然后通过依靠链表访问两个位置之间所有的数据即可，</p><p>步骤如下：</p><p>1、将PDisk1页加载到内存</p><p>2、内存中采用二分法找到255位于200关联的Disk4中，355位于Disk6页中</p><p>3、将Disk4加载到内存中，采用二分法找到第一个255的记录，然后继续完后扫描，Disk4扫描完成之后，通过链表结构继续向后访问Disk5中的300、306，当Disk5访问完毕之后，通过Disk5的nextpage指针访问下一页Disk6中，继续扫Disk6中的记录，遇到大于355的值停止。</p><h4 id="模糊匹配"><a href="#模糊匹配" class="headerlink" title="模糊匹配"></a>模糊匹配</h4><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAPuaUfLvBlhzNPsKB3oJaVWojrD0csAAlsMaxunpzhWFw1s9DdAYlIBAAMCAAN3AAM2BA.png"></p><p>数据如上图。</p><h4 id="检索以c字符开头的所有记录"><a href="#检索以c字符开头的所有记录" class="headerlink" title="检索以c字符开头的所有记录"></a>检索以c字符开头的所有记录</h4><p>执行步骤如下：</p><p>1、将Disk1数据加载到内存中</p><p>2、在Disk1页的记录中采用二分法找到最后一个小于等于c的值，这个值是ce，以及第一个大于c的，这个值是d，ce指向叶节点Disc4，d指向叶节点Disk6，此时可以断定以f开头的记录可能存在于[Disk4,Disk6)这个范围的页内，即Disk4、Disk5这两个页中</p><p>3、加载Disk4这个页，在内部以二分法找到第一条c开头的记录，然后以链表方式继续向后访问Disk5中的记录，即可以找到所有已c开头的数据</p><h4 id="检索包含c字符的记录"><a href="#检索包含c字符的记录" class="headerlink" title="检索包含c字符的记录"></a>检索包含c字符的记录</h4><p>包含一般是采用%c%来计算，但是这种写法是破坏索引的有效使用，上面的数据中，c在每个页中都存在，</p><p>我们通过Disk1页中的记录是无法判断包含c的记录会分布在哪些页中，只能加载所有的页（一次次的IO操作），并且遍历所有叶节点上的记录信息进行筛选，才可以找到包含c字符的记录。</p><p>所以如果使用了%value%这种方式，索引对查询是无效的。</p><h3 id="遵循最左匹配原则"><a href="#遵循最左匹配原则" class="headerlink" title="遵循最左匹配原则"></a>遵循最左匹配原则</h3><p>如下图，b+树的数据项是复合的数据结构，比如(empname,depno,job)这种（即构建一个联合索引）时，b+树是按照从左到右的顺序来建立搜索树的。</p><p>示例，当以(‘brand’,106,’SALEMAN’)这样的数据来检索的时候，b+树会优先比较empname来确定下一步的所搜方向，如果empname相同再依次比较depno和job，最后得到检索的数据。</p><p>但如果是(106,’SALEMAN’)这样，没有empname的数据来的时候，b+树就不知道下一步该查哪个节点，因为empname就是第一个比较因子，必须要先根据empname来搜索才能知道下一步去哪里查询。</p><p>比如当(‘brand’,’SALEMAN’)这样的数据来检索时，b+树可以用empname来指定搜索方向，但下一个字段depno的缺失，所以只能把名字等于 ‘brand’ 的数据都找到，然后再匹配职位是SALEMAN的数据了。</p><p>这个重要特征就是索引的最左匹配原则，按照这个原则执行索引效率特别高。</p><p>我们试试在b+树上分析和举例： 下图中是3个字段(depno,empname,job)的联合索引，数据以depno asc,empname asc,job asc这种排序方式存储在节点中的， 排序原则：  1、索引以depno字段升序   2、depno相同时，以empname字段升序， 3、empname相同的时候，以job字段升序  <img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAPtaUfLWLR8gfoCb1y3aW-FVT5fyiAAAloMaxunpzhW8DwD1JjIQiQBAAMCAAN3AAM2BA.png"></p><h4 id="第一位置"><a href="#第一位置" class="headerlink" title="第一位置"></a>第一位置</h4><p>检索depno&#x3D;7的记录</p><p>由于页中的记录是以depno asc,empname asc,job asc这种排序方式存储的，所以depno字段是有序的，可以通过二分法快速检索到，步骤如下：</p><p>1、将Disk1加载到内存中</p><p>2、在内存中对Disk1中的记录采用二分法找，可以确定depno&#x3D;7的记录位于{7,Brand,1}和{7,dyny,1}关联的范围内，这两个所指向的页分别是 Disk2 和 Disk4。</p><p>3、加载页Disk2，在Disk2中采用二分法快速找到第一条depno&#x3D;7的记录，然后通过链表向下一条及下一页开始扫描，直到在Disk4中找到第一个不满足depno&#x3D;7的记录为止。</p><h4 id="第一-第二位置"><a href="#第一-第二位置" class="headerlink" title="第一+第二位置"></a>第一+第二位置</h4><p>检索depno&#x3D;7 and empname like ‘B%’的记录</p><p>步骤跟上面是一致的，可以确定depno&#x3D;1 and empname like ‘B%’的记录位于{7,Band,1}和{7,Bec,1}关联的范围内，查找过程和depno&#x3D;7查找步骤类似。</p><h4 id="第二位置"><a href="#第二位置" class="headerlink" title="第二位置"></a>第二位置</h4><p>检索empname like ‘C%’的记录</p><p>这种情况通过Disk1页中的记录，无法判断empname like ‘C%’ 的记录在哪些页中的，只能逐个加载索引树的页，对所有记录进行遍历，然后进行过滤，此时索引无效。</p><h4 id="第三位置"><a href="#第三位置" class="headerlink" title="第三位置"></a>第三位置</h4><p>检索job&#x3D;8的记录</p><p>这种情况和查询 empname like ‘C%’ 也一样，也只能扫描所有叶子节点，索引也无效。</p><h4 id="第二-第三位置"><a href="#第二-第三位置" class="headerlink" title="第二+第三位置"></a>第二+第三位置</h4><p>empname和job一起查</p><p>这种原理跟前面两个一致，无法使用索引，只能对所有数据进行扫描。</p><h4 id="第一-第三位置"><a href="#第一-第三位置" class="headerlink" title="第一+第三位置"></a>第一+第三位置</h4><p>按照(depno,job)字段顺序检索</p><p>这种仅使用到索引中的depno字段了，通过depnon确定范围之后，加载所有depno下的数据，再对job条件进行过滤。如果的depno查出来的数据基数巨大，也会慢。</p><p>比如我们的测试数据中 depno&#x3D;16 的数据有50W左右，也是比较多的。</p><h4 id="停止匹配的条件"><a href="#停止匹配的条件" class="headerlink" title="停止匹配的条件"></a>停止匹配的条件</h4><p>检索depno&#x3D;1 and empname&gt;’’ and job&#x3D;1的记录</p><p>根据上面的图，这种检索方式只能先确定depno&#x3D;1 and empname&gt;’’所在页的范围，然后对这个范围的所有页进行遍历，job字段在这个查询的过程中，是无法确定数据在哪些页的，此时我们说job是不走索引的，只有depno、empname能够有效的确定索引页的范围。</p><p>类似这种的还有&gt;、&lt;、between and、like，多字段联合索引的情况下，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between and、like)就停止匹配。</p><p>通过上面的示例可以知道，遵循最左匹配原则才会真正有效利用索引。</p><h3 id="索引区分度"><a href="#索引区分度" class="headerlink" title="索引区分度"></a>索引区分度</h3><h4 id="衡量策略"><a href="#衡量策略" class="headerlink" title="衡量策略"></a>衡量策略</h4><p>假设我们有两个有序的数组，都包含10条记录</p><p>[a,b,c,d,e,f,g,h,i,j,k] 和 [a,a,a,a,a,b,b,b,b,b]</p><p>如果要检索值为b的所有记录，哪个效率会高一点？</p><p>使用二分法查找执行步骤如下：</p><p>1、使用二分法找到最后一个小于b（就是上面数组中标红色的a）的记录</p><p>2、沿着这条记录向后扫描，和b对比，直到遇到第一个大于b的值结束，或者直到扫描完所有数据。</p><p>采用上面的方法找到b的记录，第一个数组中更快的一些。因为第二个数组中含有b的基数更大，需要访问和比较的次数也更多一点。 </p><p>这种区分是有一种计算公式来衡量的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selecttivity = count(distinct c_name)/count(*) </span><br></pre></td></tr></table></figure><p>当索引区分度越高，检索速度越快，索引区分度低，则说明重复的数据比较多，检索的时候需要访问更多的记录才能够找到所有目标数据。</p><p>当索引区分度小到无限趋近于0的时候，基本等同于全表扫描了，此时检索效率肯定是慢的。</p><p>第一个数组没有重复数据，索引区分度为1，第二个区分度为0.2，所以第一个检索效率更高。</p><p>我们创建索引的时候，尽量选择区分度高的列作为索引。</p><h4 id="数据对比"><a href="#数据对比" class="headerlink" title="数据对比"></a>数据对比</h4><p>我们来看看emp 表中的两个字段，empname 和 depno 字段，</p><p>empname基本不重复，所以每个empname只有一条数据；而 500W的数据大约分配了10个部门，所以每个的depno下有约50W的数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select count(*) from emp;</span><br><span class="line">+----------+</span><br><span class="line">| count(*) |</span><br><span class="line">+----------+</span><br><span class="line">|  5000000 |</span><br><span class="line">+----------+</span><br><span class="line">1 row in set</span><br></pre></td></tr></table></figure><p>索引区分度规则在后面很多场合会用到，还可以协助判断前缀索引的最佳匹配长度。</p><h3 id="高性能索引策略"><a href="#高性能索引策略" class="headerlink" title="高性能索引策略"></a>高性能索引策略</h3><h4 id="千万级测试数据"><a href="#千万级测试数据" class="headerlink" title="千万级测试数据"></a>千万级测试数据</h4><p>请参考 <a href="https://yeoh.qzz.io/2025/04/15/MySQL%E7%B3%BB%E5%88%97-%E4%B8%80%E6%AC%A1%E6%B7%B1%E5%A4%9C%E4%BC%98%E5%8C%96%E4%BA%BF%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%88%86%E9%A1%B5%E7%9A%84%E5%A5%87%E5%A6%99%E7%BB%8F%E5%8E%86%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/">MySQL系列：一次深夜优化亿级数据分页的奇妙经历(转载) | 数根朽木，</a>中模拟的千万数据，我们以这个数据为测试数据。</p><p>emp表中有500W数据 我们用emp来做测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 mysql&gt; select count(*) from emp;</span><br><span class="line">2 +----------+</span><br><span class="line">3 | count(*) |</span><br><span class="line">4 +----------+</span><br><span class="line">5 |  5000000 |</span><br><span class="line">6 +----------+</span><br><span class="line">7 1 row in set </span><br></pre></td></tr></table></figure><h4 id="无索引的效果"><a href="#无索引的效果" class="headerlink" title="无索引的效果"></a>无索引的效果</h4><p>我们之前在emp表上做过索引，所以先看一下这个表目前所有的索引</p><p>可以看到，目前主键字段id和depno字段上都有建立索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; desc emp;</span><br><span class="line">+----------+-----------------------+------+-----+---------+----------------+</span><br><span class="line">| Field    | Type                  | Null | Key | Default | Extra          |</span><br><span class="line">+----------+-----------------------+------+-----+---------+----------------+</span><br><span class="line">| id       | int(10) unsigned      | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| empno    | mediumint(8) unsigned | NO   |     | 0       |                |</span><br><span class="line">| empname  | varchar(20)           | NO   |     |         |                |</span><br><span class="line">| job      | varchar(9)            | NO   |     |         |                |</span><br><span class="line">| mgr      | mediumint(8) unsigned | NO   |     | 0       |                |</span><br><span class="line">| hiredate | datetime              | NO   |     | NULL    |                |</span><br><span class="line">| sal      | decimal(7,2)          | NO   |     | NULL    |                |</span><br><span class="line">| comn     | decimal(7,2)          | NO   |     | NULL    |                |</span><br><span class="line">| depno    | mediumint(8) unsigned | NO   | MUL | 0       |                |</span><br><span class="line">+----------+-----------------------+------+-----+---------+----------------+</span><br><span class="line">9 rows in set</span><br><span class="line"></span><br><span class="line">mysql&gt; show index from emp;</span><br><span class="line">+-------+------------+---------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">| Table | Non_unique | Key_name      | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |</span><br><span class="line">+-------+------------+---------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">| emp   |          0 | PRIMARY       |            1 | id          | A         |     4952492 | NULL     | NULL   |      | BTREE      |         |               |</span><br><span class="line">| emp   |          1 | idx_emp_id    |            1 | id          | A         |     4952492 | NULL     | NULL   |      | BTREE      |         |               |</span><br><span class="line">| emp   |          1 | idx_emp_depno |            1 | depno       | A         |          18 | NULL     | NULL   |      | BTREE      |         |               |</span><br><span class="line">+-------+------------+---------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">3 rows in set</span><br></pre></td></tr></table></figure><p> 我们在没有做索引的字段上做一下查询看看，在500W数据中查询一个名叫LsHfFJA的员工，消耗 2.239S ，获取到一条id为4582071的数据。</p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAPnaUfGu2Hw7oWqCx9pqFrR_ksm4tkAAkAMaxunpzhWnxS_YODYQG4BAAMCAAN5AAM2BA.png"></p><p>再看看他的执行过程，扫描了4952492 条数据才找到该行数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from emp where empname=&#x27;LsHfFJA&#x27;;</span><br><span class="line">+----+-------------+-------+------+---------------+------+---------+------+---------+-------------+</span><br><span class="line">| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows    | Extra       |</span><br><span class="line">+----+-------------+-------+------+---------------+------+---------+------+---------+-------------+</span><br><span class="line">|  1 | SIMPLE      | emp   | ALL  | NULL          | NULL | NULL    | NULL | 4952492 | Using where |</span><br><span class="line">+----+-------------+-------+------+---------------+------+---------+------+---------+-------------+</span><br><span class="line">1 row in set</span><br></pre></td></tr></table></figure><h4 id="主键检索"><a href="#主键检索" class="headerlink" title="主键检索"></a>主键检索</h4><p>我们按照主键id来检索 </p><p> <img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAPwaUfMr0nU6epqNSrBdxKQBfVi-fUAAmIMaxunpzhWT4eXp7J1ZZEBAAMCAAN5AAM2BA.png"></p><p> 因为在id上有聚集索引，所以检索效率很高</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 mysql&gt; explain select * from emp where  id=4582071;</span><br><span class="line">2 +----+-------------+-------+-------+--------------------+---------+---------+-------+------+-------+</span><br><span class="line">3 | id | select_type | table | type  | possible_keys      | key     | key_len | ref   | rows | Extra |</span><br><span class="line">4 +----+-------------+-------+-------+--------------------+---------+---------+-------+------+-------+</span><br><span class="line">5 |  1 | SIMPLE      | emp   | const | PRIMARY,idx_emp_id | PRIMARY | 4       | const |    1 | NULL  |</span><br><span class="line">6 +----+-------------+-------+-------+--------------------+---------+---------+-------+------+-------+</span><br><span class="line">7 1 row in set</span><br></pre></td></tr></table></figure><p>这个速度很快，这个走的是上面介绍的唯一记录检索。 </p><h4 id="前缀索引和索引长度计算"><a href="#前缀索引和索引长度计算" class="headerlink" title="前缀索引和索引长度计算"></a>前缀索引和索引长度计算</h4><p>这个我们上一篇有讨论过，需要选择适当的索引长度。</p><p>有时候需要索引很长的字符列，这会让索引变得大且慢（每个页存储的内容是有限的，如果一个页中可以存储的索引记录越多，那么查询效率就会提高，所以我们可以指定索引的字段长度）。</p><p>通常可以索引开始的部分字符，这样可以大大节约索引空间（每个页），从而提高索引效率。但这样也会降低索引的选择性。</p><p>索引的选择性是指不重复的索引值（也称为基数，cardinality)和数据表的记录总数的比值，范围从1&#x2F;#T到1之间。索引的选择性越高则查询效率越高，因为选择性高的索引可以让MySQL在查找时过滤掉更多的行。唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。</p><p>MySQL官方：一般情况下某个前缀的选择性也是足够高的，足以满足查询性能。对于BLOB，TEXT，或者很长的VARCHAR类型的列，必须使用前缀索引，因为MySQL不允许索引这些列的完整长度。</p><h5 id="前缀索引的长度的判断方法"><a href="#前缀索引的长度的判断方法" class="headerlink" title="前缀索引的长度的判断方法"></a><strong>前缀索引的长度的判断方法</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(distinct left(`c_name`,calcul_len))/count(*) from t_name;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">    count(DISTINCT LEFT(cname, 3)) / count(*) AS sel3,</span><br><span class="line">    count(DISTINCT LEFT(cname, 4)) / count(*) AS sel4,</span><br><span class="line">    count(DISTINCT LEFT(cname, 5)) / count(*) AS sel5,</span><br><span class="line">    count(DISTINCT LEFT(cname, 6)) / count(*) AS sel6,</span><br><span class="line">    count(DISTINCT LEFT(cname, 7)) / count(*) AS sel7</span><br><span class="line">FROM</span><br><span class="line">    tname</span><br></pre></td></tr></table></figure><h5 id="添加前缀索引"><a href="#添加前缀索引" class="headerlink" title="添加前缀索引"></a><strong>添加前缀索引</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tname ADD KEY (cname[(lenth)]); </span><br></pre></td></tr></table></figure><p>测试emp_name最合适的长度，因为empname的长度基本维持在6个字符左右，少数量超过6长度，所以指定empname索引长度时6是最建议的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;  SELECT</span><br><span class="line">     count(DISTINCT LEFT(empname, 3)) / count(*) AS sel3,</span><br><span class="line">     count(DISTINCT LEFT(empname, 4)) / count(*) AS sel4,</span><br><span class="line">     count(DISTINCT LEFT(empname, 5)) / count(*) AS sel5,</span><br><span class="line">     count(DISTINCT LEFT(empname, 6)) / count(*) AS sel6,</span><br><span class="line">     count(DISTINCT LEFT(empname, 7)) / count(*) AS sel7</span><br><span class="line"> FROM</span><br><span class="line">     emp;</span><br><span class="line">+--------+--------+--------+--------+--------+</span><br><span class="line">| sel3   | sel4   | sel5   | sel6   | sel7   |</span><br><span class="line">+--------+--------+--------+--------+--------+</span><br><span class="line">| 0.0012 | 0.0076 | 0.0400 | 0.1713 | 0.1713 |</span><br><span class="line">+--------+--------+--------+--------+--------+</span><br><span class="line">1 row in set</span><br></pre></td></tr></table></figure><p>我们可以使用 不同的长度来测试检索效率</p><p>当长度为2的时候，匹配度低于 0.0012，检索效率自然比较慢</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create index idx_emp_empname on emp(empname(2));</span><br><span class="line">Query OK, 0 rows affected</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from emp where empname=&#x27;LsHfFJA&#x27;;</span><br><span class="line">+---------+---------+---------+---------+-----+---------------------+------+------+-------+</span><br><span class="line">| id      | empno   | empname | job     | mgr | hiredate            | sal  | comn | depno |</span><br><span class="line">+---------+---------+---------+---------+-----+---------------------+------+------+-------+</span><br><span class="line">| 4582071 | 4582071 | LsHfFJA | SALEMAN |   1 | 2021-01-23 16:46:03 | 2000 | 400  |   106 |</span><br><span class="line">+---------+---------+---------+---------+-----+---------------------+------+------+-------+</span><br><span class="line">1 row in set  (1.793 sec)</span><br></pre></td></tr></table></figure><p>当长度为6的时候，检索效率就比较高</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create index idx_emp_empname on emp(empname(6));</span><br><span class="line">Query OK, 0 rows affected</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from emp where empname=&#x27;LsHfFJA&#x27;;</span><br><span class="line">+---------+---------+---------+---------+-----+---------------------+------+------+-------+</span><br><span class="line">| id      | empno   | empname | job     | mgr | hiredate            | sal  | comn | depno |</span><br><span class="line">+---------+---------+---------+---------+-----+---------------------+------+------+-------+</span><br><span class="line">| 4582071 | 4582071 | LsHfFJA | SALEMAN |   1 | 2021-01-23 16:46:03 | 2000 | 400  |   106 |</span><br><span class="line">+---------+---------+---------+---------+-----+---------------------+------+------+-------+</span><br><span class="line">1 row in set  （0.003 sec）</span><br></pre></td></tr></table></figure><h4 id="联合索引的使用"><a href="#联合索引的使用" class="headerlink" title="联合索引的使用"></a>联合索引的使用</h4><p>当我们需要在多个字段上面做索引的时候，经常的做法是每个字段都建一个索引，这种策略一般是不建议的，优先的做法是优化索引列的顺序，或者创建一个全覆盖的索引。</p><p>在多个列上建立独立的单列索引大部分情况下并不能提高MySQL的查询性能。MySQL的“索引合并”（index merge）策略一定程序上可以使用表上的多个单列索引来定位指定的行。索引合并策略能够同时使用多个单列索引进行扫描，并将结果进行合并。那么什么时候选择联合索引呢？ </p><p>1、当出现服务器对多个索引做相交操作时（通常有多个and条件），更好的操作是创建一个包含所有相关列的多列索引，而不是多个独立的单列索引。</p><p>2、当服务器需要对多个索引做联合操作时（通常有多个or条件），通常需要消耗大量CPU和内存资源在算法的缓存、排序和合并操作上。特别是当其中有些索引的选择性不高，需要合并扫描返回的大量数据的时候。</p><p>这两种情况下更好的操作是创建一个包含所有相关列的多列索引，而不是多个独立的单列索引。</p><h4 id="联合索引列的顺序策略"><a href="#联合索引列的顺序策略" class="headerlink" title="联合索引列的顺序策略"></a>联合索引列的顺序策略</h4><p>在建设联合索引中，我们经常遇到的困惑就是索引的顺序问题。正确的索引应该依赖使用该索引的查询，并能同时考虑更好的满足排序和分组的需求。</p><p>联合索引意味着他按照我们上面描述的最左匹配原则来进行搜素。</p><p>当不考虑分组和排序的时候，我们经常是将选择性高的内容放在前面，以下面的查询为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from emp where  empname like &#x27;LsHfFJ%&#x27; and depno=106;</span><br></pre></td></tr></table></figure><p> 是创建(empname,depno）顺序的索引 还是(depno,empname）顺序的索引？我们应该是找一个选择性高（也就是匹配内容少）的字段放在前面。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select sum(empname like &#x27;LsHfFJ%&#x27;),sum(depno=106) from emp;</span><br><span class="line">+-----------------------------+----------------+</span><br><span class="line">| sum(empname like &#x27;LsHfFJ%&#x27;) | sum(depno=106) |</span><br><span class="line">+-----------------------------+----------------+</span><br><span class="line">| 7                           | 500194         |</span><br><span class="line">+-----------------------------+----------------+</span><br><span class="line">1 row in set</span><br></pre></td></tr></table></figure><p>可以看出 empname字段的选择性更高一点，对应条件下的数据值 empname like ‘LsHfFJ%’ 下的数量会少很多 。所以答案是将他作为索引的第一列。</p><p>但是这样也有个问题，索引的设计是根据现有的数据执行情况进行处理的，可能对其他条件的查询不公平，也可能随着数据的膨胀或者收缩，字段的选择性发生了变化。</p><p>另外一种经验做法是 考虑全局基数和选择性，而不是某个具体的查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select count(distinct empname)/count(*) as empname_selecttivity,count(distinct depno)/count(*) as depno_selecttivity,count(*) from emp;</span><br><span class="line">+----------------------+--------------------+----------+</span><br><span class="line">| empname_selecttivity | depno_selecttivity | count(*) |</span><br><span class="line">+----------------------+--------------------+----------+</span><br><span class="line">| 0.1713               | 0.0000             |  5000000 |</span><br><span class="line">+----------------------+--------------------+----------+</span><br><span class="line">1 row in set</span><br></pre></td></tr></table></figure><p>empname字段的选择性更高一点，所以答案是将他作为索引的第一列。</p><h4 id="between-and范围检索"><a href="#between-and范围检索" class="headerlink" title="between and范围检索"></a>between and范围检索</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select count(*) from emp where id between 18 and 28;</span><br><span class="line">+----------+</span><br><span class="line">| count(*) |</span><br><span class="line">+----------+</span><br><span class="line">|       11 |</span><br><span class="line">+----------+</span><br><span class="line">1 row in set  (0.001 sec)</span><br></pre></td></tr></table></figure><p>速度也很快，id上有主键索引，这个采用的上面介绍的<code>范围查找</code>可以快速定位目标数据。</p><p>但是如果范围太大，跨度的page也太多，速度也会比较慢，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select count(*) from emp where id between 18 and 28;</span><br><span class="line">+----------+</span><br><span class="line">| count(*) |</span><br><span class="line">+----------+</span><br><span class="line">|       11 |</span><br><span class="line">+----------+</span><br><span class="line">1 row in set  (0.001 sec)</span><br></pre></td></tr></table></figure><p>上面id的值跨度太大，1所在的页和499万所在页中间有很多页需要读取，所以比较慢。</p><p>所以使用between and的时候，区间跨度不要太大。 </p><h4 id="in的检索"><a href="#in的检索" class="headerlink" title="in的检索"></a>in的检索</h4><p>in方式检索数据，我们还是经常用的。</p><p>平时我们做项目的时候，建议少用表连接，比如电商中需要查询订单的信息和订单中商品的名称，可以先查询查询订单表，然后订单表中取出商品的id列表，采用in的方式到商品表检索商品信息，由于商品id是商品表的主键，所以检索速度还是比较快的。</p><p>通过id在400万数据中检索100条数据，看看效果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;  select * from emp a where</span><br><span class="line">a.id in (800000, 800001, 800002, 800003, 800004, 800005, 800006, 800007, 800008, 800009, 800010, 800011, 800012, 800013,</span><br><span class="line"> 800014, 800015, 800016, 800017, 800018, 800019, 800020, 800021, 800022, 800023, 800024, 800025, 800026, 800027, 800028,</span><br><span class="line">800029, 800030, 800031, 800032, 800033, 800034, 800035, 800036, 800037, 800038, 800039, 800040, 800041, 800042, 800043, 800044,</span><br><span class="line">800045, 800046, 800047, 800048, 800049, 800050, 800051, 800052, 800053, 800054, 800055, 800056, 800057, 800058, 800059, 800060,</span><br><span class="line">800061, 800062, 800063, 800064, 800065, 800066, 800067, 800068, 800069, 800070, 800071, 800072, 800073, 800074, 800075, 800076,</span><br><span class="line">800077, 800078, 800079, 800080, 800081, 800082, 800083, 800084, 800085, 800086, 800087, 800088, 800089, 800090, 800091, 800092,</span><br><span class="line">800093, 800094, 800095, 800096, 800097, 800098, 800099);</span><br><span class="line">+--------+--------+---------+---------+-----+---------------------+------+------+-------+</span><br><span class="line">| id     | empno  | empname | job     | mgr | hiredate            | sal  | comn | depno |</span><br><span class="line">+--------+--------+---------+---------+-----+---------------------+------+------+-------+</span><br><span class="line">| 800000 | 800000 | qVFqPY  | SALEMAN |   1 | 2021-01-23 16:43:02 | 2000 | 400  |   105 |</span><br><span class="line">| 800001 | 800001 | KVzJXL  | SALEMAN |   1 | 2021-01-23 16:43:02 | 2000 | 400  |   107 |</span><br><span class="line">| 800002 | 800002 | vWvpkj  | SALEMAN |   1 | 2021-01-23 16:43:02 | 2000 | 400  |   102 |</span><br><span class="line">............</span><br><span class="line">| 800099 | 800099 | roxtAx  | SALEMAN |   1 | 2021-01-23 16:43:02 | 2000 | 400  |   107 |</span><br><span class="line">+--------+--------+---------+---------+-----+---------------------+------+------+-------+</span><br><span class="line">100 rows in set  (0.001 sec)</span><br></pre></td></tr></table></figure><p>耗时1毫秒左右，还是相当快的。</p><p>这个相当于多个分解为多个<code>唯一记录检索</code>，然后将记录合并。所以这个其实也是快的，只要in里面的数据不是极端海量的即可。</p><h4 id="多个独立索引的执行策略"><a href="#多个独立索引的执行策略" class="headerlink" title="多个独立索引的执行策略"></a>多个独立索引的执行策略</h4><p>根据之前我们做的索引，在empname上已经做了索引，那我们在另外一个字段depno上也做索引，看看他是怎么匹配索引的。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create index idx_emp_depno on emp(depno);</span><br><span class="line">mysql&gt; show index from emp;</span><br><span class="line">+-------+------------+-----------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">| Table | Non_unique | Key_name        | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |</span><br><span class="line">+-------+------------+-----------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">| emp   |          0 | PRIMARY         |            1 | id          | A         |     4952492 | NULL     | NULL   |      | BTREE      |         |               |</span><br><span class="line">| emp   |          1 | idx_emp_id      |            1 | id          | A         |     4952492 | NULL     | NULL   |      | BTREE      |         |               |</span><br><span class="line">| emp   |          1 | idx_emp_depno   |            1 | depno       | A         |          18 | NULL     | NULL   |      | BTREE      |         |               |</span><br><span class="line">| emp   |          1 | idx_emp_empname |            1 | empname     | A         |     1650830 | NULL     | NULL   |      | BTREE      |         |               |</span><br><span class="line">+-------+------------+-----------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">4 rows in set</span><br></pre></td></tr></table></figure><p>查询下试试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from emp where empname=&#x27;LsHfFJA&#x27; and depno=&#x27;106&#x27;;</span><br><span class="line">+---------+---------+---------+---------+-----+---------------------+------+------+-------+</span><br><span class="line">| id      | empno   | empname | job     | mgr | hiredate            | sal  | comn | depno |</span><br><span class="line">+---------+---------+---------+---------+-----+---------------------+------+------+-------+</span><br><span class="line">| 4582071 | 4582071 | LsHfFJA | SALEMAN |   1 | 2021-01-23 16:46:03 | 2000 | 400  |   106 |</span><br><span class="line">+---------+---------+---------+---------+-----+---------------------+------+------+-------+</span><br><span class="line">1 row in set  (0.000 sec)</span><br></pre></td></tr></table></figure><p>上面查询速度很快，empname 和 depno上各有一个索引，觉得上面走哪个索引？</p><p>大家可能觉得empname位于where第一个，所以走的是empname字段所在的索引，过程可以解释为这样：</p><p>1、走empname所在的索引找到用户名为 empname&#x3D;’LsHfFJA’ 所对应的所有记录</p><p>2、遍历记录过滤出部门编号的值为 depno&#x3D;’106’ 的数据。</p><p>我们看一下 empname&#x3D;’LsHfFJA’ 检索速度，确实很快，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from emp where empname=&#x27;LsHfFJA&#x27;;</span><br><span class="line">+---------+---------+---------+---------+-----+---------------------+------+------+-------+</span><br><span class="line">| id      | empno   | empname | job     | mgr | hiredate            | sal  | comn | depno |</span><br><span class="line">+---------+---------+---------+---------+-----+---------------------+------+------+-------+</span><br><span class="line">| 4582071 | 4582071 | LsHfFJA | SALEMAN |   1 | 2021-01-23 16:46:03 | 2000 | 400  |   106 |</span><br><span class="line">+---------+---------+---------+---------+-----+---------------------+------+------+-------+</span><br><span class="line">1 row in set  (0.001 sec)</span><br></pre></td></tr></table></figure><p>走empname索引，然后再过滤，确实可以，速度也很快，果真和where后字段顺序有关么？我们把 empname 和 depno 的顺序对调一下，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from emp where depno=&#x27;106&#x27; and empname=&#x27;LsHfFJA&#x27;;</span><br><span class="line">+---------+---------+---------+---------+-----+---------------------+------+------+-------+</span><br><span class="line">| id      | empno   | empname | job     | mgr | hiredate            | sal  | comn | depno |</span><br><span class="line">+---------+---------+---------+---------+-----+---------------------+------+------+-------+</span><br><span class="line">| 4582071 | 4582071 | LsHfFJA | SALEMAN |   1 | 2021-01-23 16:46:03 | 2000 | 400  |   106 |</span><br><span class="line">+---------+---------+---------+---------+-----+---------------------+------+------+-------+</span><br><span class="line">1 row in set  (0.000 sec)</span><br></pre></td></tr></table></figure><p>速度还是很快，这次是不是先走 depno 索引检索出数据，然后再过滤 empname 呢？我们先来看一下depno&#x3D;106查询速度：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select count(*) from emp where depno=&#x27;106&#x27;;</span><br><span class="line">+----------+</span><br><span class="line">| count(*) |</span><br><span class="line">+----------+</span><br><span class="line">|   500194 |</span><br><span class="line">+----------+</span><br><span class="line">1 row in set  (0.121 sec)</span><br></pre></td></tr></table></figure><p>看上面，查询耗时121毫秒，50万数据，如果走depno肯定是不行的。</p><p>我们使用explain来看一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from emp where depno=&#x27;106&#x27; and empname=&#x27;LsHfFJA&#x27;;</span><br><span class="line">+----+-------------+-------+------+-------------------------------+-----------------+---------+-------+------+------------------------------------+</span><br><span class="line">| id | select_type | table | type | possible_keys                 | key             | key_len | ref   | rows | Extra                              |</span><br><span class="line">+----+-------------+-------+------+-------------------------------+-----------------+---------+-------+------+------------------------------------+</span><br><span class="line">|  1 | SIMPLE      | emp   | ref  | idx_emp_depno,idx_emp_empname | idx_emp_empname | 22      | const |    1 | Using index condition; Using where |</span><br><span class="line">+----+-------------+-------+------+-------------------------------+-----------------+---------+-------+------+------------------------------------+</span><br><span class="line">1 row in set</span><br></pre></td></tr></table></figure><p>possible_keys：列出了这个查询可能会走两个索引（idx_emp_depno、idx_emp_empname）</p><p>实际上走的却是idx_emp_empname（key列：实际走的索引）。</p><p>所以，当多个条件中有索引的时候，并且关系是and的时候，会自动匹配索引区分度高的，显然name字段重复度很低，走name查询会更快一些。</p><h4 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h4><p>看两个查询，都采用了模糊查询，但是使用%开头会造成无法从页面确定扫描的位置，导致索引无效，全表扫描。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from emp where depno=&#x27;106&#x27; and empname=&#x27;LsHfFJA&#x27;;</span><br><span class="line">+----+-------------+-------+------+-------------------------------+-----------------+---------+-------+------+------------------------------------+</span><br><span class="line">| id | select_type | table | type | possible_keys                 | key             | key_len | ref   | rows | Extra                              |</span><br><span class="line">+----+-------------+-------+------+-------------------------------+-----------------+---------+-------+------+------------------------------------+</span><br><span class="line">|  1 | SIMPLE      | emp   | ref  | idx_emp_depno,idx_emp_empname | idx_emp_empname | 22      | const |    1 | Using index condition; Using where |</span><br><span class="line">+----+-------------+-------+------+-------------------------------+-----------------+---------+-------+------+------------------------------------+</span><br><span class="line">1 row in set</span><br></pre></td></tr></table></figure><p>上面第一个查询可以利用到name字段上面的索引，下面的查询是无法确定需要查找的值所在的范围的，只能全表扫描，无法利用索引，所以速度比较慢，这个过程上面有说过。</p><h4 id="关于回表"><a href="#关于回表" class="headerlink" title="关于回表"></a>关于回表</h4><p>当需要查询的数据在索引树中不存在的时候，需要再次到聚集索引中去获取，这个过程叫做回表，如查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;  select empname,job,hiredate,sal from emp where empname like &#x27;LsHfFJA%&#x27;;</span><br><span class="line">+---------+---------+---------------------+------+</span><br><span class="line">| empname | job     | hiredate            | sal  |</span><br><span class="line">+---------+---------+---------------------+------+</span><br><span class="line">| LsHfFJA | SALEMAN | 2021-01-23 16:46:03 | 2000 |</span><br><span class="line">+---------+---------+---------------------+------+</span><br><span class="line">1 row in set</span><br></pre></td></tr></table></figure><p>上面查询 empname、job、hiredate、sal，由于empname列所在的索引中只有empname、id 两个列的值，不包含job、hiredate、sal，所以上面过程如下：</p><p>1、走 empname 索引检索  LsHfFJA 对应的记录，取出id为 4582071 的数据。</p><p>&#96;&#96;2、在主键索引中检索出 id&#x3D;4582071 的记录，获取其他字段的值 </p><h4 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h4><p>查询中采用的索引树中包含了查询所需要的所有字段的值，不需要再去聚集索引检索数据，这种叫索引覆盖。</p><p>我们来看一个查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select id,empname from emp where empname=&#x27;LsHfFJA&#x27;;</span><br><span class="line">+---------+---------+</span><br><span class="line">| id      | empname |</span><br><span class="line">+---------+---------+</span><br><span class="line">| 4582071 | LsHfFJA |</span><br><span class="line">+---------+---------+</span><br><span class="line">1 row in set  (0.000 sec)</span><br></pre></td></tr></table></figure><p>name对应idx_emp_empname索引，id为主键，所以idx_emp_empname索引树叶子节点中包含了empname、id的值，这个查询只用走idx_emp_empname这一个索引就可以了，如果select后面使用<code>*</code>，</p><p>还需要一次回表获取其他的值，比如上面的 job、hiredate、sal 字段等。</p><p>所以，获取数据时应需而取，写sql的时候，尽量避免使用<code>*</code>，<code>*</code>可能会多一次回表操作，需要看一下是否可以使用索引覆盖来实现，效率更高一些。</p><h4 id="ICP，避免回表"><a href="#ICP，避免回表" class="headerlink" title="ICP，避免回表"></a>ICP，避免回表</h4><p>索引下推,简称ICP(Index Condition Pushdown) ,是MySQL 5.6中新特性，可以在存储引擎层使用索引过滤数据的一种优化方式。</p><p>ICP可以减少存储引擎访问基表的次数以及MySQL服务器访问存储引擎的次数。</p><p>我们举个例子来看一看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select count(id) from emp where empname =&#x27;LsHfFJA&#x27; and  sal=2000;</span><br><span class="line">+-----------+</span><br><span class="line">| count(id) |</span><br><span class="line">+-----------+</span><br><span class="line">|         1 |</span><br><span class="line">+-----------+</span><br><span class="line">1 row in set</span><br></pre></td></tr></table></figure><p>执行步骤如下：</p><p>1、走empname所在的索引检索出以 empname &#x3D;’LsHfFJ’ 的记录，并得到记录id</p><p>*2、*利用id去主键索引中查询出这条记录Record1</p><p>3、判断Record1中的sal为2000的值，然后重复上面的操作，直到找到所有记录为止。</p><p>上面的过程中需要走empname所在的索引以及需要回表操作。</p><p>但是如果采用ICP的方式，可以创建一个(empname,sal)的联合索引，检索步骤如下：</p><p>1、走(empname,sal)索引检索出以 empname &#x3D;’LsHfFJ’ 的第一条记录，可以得到(empname,sal,id)，我们记为Record1。<br>2、判断 Record1.sal&#x3D;<strong>2000</strong> 的值，并重复上面的操作，直到找到所有记录为止</p><p>这个执行步骤免去回表操作，通过索引的数据就可以完成整个操作，效率会好很多。</p><h4 id="类型转换可能导致索引无效"><a href="#类型转换可能导致索引无效" class="headerlink" title="类型转换可能导致索引无效"></a>类型转换可能导致索引无效</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from emp where empname =&#x27;LsHfFJA&#x27;;</span><br><span class="line">+---------+---------+---------+---------+-----+---------------------+------+------+-------+</span><br><span class="line">| id      | empno   | empname | job     | mgr | hiredate            | sal  | comn | depno |</span><br><span class="line">+---------+---------+---------+---------+-----+---------------------+------+------+-------+</span><br><span class="line">| 4582071 | 4582071 | LsHfFJA | SALEMAN |   1 | 2021-01-23 16:46:03 | 2000 | 400  |   106 |</span><br><span class="line">+---------+---------+---------+---------+-----+---------------------+------+------+-------+</span><br><span class="line">1 row in set</span><br></pre></td></tr></table></figure><p>从这个数据中我们可以看出 empname为字符串类型的，depno为数组类型的，这两个上面都有独立的索引，我们来看两个语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from emp where empname =1;</span><br><span class="line">+---------+---------+---------+----------+-----+---------------------+-------+------+-------+</span><br><span class="line">| id      | empno   | empname | job      | mgr | hiredate            | sal   | comn | depno |</span><br><span class="line">+---------+---------+---------+----------+-----+---------------------+-------+------+-------+</span><br><span class="line">| 5000001 | 5000099 | 1       | engineer |   1 | 2021-03-05 19:09:28 | 22500 | 400  |   106 |</span><br><span class="line">+---------+---------+---------+----------+-----+---------------------+-------+------+-------+</span><br><span class="line">1 row in set  (2.645 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select count(*) from emp where depno =&#x27;106&#x27;;</span><br><span class="line">+----------+</span><br><span class="line">| count(*) |</span><br><span class="line">+----------+</span><br><span class="line">|   500195 |</span><br><span class="line">+----------+</span><br><span class="line">1 row in set  (0.000 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select count(*) from emp where depno =106;</span><br><span class="line">+----------+</span><br><span class="line">| count(*) |</span><br><span class="line">+----------+</span><br><span class="line">|   500195 |</span><br><span class="line">+----------+</span><br><span class="line">1 row in set  (0.001 sec)</span><br></pre></td></tr></table></figure><p>1、第一个查询，即便是在empname上建了索引，耗时依旧达到2s多。那是因为empname是字符串类型，字符串和数字比较的时候，会将字符串强制转换为数字，然后进行比较，所以整个查询变成了全表扫描，</p><p>一个个抽出每条数据，将empname转换为数字和1进行比较。</p><p>2、 第二个和第三个查询，depno是int类型的，两个查询效率一致，都是正常利用索引快速检索。这是因为数值类型的字段，查询匹配的值无论是字符串还是数值都会走索引。</p><h4 id="函数导致索引无效"><a href="#函数导致索引无效" class="headerlink" title="函数导致索引无效"></a>函数导致索引无效</h4><p>当我们不恰当的使用索引所对应的字段的时候，可能会导致索引失效，比如查询的过程没有保证独立的列，</p><p>这个独立的列是指索引对应的列不能作用在函数中。如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from emp  where id = 4990000;</span><br><span class="line">+---------+---------+---------+---------+-----+---------------------+------+------+-------+</span><br><span class="line">| id      | empno   | empname | job     | mgr | hiredate            | sal  | comn | depno |</span><br><span class="line">+---------+---------+---------+---------+-----+---------------------+------+------+-------+</span><br><span class="line">| 4990000 | 4990000 | PWmulY  | SALEMAN |   1 | 2021-01-23 16:46:24 | 2000 | 400  |   102 |</span><br><span class="line">+---------+---------+---------+---------+-----+---------------------+------+------+-------+</span><br><span class="line">1 row in set  (0.002 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from emp  where ABS(id) = 4990001;</span><br><span class="line">+---------+---------+---------+---------+-----+---------------------+------+------+-------+</span><br><span class="line">| id      | empno   | empname | job     | mgr | hiredate            | sal  | comn | depno |</span><br><span class="line">+---------+---------+---------+---------+-----+---------------------+------+------+-------+</span><br><span class="line">| 4990001 | 4990001 | fXtdiH  | SALEMAN |   1 | 2021-01-23 16:46:24 | 2000 | 400  |   107 |</span><br><span class="line">+---------+---------+---------+---------+-----+---------------------+------+------+-------+</span><br><span class="line">1 row in set  (2.007 sec)</span><br></pre></td></tr></table></figure><p>耗时分别是 0.002、2.007，使用explain分析后发现作用在函数的时候没有走索引，变成全表扫描：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> 1 mysql&gt; explain select * from emp  where id = 4990000;</span><br><span class="line"> 2 +----+-------------+-------+-------+--------------------+---------+---------+-------+------+-------+</span><br><span class="line"> 3 | id | select_type | table | type  | possible_keys      | key     | key_len | ref   | rows | Extra |</span><br><span class="line"> 4 +----+-------------+-------+-------+--------------------+---------+---------+-------+------+-------+</span><br><span class="line"> 5 |  1 | SIMPLE      | emp   | const | PRIMARY,idx_emp_id | PRIMARY | 4       | const |    1 | NULL  |</span><br><span class="line"> 6 +----+-------------+-------+-------+--------------------+---------+---------+-------+------+-------+</span><br><span class="line"> 7 1 row in set</span><br><span class="line"> 8 </span><br><span class="line"> 9 mysql&gt; explain select * from emp  where ABS(id) = 4990001;</span><br><span class="line">10 +----+-------------+-------+------+---------------+------+---------+------+---------+-------------+</span><br><span class="line">11 | id | select_type | table | type | possible_keys | key  | key_len | ref  | rows    | Extra       |</span><br><span class="line">12 +----+-------------+-------+------+---------------+------+---------+------+---------+-------------+</span><br><span class="line">13 |  1 | SIMPLE      | emp   | ALL  | NULL          | NULL | NULL    | NULL | 4952492 | Using where |</span><br><span class="line">14 +----+-------------+-------+------+---------------+------+---------+------+---------+-------------+</span><br><span class="line">15 1 row in set</span><br></pre></td></tr></table></figure><h4 id="表达式导致索引无效"><a href="#表达式导致索引无效" class="headerlink" title="表达式导致索引无效"></a>表达式导致索引无效</h4><p>跟上面的类型类似，索引对应的列也不能作用于表达式中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from emp  where id = 4990000;</span><br><span class="line">+---------+---------+---------+---------+-----+---------------------+------+------+-------+</span><br><span class="line">| id      | empno   | empname | job     | mgr | hiredate            | sal  | comn | depno |</span><br><span class="line">+---------+---------+---------+---------+-----+---------------------+------+------+-------+</span><br><span class="line">| 4990000 | 4990000 | PWmulY  | SALEMAN |   1 | 2021-01-23 16:46:24 | 2000 | 400  |   102 |</span><br><span class="line">+---------+---------+---------+---------+-----+---------------------+------+------+-------+</span><br><span class="line">1 row in set  (0.002 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from emp  where ABS(id) = 4990001;</span><br><span class="line">+---------+---------+---------+---------+-----+---------------------+------+------+-------+</span><br><span class="line">| id      | empno   | empname | job     | mgr | hiredate            | sal  | comn | depno |</span><br><span class="line">+---------+---------+---------+---------+-----+---------------------+------+------+-------+</span><br><span class="line">| 4990001 | 4990001 | fXtdiH  | SALEMAN |   1 | 2021-01-23 16:46:24 | 2000 | 400  |   107 |</span><br><span class="line">+---------+---------+---------+---------+-----+---------------------+------+------+-------+</span><br><span class="line">1 row in set  (2.007 sec)</span><br></pre></td></tr></table></figure><p>耗时分别是 0.002、1.762，使用explain分析后发现作用在表达式的时候没有走索引，变成全表扫描：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from emp  where id = 4990000;</span><br><span class="line">+----+-------------+-------+-------+--------------------+---------+---------+-------+------+-------+</span><br><span class="line">| id | select_type | table | type  | possible_keys      | key     | key_len | ref   | rows | Extra |</span><br><span class="line">+----+-------------+-------+-------+--------------------+---------+---------+-------+------+-------+</span><br><span class="line">|  1 | SIMPLE      | emp   | const | PRIMARY,idx_emp_id | PRIMARY | 4       | const |    1 | NULL  |</span><br><span class="line">+----+-------------+-------+-------+--------------------+---------+---------+-------+------+-------+</span><br><span class="line">1 row in set</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select * from emp  where ABS(id) = 4990001;</span><br><span class="line">+----+-------------+-------+------+---------------+------+---------+------+---------+-------------+</span><br><span class="line">| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows    | Extra       |</span><br><span class="line">+----+-------------+-------+------+---------------+------+---------+------+---------+-------------+</span><br><span class="line">|  1 | SIMPLE      | emp   | ALL  | NULL          | NULL | NULL    | NULL | 4952492 | Using where |</span><br><span class="line">+----+-------------+-------+------+---------------+------+---------+------+---------+-------------+</span><br><span class="line">1 row in set</span><br></pre></td></tr></table></figure><h4 id="索引覆盖排序字段"><a href="#索引覆盖排序字段" class="headerlink" title="索引覆盖排序字段"></a>索引覆盖排序字段</h4><p>我们先来看emp表的一个查询，我们经常会这么查员工的信息 emp:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;  select * from emp where depno = 106 limit 10;</span><br><span class="line">+-----+-------+---------+---------+-----+---------------------+------+------+-------+</span><br><span class="line">| id  | empno | empname | job     | mgr | hiredate            | sal  | comn | depno |</span><br><span class="line">+-----+-------+---------+---------+-----+---------------------+------+------+-------+</span><br><span class="line">|   8 |     8 | LsHfFJ  | SALEMAN |   1 | 2021-01-23 16:42:03 | 2000 | 400  |   106 |</span><br><span class="line">|  15 |    15 | WxxUeO  | SALEMAN |   1 | 2021-01-23 16:42:03 | 2000 | 400  |   106 |</span><br><span class="line">|  40 |    40 | dZPYxu  | SALEMAN |   1 | 2021-01-23 16:42:03 | 2000 | 400  |   106 |</span><br><span class="line">|  43 |    43 | yyWlyF  | SALEMAN |   1 | 2021-01-23 16:42:03 | 2000 | 400  |   106 |</span><br><span class="line">|  65 |    65 | xRSLaX  | SALEMAN |   1 | 2021-01-23 16:42:03 | 2000 | 400  |   106 |</span><br><span class="line">|  70 |    70 | dgwNzl  | SALEMAN |   1 | 2021-01-23 16:42:03 | 2000 | 400  |   106 |</span><br><span class="line">|  91 |    91 | lpTzQG  | SALEMAN |   1 | 2021-01-23 16:42:03 | 2000 | 400  |   106 |</span><br><span class="line">| 101 |   101 | BeSZuX  | SALEMAN |   1 | 2021-01-23 16:42:03 | 2000 | 400  |   106 |</span><br><span class="line">| 127 |   127 | hvHYVI  | SALEMAN |   1 | 2021-01-23 16:42:03 | 2000 | 400  |   106 |</span><br><span class="line">| 132 |   132 | IUyKci  | SALEMAN |   1 | 2021-01-23 16:42:03 | 2000 | 400  |   106 |</span><br><span class="line">+-----+-------+---------+---------+-----+---------------------+------+------+-------+</span><br><span class="line">10 rows in set  (0.017 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;  select * from emp where depno = 106 order by hiredate limit 10;</span><br><span class="line">+-----+-------+---------+---------+-----+---------------------+------+------+-------+</span><br><span class="line">| id  | empno | empname | job     | mgr | hiredate            | sal  | comn | depno |</span><br><span class="line">+-----+-------+---------+---------+-----+---------------------+------+------+-------+</span><br><span class="line">| 142 |   142 | EapywO  | SALEMAN |   1 | 2021-01-23 16:42:03 | 2000 | 400  |   106 |</span><br><span class="line">| 132 |   132 | IUyKci  | SALEMAN |   1 | 2021-01-23 16:42:03 | 2000 | 400  |   106 |</span><br><span class="line">| 127 |   127 | hvHYVI  | SALEMAN |   1 | 2021-01-23 16:42:03 | 2000 | 400  |   106 |</span><br><span class="line">| 101 |   101 | BeSZuX  | SALEMAN |   1 | 2021-01-23 16:42:03 | 2000 | 400  |   106 |</span><br><span class="line">|  91 |    91 | lpTzQG  | SALEMAN |   1 | 2021-01-23 16:42:03 | 2000 | 400  |   106 |</span><br><span class="line">|  70 |    70 | dgwNzl  | SALEMAN |   1 | 2021-01-23 16:42:03 | 2000 | 400  |   106 |</span><br><span class="line">|  65 |    65 | xRSLaX  | SALEMAN |   1 | 2021-01-23 16:42:03 | 2000 | 400  |   106 |</span><br><span class="line">|  43 |    43 | yyWlyF  | SALEMAN |   1 | 2021-01-23 16:42:03 | 2000 | 400  |   106 |</span><br><span class="line">|  40 |    40 | dZPYxu  | SALEMAN |   1 | 2021-01-23 16:42:03 | 2000 | 400  |   106 |</span><br><span class="line">|  15 |    15 | WxxUeO  | SALEMAN |   1 | 2021-01-23 16:42:03 | 2000 | 400  |   106 |</span><br><span class="line">+-----+-------+---------+---------+-----+---------------------+------+------+-------+</span><br><span class="line">10 rows in set  (6.411 sec)</span><br></pre></td></tr></table></figure><p>获取部门号为106的数据根据入职时间进行排序。从上面的查询可以看出，多了一个hiredate的排序，效率差很多 ，我们来分析一下。</p><p>在depno上创建过索引了，所以数据检索的步骤如下：</p><p>1、走idx_emp_depno索引，找到记录的的id </p><p>2、通过id在主键索引中回表检索出整条数据（回表的过程）</p><p>3、重复上面的操作，获取所有目标记录</p><p>4、在内存中对已查出的记录按照hiredate进行排序（排序的过程）</p><p>但是当数据量非常大的时候，排序还是比较慢的，最好的办法是查询出来的数据刚好是排好序的。</p><p>回顾一下MySQL中b+树的数据结构，记录是按照索引的值排序组成的链表，如果将depno和hiredate放在一起组成联合索引(depno,hiredate)，这样通过depno检索出来的数据自然就是按照hiredate排好序的，</p><p>少了一步排序操作，效率更好。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;  select * from emp where depno = 106 order by hiredate limit 10;</span><br><span class="line">+-----+-------+---------+---------+-----+---------------------+------+------+-------+</span><br><span class="line">| id  | empno | empname | job     | mgr | hiredate            | sal  | comn | depno |</span><br><span class="line">+-----+-------+---------+---------+-----+---------------------+------+------+-------+</span><br><span class="line">|   8 |     8 | LsHfFJ  | SALEMAN |   1 | 2021-01-23 16:42:03 | 2000 | 400  |   106 |</span><br><span class="line">|  15 |    15 | WxxUeO  | SALEMAN |   1 | 2021-01-23 16:42:03 | 2000 | 400  |   106 |</span><br><span class="line">|  40 |    40 | dZPYxu  | SALEMAN |   1 | 2021-01-23 16:42:03 | 2000 | 400  |   106 |</span><br><span class="line">|  43 |    43 | yyWlyF  | SALEMAN |   1 | 2021-01-23 16:42:03 | 2000 | 400  |   106 |</span><br><span class="line">|  65 |    65 | xRSLaX  | SALEMAN |   1 | 2021-01-23 16:42:03 | 2000 | 400  |   106 |</span><br><span class="line">|  70 |    70 | dgwNzl  | SALEMAN |   1 | 2021-01-23 16:42:03 | 2000 | 400  |   106 |</span><br><span class="line">|  91 |    91 | lpTzQG  | SALEMAN |   1 | 2021-01-23 16:42:03 | 2000 | 400  |   106 |</span><br><span class="line">| 101 |   101 | BeSZuX  | SALEMAN |   1 | 2021-01-23 16:42:03 | 2000 | 400  |   106 |</span><br><span class="line">| 127 |   127 | hvHYVI  | SALEMAN |   1 | 2021-01-23 16:42:03 | 2000 | 400  |   106 |</span><br><span class="line">| 132 |   132 | IUyKci  | SALEMAN |   1 | 2021-01-23 16:42:03 | 2000 | 400  |   106 |</span><br><span class="line">+-----+-------+---------+---------+-----+---------------------+------+------+-------+</span><br><span class="line">10 rows in set  (0.001 sec)</span><br></pre></td></tr></table></figure><h3 id="索引使用总结"><a href="#索引使用总结" class="headerlink" title="索引使用总结"></a>索引使用总结</h3><p>1、正确理解和计算索引字段的区分度，文中有计算规则，区分度高的索引，可以快速得定位数据，区分度太低，无法有效的利用索引，可能需要扫描大量数据页，和不使用索引没什么差别。</p><p>2、正确理解和计算前缀索引的字段长度，文中有判断规则，合适的长度要保证高的区分度和最恰当的索引存储容量，只有达到最佳状态，才是保证高效率的索引。</p><p>3、联合索引注意最左匹配原则：必须按照从左到右的顺序匹配，MySQL会一直向右匹配索引直到遇到范围查询(&gt;、&lt;、between、like)然后停止匹配。</p><p>如  depno&#x3D;1 and empname&gt;’’ and job&#x3D;1 如果建立(depno,empname,job)顺序的索引，job是用不到索引的。</p><p>4、应需而取策略，查询记录的时候，不要一上来就使用*，只取需要的数据，可能的话尽量只利用索引覆盖，可以减少回表操作，提升效率。 </p><p>5、正确判断是否使用联合索引（上面联合索引的使用那一小节有说明判断规则），也可以进一步分析到索引下推（IPC），减少回表操作，提升效率。</p><p>6、避免索引失效的原则：禁止对索引字段使用函数、运算符操作，会使索引失效。这是实际上就是需要保证索引所对应字段的”干净度“。</p><p>7、避免非必要的类型转换，字符串字段使用数值进行比较的时候会导致索引无效。</p><p>8、模糊查询’%value%’会使索引无效，变为全表扫描，因为无法判断扫描的区间，但是’value%’是可以有效利用索引。</p><p>9、索引覆盖排序字段，这样可以减少排序步骤，提升查询效率 </p><p>10、尽量的扩展索引，非必要不新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL系列：MySQl索引的介绍和原理分析</title>
      <link href="/2025/04/15/MySQL%E7%B3%BB%E5%88%97/MySQL%E7%B3%BB%E5%88%97-%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
      <url>/2025/04/15/MySQL%E7%B3%BB%E5%88%97/MySQL%E7%B3%BB%E5%88%97-%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="索引的定义"><a href="#索引的定义" class="headerlink" title="索引的定义"></a>索引的定义</h3><p>MySQL官方对索引的定义为：索引（Index）是协助MySQL高效获取数据的数据结构。</p><p>本质上，索引的目的是为了提高查询效率，通过不断地缩小想要获取数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，也就是说，有了这种索引机制，我们可以总是用同一种查找方式来锁定数据。</p><p>可以类比银行的保险柜，比如你要找归属你的保险柜子。如果没有索引，你需要拿着钥匙，一个个的保险柜的试过去才能找到属于你的保险柜。但是如果有了索引，而且保险柜能够以物理分区的方式存在在对应的区域，同时你可以根据钥匙上的编号（A1003-10-17），找到保险柜所在 A1003的存放房间，找到存放室保险柜的第10排，再找到第17个位置，找到属于你的保险柜，这个定位就快很多了。在没有索引的情况下，要想完成这个事情还是比较困难的。 </p><h3 id="索引的原理"><a href="#索引的原理" class="headerlink" title="索引的原理"></a>索引的原理</h3><p>除了保险柜之外，生活中可以引出很多类似的索引例子，如字典词典的目录、图书馆的检索录、火车的座次表等。</p><p>它们的原理一致：不断的缩小数据范围来筛选数据，并把随机数据变成顺序数据，方便我们更快地锁定数据。</p><p>这种索引的理解同样适用我们的数据库查询，但是数据库会有很多更复杂的情况，除了等值查询外，还有范围查询(&gt;、&lt;、between、in)、模糊查询(like)、并集查询(or)、交集查询（and）等等。这就要求数据库选择更加复杂和成熟的方式来应对所有问题。</p><p>根据我们上面保险柜的案例，可以对数据按照一定规则进行拆分，这样匹配的范围就降低了，但是这远远不够满足数据库复杂的查询要求。于是，数据库系统的设计者从查询算法的角度进行优化。</p><p>其中最基本的查询算法是顺序查找（linear search），这种算法复杂度为O(n)，在数据量很大时就很不理想了，而且数据量越大，计算越复杂。</p><p>但没关系，强大的计算机科学提供了更多优秀的查找算法，比如二分查找（binary search）、二叉树查找（binary tree search）等。</p><p>但是这些查找算法都要求应用于特定的数据结构之上，如二分查找要求被检索数据有序，而二叉树查找只能基于二叉查找树结构上操作，数据本身的组织结构不可能完全满足各种数据结构，理论上也无法同时要求将多列都按顺序进行组织。</p><p>因此，在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</p><p>这与上面MySQL官方对索引的定义遥相呼应了。</p><p>看下面的图：</p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAPaaUfBWsdB24BnVqdfI0Tdnuv7EXAAAiMMaxunpzhWf6gRzD8QW1wBAAMCAAN4AAM2BA.png"></p><p>图举例了一种索引方式。右边是一个数据表，这边一共模拟了两列七行的数据，字段1的是数据记录的物理地址（实际应用中逻辑上相邻的记录在磁盘上并不一定物理相邻，这边主要为了举例）。为了加快字段2的查找，可以维护一个左边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在O(log2n)O(log2n)的复杂度内获取到相应数据。</p><p>这是索引的一种表现形式，但是实际的数据库系统中比较普遍是采用B+树来实现的。B+树中的B代表平衡（balance），不是二叉（binary）。因为B+树是从最早的平衡二叉树演化而来的，所以我们可以先了解下二叉查找树、平衡二叉树（AVLTree）和平衡多路查找树（B-Tree），因为B+树是由这些树逐步演进而来。 </p><h4 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h4><p>二叉树具有以下性质：左子树的键值小于根的键值，右子树的键值大于根的键值。 所以左中右是依次递增的一个过程。</p><p>如下图所示就是一棵二叉查找树， </p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAPbaUfBmXf54JgFgLZTQEGs6UxEN_IAAiYMaxunpzhWcQABs2uJXc3FAQADAgADeAADNgQ.png"></p><p> 观察该二叉树有有如下发现，深度为1的节点的查找次数为1，深度为2的查找次数为2，深度为n的节点的查找次数为n，因此其平均查找次数为 (1+2+2+3+3+3+3) &#x2F; 7 &#x3D; 2.4次。</p><p>二叉查找树也可以是如下结构（同样满足二叉树 左 &lt; 中 &lt; 大的特性），同样是7,21,35,42,51,77,89 这七个数字，也可以按照下图的方式来构造： </p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAPcaUfBxEa60jyd9if6UYYk_o_Rit4AAioMaxunpzhWsvCvdILg6q4BAAMCAAN4AAM2BA.png"></p><p>但是这棵二叉树的查询效率就低了，平均查找次数为(1+2+3+4+5+6+6)&#x2F;7&#x3D;3.8次。</p><p>因此若想二叉树的查询效率尽可能高，需要这棵二叉树是平衡的，从而引出新的定义：AVL树（即平衡二叉树）。 </p><h4 id="平衡二叉树（AVL-Tree）"><a href="#平衡二叉树（AVL-Tree）" class="headerlink" title="平衡二叉树（AVL Tree）"></a>平衡二叉树（AVL Tree）</h4><p>平衡二叉树（AVL树）在符合二叉查找树的条件下，还满足任何节点的两个子树的高度最大差为1。下面的两张图片，左边是AVL树，它的任何节点的两个子树的高度差&lt;&#x3D;1；右边的不是AVL树，其根节点的左子树高度为3，而右子树高度为1，高度差&gt;1； </p><p> <img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAPdaUfB9uOKH4_L3XzdDOjqT_AE3WsAAisMaxunpzhWdbs4NhCvNkEBAAMCAAN5AAM2BA.png"></p><p>同理，在平衡二叉树进行插入或删除节点，也可能导致AVL树失去平衡，这种失去平衡的二叉树可以有四种状态：LL（左左）、RR（右右）、LR（左右）、RL（右左）。</p><p>看下图示： </p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAPeaUfCL9FlHml1iysl-vY79G2OCJQAAiwMaxunpzhWMR2IWhgq4tEBAAMCAAN5AAM2BA.png"></p><p>我们来逐一看下这几种状态。</p><p>**LL（LeftLeft），即 左左。**是指插入或删除一个节点后，根节点的左孩子（Left Child）的左孩子（Left Child）还有非空节点，导致根节点的左子树比右子树高度&gt;1，AVL树失去平衡。</p><p>**RR（RightRight），即 右右。**是指插入或删除一个节点后，根节点的右孩子（Right Child）的右孩子（Right Child）还有非空节点，导致根节点的右子树比左子树高度&gt;1，AVL树失去平衡。</p><p>**LR（LeftRight），即 左右。**插入或删除一个节点后，根节点的左孩子（Left Child）的右孩子（Right Child）还有非空节点，导致根节点的左子树比右子树高度&gt;1，AVL树失去平衡。</p><p>**RL（RightLeft），即 右左。**插入或删除一个节点后，根节点的右孩子（Right Child）的左孩子（Left Child）还有非空节点，导致根节点的右子树比左子树高度&gt;1，AVL树失去平衡。</p><p>失去平衡的AVL树，可以通过旋转来修复，旋转的本质是将树的节点进行调整，达到恢复平衡的目的。下面逐一来看下。</p><p> LL的旋转：LL失去平衡的情况下，可以通过一次旋转让AVL树恢复平衡。步骤如下：</p><p>1、将根节点的左孩子作为新根节点。</p><p>2、将新根节点的右孩子作为原根节点的左孩子。</p><p>3、将原根节点作为新根节点的右孩子。</p><p>如下图所示： </p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAPfaUfCYgp5QPGPW0upcaJ02KZqM2AAAi8MaxunpzhWQ65bLi9YBxQBAAMCAAN3AAM2BA.png"></p><p> RR的旋转：RR失去平衡的情况下，旋转方法与LL旋转相反，步骤如下：</p><p>1、将根节点的右孩子作为新根节点。</p><p>2、将新根节点的左孩子作为原根节点的右孩子。</p><p>3、将原根节点作为新根节点的左孩子。</p><p>如下图所示： </p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAPgaUfCoUjb7LKtoI8QSUgk29lc8gYAAjAMaxunpzhWYvBzWaOR8vgBAAMCAAN3AAM2BA.png"> </p><p>LR的旋转：LR失去平衡的情况下，需要进行两次旋转，步骤如下：</p><p>1、围绕根节点的左孩子进行RR旋转。</p><p>2、围绕根节点进行LL旋转。</p><p>如下图所示，它转了两次，最后恢复成一棵AVL树： </p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAPhaUfDCAwcIaGs5W_vZw71Da_HZbsAAjEMaxunpzhWy2WbkJv5Ca0BAAMCAAN3AAM2BA.png"> </p><p>RL的旋转：RL失去平衡的情况下也需要进行两次旋转，旋转方法与LR旋转相反，步骤如下：</p><p>1、围绕根节点的右孩子进行LL旋转。</p><p>2、围绕根节点进行RR旋转。</p><p>如下图所示，它转了两次，最后恢复成一棵AVL树： </p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAPiaUfDZg5Xov5eDIU9Oh3NdMGY99MAAjMMaxunpzhWNCMJhikF37QBAAMCAAN3AAM2BA.png"> </p><h4 id="平衡多路查找树（B-Tree）"><a href="#平衡多路查找树（B-Tree）" class="headerlink" title="平衡多路查找树（B-Tree）"></a>平衡多路查找树（B-Tree）</h4><p>我们知道，磁盘这种存储设备是以磁盘块（block）为基本单位的，而B-树也是基于这种存储方式设计的平衡查找树。</p><p>所以当我们从系统磁盘读取数据时，以磁盘块（block）为基本单位映射到内存中，位于同一个磁盘块中的数据会被一次性读取出来，而不是只取需要的数据。InnoDB存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。InnoDB存储引擎中默认每个页的大小为16KB，可通过参数innodb_page_size将页的大小设置为4K、8K、16K，我们可以在命令窗口输入以下脚本查看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;innodb_page_size&#x27;;</span><br><span class="line">+------------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+------------------+-------+</span><br><span class="line">| innodb_page_size | 16384 |</span><br><span class="line">+------------------+-------+</span><br><span class="line">1 row in set</span><br></pre></td></tr></table></figure><p> 而系统一个磁盘块的存储空间往往没有这么大，因此InnoDB每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小16KB。</p><p>InnoDB在把磁盘数据读入到磁盘时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，</p><p>这将会减少磁盘I&#x2F;O次数，提高查询效率。</p><p> B-Tree结构的数据可以让系统高效的找到数据所在的磁盘块。为了描述B-Tree，首先定义一条记录为一个二元组[key, data] ，key为记录的键值，对应表中的主键值，data为一行记录中除主键外的数据。对于不同的记录，key值互不相同。</p><p>一棵m阶的B-Tree有如下特性： </p><ol><li>每个节点最多有m个孩子。 </li><li>除了根节点和叶子节点外，其它每个节点至少有Ceil(m&#x2F;2)个孩子。 </li><li>若根节点不是叶子节点，则至少有2个孩子 </li><li>所有叶子节点都在同一层，且不包含其它关键字信息 </li><li>每个非终端节点包含n个关键字信息（P0,P1,…Pn, k1,…kn） </li><li>关键字的个数n满足：ceil(m&#x2F;2)-1 &lt;&#x3D; n &lt;&#x3D; m-1 </li><li>ki(i&#x3D;1,…n)为关键字，且关键字升序排序。 </li><li>Pi(i&#x3D;1,…n)为指向子树根节点的指针。P(i-1)指向的子树的所有节点关键字均小于ki，但都大于k(i-1)</li></ol><p>B-Tree中的每个节点根据实际情况可以包含大量的关键字信息和分支，如下图所示为一个3阶的B-Tree： </p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAPjaUfD15D43NV45BWQ3FmYIV7bleIAAjQMaxunpzhWZbYSq8_5rU4BAAMCAAN5AAM2BA.png"></p><p>每个节点占用一个盘块的磁盘空间，一个节点上有两个升序排序的关键字和三个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。两个键值数据划分成的三个范围域对应三个指针指向的子树的数据的范围域。以根节点为例，两个键值数据为33和66，P1指针指向的子树的数据范围为小于33，P2指针指向的子树的数据范围为33~66之间，P3指针指向的子树的数据范围为大于66。</p><p>模拟查找关键字55的过程：</p><p>1、根据根节点找到磁盘块Disk1，读入内存。第1次操作磁盘I&#x2F;O。</p><p>2、比较键值55在区间（33,66），找到磁盘块Disk1的指针P2。</p><p>3、根据P2指针找到磁盘块Disk3，读入内存。第2次操作磁盘I&#x2F;O。</p><p>4、比较键值55在区间（39,62），找到磁盘块Disk3的指针P2。</p><p>5、根据P2指针找到磁盘块Disk8，读入内存。第3次操作磁盘I&#x2F;O。</p><p>6、在Disk8中的键值列表中找到关键字55。</p><p>通过上面的操作过程，发现需要3次磁盘I&#x2F;O操作，和3次内存查找操作。由于内存中的关键字是一个有序表结构，可以利用二分法查找提高效率。而3次磁盘I&#x2F;O操作是影响整个B-Tree查找效率的决定因素。</p><p>B-Tree相对于AVLTree缩减了节点个数，使每次磁盘I&#x2F;O取到内存的数据都发挥了作用，从而提高了查询效率。 </p><h4 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B+Tree"></a>B+Tree</h4><p>B+Tree是在B-Tree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是用B+Tree实现其索引结构。</p><p>从上面的B-Tree结构图中可以看到每个节点中不仅包含数据的key值，还有data值。而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，当存储的数据量很大时同样会导致B-Tree的深度较大，增大查询时的磁盘I&#x2F;O次数，进而影响查询效率。在B+Tree中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度，提高查找效率。</p><p>B+Tree相比较于B-Tree的不同点：</p><p>1、非叶子节点只存储键值信息。</p><p>2、所有叶子节点之间都有一个链指针。</p><p>3、数据记录都存放在叶子节点中。</p><p>将上面的B-Tree优化，由于B+Tree的非叶子节点只存储键值信息，假设每个磁盘块能存储4个键值及指针信息，则变成B+Tree后其结构如下图所示： </p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAPkaUfEASZNr5_QTWsxEcTO8ZhFtBwAAjUMaxunpzhWctV9MDK2l40BAAMCAAN3AAM2BA.png"></p><p>通常在B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。因此可以对B+Tree进行两种查找运算：一种是对于主键的范围查找和分页查找，另一种是从根节点开始，进行随机查找。</p><p>可能上面例子中只有22条数据记录，看不出B+Tree的优点，下面做一个推算：</p><p>InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT（占用4个字节）或BIGINT（占用8个字节），指针类型也一般为4或8个字节，也就是说一个页（B+Tree中的一个节点）中大概存储16KB&#x2F;(8B+8B)&#x3D;1K个键值（因为是估值，为方便计算，这里的K取值为〖10〗^3）。也就是说一个深度为3的B+Tree索引可以维护10^3 * 10^3 * 10^3 &#x3D; 10亿 条记录。</p><p>实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree的高度一般都在2<del>4层。mysql的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1</del>3次磁盘I&#x2F;O操作。</p><p>数据库中的B+Tree索引可以分为聚集索引（clustered index）和辅助索引（secondary index）。上面的B+Tree示例图在数据库中的实现即为聚集索引，聚集索引的B+Tree中的叶子节点存放的是整张表的行记录数据。辅助索引与聚集索引的区别在于辅助索引的叶子节点并不包含行记录的全部数据，而是存储相应行数据的聚集索引键，即主键。当通过辅助索引来查询数据时，InnoDB存储引擎会遍历辅助索引找到主键，然后再通过主键在聚集索引中找到完整的行记录数据。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>根据上面，二叉查找树，红黑树等数据结构也可以用来实现索引，但是文件系统及数据库系统普遍采用B+Tree作为索引结构（目前MySQL的MYISAM 和 INNODB 都是采用B+Tree作为索引结构），这是因为B+Tree索引的设计是以计算机磁盘存储结构为理论基础的。</p><p>索引以索引文件的形式存储在磁盘上，当采用B+Tree查找的时候，产生磁盘I&#x2F;O消耗对性能的影响比其他方式小很多（评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I&#x2F;O操作次数的渐进复杂度）。</p><p>换句话说，索引的结构组织要尽量减少查找过程中磁盘I&#x2F;O的存取次数，而B+Tree无疑是较优的算法</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL系列：MySQl索引实现和使用</title>
      <link href="/2025/04/15/MySQL%E7%B3%BB%E5%88%97/MySQL%E7%B3%BB%E5%88%97-%E7%B4%A2%E5%BC%95%E5%AE%9E%E7%8E%B0%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
      <url>/2025/04/15/MySQL%E7%B3%BB%E5%88%97/MySQL%E7%B3%BB%E5%88%97-%E7%B4%A2%E5%BC%95%E5%AE%9E%E7%8E%B0%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="MySQL索引实现"><a href="#MySQL索引实现" class="headerlink" title="MySQL索引实现"></a>MySQL索引实现</h3><p>上一篇我们详细了解了B+树的实现原理(<a href="https://yeoh.qzz.io/2025/04/15/MySQL%E7%B3%BB%E5%88%97-%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">MySQL系列：MySQl索引的介绍和原理分析 | 数根朽木，</a>)。我们知道，MySQL内部索引是由不同的引擎实现的，主要包含InnoDB和MyISAM这两种，并且这两种引擎中的索引都是使用b+树的结构来存储的。</p><h4 id="InnoDB引擎中的索引"><a href="#InnoDB引擎中的索引" class="headerlink" title="InnoDB引擎中的索引"></a>InnoDB引擎中的索引</h4><p>Innodb中有2种索引：主键索引（也叫聚集索引）、辅助索引（也叫非聚集索引）。</p><p>**主键索引：**每个表只有一个主键索引，b+树结构，叶子节点存储主键的值以及对应整条记录的数据，非叶子节点不存储记录的数据，只存储主键的值。</p><p>当表中未指定主键时，MySQL内部会自动给每条记录添加一个隐藏的rowid字段（默认4个字节）作为主键，用rowid构建聚集索引。聚集索引在MySQL中即主键索引。 </p><p>**辅助索引：**每个表可以有多个辅助索引，b+树结构，非聚集索引叶子节点存储字段（索引字段）的值以及对应记录主键的值，其他节点只存储字段的值（索引字段），这就是与聚集索引不同的地方。每个表可以有多个非聚集索引。</p><p>MySQL中非聚集索引进一步区分：</p><table><thead><tr><th>非聚集索引类型</th><th>说明</th></tr></thead><tbody><tr><td>单列索引</td><td>一个索引只包含一个列</td></tr><tr><td>多列索引（复合索引）</td><td>一个索引包含多个列</td></tr><tr><td>唯一索引</td><td>索引列的值必须唯一，允许有一个空值</td></tr></tbody></table><h4 id="MyISAM引擎中的索引"><a href="#MyISAM引擎中的索引" class="headerlink" title="MyISAM引擎中的索引"></a>MyISAM引擎中的索引</h4><p>也是B+树结构，MyISM使用的是非聚簇索引，如下图，非聚簇索引的两棵B+树看上去没什么不同，节点的结构完全一致只是存储的内容不同而已，主键索引B+树的节点存储了主键，</p><p>辅助键索引B+树存储了辅助键。表数据存储在独立的地方，这两颗B+树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别。</p><p>由于索引树是独立的，通过辅助键检索无需访问主键的索引树。</p><p>下图更形象说明这两种索引的区别，这边假设了一个存储4行数据的表。Id为主键索引，Name作为辅助索引，图中清晰的体现了聚簇索引和非聚簇索引的差异。</p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAPmaUfGi9BgpGEH3etIIFFDewf48SwAAjoMaxunpzhWq-moRl6wVw4BAAMCAAN4AAM2BA.png"> </p><p>我们来分析一下图中数据检索过程：</p><h4 id="InnoDB数据检索过程"><a href="#InnoDB数据检索过程" class="headerlink" title="InnoDB数据检索过程"></a>InnoDB数据检索过程</h4><p>上面的表中有2个索引：id作为主键索引，name作为辅助索引。</p><p>如果需要查询id&#x3D;14的数据，只需要在左边的主键索引中检索就可以了。</p><p>如果需要搜索name&#x3D;’Ellison’的数据，需要2步：</p><p>1、先在辅助索引中检索到name&#x3D;’Ellison’的数据，获取id为14</p><p>2、再到主键索引中检索id为14的记录</p><p>辅助索引这个查询过程在mysql中叫做回表，相对于主键索引多了第二步操作。 </p><h4 id="MyISAM数据检索过程"><a href="#MyISAM数据检索过程" class="headerlink" title="MyISAM数据检索过程"></a>MyISAM数据检索过程</h4><p>1、在索引中找到对应的关键字，获取关键字对应的记录的地址</p><p>2、通过记录的地址查找到对应的数据记录</p><p>对比发现：innodb中最好是采用主键查询，这样只需要一次索引，如果使用辅助索引检索，涉及多一步的回表操作，比主键查询要耗时一些。</p><p>而innodb中辅助索引区别于myisam的是：</p><p>表中的数据发生变更的时候，会影响其他记录地址的变化，如果辅助索引中记录数据的地址，此时会受影响，而主键的值一般是很少更新的，当页中的记录发生地址变更的时候，对辅助索引是没有影响的。 </p><h3 id="索引管理和使用"><a href="#索引管理和使用" class="headerlink" title="索引管理和使用"></a>索引管理和使用</h3><h4 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h4><p>请参考(<a href="https://yeoh.qzz.io/2025/04/15/MySQL%E7%B3%BB%E5%88%97-%E4%B8%80%E6%AC%A1%E6%B7%B1%E5%A4%9C%E4%BC%98%E5%8C%96%E4%BA%BF%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%88%86%E9%A1%B5%E7%9A%84%E5%A5%87%E5%A6%99%E7%BB%8F%E5%8E%86%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/">MySQL系列：一次深夜优化亿级数据分页的奇妙经历(转载) | 数根朽木，</a>)中模拟的千万数据，我们以这个数据为测试数据。 </p><h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><p>create 方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 create [unique] index index_name on t_name(c_name[(length)]); </span><br></pre></td></tr></table></figure><p>alter表 方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 alter t_name add [unique] index index_name on (cname[(length)]);</span><br></pre></td></tr></table></figure><p>这边需注意的是：</p><p>index_name 代表索引名称、t_name代表 表名称、c_name代表字段名称。</p><p>[]中括号的内容是可以省略的，也就是说 unique 和 length 可以不写。如果加上了unique，表示创建唯一索引。</p><p>如果字段是char、varchar类型，length可以小于字段实际长度，如果是blog、text等长文本类型，必须指定length。</p><p>如果tname后面只写一个字段，就是单列索引，如果需要写多个字段，可以使用逗号隔开，这种叫做复合索引。</p><h4 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop index index_name on t_name;</span><br></pre></td></tr></table></figure><h4 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show index from t_name; </span><br></pre></td></tr></table></figure><h4 id="索引修改"><a href="#索引修改" class="headerlink" title="索引修改"></a>索引修改</h4><p>即先删除索引，再重建索引：drop +create。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>emp表中有500W数据 我们用emp来做测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select count(*) from emp;</span><br><span class="line">+----------+</span><br><span class="line">| count(*) |</span><br><span class="line">+----------+</span><br><span class="line">|  5000000 |</span><br><span class="line">+----------+</span><br><span class="line">1 row in set</span><br></pre></td></tr></table></figure><h5 id="查看和创建索引"><a href="#查看和创建索引" class="headerlink" title="查看和创建索引"></a>查看和创建索引</h5><p>记得我们之前在emp表上做过索引，所以先看一下这个表目前所有的索引</p><p>可以看到，目前主键字段id和depno字段上都有建立索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; desc emp;</span><br><span class="line">+----------+-----------------------+------+-----+---------+----------------+</span><br><span class="line">| Field    | Type                  | Null | Key | Default | Extra          |</span><br><span class="line">+----------+-----------------------+------+-----+---------+----------------+</span><br><span class="line">| id       | int(10) unsigned      | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| empno    | mediumint(8) unsigned | NO   |     | 0       |                |</span><br><span class="line">| empname  | varchar(20)           | NO   |     |         |                |</span><br><span class="line">| job      | varchar(9)            | NO   |     |         |                |</span><br><span class="line">| mgr      | mediumint(8) unsigned | NO   |     | 0       |                |</span><br><span class="line">| hiredate | datetime              | NO   |     | NULL    |                |</span><br><span class="line">| sal      | decimal(7,2)          | NO   |     | NULL    |                |</span><br><span class="line">| comn     | decimal(7,2)          | NO   |     | NULL    |                |</span><br><span class="line">| depno    | mediumint(8) unsigned | NO   | MUL | 0       |                |</span><br><span class="line">+----------+-----------------------+------+-----+---------+----------------+</span><br><span class="line">9 rows in set</span><br><span class="line"></span><br><span class="line">mysql&gt; show index from emp;</span><br><span class="line">+-------+------------+---------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">| Table | Non_unique | Key_name      | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |</span><br><span class="line">+-------+------------+---------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">| emp   |          0 | PRIMARY       |            1 | id          | A         |     4952492 | NULL     | NULL   |      | BTREE      |         |               |</span><br><span class="line">| emp   |          1 | idx_emp_id    |            1 | id          | A         |     4952492 | NULL     | NULL   |      | BTREE      |         |               |</span><br><span class="line">| emp   |          1 | idx_emp_depno |            1 | depno       | A         |          18 | NULL     | NULL   |      | BTREE      |         |               |</span><br><span class="line">+-------+------------+---------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">3 rows in set</span><br></pre></td></tr></table></figure><p> 我们在没有做索引的字段上做一下查询看看，在500W数据中查询一个名叫LsHfFJA的员工，消耗 2.239S </p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAPnaUfGu2Hw7oWqCx9pqFrR_ksm4tkAAkAMaxunpzhWnxS_YODYQG4BAAMCAAN5AAM2BA.png"></p><p>再看看他的执行过程，扫描了4952492 条数据才找到该行数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from emp where empname=&#x27;LsHfFJA&#x27;;</span><br><span class="line">+----+-------------+-------+------+---------------+------+---------+------+---------+-------------+</span><br><span class="line">| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows    | Extra       |</span><br><span class="line">+----+-------------+-------+------+---------------+------+---------+------+---------+-------------+</span><br><span class="line">|  1 | SIMPLE      | emp   | ALL  | NULL          | NULL | NULL    | NULL | 4952492 | Using where |</span><br><span class="line">+----+-------------+-------+------+---------------+------+---------+------+---------+-------------+</span><br><span class="line">1 row in set</span><br></pre></td></tr></table></figure><p> 我们在empname这个字段上建立索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create index idx_emp_empname on emp(empname);</span><br><span class="line">Query OK, 0 rows affected</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; show index from emp;</span><br><span class="line">+-------+------------+-----------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">| Table | Non_unique | Key_name        | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |</span><br><span class="line">+-------+------------+-----------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">| emp   |          0 | PRIMARY         |            1 | id          | A         |     4952492 | NULL     | NULL   |      | BTREE      |         |               |</span><br><span class="line">| emp   |          1 | idx_emp_id      |            1 | id          | A         |     4952492 | NULL     | NULL   |      | BTREE      |         |               |</span><br><span class="line">| emp   |          1 | idx_emp_depno   |            1 | depno       | A         |          18 | NULL     | NULL   |      | BTREE      |         |               |</span><br><span class="line">| emp   |          1 | idx_emp_empname |            1 | empname     | A         |     1650830 | NULL     | NULL   |      | BTREE      |         |               |</span><br><span class="line">+-------+------------+-----------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">4 rows in set</span><br></pre></td></tr></table></figure><p> 再看一下这个执行效率，就会发现有质的飞跃：0.001S，就是这么神奇，学过之前那篇的B+ Tree就知道，它不用从头开始扫表核对，而是很小次数的io读取</p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAPlaUfFyHPV1iW3CCLRcPi_uQ2bAqYAAjkMaxunpzhWHeSnvn9NND0BAAMCAAN5AAM2BA.png"> </p><p>再看看他的执行过程，一次定位到该条数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from emp where empname=&#x27;LsHfFJA&#x27;;</span><br><span class="line">+----+-------------+-------+------+-----------------+-----------------+---------+-------+------+-----------------------+</span><br><span class="line">| id | select_type | table | type | possible_keys   | key             | key_len | ref   | rows | Extra                 |</span><br><span class="line">+----+-------------+-------+------+-----------------+-----------------+---------+-------+------+-----------------------+</span><br><span class="line">|  1 | SIMPLE      | emp   | ref  | idx_emp_empname | idx_emp_empname | 22      | const |    1 | Using index condition |</span><br><span class="line">+----+-------------+-------+------+-----------------+-----------------+---------+-------+------+-----------------------+</span><br><span class="line">1 row in set</span><br></pre></td></tr></table></figure><h5 id="设置合适的索引长度"><a href="#设置合适的索引长度" class="headerlink" title="设置合适的索引长度"></a>设置合适的索引长度</h5><p>根据我们之前的了解，每个磁盘块（disk）存储的内容是有限的，如果一个页中可以存储的索引记录越多，那么查询效率就会提高，所以我们可以指定索引的字段长度。</p><p>但并不是越短越好，要保证字符类型字段查询有足够高的区分度，如果只设置了一个长度，反而导致查询的相似匹配度不高。</p><p>长度的原则是要恰到好处，太长索引文件就会变大，因此要在区分度和长度上做一个平衡。</p><p><strong>如果在我们搜索的内容中，最后的内容是一致的或者高度一致的，那我们就可以省略，比如在用户的email字段上做索引，几乎前10个字符是不一样的，结尾限定在 @，那么通过前面10个字符就可以定位一个email地址了。</strong></p><p><strong>我们在该字段创建索引的时候就可以指定长度为10，这样相对于整个email字段更短些，查询效果确却基本一样，这样一个页中也可以存储更多的索引记录。</strong></p><p>像我们上面的那个 empname 字段，基本都是6位数的，只是小部分是超过6位数，而且后缀基本一致，所以6位数之后的区分度差不多。</p><p>有一个判断 高区分度以及合适长度索引 的通用算法，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 select count(distinct left(`c_name`,calcul_len))/count(*) from t_name;</span><br></pre></td></tr></table></figure><p> 下面是对 empname 做的分析，匹配度越高搜索效率越高：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select count(distinct left(`empname`,3))/count(*) from emp;</span><br><span class="line">+--------------------------------------------+</span><br><span class="line">| count(distinct left(`empname`,3))/count(*) |</span><br><span class="line">+--------------------------------------------+</span><br><span class="line">| 0.0012                                     |</span><br><span class="line">+--------------------------------------------+</span><br><span class="line">1 row in set</span><br><span class="line"></span><br><span class="line">mysql&gt; select count(distinct left(`empname`,4))/count(*) from emp;</span><br><span class="line">+--------------------------------------------+</span><br><span class="line">| count(distinct left(`empname`,4))/count(*) |</span><br><span class="line">+--------------------------------------------+</span><br><span class="line">| 0.0076                                     |</span><br><span class="line">+--------------------------------------------+</span><br><span class="line">1 row in set</span><br><span class="line"></span><br><span class="line">mysql&gt; select count(distinct left(`empname`,6))/count(*) from emp;</span><br><span class="line">+--------------------------------------------+</span><br><span class="line">| count(distinct left(`empname`,6))/count(*) |</span><br><span class="line">+--------------------------------------------+</span><br><span class="line">| 0.1713                                     |</span><br><span class="line">+--------------------------------------------+</span><br><span class="line">1 row in set</span><br><span class="line"></span><br><span class="line">mysql&gt; select count(distinct left(`empname`,7))/count(*) from emp;</span><br><span class="line">+--------------------------------------------+</span><br><span class="line">| count(distinct left(`empname`,7))/count(*) |</span><br><span class="line">+--------------------------------------------+</span><br><span class="line">| 0.1713                                     |</span><br><span class="line">+--------------------------------------------+</span><br><span class="line">1 row in set</span><br></pre></td></tr></table></figure><h5 id="删除索引-1"><a href="#删除索引-1" class="headerlink" title="删除索引"></a>删除索引</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; drop index idx_emp_empname on emp;</span><br><span class="line">Query OK, 0 rows affected</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; show index from emp;</span><br><span class="line">+-------+------------+---------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">| Table | Non_unique | Key_name      | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |</span><br><span class="line">+-------+------------+---------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">| emp   |          0 | PRIMARY       |            1 | id          | A         |     4952492 | NULL     | NULL   |      | BTREE      |         |               |</span><br><span class="line">| emp   |          1 | idx_emp_id    |            1 | id          | A         |     4952492 | NULL     | NULL   |      | BTREE      |         |               |</span><br><span class="line">| emp   |          1 | idx_emp_depno |            1 | depno       | A         |          18 | NULL     | NULL   |      | BTREE      |         |               |</span><br><span class="line">+-------+------------+---------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">3 rows in set</span><br></pre></td></tr></table></figure><p>执行完删除命令再查看，发现索引已经没了</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>本文只是理解索引的基本用法，后面会认真讲一讲索引的性能分析和优化策略。</p><p>总之，理想的索引应该符合以下特征：</p><p>1、相对低频的写操作，以及高频的查询的表和字段上建立索引</p><p>2、字段区分度高</p><p>3、长度小（合适的长度，不是越小越好）</p><p>4、尽量能够覆盖常用字段</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java核心系列10：线程管理</title>
      <link href="/2025/04/02/Java%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/Java%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%8610-%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
      <url>/2025/04/02/Java%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/Java%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%8610-%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="1-线程的基本概念"><a href="#1-线程的基本概念" class="headerlink" title="1 线程的基本概念"></a>1 线程的基本概念</h2><p>线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。每个线程都有一个独立的执行路径，但共享进程的资源，如内存和文件句柄。在Java中，线程可以通过继承<code>Thread</code>类或实现<code>Runnable</code>接口来创建。</p><p>此外，<code>Java 5</code>开始，引入了<code>java.util.concurrent</code>包，提供了更多的并发工具，如Callable接口与Future接口，它们主要用于任务执行。</p><h2 id="2-线程的创建与启动"><a href="#2-线程的创建与启动" class="headerlink" title="2 线程的创建与启动"></a>2 线程的创建与启动</h2><h3 id="2-1-继承Thread类"><a href="#2-1-继承Thread类" class="headerlink" title="2.1 继承Thread类"></a>2.1 继承Thread类</h3><ul><li>创建一个类继承自<code>Thread</code>类。</li><li>重写<code>run()</code>方法，该方法包含了线程要执行的任务。</li><li>创建该类的对象，并调用<code>start()</code>方法启动线程。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">run</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;线程运行中&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="title class_">String</span>[] args</span>) &#123;</span><br><span class="line">        <span class="title class_">MyThread</span> t = <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        t.<span class="title function_">start</span>(); <span class="comment">// 调用start()方法来启动线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-实现Runnable接口"><a href="#2-2-实现Runnable接口" class="headerlink" title="2.2 实现Runnable接口"></a>2.2 实现Runnable接口</h3><ul><li>创建一个类实现<code>Runnable</code>接口。</li><li>实现<code>run()</code>方法，该方法同样包含了线程要执行的任务。</li><li>将该类的对象作为参数传递给<code>Thread</code>类的构造函数，创建<code>Thread</code>对象。</li><li>调用<code>Thread</code>对象的<code>start()</code>方法启动线程。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">run</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;线程运行中&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="title class_">String</span>[] args</span>) &#123;</span><br><span class="line">        <span class="title class_">Thread</span> t = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        t.<span class="title function_">start</span>(); <span class="comment">// 调用start()方法来启动线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-线程的同步与通信"><a href="#3-线程的同步与通信" class="headerlink" title="3 线程的同步与通信"></a>3 线程的同步与通信</h2><p>由于多个线程可能会同时访问共享资源，因此需要使用同步机制来确保数据的正确性和一致性。Java提供了多种同步机制，如<code>synchronized</code>关键字、<code>wait()</code>和<code>notify()</code>方法、以及<code>ReentrantLock</code>等。</p><h3 id="3-1-synchronized关键字"><a href="#3-1-synchronized关键字" class="headerlink" title="3.1 synchronized关键字"></a>3.1 synchronized关键字</h3><ol><li>可以用于方法或代码块上，以确保同一时刻只有一个线程能够执行该方法或代码块。</li><li>当一个线程持有某个对象的锁时，其他线程将无法访问该对象的同步方法或代码块，直到锁被释放。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">SynchronizedExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedExample</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建多个线程来测试同步</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                example.increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                example.increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待线程执行完毕</span></span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出最终结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Final count: &quot;</span> + example.getCount()); <span class="comment">// 最终输出2000</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-wait-和notify-方法"><a href="#3-2-wait-和notify-方法" class="headerlink" title="3.2 wait()和notify()方法"></a>3.2 wait()和notify()方法</h3><p>这两个方法用于在线程之间进行通信。</p><ol><li><code>wait()</code>方法使当前线程等待，直到其他线程调用<code>notify()</code>或<code>notifyAll()</code>方法唤醒它。</li><li><code>notify()</code>方法唤醒一个等待该对象的线程（如果有多个线程在等待，则选择其中一个），而<code>notifyAll()</code>方法唤醒所有等待该对象的线程。</li></ol><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAPRaUeueyavezm8d1RgrPrVUbZrLcAAAvcLaxunpzhWCiLKGOtGlPUBAAMCAAN5AAM2BA.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"># 先写后读</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitNotifyExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">ready</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writer</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="comment">// 模拟写操作</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>); <span class="comment">// 假设写操作需要1秒</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Data is ready&quot;</span>);</span><br><span class="line">            ready = <span class="literal">true</span>;</span><br><span class="line">            lock.notify(); <span class="comment">// 唤醒等待的线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reader</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!ready) &#123;</span><br><span class="line">                lock.wait(); <span class="comment">// 等待数据准备好</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 读取数据</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Data has been read&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">WaitNotifyExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WaitNotifyExample</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">writerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(example::writer);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">readerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(example::reader);</span><br><span class="line"></span><br><span class="line">        writerThread.start();</span><br><span class="line">        readerThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-ReentrantLock"><a href="#3-3-ReentrantLock" class="headerlink" title="3.3 ReentrantLock"></a>3.3 ReentrantLock</h3><ol><li>提供了比<code>synchronized</code>更灵活的锁机制。</li><li>可以显式地加锁和解锁，还支持公平锁和非公平锁等特性。</li></ol><h3 id="3-4-线程的生命周期与状态"><a href="#3-4-线程的生命周期与状态" class="headerlink" title="3.4 线程的生命周期与状态"></a>3.4 线程的生命周期与状态</h3><p>Java线程在其生命周期中会经历多种状态，包括新建（New）、就绪（Runnable）、运行（Running）、阻塞（Blocked）、等待（Waiting）、超时等待（Timed Waiting）和终止（Terminated）。</p><ul><li><strong>新建（New）</strong>：线程被创建但尚未启动。</li><li><strong>就绪（Runnable）</strong>：线程已启动且正在等待CPU分配时间片。</li><li><strong>运行（Running）</strong>：线程正在执行其任务。</li><li><strong>阻塞（Blocked）</strong>：线程因等待某个条件而暂时停止执行。</li><li><strong>等待（Waiting）</strong>：线程因调用<code>wait()</code>方法而等待其他线程唤醒。</li><li><strong>超时等待（Timed Waiting）</strong>：线程在等待某个条件的同时还设置了一个超时时间。</li><li><strong>终止（Terminated）</strong>：线程已完成任务并退出。</li></ul><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAPOaUer6dvmjBFagfhkaXqEfpl3ui4AAu0LaxunpzhWc0KL_3hfiHIBAAMCAAN5AAM2BA.png"></p><h2 id="5-线程池"><a href="#5-线程池" class="headerlink" title="5 线程池"></a>5 线程池</h2><p>为了更有效地管理线程，Java提供了线程池机制。线程池是一种用于管理和复用线程的框架，它允许开发者以较小的开销来创建和管理大量的线程。Java中的<code>ExecutorService</code>接口及其实现类（如<code>ThreadPoolExecutor</code>）提供了强大的线程池功能。<br>Java中提供了几种常见的线程池类型，包括：</p><ol><li>FixedThreadPool（固定大小线程池）：包含固定数量的线程，适用于需要限制并发线程数量的场景。</li><li>CachedThreadPool（缓存线程池）：不固定线程数量，可以根据需要自动创建新线程，适用于短期异步任务。</li><li>SingleThreadPool（单线程池）：只包含一个工作线程，保证所有任务按顺序执行，适用于需要保持任务顺序执行的场景。</li><li>ScheduledThreadPool（定时线程池）：可以执行定时任务和周期性任务。</li><li>WorkStealingPool（工作窃取线程池）：Java 8中引入的一种新类型的线程池，主要用于处理耗时任务，适用于需要大量并行任务、任务之间没有依赖关的情况。</li></ol><p>在后续的章节里面，我们会专门来详细介绍下线程池的使用</p><h2 id="6-最佳实践"><a href="#6-最佳实践" class="headerlink" title="6 最佳实践"></a>6 最佳实践</h2><ul><li><strong>避免创建过多的线程</strong>：过多的线程会导致上下文切换频繁，从而降低系统性能。</li><li><strong>合理设置线程优先级</strong>：根据任务的紧急程度和重要性来设置线程的优先级。</li><li><strong>使用线程安全的集合</strong>：在多线程环境下使用线程安全的集合来避免数据不一致的问题。</li><li><strong>避免死锁</strong>：在设计多线程程序时要特别注意避免死锁的发生。</li></ul><p>综上所述，Java线程管理是一个复杂而重要的领域。通过合理地创建、调度、同步和销毁线程，可以显著提高程序的性能、响应性和稳定性。同时，开发者还需要遵循一些最佳实践来避免常见的问题和陷阱。</p>]]></content>
      
      
      <categories>
          
          <category> Java核心系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java核心 </tag>
            
            <tag> Java基础 </tag>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java核心系列5：反射机制详解</title>
      <link href="/2025/04/02/Java%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/Java%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%865-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
      <url>/2025/04/02/Java%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/Java%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%865-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h1><p>无论是那种语言体系，反射都是必不可少的一个技术特征。从Java体系来说，很多常用的技术框架或多或少都使用到了反射技术，比如Spring、MyBatis、RocketMQ、FastJson 等等。反射技术强大而必要，在大多数框架中起到举足轻重的作用。所以，反射也是Java必不可少的核心技术之一。</p><p>接下来我们来看看反射的一些技术要点：</p><ol><li>反射的概念（即什么是反射）？</li><li>反射的作用（它帮我们解决了哪些问题）？</li><li>反射的实现原理？</li><li>如何使用反射？<br>下面我就针对以上的疑问，一一来讲解。</li></ol><h2 id="1-1-反射是什么？"><a href="#1-1-反射是什么？" class="headerlink" title="1.1 反射是什么？"></a>1.1 反射是什么？</h2><p>Java反射（Reflection）是Java语言的一个核心特性，它允许运行中的Java代码对自身进行自我检查，甚至修改自身的组件。具体来说，反射机制提供了在运行状态中，对于任意一个类，都能够了解这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。这种动态获取的信息以及动态调用对象的方法在Java中就叫做反射。</p><p>一句话总结：反射就是在运行时才具体知晓要操作的类是什么结构，并在运行时获取类的完整构造，并调用对应的方法、属性等。</p><p>Java的反射主要包括以下三个部分：</p><ul><li>类的加载：Java的类在需要使用时才会被加载到JVM中。这个过程是由类加载器（ClassLoader）完成的。类加载器首先检查这个类是否已经被加载过，如果还没有加载，那么就会从磁盘上加载类的字节码并创建一个Class对象。</li><li>获取类的信息：当一个对象被创建后，我们可以使用反射来获取这个对象的Class对象。通过这个Class对象，我们可以获取到这个类的所有属性和方法。</li><li>方法的调用：通过反射，我们可以动态的调用一个对象的方法。即使这个方法是一个私有的方法，也能够通过反射来调用。</li></ul><h2 id="1-2-为什么要用反射？"><a href="#1-2-为什么要用反射？" class="headerlink" title="1.2 为什么要用反射？"></a>1.2 为什么要用反射？</h2><p>Java Reflection功能非常强大，并且非常有用，比如：</p><ul><li>获取任意类的名称、package信息、所有属性、方法、注解、类型、类加载器等</li><li>获取任意对象的属性，并且能改变对象的属性</li><li>调用任意对象的方法</li><li>判断任意一个对象所属的类</li><li>实例化任意一个类的对象</li><li>通过反射我们可以实现动态装配，降低代码的耦合度，实现动态代理等。</li></ul><p>具体的应用场景：</p><ul><li>框架设计：许多框架，如Spring，Hibernate等，都大量使用了反射来实现对象的自动装配，动态代理等功能。</li><li>单元测试：单元测试框架（如JUnit）会使用反射来调用被注解的方法。</li><li>插件化：为了实现插件化，可以通过反射加载不同的插件。</li><li>对象序列化与反序列化：在对象进行序列化和反序列化的时候，会使用反射获取到对象的所有属性和方法。</li></ul><h1 id="2-反射的使用"><a href="#2-反射的使用" class="headerlink" title="2 反射的使用"></a>2 反射的使用</h1><p>在Java中，Class类与java.lang.reflect类库配合对反射技术进行了完整的支持。在反射的Package中，我们经常使用功能类如下：</p><ul><li>Constructor类表示的是Class 对象所表示的类的构造方法，利用它可以在运行时动态创建对象</li><li>Field类表示Class对象所表示的类的成员变量，通过它可以在运行时动态修改成员变量的属性值(包含private)</li><li>Method类表示Class对象所表示的类的成员方法，通过它可以动态调用对象的方法(包含private)</li></ul><p>下面将对这几个类进行详细介绍。</p><h2 id="2-1-反射创建类对象"><a href="#2-1-反射创建类对象" class="headerlink" title="2.1 反射创建类对象"></a>2.1 反射创建类对象</h2><p>一般情况下我们通过反射创建类对象主要有两种方式：</p><ul><li>通过 Class 对象的 newInstance() 方法</li><li>通过 Constructor 对象的 newInstance() 方法</li><li>通过 Class 对象的 newInstance() 方法实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.ad.reflection.TestRefle&quot;</span>);</span><br><span class="line">TestRefle tr= (TestRefle)clz.newInstance();</span><br></pre></td></tr></table></figure><ul><li>通过 Constructor 对象的 newInstance() 方法实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.ad.reflection.TestRefle&quot;</span>);</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clz.getConstructor();</span><br><span class="line">TestRefle tr= (TestRefle)constructor.newInstance();</span><br></pre></td></tr></table></figure><p>这边需要注意，通过 Constructor 对象创建类对象可以选择特定构造方法，而通过 Class 对象则只能使用默认的无参数构造方法。</p><p>下面的代码演示的是通过 Constructor 调用有参构造方法进行了类对象初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.ad.reflection.TestRefle&quot;</span>);</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clz.getConstructor(String.class);</span><br><span class="line">TestRefle tr= (TestRefle)constructor.newInstance(<span class="string">&quot;提供一个String参数&quot;</span>);</span><br></pre></td></tr></table></figure><p>接下来我们继续，通过具体的API获取详细的类信息：类信息、方法信息、属性信息等。</p><h2 id="2-2-获取Class类对象"><a href="#2-2-获取Class类对象" class="headerlink" title="2.2 获取Class类对象"></a>2.2 获取Class类对象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取Class对象的三种方式</span></span><br><span class="line">根据类名: <span class="type">Class</span> <span class="variable">mailClass</span> <span class="operator">=</span> MailInfo.class;</span><br><span class="line">根据对象: <span class="type">Class</span> <span class="variable">mailClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MailInfo</span>().getClass();</span><br><span class="line">根据全限定类名: <span class="type">Class</span> <span class="variable">mailClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.ad.MailInfo&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据对象获取信息和实例对象</span></span><br><span class="line">获取全限定类名: mailClass.getName();</span><br><span class="line">获取类名: mailClass.getSimpleName();</span><br><span class="line">实例化: userClass.getDeclaredConstructor().newInstance();</span><br></pre></td></tr></table></figure><p>更加详细Class类获取参考如下：</p><table><thead><tr><th>方法</th><th>用途</th></tr></thead><tbody><tr><td>forName()</td><td>(1)获取Class对象的一个引用，但引用的类还没有加载(该类的第一个对象没有生成)就加载了这个类。 (2)为了产生Class引用，forName()立即就进行了初始化。</td></tr><tr><td>Object-getClass()</td><td>获取Class对象的一个引用，返回表示该对象的实际类型的Class引用。</td></tr><tr><td>getName()</td><td>取全限定的类名(包括包名)，即类的完整名字。 getSimpleName() 获取类名(不包括包名)</td></tr><tr><td>getCanonicalName()</td><td>获取全限定的类名(包括包名)</td></tr><tr><td>isInterface()</td><td>判断Class对象是否是表示一个接口</td></tr><tr><td>getInterfaces()</td><td>返回Class对象数组，表示Class对象所引用的类所实现的所有接口。</td></tr><tr><td>getSupercalss()</td><td>返回Class对象，表示Class对象所引用的类所继承的直接基类。应用该方法可在运行时发现一个对象完整的继承结构。</td></tr><tr><td>newInstance()</td><td>返回一个Oject对象，是实现“虚拟构造器”的一种途径。使用该方法创建的类，必须带有无参的构造器。</td></tr></tbody></table><h2 id="2-3-获取类的成员变量的信息"><a href="#2-3-获取类的成员变量的信息" class="headerlink" title="2.3 获取类的成员变量的信息"></a>2.3 获取类的成员变量的信息</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Field[] fields = _class.getDeclaredFields();</span><br></pre></td></tr></table></figure><p>更加详细成员变量获取参考如下：</p><table><thead><tr><th>方法</th><th>用途</th></tr></thead><tbody><tr><td>getField(String name)</td><td>获得某个公有的属性对象</td></tr><tr><td>getFields()</td><td>获取所有的公有的属性对象</td></tr><tr><td>getDeclaredField(String name)</td><td>获得某个属性对象（public和非public）</td></tr><tr><td>getDeclaredFields()</td><td>获得所有属性对象（public和非public）</td></tr></tbody></table><h2 id="2-4-获得类方法"><a href="#2-4-获得类方法" class="headerlink" title="2.4 获得类方法"></a>2.4 获得类方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Method[] methods = _class.getDeclaredMethods();</span><br></pre></td></tr></table></figure><p>更加详细方法获取参考如下：</p><table><thead><tr><th>方法</th><th>用途</th></tr></thead><tbody><tr><td>getMethod(String name, Class…&lt;?&gt; paramerterTypes)</td><td>获得某个公有的方法对象</td></tr><tr><td>getMethods()</td><td>获取所有的公有的方法对象</td></tr><tr><td>getDeclaredMethod(String name, Class…&lt;?&gt; paramerterTypes)</td><td>获得对应类下某个方法（public和非public）</td></tr><tr><td>getDeclaredMethods()</td><td>获得对应类下所有方法（public和非public）</td></tr></tbody></table><h2 id="2-5-获得构造函数"><a href="#2-5-获得构造函数" class="headerlink" title="2.5 获得构造函数"></a>2.5 获得构造函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Constructor[] constructors = _class.getDeclaredConstructors();</span><br></pre></td></tr></table></figure><p>更加详细构造函数获取参考如下：</p><table><thead><tr><th>方法</th><th>用途</th></tr></thead><tbody><tr><td>getConstructor(Class…&lt;?&gt; paramerterTypes)</td><td>获得该类中与参数类型匹配的公有构造方法</td></tr><tr><td>getConstructors()</td><td>获取该类的所有公有构造方法</td></tr><tr><td>getDeclaredConstructor(Class…&lt;?&gt; paramerterTypes)</td><td>获得该类中与参数类型匹配的构造方法</td></tr><tr><td>getDeclaredConstructors()</td><td>获取该类的所有构造方法</td></tr></tbody></table><p>这样通过反射就可以做在运行时获取类的完整构造，并获得类信息了。</p><table><thead><tr><th>类名</th><th>用途</th></tr></thead><tbody><tr><td>Class类</td><td>代表类的实体，在运行的Java应用程序中表示类和接口</td></tr><tr><td>Field类</td><td>代表类的成员变量（即类的属性）</td></tr><tr><td>Method类</td><td>代表类的方法</td></tr><tr><td>Constructor类</td><td>代表类的构造函数</td></tr></tbody></table><p>通过上面的几个示例我们基本了解了反射的使用，但这仅仅是使用，我们还需深入理解反射背后的底层实现原理。</p><h1 id="3-反射原理分析"><a href="#3-反射原理分析" class="headerlink" title="3 反射原理分析"></a>3 反射原理分析</h1><h2 id="3-1-反射的调用流程"><a href="#3-1-反射的调用流程" class="headerlink" title="3.1 反射的调用流程"></a>3.1 反射的调用流程</h2><p>1、编写完Java项目之后，java文件都会被编译成一个.class文件</p><p>2、这些class文件在程序运行时会被ClassLoader加载到JVM中，当一个类被加载以后，JVM就会在内存中自动产生一个Class对象。</p><p>3、通过Class对象获取 Field（属性）、Method（方法）、Construcor（构造函数）</p><p>我们平时通过new的形式创建对象，本质上就是通过Class来创建个新对象<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAPAaUehAAF9R3HKiOn5QC9oh0Sgm434AAK8C2sbp6c4VmhFq0MC4Pb2AQADAgADdwADNgQ.png"><br>通过上面的流程我们可以看出反射的优势：</p><ul><li><strong>动态装配</strong></li></ul><p>我们的程序在运行时，可能不一定会用到所有我们编写和构建的类，这样避免启动时间太长并且浪费大量无用的机器资源。<br>取而代之的是动态的加载一些类，这些类可能之前用不到所以不用加载到jvm，而是在运行时根据需要才加载。</p><ul><li><strong>降低耦合</strong></li></ul><p>如果你在使用new时明确的指定类名，那这就是典型的硬编码实现，而在使用反射的时候，可以只传入类名参数，就可以生成对象，降低了耦合度，使得程序更具灵性。</p><p>完整的调用流程，图片来自网上，比较模糊，后续再补一个<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAO_aUegrA7OJrzaigLEU5oJUlJhjf8AArsLaxunpzhWp76Dja8gOcUBAAMCAAN3AAM2BA.png" alt="反射调用整体流程">ttps:&#x2F;&#x2F;img2022.cnblogs.com&#x2F;blog&#x2F;167509&#x2F;202203&#x2F;167509-20220326110641303-1256637401.png)</p><h2 id="3-2-反射的应用场景"><a href="#3-2-反射的应用场景" class="headerlink" title="3.2 反射的应用场景"></a>3.2 反射的应用场景</h2><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAO-aUeggAq1cBsBeU0CUigwhcOh9VQAAroLaxunpzhWjoQDizWii1oBAAMCAAN4AAM2BA.png" alt="反射的应用场景"></p><ul><li>框架设计：许多框架，如Spring，Hibernate，mybatis，dubbo，rocketmq等，都大量使用了反射来实现对象的自动装配，动态代理等功能。</li><li>单元测试：单元测试框架（如JUnit）会使用反射来调用被注解的方法。</li><li>插件化：为了实现插件化，可以通过反射加载不同的插件。</li><li>对象序列化与反序列化：在对象进行序列化和反序列化的时候，会使用反射获取到对象的所有属性和方法。</li><li>动态配置、动态代理：通过反射去读取配置，以及代理请求</li></ul><h1 id="4-反射经典案例解析"><a href="#4-反射经典案例解析" class="headerlink" title="4 反射经典案例解析"></a>4 反射经典案例解析</h1><p>以下案例来自百度文心一言大模型自动生成，已调试通过。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectionExample</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="comment">// 获取目标类的Class对象  </span></span><br><span class="line">            Class&lt;?&gt; targetClass = Class.forName(<span class="string">&quot;java.util.ArrayList&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 获取目标类的所有公共方法  </span></span><br><span class="line">            Method[] methods = targetClass.getMethods();  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 遍历所有方法并打印方法名  </span></span><br><span class="line">            <span class="keyword">for</span> (Method method : methods) &#123;  </span><br><span class="line">                System.out.println(method.getName());  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 获取特定方法，比如添加元素的add方法  </span></span><br><span class="line">            <span class="type">Method</span> <span class="variable">addMethod</span> <span class="operator">=</span> targetClass.getMethod(<span class="string">&quot;add&quot;</span>, Object.class);  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 创建目标类的实例对象  </span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">targetObject</span> <span class="operator">=</span> targetClass.newInstance();  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 调用add方法添加元素  </span></span><br><span class="line">            addMethod.invoke(targetObject, <span class="string">&quot;Hello, World!&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 获取目标类的所有属性（字段）并打印属性名  </span></span><br><span class="line">            Field[] fields = targetClass.getDeclaredFields();  </span><br><span class="line">            <span class="keyword">for</span> (Field field : fields) &#123;  </span><br><span class="line">                System.out.println(field.getName());  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个案例展示了如何使用反射来获取目标类的Class对象，获取并打印目标类的所有公共方法，获取特定方法，创建目标类的实例对象，调用目标类的方法，以及获取并打印目标类的所有属性（字段）。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>无论是那种语言体系（C#、Java等等），反射都是必不可少的一个技术特征。而从Java体系来说，很多常用的技术框架或多或少都使用到了反射技术，比如Spring、MyBatis、RocketMQ、FastJson 等等。</p><p>学习好Java反射技术能帮助你更好的理解底层调用的原理，也有助于设计更加轻巧、高内聚、低耦合的业务框架。</p>]]></content>
      
      
      <categories>
          
          <category> Java核心系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java核心 </tag>
            
            <tag> Java基础 </tag>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java核心系列6：集合框架详解</title>
      <link href="/2025/04/02/Java%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/Java%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%866-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
      <url>/2025/04/02/Java%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/Java%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%866-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="1-集合框架图总览"><a href="#1-集合框架图总览" class="headerlink" title="1 集合框架图总览"></a>1 集合框架图总览</h1><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAPFaUek1AeB4_p1r3pvUbac0epF6w0AAsULaxunpzhWejH-1zwrEC4BAAMCAAN4AAM2BA.png" alt="Java集合框架图"><br>我们来简单解读下上面这个框架图：</p><ul><li>所有集合类都位于java.util包下</li><li>Iterator是遍历集合的工具，我们经常通过Iterator迭代器来遍历集合。我们说Collection依赖于Iterator，是因为Collection的实现类都要实现iterator()函数，返回一个Iterator对象。ListIterator主要作用就是遍历List。</li><li>Java的集合类主要由两个接口派生而出：Collection和Map，作为Java集合框架的根接口，这两个接口包含了一些子接口和实现类。</li><li>集合接口：即图中的 LinkIterator、List、Set、Queue、SortedMap、SortedMap 6个接口（即短虚线框部分），表示不同集合类型，是集合框架的基础。</li><li>抽象类：即图中的 AbstractCollection、AbstractList、AbstractSet、AbstractMap、AbstractSequentialList 5个抽象类（长虚线框部分），抽象类只是对集合接口的部分实现，有需要的话可以继续扩展，完善自定义集合类。</li><li>实现类：即图片中LinkHashMap、TreeMap等8个实现类（实线框部分），主要是对接口的具体实现。</li><li>Collection 接口包含一组允许重复的对象</li><li>Set 接口继承 Collection，但是集合内的元素不重复。Set的实现类有HastSet和TreeSet。HashSet依赖于HashMap，它实际上是通过HashMap实现的；TreeSet依赖于TreeMap，它实际上是通过TreeMap实现的。</li><li>List 接口继承 Collection，集合内元素允许重复，但维护了元素的插入顺序，所以是个有序队列。每一个元素都有它的索引。第一个元素的索引值是0。List的实现类有LinkedList, ArrayList, Vector, Stack。</li><li>Map接口是键－值对象顶层接口，下面还包含了一些子接口和实现类。AbstractMap是个抽象类，它实现了Map接口中的大部分API。而HashMap，TreeMap，WeakHashMap都是继承于AbstractMap。Hashtable虽然继承于Dictionary，但它实现了Map接口。</li><li>Set、List和Map是集合的三大类：<ul><li>List：有序集合，集合中元素可重复，访问元素可以根据元素索引访问。</li><li>Set：无序集合，集合中元素不可以重复，访问集合中的元素只能根据元素自身信息来访问（因此元素不允许重复）。</li><li>Map：Key-value模式的键值对元素，访问时根据元素key来读取对应的value。</li></ul></li><li>Arrays和Collections是操作数组、集合的两个工具类。</li></ul><p>完成对上面框架的整体介绍之后，我们接着对每个类别进行详细的分析。</p><h1 id="2-Collection接口"><a href="#2-Collection接口" class="headerlink" title="2 Collection接口"></a>2 Collection接口</h1><p>Collection接口是处理对象集合的根接口，其中定义了很多对元素进行操作的方法。Collection接口有两个主要的子接口List和Set，注意Map不是Collection的子接口，这个要牢记。<br>Collection接口中的方法如下:<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAPEaUekrkV4riOG17In-S6vi6FMOfwAAsQLaxunpzhWNj0R50W5FRgBAAMCAAN5AAM2BA.png" alt="Collection接口中的方法"><br>其中，有几个比较常用的方法，比如方法add()添加一个元素到集合中，addAll()将指定集合中的所有元素添加到集合中，contains()方法检测集合中是否包含指定的元素，toArray()方法返回一个表示集合的数组。</p><p>另外，Collection中有一个iterator()函数，它的作用是返回一个Iterator接口。通常，我们通过Iterator迭代器来遍历集合。ListIterator是List接口所特有的，在List接口中，通过ListIterator()返回一个ListIterator对象。</p><p>Collection接口有两个常用的子接口，下面会详细介绍。</p><h2 id="2-1-List接口"><a href="#2-1-List接口" class="headerlink" title="2.1 List接口"></a>2.1 List接口</h2><p>List集合代表一个有序集合，集合中每个元素都有其对应的顺序索引。List集合允许使用重复元素，可以通过索引来访问指定位置的集合元素。</p><p>List接口继承于Collection接口，它可以定义一个允许重复的有序集合。因为List中的元素是有序的，所以我们可以通过使用索引（元素在List中的位置，类似于数组下标）来访问List中的元素，这类似于Java的数组。</p><p>List接口为Collection直接接口。List所代表的是有序的Collection，即它用某种特定的插入顺序来维护元素顺序。用户可以对列表中每个元素的插入位置进行精确地控制，同时可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。实现List接口的集合主要有：ArrayList、LinkedList、Vector、Stack。</p><h3 id="2-1-1-ArrayList"><a href="#2-1-1-ArrayList" class="headerlink" title="2.1.1 ArrayList"></a>2.1.1 ArrayList</h3><p>ArrayList是一个动态数组，也是我们最常用的集合。它允许任何符合规则的元素插入甚至包括null。每一个ArrayList都有一个初始容量（10），该容量代表了数组的大小。随着容器中的元素不断增加，容器的大小也会随着增加。在每次向容器中增加元素的同时都会进行容量检查，当快溢出时，就会进行扩容操作。所以如果我们明确所插入元素的多少，最好指定一个初始容量值，避免过多的进行扩容操作而浪费时间、效率。</p><p>size、isEmpty、get、set、iterator 和 listIterator 操作都以固定时间运行。add 操作以分摊的固定时间运行，也就是说，添加 n 个元素需要 O(n) 时间（由于要考虑到扩容，所以这不只是添加元素会带来分摊固定时间开销那样简单）。</p><p>ArrayList擅长于随机访问。同时ArrayList是非同步的。</p><h3 id="2-1-2-LinkedList"><a href="#2-1-2-LinkedList" class="headerlink" title="2.1.2 LinkedList"></a>2.1.2 LinkedList</h3><p>同样实现List接口的LinkedList与ArrayList不同，ArrayList是一个动态数组，而LinkedList是一个双向链表。所以它除了有ArrayList的基本操作方法外还额外提供了get，remove，insert方法在LinkedList的首部或尾部。</p><p>由于实现的方式不同，LinkedList不能随机访问，它所有的操作都是要按照双重链表的需要执行。在列表中索引的操作将从开头或结尾遍历列表（从靠近指定索引的一端）。这样做的好处就是可以通过较低的代价在List中进行插入和删除操作。</p><p>与ArrayList一样，LinkedList也是非同步的。如果多个线程同时访问一个List，则必须自己实现访问同步。一种解决方法是在创建List时构造一个同步的List:</p><p>List list &#x3D; Collections.synchronizedList(new LinkedList(…));</p><h3 id="2-1-3-Vector"><a href="#2-1-3-Vector" class="headerlink" title="2.1.3 Vector"></a>2.1.3 Vector</h3><p>与ArrayList相似，但是Vector是同步的。所以说Vector是线程安全的动态数组。它的操作与ArrayList几乎一样。<br>的</p><h3 id="2-1-4-Stack"><a href="#2-1-4-Stack" class="headerlink" title="2.1.4 Stack"></a>2.1.4 Stack</h3><p>Stack继承自Vector，实现一个后进先出的堆栈。Stack提供5个额外的方法使得Vector得以被当作堆栈使用。基本的push和pop 方法，还有peek方法得到栈顶的元素，empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置。Stack刚创建后是空栈。<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAPDaUekeRSEZ24DUKcqW8MitpUC3zAAAsELaxunpzhWfxhQQkaAvQsBAAMCAAN5AAM2BA.png" alt="List集合"></p><h2 id="2-2-Set接口"><a href="#2-2-Set接口" class="headerlink" title="2.2 Set接口"></a>2.2 Set接口</h2><p>Set是一种不包括重复元素的Collection。它维持它自己的内部排序，所以随机访问没有任何意义。与List一样，它同样允许null的存在但是仅有一个。由于Set接口的特殊性，所有传入Set集合中的元素都必须不同，同时要注意任何可变对象，如果在对集合中元素进行操作时，导致element1.equals(element2)为true，则必定会产生数据冲突的问题。Set接口有三个具体实现类，分别是：</p><ul><li>散列集HashSet</li><li>链式散列集LinkedHashSet</li><li>树形集TreeSet</li></ul><p>Set是一种不包含重复的元素的Collection，无序，即任意的两个元素element1和element2都有element1.equals(element2)为false，Set最多可以有一个null元素。需要注意的是，虽然Set中元素没有顺序性，但是元素在set中的位置是由该元素的HashCode决定的，所以具体的位置其实是固定的。</p><p>此外需要说明一点，在set接口中的不重复是有特殊要求的。</p><p>举一个例子:对象A和对象B，本来是不同的两个对象，正常情况下它们是能够放入到Set里面的，但是如果对象A和B的都重写了hashcode和equals方法，并且重写后的hashcode和equals方法是相同的话。那么A和B是不能同时放入到Set集合中去的，也就是Set集合中的去重和hashcode与equals方法直接相关。</p><p>为了更好地理解，请看下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setWork</span><span class="params">()</span> &#123;</span><br><span class="line">       Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">       set.add(<span class="string">&quot;Brand1&quot;</span>);</span><br><span class="line">       set.add(<span class="string">&quot;Brand2&quot;</span>);</span><br><span class="line">       set.add(<span class="string">&quot;Brand1&quot;</span>);</span><br><span class="line">       System.out.println(<span class="string">&quot;Set Size:&quot;</span> + set.size());</span><br><span class="line">       System.out.println(<span class="string">&quot;Set Elements:&quot;</span> + set.toString());</span><br><span class="line"></span><br><span class="line"><span class="comment">//再次添加一个字符串对象 Brand2，然后通过equals方法比较，发现是相等的，所以添加失败返回false</span></span><br><span class="line">       <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> set.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Brand2&quot;</span>));</span><br><span class="line">       System.out.println(result);</span><br><span class="line">       System.out.println(set);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>执行结果：<br>Set Size:2<br>Set Elements:[Brand1, Brand2]<br>false<br>[Brand1, Brand2]<br>可以看出，因为有hashcode和equals方法，用来比较指向的字符串对象所存储的字符串是否相等，所以第二个Brand1加进去是无效的。</p><p>程序通过new关键字来创建新的字符串对象Brand2，使用&#x3D;&#x3D;运算符判断返回false，使用equals方法比较返回true，所以同样不能添加到Set集合中，最终还是两个元素。</p><h3 id="2-2-1-HashSet"><a href="#2-2-1-HashSet" class="headerlink" title="2.2.1 HashSet"></a>2.2.1 HashSet</h3><p>HashSet 是一个没有重复元素的集合。它是由HashMap实现的，不保证元素的顺序(这里所说的没有顺序是指：元素插入的顺序与输出的顺序不一致)，而且HashSet允许使用null 元素。HashSet是非同步的，如果多个线程同时访问一个哈希set，而其中至少一个线程修改了该set，那么它必须保持外部同步。 HashSet按Hash算法来存储集合的元素，因此具有很好的存取和查找性能。</p><p>HashSet的实现方式大致如下，通过一个HashMap存储元素，元素是存放在HashMap的Key中，而Value统一使用一个Object对象。</p><p>HashSet使用和理解中容易出现的误区:</p><ul><li>HashSet中存放null值<br>HashSet中是允许存入null值的，但是在HashSet中仅仅能够存入一个null值。</li><li>HashSet中存储元素的位置是固定的<br>HashSet中存储的元素的是无序的，这个没什么好说的，但是由于HashSet底层是基于Hash算法实现的，使用了hashcode，所以HashSet中相应的元素的位置是固定的。</li><li>必须小心操作可变对象（Mutable Object）。<br>如果一个Set中的可变元素改变了自身状态导致Object.equals(Object)&#x3D;true将导致一些问题。</li></ul><h3 id="2-2-2-LinkedHashSet"><a href="#2-2-2-LinkedHashSet" class="headerlink" title="2.2.2 LinkedHashSet"></a>2.2.2 LinkedHashSet</h3><p>LinkedHashSet继承自HashSet，其底层是基于LinkedHashMap来实现的，有序，非同步。LinkedHashSet集合同样是根据元素的hashCode值来决定元素的存储位置，但是它同时使用链表维护元素的次序。这样使得元素看起来像是以插入顺序保存的，也就是说，当遍历该集合时候，LinkedHashSet将会以元素的添加顺序访问集合的元素。</p><h3 id="2-2-3-TreeSet"><a href="#2-2-3-TreeSet" class="headerlink" title="2.2.3 TreeSet"></a>2.2.3 TreeSet</h3><p>TreeSet是一个有序集合，其底层是基于TreeMap实现的，非线程安全。TreeSet可以确保集合元素处于排序状态。TreeSet支持两种排序方式，自然排序和定制排序，其中自然排序为默认的排序方式。当我们构造TreeSet时，若使用不带参数的构造函数，则TreeSet的使用自然比较器；若用户需要使用自定义的比较器，则需要使用带比较器的参数。</p><p>注意：TreeSet集合不是通过hashcode和equals函数来比较元素的.它是通过compare或者comparaeTo函数来判断元素是否相等.compare函数通过判断两个对象的id，相同的id判断为重复元素，不会被加入到集合中。</p><h1 id="3-Map接口"><a href="#3-Map接口" class="headerlink" title="3 Map接口"></a>3 Map接口</h1><p>Map与List、Set接口不同，它是由一系列键值对组成的集合，提供了key到Value的映射。同时它也没有继承Collection。在Map中它保证了key与value之间的一一对应关系。也就是说一个key对应一个value，所以它不能存在相同的key值，当然value值可以相同。</p><h2 id="3-1-HashMap"><a href="#3-1-HashMap" class="headerlink" title="3.1 HashMap"></a>3.1 HashMap</h2><p>以哈希表数据结构实现，查找对象时通过哈希函数计算其位置，它是为快速查询而设计的，其内部定义了一个hash表数组（Entry[] table），元素会通过哈希转换函数将元素的哈希地址转换成数组中存放的索引，如果有冲突，则使用散列链表的形式将所有相同哈希地址的元素串起来，可能通过查看HashMap.Entry的源码它是一个单链表结构。</p><h2 id="3-2-LinkedHashMap"><a href="#3-2-LinkedHashMap" class="headerlink" title="3.2 LinkedHashMap"></a>3.2 LinkedHashMap</h2><p>LinkedHashMap是HashMap的一个子类，它保留插入的顺序，如果需要输出的顺序和输入时的相同，那么就选用LinkedHashMap。</p><p>LinkedHashMap是Map接口的哈希表和链接列表实现，具有可预知的迭代顺序。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。<br>LinkedHashMap实现与HashMap的不同之处在于，后者维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，该迭代顺序可以是插入顺序或者是访问顺序。</p><p>根据链表中元素的顺序可以分为：按插入顺序的链表，和按访问顺序(调用get方法)的链表。默认是按插入顺序排序，如果指定按访问顺序排序，那么调用get方法后，会将这次访问的元素移至链表尾部，不断访问可以形成按访问顺序排序的链表。<br>注意，此实现不是同步的。如果多个线程同时访问链接的哈希映射，而其中至少一个线程从结构上修改了该映射，则它必须保持外部同步。</p><p>由于LinkedHashMap需要维护元素的插入顺序，因此性能略低于HashMap的性能，但在迭代访问Map里的全部元素时将有很好的性能，因为它以链表来维护内部顺序。</p><h2 id="3-3-TreeMap"><a href="#3-3-TreeMap" class="headerlink" title="3.3 TreeMap"></a>3.3 TreeMap</h2><p>TreeMap 是一个有序的key-value集合，非同步，基于红黑树（Red-Black tree）实现，每一个key-value节点作为红黑树的一个节点。TreeMap存储时会进行排序的，会根据key来对key-value键值对进行排序，其中排序方式也是分为两种，一种是自然排序，一种是定制排序，具体取决于使用的构造方法。</p><p>自然排序：TreeMap中所有的key必须实现Comparable接口，并且所有的key都应该是同一个类的对象，否则会报ClassCastException异常。</p><p>定制排序：定义TreeMap时，创建一个comparator对象，该对象对所有的treeMap中所有的key值进行排序，采用定制排序的时候不需要TreeMap中所有的key必须实现Comparable接口。</p><p>TreeMap判断两个元素相等的标准：两个key通过compareTo()方法返回0，则认为这两个key相等。</p><p>如果使用自定义的类来作为TreeMap中的key值，且想让TreeMap能够良好的工作，则必须重写自定义类中的equals()方法，TreeMap中判断相等的标准是：两个key通过equals()方法返回为true，并且通过compareTo()方法比较应该返回为0。<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAPCaUejy88_1sBCEpcW5-r6wslnfV4AAsALaxunpzhWzPj4F5SrGPQBAAMCAAN4AAM2BA.png" alt="Map集合"></p><h1 id="4-Iterator-与-ListIterator详解"><a href="#4-Iterator-与-ListIterator详解" class="headerlink" title="4 Iterator 与 ListIterator详解"></a>4 Iterator 与 ListIterator详解</h1><h2 id="4-1-Iterator"><a href="#4-1-Iterator" class="headerlink" title="4.1 Iterator"></a>4.1 Iterator</h2><p>Iterator的定义如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><p>Java的Iterator（迭代器）是一个设计模式，它使你可以遍历一个容器（如列表，集合，队列等）。它提供了一种方法来顺序访问聚合对象的元素，而不需要暴露该对象的内部表示。</p><p>Iterator提供的API接口如下：</p><ul><li>boolean hasNext()：判断集合里是否存在下一个元素。如果有，hasNext()方法返回 true。</li><li>Object next()：返回集合里下一个元素。</li><li>void remove()：删除集合里上一次next方法返回的元素。<br>参考如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;  </span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">         <span class="comment">// 创建一个ArrayList对象</span></span><br><span class="line">            List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            list.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">            list.add(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">            list.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取该ArrayList的迭代器</span></span><br><span class="line">            Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用迭代器遍历列表中的元素</span></span><br><span class="line">            <span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">element</span> <span class="operator">=</span> it.next();</span><br><span class="line">                System.out.println(element);</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;Java&quot;</span>.equals(element)) &#123;</span><br><span class="line">                    it.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 移除之后的ArrayList对象</span></span><br><span class="line">            System.out.println(<span class="string">&quot;after remove element 「java」: &quot;</span> + list);</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Hello</span><br><span class="line">World</span><br><span class="line">Java</span><br><span class="line">remove java element : [Hello, World]</span><br></pre></td></tr></table></figure><p>需要注意的点如下：</p><ul><li>Iterator只能单向移动。</li><li>Iterator.remove()是唯一安全在迭代过程中修改集合；如果在迭代过程中以任何其它的方式修改了基本集合将会产生未知的行为。而且每调用一次next()方法，remove()方法只能被调用一次，如果违反这个规则将抛出一个异常，因为可能导致数据异常。</li></ul><h2 id="4-2-ListIterator"><a href="#4-2-ListIterator" class="headerlink" title="4.2 ListIterator"></a>4.2 ListIterator</h2><p>ListIterator是一个功能更加强大的迭代器, 它继承于Iterator接口,只能用于各种List类型的访问。它提供了在列表中插入和删除元素的方法，以及使用hasPrevious()和previous()方法在迭代过程中向前和向后遍历列表的功能。<br>以下是ListIterator的主要方法：</p><ul><li>boolean hasNext(): 返回true如果迭代器有下一个元素。</li><li>Object next(): 返回迭代器的下一个元素并将指针移到下一个元素。</li><li>boolean hasPrevious(): 返回true如果迭代器有前一个元素。</li><li>Object previous(): 返回迭代器的前一个元素并将指针移到前一个元素。</li><li>int nextIndex(): 返回迭代器下一次要访问的元素的索引。</li><li>int previousIndex(): 返回迭代器上一次访问的元素的索引。</li><li>void remove(): 从列表中删除迭代器最后一次返回的元素。</li><li>void add(Object o): 在迭代器指向的位置插入指定的元素。</li><li>void set(E e): 从列表中替换迭代器最后一次返回的元素。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ListIterator</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>; </span><br><span class="line">    E <span class="title function_">next</span><span class="params">()</span>; </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasPrevious</span><span class="params">()</span>; </span><br><span class="line">    E <span class="title function_">previous</span><span class="params">()</span>; </span><br><span class="line">    <span class="type">int</span> <span class="title function_">nextIndex</span><span class="params">()</span>; </span><br><span class="line">    <span class="type">int</span> <span class="title function_">previousIndex</span><span class="params">()</span>; </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span>; </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(E e)</span>; </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由以上定义我们可以推出ListIterator可以:</p><ul><li>双向移动（向前或者向后遍历）</li><li>产生相对于迭代器在列表中指向的当前位置的前一个和后一个元素的索引</li><li>可以使用set()方法替换它访问过的最后一个元素</li><li>可以使用add()方法在next()方法返回的元素之前或previous()方法返回的元素之后插入一个元素</li></ul><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">listIteratorWork</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个 ArrayList</span></span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">&quot;Element A&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;Element B&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;Element C&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;当前列表 : &quot;</span> + list);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 ListIterator 对象</span></span><br><span class="line">    ListIterator&lt;String&gt; listIterator = list.listIterator();</span><br><span class="line">    <span class="comment">// 使用 hasNext() 和 next() 方法迭代列表</span></span><br><span class="line">    System.out.println(<span class="string">&quot;逐一遍历 : &quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (listIterator.hasNext()) &#123;</span><br><span class="line">        System.out.println(listIterator.next() + <span class="string">&quot;, &quot;</span> + listIterator.previousIndex() + <span class="string">&quot;, &quot;</span> + listIterator.nextIndex());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在迭代过程中使用 add() 方法添加元素</span></span><br><span class="line">    listIterator.add(<span class="string">&quot;Element D&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;添加一个元素之后:&quot;</span> + list);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在迭代过程中使用 set() 方法进行元素修改</span></span><br><span class="line">    listIterator = list.listIterator(<span class="number">1</span>);</span><br><span class="line">    System.out.print(<span class="string">&quot;修改一个元素之后:&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (listIterator.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;Element D&quot;</span>.equals(listIterator.next())) &#123;</span><br><span class="line">            listIterator.set(<span class="string">&quot;Element replace&quot;</span>);</span><br><span class="line">        &#125;           </span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(list);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">当前列表 : [<span class="built_in">Element</span> A, <span class="built_in">Element</span> B, <span class="built_in">Element</span> C]</span><br><span class="line">逐一遍历 : </span><br><span class="line"><span class="built_in">Element</span> A, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="built_in">Element</span> B, <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="built_in">Element</span> C, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line">添加一个元素之后:[<span class="built_in">Element</span> A, <span class="built_in">Element</span> B, <span class="built_in">Element</span> C, <span class="built_in">Element</span> D]</span><br><span class="line">修改一个元素之后:[<span class="built_in">Element</span> A, <span class="built_in">Element</span> B, <span class="built_in">Element</span> C, <span class="built_in">Element</span> replace]</span><br></pre></td></tr></table></figure><h1 id="5-面试考点分析"><a href="#5-面试考点分析" class="headerlink" title="5 面试考点分析"></a>5 面试考点分析</h1><h2 id="5-1-ArrayList和LinkedList对比"><a href="#5-1-ArrayList和LinkedList对比" class="headerlink" title="5.1 ArrayList和LinkedList对比"></a>5.1 ArrayList和LinkedList对比</h2><ul><li>ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。</li><li>两者都是线程不安全，都实现了Collection接口。</li><li>数据结构：ArrayList是基于动态数组的数据结构，LinkedList是基于双向链表的数据结构。</li><li>性能：ArrayList支持随机访问，查询快，增删慢，查询的时间复杂度为O(1)，插入和删除的时间复杂度为O(n)，因为对插入和删除位置后面的元素进行移动位置，以保证内存的连续性，所以<ul><li>对于随机访问get和set，ArrayList绝对优于LinkedList，因为LinkedList要移动指针。</li><li>对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。</li></ul></li><li>内存空间占用： ArrayList的空 间浪费主要体现在在list列表的结尾会预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗 比ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）。</li></ul><h2 id="5-2-HashTable与HashMap对比"><a href="#5-2-HashTable与HashMap对比" class="headerlink" title="5.2 HashTable与HashMap对比"></a>5.2 HashTable与HashMap对比</h2><ul><li>相同点：<ul><li>都实现了Map、Cloneable、java.io.Serializable接口。</li><li>都是存储”键值对(key-value)”的散列表，而且都是采用拉链法实现的。</li></ul></li><li>不同点：<ul><li>是否安全：HashMap是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过 synchronized 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap ）</li><li>同步性：HashTable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的 。</li><li>对null值的处理：HashMap的key、value都可为null，HashTable的key、value都不可为null 。</li><li>基类不同：HashMap继承于AbstractMap，而Hashtable继承于Dictionary。</li><li>支持的遍历种类不同：HashMap只支持Iterator(迭代器)遍历。而Hashtable支持Iterator(迭代器)和Enumeration(枚举器)两种方式遍历。</li><li>操作效率：因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；</li><li>对Null key 和Null value的支持： HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛出 NullPointerException</li><li>初始容量大小和每次扩充容量大小的不同 ：<ul><li>创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。</li><li>创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小。也就是说 HashMap 总是使用2的幂作为哈希表的大小,后面会介绍到为什么是2的幂次方。</li></ul></li><li>底层数据结构： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li></ul></li></ul><h2 id="5-3-LinkedHashMap和TreeMap比较"><a href="#5-3-LinkedHashMap和TreeMap比较" class="headerlink" title="5.3 LinkedHashMap和TreeMap比较"></a>5.3 LinkedHashMap和TreeMap比较</h2><p>LinkedHashMap保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时用带参数，按照应用次数排序。在遍历的时候会比HashMap慢。</p><p>TreeMap实现SortMap接口，内部实现是红黑树。能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap时，得到的记录是排过序的。TreeMap不允许key的值为null。非同步的。</p><h2 id="5-4-HashSet、LinkedHashSet、TreeSet比较"><a href="#5-4-HashSet、LinkedHashSet、TreeSet比较" class="headerlink" title="5.4 HashSet、LinkedHashSet、TreeSet比较"></a>5.4 HashSet、LinkedHashSet、TreeSet比较</h2><h3 id="5-4-1-Set接口"><a href="#5-4-1-Set接口" class="headerlink" title="5.4.1 Set接口"></a>5.4.1 Set接口</h3><p>Set不允许包含相同的元素，如果试图把两个相同元素加入同一个集合中，add方法返回false。</p><p>Set判断两个对象相同不是使用&#x3D;&#x3D;运算符，而是根据equals方法。也就是说，只要两个对象用equals方法比较返回true，Set就不会接受这两个对象。</p><h3 id="5-4-2-HashSet"><a href="#5-4-2-HashSet" class="headerlink" title="5.4.2 HashSet"></a>5.4.2 HashSet</h3><p>HashSet有以下特点：</p><ul><li>不能保证元素的排列顺序，顺序有可能发生变化。</li><li>不是同步的。</li><li>集合元素可以是null，但只能放入一个null。<br>HashSet集合判断两个元素相等的标准是两个对象通过equals方法比较相等，并且两个对象的hashCode()方法返回值也相等。</li></ul><h3 id="5-4-3-LinkedHashSet"><a href="#5-4-3-LinkedHashSet" class="headerlink" title="5.4.3 LinkedHashSet"></a>5.4.3 LinkedHashSet</h3><p>LinkedHashSet集合同样是根据元素的hashCode值来决定元素的存储位置，但是它同时使用链表维护元素的次序。这样使得元素看起来像是以插入顺序保存的，也就是说，当遍历该集合时候，LinkedHashSet将会以元素的添加顺序访问集合的元素。LinkedHashSet在迭代访问Set中的全部元素时，性能比HashSet好，但是插入时性能稍微逊色于HashSet。</p><h3 id="5-4-4-TreeSet类"><a href="#5-4-4-TreeSet类" class="headerlink" title="5.4.4 TreeSet类"></a>5.4.4 TreeSet类</h3><p>TreeSet是SortedSet接口的唯一实现类，TreeSet可以确保集合元素处于排序状态。TreeSet支持两种排序方式，自然排序和定制排序，其中自然排序为默认的排序方式。向TreeSet中加入的应该是同一个类的对象。</p><p>TreeSet判断两个对象不相等的方式是两个对象通过equals方法返回false，或者通过CompareTo方法比较没有返回0。</p><h2 id="5-5-Iterator和ListIterator区别"><a href="#5-5-Iterator和ListIterator区别" class="headerlink" title="5.5 Iterator和ListIterator区别"></a>5.5 Iterator和ListIterator区别</h2><ul><li>ListIterator有add()方法，可以向List中添加对象，而Iterator不能</li><li>ListIterator和Iterator都有hasNext()和next()方法，可以实现顺序向后遍历，但是ListIterator有hasPrevious()和previous()方法，可以实现逆向（顺序向前）遍历。Iterator就不可以。</li><li>ListIterator可以定位当前的索引位置，nextIndex()和previousIndex()可以实现。Iterator没有此功能。</li><li>都可实现删除对象，但是ListIterator可以实现对象的修改，set()方法可以实现。Iierator仅能遍历，不能修改。<br>因为ListIterator的这些功能，可以方便的实现对LinkedList等List数据结构的操作。其实，数组对象也可以用迭代器来实现。</li></ul><h2 id="5-6-Collection-和-Collections区别"><a href="#5-6-Collection-和-Collections区别" class="headerlink" title="5.6 Collection 和 Collections区别"></a>5.6 Collection 和 Collections区别</h2><p>Java中的Collection和Collections都是用于处理集合的类，但它们有一些重要的区别。</p><p><strong>继承关系</strong>：Collection是所有集合类的根接口，它定义了集合的基本操作，比如添加元素、删除元素等。Collections是一个帮助类，它提供了静态方法来操作和操作集合，比如排序、查找等。Collections类通过实现和实例化集合类的各种基本操作，让集合类的操作更加简单。</p><p><strong>用法</strong>：Collection通常用于定义集合类的基本操作，而Collections则提供了各种静态方法来操作和操作集合。Collections类中包含了很多有用的静态方法，比如排序、查找、复制等。</p>]]></content>
      
      
      <categories>
          
          <category> Java核心系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java核心 </tag>
            
            <tag> Java基础 </tag>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java核心系列7：线程安全性讨论</title>
      <link href="/2025/04/02/Java%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/Java%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%867-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%A8%E8%AE%BA/"/>
      <url>/2025/04/02/Java%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/Java%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%867-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%A8%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="1-为什么需要多线程"><a href="#1-为什么需要多线程" class="headerlink" title="1 为什么需要多线程"></a>1 为什么需要多线程</h1><p>我们都知道，CPU、内存、I&#x2F;O 设备的速度是有极大差异的，为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系结构、操作系统、编译程序都做出了优化，主要体现为:</p><ul><li>CPU增加了缓存，均衡了与内存之间的速度差异，但会导致可见性问题</li><li>操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I&#x2F;O 设备的速度差异，但会导致原子性问题</li><li>编译程序优化指令执行次序，使得缓存能够得到更加合理地利用，但会导致有序性问题</li></ul><p>从上面可以看到，虽然多线程平衡了CPU、内存、I&#x2F;O 设备之间的效率，但是同样也带来了一些问题。</p><h1 id="2-线程不安全案例分析"><a href="#2-线程不安全案例分析" class="headerlink" title="2 线程不安全案例分析"></a>2 线程不安全案例分析</h1><p>如果有多个线程，对一个共享数据进行操作，但没有采取同步的话，那操作结果可能超出预想，产生不一致。</p><p>下面举个粒子，设置一个计数器count，我们通过1000个线程同时对它进行增量操作，看看操作之后的值，是不是符合预想中的1000。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnsafeThreadTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadNum</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">    <span class="type">UnsafeThreadTest</span> <span class="variable">threadTest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnsafeThreadTest</span>();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(threadSize);</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorSvc</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line"><span class="comment">// 执行并发计数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>; idx &lt; threadNum; idx ++) &#123;</span><br><span class="line">        executorSvc.execute(() -&gt; &#123;</span><br><span class="line">            threadTest.add();</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.await();</span><br><span class="line"><span class="comment">// 关闭线程池</span></span><br><span class="line">    executorSvc.shutdown();</span><br><span class="line">    System.out.println(<span class="string">&quot;最终计数：&quot;</span> + threadTest.get());</span><br><span class="line">&#125;</span><br><span class="line">最终计数：<span class="number">994</span>  <span class="comment">// 结果跟预期的 1000 不一样</span></span><br></pre></td></tr></table></figure><h1 id="3-并发出现问题的原因"><a href="#3-并发出现问题的原因" class="headerlink" title="3 并发出现问题的原因"></a>3 并发出现问题的原因</h1><blockquote><p>可以看到，上述代码输出的结果跟预期的 1000 不一样，我们需要理清楚发生了什么问题?</p><p><strong>★ 并发三要素：可见性、原子性、有序性</strong></p></blockquote><h2 id="3-1-可见性：由CPU缓存引起"><a href="#3-1-可见性：由CPU缓存引起" class="headerlink" title="3.1 可见性：由CPU缓存引起"></a>3.1 可见性：由CPU缓存引起</h2><p>CPU缓存是一种高速缓存，用于存储CPU最近使用的数据。由于CPU缓存比主存储器更快，因此CPU会尽可能地使用缓存，以提高程序的性能。但是，这也会导致可见性问题。</p><p>可见性问题是指当一个线程修改了一个共享变量的值时，另一个线程可能无法立即看到这个修改。</p><p>我们举个简单的例子，看下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主存中 index 的值默认为 10</span></span><br><span class="line">System.out.println(<span class="string">&quot;主存中的值：&quot;</span> + index);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread1 执行赋值</span></span><br><span class="line">index = <span class="number">100</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Thread2 执行的</span></span><br><span class="line">threadA = index;</span><br></pre></td></tr></table></figure><p>因为Thread1修改后的值可能仍然存储在CPU缓存中，而没有被写回主存储器。这种情况下，Thread2无法读取到修改后的值，所以导致错误信息。</p><p>具体来说，当多个线程同时运行在同一个处理器上时，它们共享该处理器的缓存。如果一个线程修改了某个共享变量的值，该值可能被存储在处理器缓存中，并且未被立即写回到主存储器中。</p><p>因此，当另一个线程试图读取该变量的值时，它可能会从主存储器中读取旧的值 10，而不是从处理器缓存中读取已更新的值 100。</p><h2 id="3-2-原子性-由分时复用引起"><a href="#3-2-原子性-由分时复用引起" class="headerlink" title="3.2 原子性: 由分时复用引起"></a>3.2 原子性: 由分时复用引起</h2><p>原子性：原子性是指一个操作在执行过程中不可分割，即该操作要么完全执行，要么完全不执行。</p><p>我们举个简单的例子，看下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主存中 index 的值默认为 10</span></span><br><span class="line">System.out.println(<span class="string">&quot;主存中的值：&quot;</span> + index);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread1 执行增值</span></span><br><span class="line">index += <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Thread2 执行增值</span></span><br><span class="line">index += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>以上的信息可以看出：</p><ul><li>主存的值为10</li><li>i +&#x3D; 1 这个操作实际执行三条 CPU 指令<ul><li>变量 i 从内存读取到 CPU寄存器；</li><li>在CPU寄存器中执行 i + 1 操作；</li><li>将最后的结果i写入内存，因为有缓存机制，所以最终可能写入的是 CPU 缓存而不是内存。</li></ul></li><li>由于CPU分时复用（线程切换）的存在，Thread1执行了第一条指令后，就切换到Thread2执行，Thread2全部执行完成之后，再切换会Thread1执行后续两条指令，将造成最后写到内存中的index值是11而不是12。</li></ul><h2 id="3-3-有序性-重排序引起"><a href="#3-3-有序性-重排序引起" class="headerlink" title="3.3 有序性: 重排序引起"></a>3.3 有序性: 重排序引起</h2><p>有序性：即程序执行的顺序按照代码的先后顺序执行。</p><p>重排序（Reordering）是指在计算机系统中，由于处理器优化或编译器优化等原因，导致指令执行的顺序与程序代码中的顺序不一致。重排序可能会引起有序性错误，即在并发或多线程环境中，程序执行的顺序与代码的先后顺序不一致，导致程序结果不正确或出现意外的结果。</p><p>我们举个简单的例子，看下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isCheck</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">idx += <span class="number">1</span>;                <span class="comment">// 执行语句1  </span></span><br><span class="line">isCheck = <span class="literal">false</span>;          <span class="comment">// 执行语句2</span></span><br></pre></td></tr></table></figure><p>上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行操作。</p><p>从代码顺序上看，执行语句1是在执行语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗? 不一定，为什么呢? 这里可能会发生指令重排序（Instruction Reorder）。</p><p>重排序（Reordering）是指在计算机系统中，由于处理器优化或编译器优化等原因，导致指令执行的顺序与程序代码中的顺序不一致。重排序可能会引起有序性错误，即在并发或多线程环境中，程序执行的顺序与代码的先后顺序不一致，导致程序结果不正确或出现意外的结果。</p><p>重排序引起的有序性错误主要有以下几种情况：</p><ol><li>指令重排序：处理器为了优化程序的执行，可能会对指令进行重排序。这种重排序不会改变单线程程序的执行结果，但可能会影响多线程程序的行为。例如，一个线程修改了一个共享变量的值，但由于指令重排序，另一个线程在读取该变量时可能读取到过时的值。</li><li>内存访问重排序：处理器为了提高程序的执行效率，可能会对内存访问进行重排序。例如，一个线程先读取一个共享变量的值，然后再写入该值，但由于内存访问重排序，处理器可能会先执行写入操作，再执行读取操作，从而导致其他线程无法正确地读取到修改后的值。</li><li>同步操作重排序：在并发或多线程环境中，同步操作可能会被重排序。例如，一个线程先释放了一个锁，然后再执行另一个操作，但由于同步操作重排序，释放锁的操作可能会先于另一个操作执行，从而导致其他线程无法正确地获取锁。</li></ol><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAPGaUelcLCws8zRT7ERXBCf6R3tCr8AAtMLaxunpzhWk41It71juDIBAAMCAAN4AAM2BA.png" alt=" "></p><p>为了避免重排序引起的有序性错误，可以采用一些同步机制来确保程序的执行顺序，如内存屏障（Memory barrier，intel 称为 memory fence）、指令fence等。这些同步机制可以确保指令的执行顺序与代码中的顺序一致，避免指令重排序和内存访问重排序等问题。同时，也可以使用串行化（Serialization）或事务内存（Transactional memory）等技术来保证并发程序的有序性。</p><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h1><ul><li>CPU、内存、I&#x2F;O 设备的速度是有极大差异的，多线程 的实现是为了合理利用 CPU 的高性能，平衡这三者的速度差异</li><li>多线程情况下，并发产生问题的三要素：可见性、原子性、有序性<ul><li>可见性：由CPU缓存引起</li><li>原子性: 由分时复用引起</li><li>有序性: 重排序引起</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java核心系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java核心 </tag>
            
            <tag> Java基础 </tag>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java核心系列4：AOP原理和切面应用</title>
      <link href="/2025/04/02/Java%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/Java%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%864-AOP%E5%8E%9F%E7%90%86%E5%92%8C%E5%88%87%E9%9D%A2%E5%BA%94%E7%94%A8/"/>
      <url>/2025/04/02/Java%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/Java%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%864-AOP%E5%8E%9F%E7%90%86%E5%92%8C%E5%88%87%E9%9D%A2%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><p>我们所说的Aop（即面向切面编程），即面向接口，也面向方法，在基于IOC的基础上实现。</p><p>Aop最大的特点是对指定的方法进行拦截并增强，这种增强的方式不需要业务代码进行调整，无需侵入到业务代码中，使业务与非业务处理逻辑分离。</p><p>以Spring举例，通过事务的注解配置，Spring会自动在业务方法中开启、提交业务，并且在业务处理失败时，执行相应的回滚策略。</p><p>aop的实现主要包括了两个部分：</p><ul><li>匹配符合条件的方法(Pointcut)</li><li>对匹配的方法增强(<strong>JDK代理、cglib代理</strong>)<br>spring针对xml配置和配置自动代理的Advisor有很大的处理差别，在IOC中主要是基于XML配置分析的，在AOP的源码解读中，则主要从自动代理的方式解析，分析完注解的方式，再分析基于xml的方式。</li></ul><h1 id="2-案例分析"><a href="#2-案例分析" class="headerlink" title="2 案例分析"></a>2 案例分析</h1><p>下面是spring aop的用法，也是用于源码分析的案例切面类：TracesRecordAdvisor</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TracesRecordAdvisor</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* spring.action.expend.aop.services.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">expression</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;expression()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beforePrint</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进入服务，在服务执行之前,记录日志....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning(&quot;expression()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPrint</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;退出服务，在服务执行结束之后,记录日志.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>xml配置: aop的注解启用只需要在xml中配置这段代码即可，这个是作为入口</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>服务类：PayServiceImpl 使用jdk代理 所以要有一个接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PayServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">PayService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">payMoneyMenthod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在执行付款...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">springAopTestService</span><span class="params">()</span> &#123;</span><br><span class="line">    ClassPathXmlApplicationContext applicationContext=<span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;spring-aop.xml&quot;</span>);</span><br><span class="line">    PayService payService= (PayService) applicationContext.getBean(<span class="string">&quot;payServiceImpl&quot;</span>);</span><br><span class="line">    payService.payMoneyMenthod();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">进入服务，在服务执行之前,记录日志....</span><br><span class="line">正在执行付款...</span><br><span class="line">退出服务，在服务执行结束之后,记录日志.....</span><br></pre></td></tr></table></figure><p>从上面的执行结果看，payMoneyMenthod 方法的确是被增强了。</p><h1 id="3-BeanFactoryPostProcessor"><a href="#3-BeanFactoryPostProcessor" class="headerlink" title="3 BeanFactoryPostProcessor"></a>3 BeanFactoryPostProcessor</h1><p>读spring源码的时候，可以首先看下BeanFactoryPostProcessor和BeanPostProcess,这两个接口都是在spring通过配置文件或者xml获取bean声明，生成BeanDefinition后，允许我们再对生成的BeanDefinition，进行入口包装和增强。</p><p>我们看看BeanFactoryPostProcessor的定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanFactoryPostProcessor</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法postProcessBeanFactory的参数为ConfigurableListableBeanFactory，我们之前讨论过beanFactory用来获取bean的，而ConfigurableListableBeanFactory继承接口SingletonBeanRegistry和BeanFactroy，所以可以访问到已经生成过的BeanDefinitions集合，如果某个类实现该接口，spring会注册这个类，然后执行这个类的postProcessBeanFactory方法，以便我们对BeanDefinition进行扩展。</p><p>接下来的代码表示Spring是如何注册BeanFactoryPostProcessor并执行postProcessBeanFactory的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        prepareRefresh();</span><br><span class="line">        <span class="comment">//核心方法1</span></span><br><span class="line">        <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> obtainFreshBeanFactory();</span><br><span class="line">        prepareBeanFactory(beanFactory);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            postProcessBeanFactory(beanFactory);</span><br><span class="line">            <span class="comment">//核心方法2 执行BeanFactoryPostProcessor</span></span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">            <span class="comment">//核心方法 3 注册BeanPostProcessor</span></span><br><span class="line">            registerBeanPostProcessors(beanFactory);</span><br><span class="line">            <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">            initMessageSource();</span><br><span class="line">            <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">            initApplicationEventMulticaster();</span><br><span class="line">            <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">            onRefresh();</span><br><span class="line">            <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">            registerListeners();</span><br><span class="line">            <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">            finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">            <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">            finishRefresh();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">             ............</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">             ............</span><br><span class="line">            resetCommonCaches();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心方法1obtainFreshBeanFactory就是前两篇所说的生成BeanDefinition的入口，invokeBeanFactoryPostProcessors核心方法2就是执行BeanFactoryPostProcessor接口的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">   PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过方法getBeanFactoryPostProcessors获取注册BeanFactoryPostProcessor，然后来看看如何添加一个处理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addBeanFactoryPostProcessor</span><span class="params">(BeanFactoryPostProcessor beanFactoryPostProcessor)</span> &#123;</span><br><span class="line">   <span class="built_in">this</span>.beanFactoryPostProcessors.add(beanFactoryPostProcessor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于方法invokeBeanFactoryPostProcessors不再往下看了，里面的方法大致先对BeanFactoryPostProcessor进行排序，排序的标准是是否实现了PriorityOrdered，然后根据设置的order大小指定执行顺序，生成一个排序集合和一个普通的集合，最后执行invokeBeanFactoryPostProcessors</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invokeBeanFactoryPostProcessors</span><span class="params">(</span></span><br><span class="line"><span class="params">      Collection&lt;? extends BeanFactoryPostProcessor&gt; postProcessors, ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (BeanFactoryPostProcessor postProcessor : postProcessors) &#123;</span><br><span class="line">              <span class="comment">//执行到自定义的BeanFactoryPostProcessor</span></span><br><span class="line">             postProcessor.postProcessBeanFactory(beanFactory);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法就会循环先前注册的BeanFactoryPostProcessor集合，然后执行postProcessBeanFactory。</p><h1 id="4-BeanPostProcess-解读"><a href="#4-BeanPostProcess-解读" class="headerlink" title="4 BeanPostProcess 解读"></a>4 BeanPostProcess 解读</h1><p>与BeanFactoryPostProcessor相比，BeanPostProcess就重要得多了，因为Spring的注解、AOP等都是通过这个接口的方法拦截执行的，它贯穿了Bean创建过程的整个生命周期，在IOC阶段，Spring只注册BeanPostProcess，执行则放到了Bean的实例化创建阶段。</p><p>首先看下BeanPostProcessor的接口定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line">        <span class="comment">//在bean创建 属性赋值之后  Aware接口执行之后执行</span></span><br><span class="line">        Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">        <span class="comment">//在init-method afterPropertiesSet 执行之后执行</span></span><br><span class="line">        Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在bean的声明周期中，下面的序列是bean创建后要执行的接口和方法顺序：</p><ul><li>实例化（autowireConstructor或者instantiateBean)</li><li>属性初始化(populateBean)</li><li>Aware接口（如果你的 bean 有进行实现)</li><li>BeanPostProcess.postProcessBeforeInitialization</li><li>PostConstructInitializingBean.afterPropertiesSet</li><li>BeanPostProcess.postProcessAfterInitialization</li></ul><p>其中通过注解引入依赖的方式就是在AutowiredAnnotationBeanPostProcessor这个类中实现的，而接下来要分析的Spring Aop也是从这里开始的，这个类叫AnnotationAwareAspectJAutoProxyCreator,</p><h1 id="5-NameSpaceHanlder-解读"><a href="#5-NameSpaceHanlder-解读" class="headerlink" title="5 NameSpaceHanlder 解读"></a>5 NameSpaceHanlder 解读</h1><p>在Spring中，任何的技术都是在IOC的基础上进行的，Aop也不例外，程序会首先读取xml配置文件，然后对读取到的标签先查找命名空间，然后找对应的NameSpaceHandler，最终调用parse方法解析标签。</p><p>aop标签的解析，使用纯注解的方式aop:aspectj-autoproxy和使用aop:config的配置解析不太一样，具体表现在生成PointCut和生成Before、After、Around等切面类时，使用aop:config的方式会为这些注解生成一个BeanDefinition，而这个BeanDefinition的构造函数是由3个BeanDefinition组成，表明这个类是合成类，即synthetic这个属性为true。然后跟解析普通的bean一样，生成这些实例对象，后面的过程就跟是用纯注解的方式相同了，接下来的分析是基于纯注解分析的，也就是解析从解析aop:aspectj-autoproxy这个标签开始。</p><p>前面的xml文件的标签解析是通过parseDefaultElement方法解析默认的标签的，而我们在配置文件里面配置了启动自动代理的方式<code>&lt;aop:aspectj-autoproxy/&gt;</code>，当Spring读取到这个标签，则会走parseCustomElement(root)这个方法了，这个方法的源码不再解析，主要完成的功能如下:</p><ul><li>获取element的nameSpaceUri,根据nameSpaceUri找到NameSpaceHanlder</li><li>调用NameSpaceHanlder的parse方法解析element</li></ul><p>下面是NameSpaceHanlder接口的定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">NamespaceHandler</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>;</span><br><span class="line">        BeanDefinition <span class="title function_">parse</span><span class="params">(Element element, ParserContext parserContext)</span>;</span><br><span class="line">        BeanDefinitionHolder <span class="title function_">decorate</span><span class="params">(Node source, BeanDefinitionHolder definition, ParserContext parserContext)</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里面的init方法是我们初始化操作的，这里可以完成对指定的标签设置解析器，然后再parse方法里面找到指定标签的解析器，然后调用该解析器的parse方法解析标签，后面会重点看这两个方法。</p><p>再来看下Spring如何加载NameSpaceHanlder的，Spring首先会取查找项目空间下目录META-INF&#x2F;的所有spring.handlers文件，这个文件是在Spring依赖的jar下面，在核心jar包都会由这个文件，aop的jar包路径下文件内容为：spring.handlers</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.springframework.org/schema/aop=org.springframework.aop.config.AopNamespaceHandler</span><br></pre></td></tr></table></figure><p>发现这里面存储的是一个key，value,key是aop的nameSpaceUri，value是AopNamespaceHandler，从这个类名上就能发现该类实现了NamespaceHandler，肯定也就实现了init和parse方法，所以解析<code>&lt;aop:aspectj-autoproxy/&gt;</code>的任务就由AopNamespaceHandler的parse完成。</p><p>查看AopNamespaceHandler的init方法</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">init</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// In 2.0 XSD as well as in 2.1 XSD.</span></span><br><span class="line">    <span class="title function_">registerBeanDefinitionParser</span>(<span class="string">&quot;config&quot;</span>, <span class="keyword">new</span> <span class="title class_">ConfigBeanDefinitionParser</span>());</span><br><span class="line">    <span class="title function_">registerBeanDefinitionParser</span>(<span class="string">&quot;aspectj-autoproxy&quot;</span>, <span class="keyword">new</span>                       <span class="title class_">AspectJAutoProxyBeanDefinitionParser</span>());</span><br><span class="line">    <span class="title function_">registerBeanDefinitionDecorator</span>(<span class="string">&quot;scoped-proxy&quot;</span>, <span class="keyword">new</span> <span class="title class_">ScopedProxyBeanDefinitionDecorator</span>());</span><br><span class="line">    <span class="comment">// Only in 2.0 XSD: moved to context namespace as of 2.1</span></span><br><span class="line">    <span class="title function_">registerBeanDefinitionParser</span>(<span class="string">&quot;spring-configured&quot;</span>, <span class="keyword">new</span> <span class="title class_">SpringConfiguredBeanDefinitionParser</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码就很清晰了，<code>&lt;aop:config&gt;</code> 标签由ConfigBeanDefinitionParser处理，<code>&lt;aop:aspectj-autoproxy/&gt;</code> 则由AspectJAutoProxyBeanDefinitionParser这个类处理，这两种处理其实对应了自动代理和通过xml配置的处理方式，然后会调用AspectJAutoProxyBeanDefinitionParser的parse方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BeanDefinition <span class="title function_">parse</span><span class="params">(Element element, ParserContext parserContext)</span> &#123;</span><br><span class="line">        AopNamespaceUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(parserContext, element);</span><br><span class="line">        extendBeanDefinition(element, parserContext);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个方法其实就是为了注册一个AnnotationAwareAspectJAutoProxyCreator类，然后AOP的所有处理逻辑都会交给这个类处理,由于这个类的实现了BeanPostProcessor,所以这个类的入口就是BeanPostProcessor接口的两个方法：</p><ul><li>postProcessBeforeInitialization</li><li>postProcessAfterInitialization</li></ul><h1 id="6-Spring-Aop-源码分析"><a href="#6-Spring-Aop-源码分析" class="headerlink" title="6 Spring Aop 源码分析"></a>6 Spring Aop 源码分析</h1><p>我们前面分析了，当spring读取xml文件遇到<code>&lt;aop:aspectj-autoproxy/&gt;</code>会找到AopNamespaceHandler这个处理类，然后这个类又将这个标签委托给了AspectJAutoProxyBeanDefinitionParser类，最终调用这个类得parse方法，parse方法未做分析，其实这个方法的目的很简单，就是注册AnnotationAwareAspectJAutoProxyCreator这个类，这个类实现了BeanPostProcessor和InstantiationAwareBeanPostProcessor接口，最终在实例化bean对象也就是执行BeanFactory.getBean(beanName)的过程中，会调用这两个接口的方法(执行顺序如下)：</p><p>InstantiationAwareBeanPostProcessor先执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">postProcessBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName)</span><br><span class="line">postProcessAfterInstantiation(Object bean, String beanName)</span><br></pre></td></tr></table></figure><p>BeanPostProcessor再执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">postProcessBeforeInitialization(Object bean, String beanName)</span><br><span class="line">Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span></span><br></pre></td></tr></table></figure><p>AOP的实现基本上是在这两个方法中进行的，所以就从这里来看Spring是如何实现AOP的，Spring的AOP代理目前支持方法的增强，看源码目前好像也支持了属性的增强了。</p><p>读取源码前首先来分析一下方法增强的原理，有助于我们读取源码时紧紧抓住主线。首先第一个问题，如果我们想对一个类的方法进行增强，我们应该怎么做呢？</p><p>这种业务需求可以通过代理实现，在方法执行前，拦截这个方法，并且加入要执行增强的逻辑，最后再执行目标方法。下面是Spring用的两种代理方式：</p><blockquote><p><strong>JDK代理</strong>：我们可以通Proxy类获取一个目标类的代理对象，但JDK代理要求被代理的类必须实现接口，所以是基于接口的代理。</p></blockquote><blockquote><p><strong>cglib代理</strong>：如果目标类没有接口，使用cglib代理，是由asm封装的，直接操作类得字节码，效率也很高。</p></blockquote><p>由于在生产业务中，我们不可能对所有的类都执行增强，所以还需要一个选择器，将符合条件的bean进行增强，Spring使用了PointCut接口，通过该接口的getMethodMatcher方法获取一个方法匹配器，然后通过matches方法匹配到目标类对象的目标方法执行增强操作。mathcer匹配规则就是通过Spring 配置的expression表达式了。</p><p>所以在分析源码的时，要围绕这两方面进行：</p><ul><li>匹配切点方法（构建切入点表达式类和切面类）</li><li>创建代理对象</li></ul><p>这两方面在Spring的实现里非常复杂，尤其是第一步匹配切点方法过程，这个过程中，Spring会将@Aspect注解类的@Before，@After，@Around、@Pointcut等注解都封装成待执行的切面方法类，然后通过方法匹配器匹配到的要增强的方法前后执行切面方法类，达到方法增强的目的。</p><p>第二阶段，创建代理对象默认是通过JDK代理实现配置，&lt;aop:aspectj-autoproxy proxy-target-class&#x3D;”true”&gt;这样配置可以指定使用cglib代理。</p><h1 id="7-注解切面代理类分析"><a href="#7-注解切面代理类分析" class="headerlink" title="7 注解切面代理类分析"></a>7 注解切面代理类分析</h1><p>上面分析了真正实现AOP功能的是AnnotationAwareAspectJAutoProxyCreator,由于这个类实现了BeanPostProcessor和InstantiationAwareBeanPostProcessor，所以在创建一个bean的时候，会进入到这两个接口的方法，这两个接口包含了四个方法，方法执行顺序上面已经分析过了，来看看这个类的类图：<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAO8aUea8taWIg069oOemwfAWUdNTAcAArMLaxunpzhWofFefUwj4FEBAAMCAAN3AAM2BA.png" alt="AnnotationAwareAspectJAutoProxyCreator类"><br>类图上比较重要的接口就是右上角实现的两个接口，在bean创建的生命周期过程中，会校验当前容器中是否注册了实现了这两个接口的类，如果有则调用接口的方法，前面的分析中在解析aop:aspectj-autoproxy&#x2F;时，将这个类注册到了容器中，而且上面也罗列了这两个接口中四个方法的调用顺序，在这个类中完成主要功能的2个方法及其执行顺序:</p><ul><li>InstantiationAwareBeanPostProcessor先执行：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">postProcessBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName)</span><br></pre></td></tr></table></figure><ul><li>BeanPostProcessor再执行：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span></span><br></pre></td></tr></table></figure><p>postProcessBeforeInstantiation方法主要是找出注解了Advice的类，并将Advice的类使用了@Before，@After，@Around、@Pointcut,@AfterThrowing等注解的方法封装成一个一个类放入到缓存中供匹配到的类生成代理用</p><p>postProcessAfterInitialization主要是匹配符合条件的目标类对象，然后生成代理的过程,接下来就按顺序分析这两个方法完成的功能。</p><h1 id="8-Aspect注解类分析"><a href="#8-Aspect注解类分析" class="headerlink" title="8 Aspect注解类分析"></a>8 Aspect注解类分析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="comment">//构建一个缓存key</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">cacheKey</span> <span class="operator">=</span> getCacheKey(beanClass, beanName);</span><br><span class="line">    <span class="keyword">if</span> (beanName == <span class="literal">null</span> || !<span class="built_in">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">        <span class="comment">//如果当前beanClass的缓存key 存在于Class为Advise的缓存中，表示当前的beanClass是Adivse类</span></span><br><span class="line">        <span class="comment">//而且不需要生成代理。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.advisedBeans.containsKey(cacheKey)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//核心校验：1 当前类是否是AOP的基础类 2、当前类是否应该跳过不生成代理</span></span><br><span class="line">        <span class="keyword">if</span> (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这部分主要是用于实现了TargetSource接口的bean，然后从getTarget中获取对象 创建代理</span></span><br><span class="line">    <span class="keyword">if</span> (beanName != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">TargetSource</span> <span class="variable">targetSource</span> <span class="operator">=</span> getCustomTargetSource(beanClass, beanName);</span><br><span class="line">        <span class="keyword">if</span> (targetSource != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.targetSourcedBeans.add(beanName);</span><br><span class="line">            Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">proxy</span> <span class="operator">=</span> createProxy(beanClass, beanName, specificInterceptors, targetSource);</span><br><span class="line">            <span class="built_in">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">            <span class="keyword">return</span> proxy;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法主要是先为beanClass生成一个缓存的key，这个beanClass如果是FactoryBean，则按照工厂类的命名规则命名，否则用beanName命名，然后用刚才生成的key判断beanClass是否已经存在于Advice的缓存集合中，如果已经存在则代表该类是切面类而且已经被处理过了，后续处理不会为该类生成代理，如果没有没处理过，则会调用下面的方法校验该类是否是AOP的基础类 ，总之这个方法作用就是将AOP相关操作的切面类和基础类放入到缓存中，当为bean生成代理的时候，忽略advice缓存中的AOP切面类和基础类，下面是具体校验过程：AnnotationAwareAspectJAutoProxyCreator重写了该方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isInfrastructureClass</span><span class="params">(Class&lt;?&gt; beanClass)</span> &#123;</span><br><span class="line"><span class="comment">//调用父类的isInfrastructureClass判断是否是aop基础类</span></span><br><span class="line"><span class="comment">//校验当前类是否使用@Aspect注解</span></span><br><span class="line"><span class="keyword">return</span> (<span class="built_in">super</span>.isInfrastructureClass(beanClass) || <span class="built_in">this</span>.aspectJAdvisorFactory.isAspect(beanClass));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>父类的isInfrastructureClass方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isInfrastructureClass</span><span class="params">(Class&lt;?&gt; beanClass)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">retVal</span> <span class="operator">=</span> Advice.class.isAssignableFrom(beanClass) ||</span><br><span class="line">            Advisor.class.isAssignableFrom(beanClass) ||</span><br><span class="line">            AopInfrastructureBean.class.isAssignableFrom(beanClass);</span><br><span class="line">    <span class="keyword">if</span> (retVal &amp;&amp; logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">&quot;Did not attempt to auto-proxy infrastructure class [&quot;</span> + beanClass.getName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>里面isAssignableFrom表示当前类是否允许被设置为beanClass类对象，可以以此判断beanClass是否是Advice类，所以这个方法的校验目的就是判断当前正在创建目标类是否是AOP的基础类，即该类是否是Advice,Advisor或者实现了AopInfrastructureBean接口。该方法调用父类的isInfrastructureClass判断是否是aop基础类，然后再校验当前类是否使用@Aspect注解，目的只有一个，如果是Advice切面相关的类不做任何处理，直接放入advice缓存即可。然后再来看shouldSkip(beanClass, beanName)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">shouldSkip</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> &#123;</span><br><span class="line">    <span class="comment">//查找当前已经生成的所有Advisor切面类  不展开分析</span></span><br><span class="line">    List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</span><br><span class="line">    <span class="keyword">for</span> (Advisor advisor : candidateAdvisors) &#123;</span><br><span class="line">        <span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> AspectJPointcutAdvisor) &#123;</span><br><span class="line">            <span class="keyword">if</span> (((AbstractAspectJAdvice) advisor.getAdvice()).getAspectName().equals(beanName)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.shouldSkip(beanClass, beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法主要是校验当前正在创建bean的beanName是否属于已经创建好的切面类缓存中，如果是则加入到advices缓存中，不再处理。其中findCandidateAdvisors()会查找当前容器中生成的所有实现了Advisor的类，Spring会将@Before，@After，@Around等生成一个继承了Advisor类对象存储到缓存中供后续使用,这一部分时Spring AOP前半段的核心内容，后续都会围绕着如何将切面类的注解生成Adisor类探索。</p><p>AnnotationAwareAspectJAutoProxyCreator重写了findCandidateAdvisors方法，所以会执行到该方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title function_">findCandidateAdvisors</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">//通过父类的方法查找所有容器中的Advisor类，也就是基于xml配置的&lt;aop:before/&gt;生成的</span></span><br><span class="line">   List&lt;Advisor&gt; advisors = <span class="built_in">super</span>.findCandidateAdvisors();</span><br><span class="line">   <span class="comment">//查找通过注解的方式生成Advisor类</span></span><br><span class="line">   advisors.addAll(<span class="built_in">this</span>.aspectJAdvisorsBuilder.buildAspectJAdvisors());</span><br><span class="line">   <span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法会首先调用父类的findCandidateAdvisors方法用于获取通过xml文件配置生成的Advisor，也就是通过aop:before,aop:after等生成的，然后调用通过注解方式即@Before，@After，@Around、@Pointcut,@AfterThrowing生成的advisor.</p><p>可以说，这两个方法分别处理了基于xml配置文件的方式和基于注解的配置方式，因为所有的分析都是基于AnnotationAwareAspectJAutoProxyCreator这个类进行的，所以在这个地方会先获取配置文件的，再生成基于注解类的Advisor，这样就将基于xml配置的和基于注解的配置都会解析到。看下 this.aspectJAdvisorsBuilder.buildAspectJAdvisors()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Advisor&gt; <span class="title function_">buildAspectJAdvisors</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;String&gt; aspectNames = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        aspectNames = <span class="built_in">this</span>.aspectBeanNames;</span><br><span class="line">        <span class="keyword">if</span> (aspectNames == <span class="literal">null</span>) &#123;</span><br><span class="line">            List&lt;Advisor&gt; advisors = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Advisor&gt;();</span><br><span class="line">            aspectNames = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;String&gt;();</span><br><span class="line">            <span class="comment">//从beanDefinitions中获取所有的beanName</span></span><br><span class="line">            String[] beanNames =</span><br><span class="line">                    BeanFactoryUtils.beanNamesForTypeIncludingAncestors(<span class="built_in">this</span>.beanFactory, Object.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">                <span class="comment">//如果beanName不符合配置的 &lt;aop:include name=&quot;***&quot;/&gt;</span></span><br><span class="line">                <span class="comment">//忽略这个bean上所有的切面方法</span></span><br><span class="line">                <span class="keyword">if</span> (!isEligibleBean(beanName)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                Class&lt;?&gt; beanType = <span class="built_in">this</span>.beanFactory.getType(beanName);</span><br><span class="line">                <span class="keyword">if</span> (beanType == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果当前beanType是一个切面类 则将该切面类相关信息封装起来</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.advisorFactory.isAspect(beanType)) &#123;</span><br><span class="line">                    aspectNames.add(beanName);</span><br><span class="line">                    <span class="type">AspectMetadata</span> <span class="variable">amd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AspectMetadata</span>(beanType, beanName);</span><br><span class="line">                    <span class="keyword">if</span> (amd.getAjType().getPerClause().getKind() == PerClauseKind.SINGLETON) &#123;</span><br><span class="line">                        <span class="comment">// 将切面信息放入到分装到MetadataAwareAspectInstanceFactory 生成一个AspectMetadata</span></span><br><span class="line">                        <span class="type">MetadataAwareAspectInstanceFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanFactoryAspectInstanceFactory</span>(<span class="built_in">this</span>.beanFactory, beanName);</span><br><span class="line">                        <span class="comment">// 获取容器中所有Advisor类 需要进入这个方法详细分析</span></span><br><span class="line">                        List&lt;Advisor&gt; classAdvisors = <span class="built_in">this</span>.advisorFactory.getAdvisors(factory);</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">this</span>.beanFactory.isSingleton(beanName)) &#123;</span><br><span class="line">                            <span class="comment">//单例加入缓存</span></span><br><span class="line">                            <span class="built_in">this</span>.advisorsCache.put(beanName, classAdvisors);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">//非单例  将工厂加入缓存</span></span><br><span class="line">                            <span class="built_in">this</span>.aspectFactoryCache.put(beanName, factory);</span><br><span class="line">                        &#125;</span><br><span class="line">                        advisors.addAll(classAdvisors);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 非单例  将生成Advisor的工厂类加入到缓存</span></span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">this</span>.beanFactory.isSingleton(beanName)) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Bean with name &#x27;&quot;</span> + beanName +</span><br><span class="line">                                    <span class="string">&quot;&#x27; is a singleton, but aspect instantiation model is not singleton&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="type">MetadataAwareAspectInstanceFactory</span> <span class="variable">factory</span> <span class="operator">=</span></span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">PrototypeAspectInstanceFactory</span>(<span class="built_in">this</span>.beanFactory, beanName);</span><br><span class="line">                        <span class="built_in">this</span>.aspectFactoryCache.put(beanName, factory);</span><br><span class="line">                        advisors.addAll(<span class="built_in">this</span>.advisorFactory.getAdvisors(factory));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">this</span>.aspectBeanNames = aspectNames;</span><br><span class="line">            <span class="keyword">return</span> advisors;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ..............</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法主要的任务其实就是获取类得类型为Aspect的切面类，然后获取切面类方法的所有注解并将注解转换成Advisor类返回，主要步骤为：</p><ul><li>获取容器中所有的BeanDefinition的beanName</li><li>根据beanName，或者beanClass，匹配符合规则的Aspect切面类，通过aop:include配置的规则</li><li>获取Aspect切面类的所有切面方法封装成Advisor对象返回。</li><li>将获取到的所有Advisor放入到缓存中。<br>这个方法代码虽然很多，但是核心的是this.advisorFactory.getAdvisors(factory)，即第三个步骤，这个方法将会获取到切面类的所有切面方法，并封装成Advisor，getAdvisors是一个接口，ReflectiveAspectJAdvisorFactory实现了这个接口，下面代码是其实现逻辑：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Advisor&gt; <span class="title function_">getAdvisors</span><span class="params">(MetadataAwareAspectInstanceFactory aspectInstanceFactory)</span> &#123;</span><br><span class="line">        <span class="comment">//获取切面类Class</span></span><br><span class="line">        Class&lt;?&gt; aspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();</span><br><span class="line">        <span class="comment">//获取切面类的beanName</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">aspectName</span> <span class="operator">=</span> aspectInstanceFactory.getAspectMetadata().getAspectName();</span><br><span class="line">        validate(aspectClass);</span><br><span class="line">        <span class="comment">//进一步对AspectMetadata封装 里面包含了切面类的信息</span></span><br><span class="line">        <span class="type">MetadataAwareAspectInstanceFactory</span> <span class="variable">lazySingletonAspectInstanceFactory</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LazySingletonAspectInstanceFactoryDecorator</span>(aspectInstanceFactory);</span><br><span class="line">        List&lt;Advisor&gt; advisors = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Advisor&gt;();</span><br><span class="line">        <span class="comment">//获取切面类中没有使用Pointcut注解的方法</span></span><br><span class="line">        <span class="keyword">for</span> (Method method : getAdvisorMethods(aspectClass)) &#123;</span><br><span class="line">            <span class="comment">//检查该方法是否是切面方法， 如果是成Advisor类返回</span></span><br><span class="line">            <span class="type">Advisor</span> <span class="variable">advisor</span> <span class="operator">=</span> getAdvisor(method, lazySingletonAspectInstanceFactory, advisors.size(), aspectName);</span><br><span class="line">            <span class="keyword">if</span> (advisor != <span class="literal">null</span>) &#123;</span><br><span class="line">                advisors.add(advisor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果没有切面方法 设置一个空的</span></span><br><span class="line">        <span class="keyword">if</span> (!advisors.isEmpty() &amp;&amp; lazySingletonAspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) &#123;</span><br><span class="line">            <span class="type">Advisor</span> <span class="variable">instantiationAdvisor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SyntheticInstantiationAdvisor</span>(lazySingletonAspectInstanceFactory);</span><br><span class="line">            advisors.add(<span class="number">0</span>, instantiationAdvisor);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理属性字段 Spring支持到了属性的增强</span></span><br><span class="line">        <span class="keyword">for</span> (Field field : aspectClass.getDeclaredFields()) &#123;</span><br><span class="line">            <span class="type">Advisor</span> <span class="variable">advisor</span> <span class="operator">=</span> getDeclareParentsAdvisor(field);</span><br><span class="line">            <span class="keyword">if</span> (advisor != <span class="literal">null</span>) &#123;</span><br><span class="line">                advisors.add(advisor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> advisors;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个方法首先已经将切面类信息封装到AspectMetadata的类再次封装到MetadataAwareAspectInstanceFactory，然后获取切面类的所有没有使用Pointcut注解的方法，调用getAdvisor获取这个方法使用的切面注解，生成对应的Advisor类。 至于PointCut的处理则是再后面的getAdvisor中处理的。</p><h1 id="9-获取切面类的Advisor"><a href="#9-获取切面类的Advisor" class="headerlink" title="9 获取切面类的Advisor"></a>9 获取切面类的Advisor</h1><p>获取Advisor类的方法为getAdvisor，首先来看下这个方法的参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//切面类的切面方法  这里可能就是 beforePrint()</span></span><br><span class="line">Method  candidateAdviceMethod </span><br><span class="line"><span class="comment">//获取AspectMetadata的实例工厂(可以获取切面的类所有信息)</span></span><br><span class="line">MetadataAwareAspectInstanceFactory aspectInstanceFactory</span><br><span class="line"><span class="comment">//切面的排序</span></span><br><span class="line"><span class="type">int</span> declarationOrderInAspect</span><br><span class="line"><span class="comment">//切面类的beanName 这里是tracesRecordAdvisor</span></span><br><span class="line"> String aspectName</span><br></pre></td></tr></table></figure><p>上面的参数中可以获取到切面类和切面方法，这样就可以获得一个Advisor对象，然后还需要一个切入点表达式PointCut用来匹配符合条件的方法，拦截到目标方法后，就可以执行Adivsor增强方法了。 来看看创建Advisor的过程，这里假设Method是TracesRecordAdvisor类的beforePrint方法，也就是我们测试案例中创建使用了@Before注解的切面方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Advisor <span class="title function_">getAdvisor</span><span class="params">(Method candidateAdviceMethod, MetadataAwareAspectInstanceFactory aspectInstanceFactory,</span></span><br><span class="line"><span class="params">      <span class="type">int</span> declarationOrderInAspect, String aspectName)</span> &#123;</span><br><span class="line"></span><br><span class="line">   validate(aspectInstanceFactory.getAspectMetadata().getAspectClass());</span><br><span class="line">   <span class="comment">//获取pointCut,这里实际上获得的是 expression()这个方法对应了pointCut的内容</span></span><br><span class="line">   <span class="type">AspectJExpressionPointcut</span> <span class="variable">expressionPointcut</span> <span class="operator">=</span> getPointcut(</span><br><span class="line">         candidateAdviceMethod, aspectInstanceFactory.getAspectMetadata().getAspectClass());</span><br><span class="line">   <span class="keyword">if</span> (expressionPointcut == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">//创建advisor</span></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">InstantiationModelAwarePointcutAdvisorImpl</span>(expressionPointcut, candidateAdviceMethod,</span><br><span class="line">         <span class="built_in">this</span>, aspectInstanceFactory, declarationOrderInAspect, aspectName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看看getPointCut方法如何获取到exression过程需要嵌套很多步骤，这里不展开了，简单看下如何将查找到的值设置到表达式中的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> AspectJExpressionPointcut <span class="title function_">getPointcut</span><span class="params">(Method candidateAdviceMethod, Class&lt;?&gt; candidateAspectClass)</span> &#123;</span><br><span class="line">   <span class="comment">//</span></span><br><span class="line">   AspectJAnnotation&lt;?&gt; aspectJAnnotation =</span><br><span class="line">         AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod);</span><br><span class="line">   <span class="keyword">if</span> (aspectJAnnotation == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="type">AspectJExpressionPointcut</span> <span class="variable">ajexp</span> <span class="operator">=</span></span><br><span class="line">         <span class="keyword">new</span> <span class="title class_">AspectJExpressionPointcut</span>(candidateAspectClass, <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>], <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[<span class="number">0</span>]);</span><br><span class="line">   <span class="comment">//将上面生成的AspectJAnnotation 解析出的expression方法放入到表达式中</span></span><br><span class="line">   <span class="comment">//</span></span><br><span class="line">   ajexp.setExpression(aspectJAnnotation.getPointcutExpression());</span><br><span class="line">   <span class="keyword">return</span> ajexp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要关注下上面的findAspectJAnnotationOnMethod方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> AspectJAnnotation&lt;?&gt; findAspectJAnnotationOnMethod(Method method) &#123;</span><br><span class="line">    <span class="comment">//看到了我们熟悉的切面方法注解，这里的beforePrint使用@Before注解</span></span><br><span class="line">   Class&lt;?&gt;[] classesToLookFor = <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] &#123;</span><br><span class="line">         Before.class, Around.class, After.class, AfterReturning.class, AfterThrowing.class, Pointcut.class&#125;;</span><br><span class="line">   <span class="keyword">for</span> (Class&lt;?&gt; c : classesToLookFor) &#123;</span><br><span class="line">      AspectJAnnotation&lt;?&gt; foundAnnotation = findAnnotation(method, (Class&lt;Annotation&gt;) c);</span><br><span class="line">      <span class="keyword">if</span> (foundAnnotation != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> foundAnnotation;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法就是查找切面方法是否使用了Before, Around, After，AfterReturning, AfterThrowing,Pointcut注解，如果使用了，则返回一个AspectJAnnotation对象，里面有一个annotation的泛型对象，这个泛型对象就是被设置为这些注解的值，而且还会获得这些注解里面配置的pointcut表达式内容，如果是引用的表达式方法，则将方法参数设置到pointcutExpression这个属性中。<br>解析完切面方法的注解后现在再回过头来看看如何创建一个advisor实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">InstantiationModelAwarePointcutAdvisorImpl</span><span class="params">(AspectJExpressionPointcut declaredPointcut,</span></span><br><span class="line"><span class="params">      Method aspectJAdviceMethod, AspectJAdvisorFactory aspectJAdvisorFactory,</span></span><br><span class="line"><span class="params">      MetadataAwareAspectInstanceFactory aspectInstanceFactory, <span class="type">int</span> declarationOrder, String aspectName)</span> &#123;</span><br><span class="line">           <span class="built_in">this</span>.declaredPointcut = declaredPointcut;</span><br><span class="line">           <span class="built_in">this</span>.aspectJAdviceMethod = aspectJAdviceMethod;</span><br><span class="line">           <span class="built_in">this</span>.aspectJAdvisorFactory = aspectJAdvisorFactory;</span><br><span class="line">           <span class="built_in">this</span>.aspectInstanceFactory = aspectInstanceFactory;</span><br><span class="line">           <span class="built_in">this</span>.declarationOrder = declarationOrder;</span><br><span class="line">           <span class="built_in">this</span>.aspectName = aspectName;</span><br><span class="line">            <span class="comment">//切面类是否是懒加载</span></span><br><span class="line">            <span class="keyword">if</span> (aspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) &#123;</span><br><span class="line">                <span class="comment">// Static part of the pointcut is a lazy type.</span></span><br><span class="line">                <span class="type">Pointcut</span> <span class="variable">preInstantiationPointcut</span> <span class="operator">=</span> Pointcuts.union(</span><br><span class="line">                    aspectInstanceFactory.getAspectMetadata().getPerClausePointcut(), <span class="built_in">this</span>.declaredPointcut);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Make it dynamic: must mutate from pre-instantiation to post-instantiation state.</span></span><br><span class="line">                <span class="comment">// If it&#x27;s not a dynamic pointcut, it may be optimized out</span></span><br><span class="line">                <span class="comment">// by the Spring AOP infrastructure after the first evaluation.</span></span><br><span class="line">                <span class="built_in">this</span>.pointcut = <span class="keyword">new</span> <span class="title class_">PerTargetInstantiationModelPointcut</span>(</span><br><span class="line">                    <span class="built_in">this</span>.declaredPointcut, preInstantiationPointcut, aspectInstanceFactory);</span><br><span class="line">                <span class="built_in">this</span>.lazy = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.pointcut = <span class="built_in">this</span>.declaredPointcut;</span><br><span class="line">                <span class="built_in">this</span>.lazy = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">//最终会执行到这里获取一个advice</span></span><br><span class="line">                <span class="built_in">this</span>.instantiatedAdvice = instantiateAdvice(<span class="built_in">this</span>.declaredPointcut);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h1 id="10-为切面方法创建Advice"><a href="#10-为切面方法创建Advice" class="headerlink" title="10 为切面方法创建Advice"></a>10 为切面方法创建Advice</h1><p>上面方法的最后一句instantiateAdvice(this.declaredPointcut)会创建一个advice，具体是调用getAdvice方法获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Advice <span class="title function_">getAdvice</span><span class="params">(Method candidateAdviceMethod, AspectJExpressionPointcut expressionPointcut,</span></span><br><span class="line"><span class="params">                        MetadataAwareAspectInstanceFactory aspectInstanceFactory, <span class="type">int</span> declarationOrder, String aspectName)</span> &#123;</span><br><span class="line">        <span class="comment">//获取切面类对象，这里是TracesRecordAdvisor</span></span><br><span class="line">        Class&lt;?&gt; candidateAspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();</span><br><span class="line">        validate(candidateAspectClass);</span><br><span class="line">        <span class="comment">//核心点1：获取切面注解，这里得方法是 beforePrint 使用了@Before注解</span></span><br><span class="line">        AspectJAnnotation&lt;?&gt; aspectJAnnotation =</span><br><span class="line">                AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod);</span><br><span class="line">        <span class="keyword">if</span> (aspectJAnnotation == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            ....................</span><br><span class="line">        AbstractAspectJAdvice springAdvice;</span><br><span class="line">        <span class="comment">//核心点2：根据注解转换后的 将注解生成不同的Advice类。</span></span><br><span class="line">        <span class="keyword">switch</span> (aspectJAnnotation.getAnnotationType()) &#123;</span><br><span class="line">            <span class="keyword">case</span> AtBefore:</span><br><span class="line">                springAdvice = <span class="keyword">new</span> <span class="title class_">AspectJMethodBeforeAdvice</span>(</span><br><span class="line">                        candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AtAfter:</span><br><span class="line">                springAdvice = <span class="keyword">new</span> <span class="title class_">AspectJAfterAdvice</span>(</span><br><span class="line">                        candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AtAfterReturning:</span><br><span class="line">                springAdvice = <span class="keyword">new</span> <span class="title class_">AspectJAfterReturningAdvice</span>(</span><br><span class="line">                        candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);</span><br><span class="line">                <span class="type">AfterReturning</span> <span class="variable">afterReturningAnnotation</span> <span class="operator">=</span> (AfterReturning) aspectJAnnotation.getAnnotation();</span><br><span class="line">                <span class="keyword">if</span> (StringUtils.hasText(afterReturningAnnotation.returning())) &#123;</span><br><span class="line">                    springAdvice.setReturningName(afterReturningAnnotation.returning());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AtAfterThrowing:</span><br><span class="line">                springAdvice = <span class="keyword">new</span> <span class="title class_">AspectJAfterThrowingAdvice</span>(</span><br><span class="line">                        candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);</span><br><span class="line">                <span class="type">AfterThrowing</span> <span class="variable">afterThrowingAnnotation</span> <span class="operator">=</span> (AfterThrowing) aspectJAnnotation.getAnnotation();</span><br><span class="line">                <span class="keyword">if</span> (StringUtils.hasText(afterThrowingAnnotation.throwing())) &#123;</span><br><span class="line">                    springAdvice.setThrowingName(afterThrowingAnnotation.throwing());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AtAround:</span><br><span class="line">                springAdvice = <span class="keyword">new</span> <span class="title class_">AspectJAroundAdvice</span>(</span><br><span class="line">                        candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AtPointcut:</span><br><span class="line">                <span class="comment">//这里对PointCut不做处理</span></span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">&quot;Processing pointcut &#x27;&quot;</span> + candidateAdviceMethod.getName() + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(</span><br><span class="line">                        <span class="string">&quot;Unsupported advice type on method: &quot;</span> + candidateAdviceMethod);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将切面类信息配置到SpringAdvice中</span></span><br><span class="line">        springAdvice.setAspectName(aspectName);</span><br><span class="line">        springAdvice.setDeclarationOrder(declarationOrder);</span><br><span class="line">        String[] argNames = <span class="built_in">this</span>.parameterNameDiscoverer.getParameterNames(candidateAdviceMethod);</span><br><span class="line">        <span class="keyword">if</span> (argNames != <span class="literal">null</span>) &#123;</span><br><span class="line">            springAdvice.setArgumentNamesFromStringArray(argNames);</span><br><span class="line">        &#125;</span><br><span class="line">        springAdvice.calculateArgumentBindings();</span><br><span class="line">        <span class="keyword">return</span> springAdvice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先来看看核心点1，上面其实已经看过了， 但是上面的方法作用仅仅是为了获取注解上的exression表达式的，这里再调用一遍就是为注解生成Advice类的，目的就是获取切面注解与AspectJAnnotation的映射类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> AspectJAnnotation&lt;?&gt; findAspectJAnnotationOnMethod(Method method) &#123;</span><br><span class="line">    <span class="comment">//看到了我们熟悉的切面方法注解，这里的beforePrint使用@Before注解</span></span><br><span class="line">   Class&lt;?&gt;[] classesToLookFor = <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] &#123;</span><br><span class="line">         Before.class, Around.class, After.class, AfterReturning.class, AfterThrowing.class, Pointcut.class&#125;;</span><br><span class="line">   <span class="keyword">for</span> (Class&lt;?&gt; c : classesToLookFor) &#123;</span><br><span class="line">      AspectJAnnotation&lt;?&gt; foundAnnotation = findAnnotation(method, (Class&lt;Annotation&gt;) c);</span><br><span class="line">      <span class="keyword">if</span> (foundAnnotation != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> foundAnnotation;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法就是查找切面方法是否实现了Before, Around, After，AfterReturning, AfterThrowing,Pointcut注解，如果实现了，则返回一个AspectJAnnotation对象，里面有一个annotation的泛型对象，这个泛型对象就是被设置为这些注解的值。最终这些对象会被转换成下面的对象存入AspectJAnnotation中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">       <span class="comment">//会将注解转换成后面的AspectJAnnotationType枚举的类。 </span></span><br><span class="line">       annotationTypes.put(Pointcut.class,AspectJAnnotationType.AtPointcut);</span><br><span class="line">       annotationTypes.put(After.class,AspectJAnnotationType.AtAfter);</span><br><span class="line">       annotationTypes.put(AfterReturning.class,AspectJAnnotationType.AtAfterReturning);</span><br><span class="line">       annotationTypes.put(AfterThrowing.class,AspectJAnnotationType.AtAfterThrowing);</span><br><span class="line">       annotationTypes.put(Around.class,AspectJAnnotationType.AtAround);</span><br><span class="line">       annotationTypes.put(Before.class,AspectJAnnotationType.AtBefore);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过核心点1，Spring已经将注解@Before对应转换为AtBefore，@After转换成AtAfter，以此类推，都会一一映射到了核心点2的switch的条件类了，在核心点2中，会为对应的切面注解类生成Advice类。 所有的注解切面类具体实现都是由AbstractAspectJAdvice这个抽象类实现的，这个类的构造函数有三个参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//切面方法 这里可能是beforePrint</span></span><br><span class="line">Method aspectJAroundAdviceMethod</span><br><span class="line"><span class="comment">//切入点表达式匹配器 这里指封装了exression的匹配器</span></span><br><span class="line">AspectJExpressionPointcut pointcut</span><br><span class="line"><span class="comment">//切面类  这里指TracesRecordAdvisor</span></span><br><span class="line">AspectInstanceFactory aif</span><br></pre></td></tr></table></figure><p>下面是Spring为对应注解生成对应的Advice类<br>|–|–|<br>|注解类|Advice 顾问方法|<br>|AtBefore|AspectJMethodBeforeAdvice|<br>|AtAfter|AspectJAfterAdvice|<br>|AtAfterReturning|AspectJAfterReturningAdvice|<br>|AtAfterThrowing|AspectJAfterThrowingAdvice|<br>|AtAround|AspectJAroundAdvice|</p><p>各个注解会在不同的实际执行自身增强方法，这个部分只是生成Advice类，然会放入到缓存中，等真正生成代理时就会调用这些方法。这个在创建代理的时候需要具体拆开说，至此，Spring将使用了@Aspect注解的切面类的切面方法，都转换成了对应的Adivsor类，这个类包含了切面方法，封装后的切点匹配器PointCut以及生成切面类的实例对象，通过这个类就可以匹配到符合条件的目标类的目标方法，然后执行增强操作了。</p><p>由切面注解生成的Advice类，最终会放入到一个缓存中，当生成目标bean的时候，会将所有所以能够匹配到目标bean的advice放入到集合中，由一个实现了MethodInvocation的类统一管理调用过程，这个类后面会详细说到，这里简单分析下AspectJAfterAdvice的invoke方法，看看它的调用过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//调用是实现了MethodInvocation方法的类 这个其实是个链式调用</span></span><br><span class="line"><span class="keyword">return</span> mi.proceed();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">//最终执行后置增强方法</span></span><br><span class="line">invokeAdviceMethod(getJoinPointMatch(), <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的invoke方法需要一个MethodInvocation的参数，上面的Advice类除了AspectJMethodBeforeAdvice之外，都实现了这个接口，所以可以实现链式调用，这个逻辑会在创建代理的具体讲解，这里只是简单分析下，这些advice的invoke方法规定了切面方法于要增强方法的执行时机。</p><h1 id="11-初探AOP代理"><a href="#11-初探AOP代理" class="headerlink" title="11 初探AOP代理"></a>11 初探AOP代理</h1><p>上面一部分操作主要是处理使用了@Aspect注解的切面类，然后将切面类的所有切面方法根据使用的注解生成对应的Advisor的过程，这个Advisor包含了切面方法，切入点匹配器和切面类，也就是准好了要增强的逻辑，接下来就是要将这些逻辑注入到合适的位置进行增强，这部分的操作就是由老生常谈的代理实现的了。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="title class_">Object</span> <span class="title function_">postProcessAfterInitialization</span>(<span class="title class_">Object</span> bean, <span class="title class_">String</span> beanName) throws <span class="title class_">BeansException</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="title class_">Object</span> cacheKey = <span class="title function_">getCacheKey</span>(bean.<span class="title function_">getClass</span>(), beanName);</span><br><span class="line">       <span class="comment">//如果要创建的类不是提前暴露的代理 则进入下面的方法</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">earlyProxyReferences</span>.<span class="title function_">contains</span>(cacheKey)) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="title function_">wrapIfNecessary</span>(bean, beanName, cacheKey);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建代理前，需要先校验bean是否需要创建代理</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) &#123;</span><br><span class="line">    <span class="comment">//如果bean是通过TargetSource接口获取 则直接返回</span></span><br><span class="line">   <span class="keyword">if</span> (beanName != <span class="literal">null</span> &amp;&amp; <span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">      <span class="keyword">return</span> bean;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">//如果bean是切面类 直接返回</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">Boolean</span>.FALSE.equals(<span class="keyword">this</span>.advisedBeans.<span class="keyword">get</span>(cacheKey))) &#123;</span><br><span class="line">      <span class="keyword">return</span> bean;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">//如果bean是Aspect 而且允许跳过创建代理， 加入advise缓存 返回</span></span><br><span class="line">   <span class="keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.advisedBeans.put(cacheKey, <span class="built_in">Boolean</span>.FALSE);</span><br><span class="line">      <span class="keyword">return</span> bean;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//如果前面生成的advisor缓存中存在能够匹配到目标类方法的Advisor 则创建代理</span></span><br><span class="line">   Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="literal">null</span>);</span><br><span class="line">   <span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line">      <span class="keyword">this</span>.advisedBeans.put(cacheKey, <span class="built_in">Boolean</span>.TRUE);</span><br><span class="line">       <span class="comment">//创建代理</span></span><br><span class="line">      Object proxy = createProxy(</span><br><span class="line">            bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));</span><br><span class="line">      <span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">      <span class="keyword">return</span> proxy;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">this</span>.advisedBeans.put(cacheKey, <span class="built_in">Boolean</span>.FALSE);</span><br><span class="line">   <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法很简单，主要的关注点在getAdvicesAndAdvisorsForBean和createProxy上，第一个是获取能够匹配目标类方法的Advisor集合，如果这个集合不为空，则代表该类需要被增强，需要生成代理，如果匹配不到，则表示该类并不需要被增强，无需创建代理。至于createProxy就很明显了，就是创建代理，这个方法里面决定了使用jdk代理还是cglib代理，并且用到了前面生成的Advisor实现增强功能。 这部分内容会放到下一篇文章中专门分析。</p><h1 id="12-总结"><a href="#12-总结" class="headerlink" title="12 总结"></a>12 总结</h1><p>简单总结一下，Spring AOP在初始阶段完成的主要任务：<br><strong>读取配置文件阶段：</strong></p><ul><li>读取xml文件遇到 <code>&lt;aop:aspectj-autoproxy/&gt;</code>标签时，找到命名空间处理器AopNamespaceHandler,然后找到处理该标签的类AspectJAutoProxyBeanDefinitionParser</li><li>通过AspectJAutoProxyBeanDefinitionParser的parse方法，将AspectJAwareAdvisorAutoProxyCreator注册到容器的声明周期中。<br><strong>创建bean阶段：</strong></li><li>执行AspectJAwareAdvisorAutoProxyCreator的postProcessBeforeInstantiation校验目标类是否是Aspect类和AOP基础类以及是否需要跳过不需要执行代理的类</li><li>获取beanDefinitions中所有使用了Aspect注解的类，然后将切面方法根据使用的注解生成Advisor类放入到缓存（关键）</li><li>调用AspectJAwareAdvisorAutoProxyCreator的postProcessAfterInitialization的方法，对需要增强的类创建代理。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java核心系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java核心 </tag>
            
            <tag> Java基础 </tag>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java核心系列8：Java如何保证线程安全性</title>
      <link href="/2025/04/02/Java%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/Java%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%868-Java%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7/"/>
      <url>/2025/04/02/Java%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/Java%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%868-Java%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Java内存模型（JMM）-如何解决并发问题"><a href="#1-Java内存模型（JMM）-如何解决并发问题" class="headerlink" title="1 Java内存模型（JMM） 如何解决并发问题"></a>1 Java内存模型（JMM） 如何解决并发问题</h1><p><strong>维度1：使用关键字、属性进行优化</strong></p><p>JMM本质实际就是：Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法。这些方法包括了：</p><ul><li>volatile、synchronized 和 final 关键字</li><li>Happens-Before 规则</li></ul><p><strong>维度2：从 顺序一致性、可见性、有序性、原子性角度</strong></p><ul><li>顺序一致性</li></ul><p>一个线程中的所有操作按照程序的顺序执行，不受其他线程的影响。</p><ul><li>原子性</li></ul><p>Java程序中，对数据的读和写操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行，否则会产生问题。<br>通过下面的案例可以看出，哪些是原子操作，哪些是非原子操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1个动作，线程直接将值赋给idx，也就是直接写到内存中</span></span><br><span class="line">idx = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3个动作：先定义 jdx，再读取idx的值，最后赋值给jdx</span></span><br><span class="line">jdx := idx</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3个动作：读取jdx的值，进行加1操作，然后新值重新写入新的值</span></span><br><span class="line">jdx ++</span><br></pre></td></tr></table></figure><p>从上面的案例中可以看中，只有第一个例子才是具备原子性的，因为他只有一个存的动作。至于其他的例子，包含读取、操作、赋值等多个动作，有一个动作失败则不成立。</p><p>所以，基本读取和赋值，Java内存模型可以保证原子性操作，如果要实现更大范围、步骤更多的操作的原子性，则需要通过synchronized或者Lock来实现。</p><p>synchronized和Lock的存在是为了够保证任一时刻只有一个线程能够执行该代码块，这样也就解决了原子性。</p><ul><li>可见性</li></ul><p>Java提供了volatile关键字来保证可见性，使用volatile来修饰共享变量，可以保证修改的值立即更新到主存中。这样其他线程读取数据时，始终都会从内存中读取到新值。</p><p>而普通的共享变量不能保证可见性，因为修改之后，不确定什么时候被写入主存，当其他Thread去读取时，内存中很有可能还是原来的旧值，所以无法保证可见性。</p><p>另外，通过synchronized关键字和Lock功能也能够保证可见性，因为能限制同一时刻只有一个线程获取锁然后执行同步代码，且在释放之前会将变量的修改更新到主存中。所以实时可见。</p><ul><li>有序性</li></ul><p>在Java里面，可以通过volatile关键字来保证一定的“有序性”。</p><p>另外，通过synchronized关键字和Lock功能也能够保证可见性，因为能限制同一时刻只有一个线程获取锁然后执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。</p><p>注：JMM是通过Happens-Before 规则来保证Thread操作有序性。</p><h2 id="2-1-关键字-volatile、synchronized-和-final"><a href="#2-1-关键字-volatile、synchronized-和-final" class="headerlink" title="2.1 关键字: volatile、synchronized 和 final"></a>2.1 关键字: volatile、synchronized 和 final</h2><p>在Java中，volatile、synchronized和final是三个非常重要的关键字，它们都与并发编程密切相关。下面是对这三个关键字的详细介绍：</p><h3 id="2-1-1-volatile"><a href="#2-1-1-volatile" class="headerlink" title="2.1.1 volatile"></a>2.1.1 volatile</h3><p>volatile是Java中的一种修饰符，它用于声明一个共享变量，以确保多个线程对该变量的访问是可见的和有序的。volatile关键字的作用是禁止指令重排和强制刷新缓存，以保证操作的顺序性和可见性。</p><p>当一个变量被声明为volatile时，它表示该变量的值可能会被意想不到地改变。编译器和处理器会注意到这个变量的特殊性，并采取相应的措施来保证多个线程对该变量的访问是正确的。具体来说，volatile关键字会禁止编译器对volatile变量进行优化，每次读取该变量时都会直接从它的内存地址中读取，而不是从寄存器或缓存中读取。同时，volatile关键字也会强制处理器在每个操作该变量的指令之后立即刷新缓存，以保证其他线程能够看到最新的值。</p><p>需要注意的是，虽然volatile关键字可以保证可见性和有序性，但它并不能保证原子性。也就是说，如果一个操作包含多个步骤，而这些步骤不能被一个指令替换，那么这个操作就不能被保证为原子性。在这种情况下，需要使用锁或者其他同步机制来保证原子性。</p><h3 id="2-1-2-synchronized"><a href="#2-1-2-synchronized" class="headerlink" title="2.1.2 synchronized"></a>2.1.2 synchronized</h3><p>synchronized是Java中的一种关键字，它用于实现同步代码块和方法。synchronized关键字可以保证同一时刻只有一个线程能够执行被synchronized修饰的代码块或方法。synchronized关键字会创建一个锁对象或锁标识符，当一个线程获取了这个锁对象或锁标识符后，其他线程就不能再获取这个锁对象或锁标识符，直到第一个线程释放了这个锁对象或锁标识符。</p><p>synchronized关键字可以保证多个线程对共享变量的访问是互斥的，也就是说在同一时刻只有一个线程能够访问共享变量。这样可以避免多个线程同时修改共享变量而导致数据不一致的问题。同时，synchronized关键字还可以保证多个线程之间的操作是有序的，即一个线程在执行synchronized代码块或方法之前必须等待其他线程完成之前的操作。</p><p>需要注意的是，synchronized关键字虽然可以保证互斥性和有序性，但它并不能保证原子性。也就是说，如果一个操作包含多个步骤，而这些步骤不能被一个指令替换，那么这个操作就不能被保证为原子性。在这种情况下，需要使用其他同步机制来保证原子性。</p><h3 id="2-1-3-final"><a href="#2-1-3-final" class="headerlink" title="2.1.3 final"></a>2.1.3 final</h3><p>final是Java中的一种修饰符，它用于声明一个最终变量或方法。final关键字表示该变量或方法不能被修改或重写。具体来说，final关键字可以用于声明一个常量，该常量的值不能被修改；也可以用于声明一个方法，该方法不能被重写。</p><p>final关键字在并发编程中也有着重要的作用。final关键字可以保证一个共享变量的值只被一个线程修改，这样可以避免多个线程同时修改共享变量而导致数据不一致的问题。同时，final关键字还可以保证一个方法的执行不会被其他线程中断或干扰，这样可以保证方法的原子性和可见性。</p><p>需要注意的是，final关键字并不能保证多个线程之间的操作是有序的。也就是说，在一个线程中执行final方法时，其他线程可能会同时执行自己的操作，而这些操作之间是没有顺序关系的。在这种情况下，需要使用其他同步机制来保证操作的顺序性。</p><h2 id="2-2-Happens-Before-规则"><a href="#2-2-Happens-Before-规则" class="headerlink" title="2.2 Happens-Before 规则"></a>2.2 Happens-Before 规则</h2><p>上面提到了可以用 volatile 和 synchronized 来保证有序性。除此之外，在JVM 中还有Happens-Before规则，用来确定并发操作之间的顺序关系。</p><p>Happens-Before规则定义了以下几种顺序关系：</p><h3 id="2-2-1-程序顺序规则（Program-Order-Rule）"><a href="#2-2-1-程序顺序规则（Program-Order-Rule）" class="headerlink" title="2.2.1 程序顺序规则（Program Order Rule）"></a>2.2.1 程序顺序规则（Program Order Rule）</h3><p>在一个程序中，按照代码的顺序，先执行的操作Happens-Before后执行的操作。这意味着在程序中，如果一个操作先于另一个操作执行，那么这个操作的结果对后续操作是可见的。</p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAPMaUep0s9i6B7J4M0_5mE3hgMmkgMAAuULaxunpzhWEIJNAd4lSE8BAAMCAAN4AAM2BA.png" alt="程序顺序规则"></p><h3 id="2-2-2-管程锁定规则（Monitor-Lock-Rule）"><a href="#2-2-2-管程锁定规则（Monitor-Lock-Rule）" class="headerlink" title="2.2.2 管程锁定规则（Monitor Lock Rule）"></a>2.2.2 管程锁定规则（Monitor Lock Rule）</h3><p>一个unlock操作先行发生于后面对同一个锁的lock操作。<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAPLaUepsGjsjrpgPnxIYsLvGgLsCdwAAuQLaxunpzhWXx3hv6JOovgBAAMCAAN5AAM2BA.png" alt="管程锁定规则"></p><h3 id="2-2-3-volatile变量规则（Volatile-Variable-Rule）"><a href="#2-2-3-volatile变量规则（Volatile-Variable-Rule）" class="headerlink" title="2.2.3 volatile变量规则（Volatile Variable Rule）"></a>2.2.3 volatile变量规则（Volatile Variable Rule）</h3><p>对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作，先写后读。<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAPKaUepjPks8Y6U1Ty5ZCn-a8R-M3kAAuMLaxunpzhW-spg20adwdgBAAMCAAN5AAM2BA.png" alt="volatile变量规则"></p><h3 id="2-2-4-线程启动规则（Thread-Start-Rule）"><a href="#2-2-4-线程启动规则（Thread-Start-Rule）" class="headerlink" title="2.2.4 线程启动规则（Thread Start Rule）"></a>2.2.4 线程启动规则（Thread Start Rule）</h3><p>Thread 对象的 start() 方法调用先行发生于此线程的每一个动作。<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAPJaUepceFgT1znaYKlNU4R0FNmaIUAAuELaxunpzhWFVMao-WL6a4BAAMCAAN5AAM2BA.png" alt="线程启动规则"></p><h3 id="2-2-5-线程加入规则-（Thread-Join-Rule）"><a href="#2-2-5-线程加入规则-（Thread-Join-Rule）" class="headerlink" title="2.2.5 线程加入规则(（Thread Join Rule）"></a>2.2.5 线程加入规则(（Thread Join Rule）</h3><p>Thread 对象的结束先行发生于 join() 方法返回。<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAPIaUepPEETisPsjID9A7_DlUmKBRsAAuALaxunpzhWNpI2Dr_LHlEBAAMCAAN5AAM2BA.png" alt="线程加入规则"></p><h3 id="2-2-6-线程终止规则（Thread-Termination-Rule）"><a href="#2-2-6-线程终止规则（Thread-Termination-Rule）" class="headerlink" title="2.2.6 线程终止规则（Thread Termination Rule）"></a>2.2.6 线程终止规则（Thread Termination Rule）</h3><p>线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join()方法和Thread.isAlive()的返回值等手段检测线程是否已经终止执行</p><h3 id="2-2-7-线程中断规则（-Thread-Interruption-Rule）"><a href="#2-2-7-线程中断规则（-Thread-Interruption-Rule）" class="headerlink" title="2.2.7 线程中断规则（ Thread Interruption Rule）"></a>2.2.7 线程中断规则（ Thread Interruption Rule）</h3><p>对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。</p><h3 id="2-2-8-对象终结规则（Finalizer-Rule）"><a href="#2-2-8-对象终结规则（Finalizer-Rule）" class="headerlink" title="2.2.8 对象终结规则（Finalizer Rule）"></a>2.2.8 对象终结规则（Finalizer Rule）</h3><p>一个对象的初始化完成(构造函数执行结束)先行发生于它的 finalize() 方法的开始。</p><h3 id="2-2-9-传递性（Transitivity）"><a href="#2-2-9-传递性（Transitivity）" class="headerlink" title="2.2.9 传递性（Transitivity）"></a>2.2.9 传递性（Transitivity）</h3><p>如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。</p><h1 id="3-线程安全性能讨论"><a href="#3-线程安全性能讨论" class="headerlink" title="3 线程安全性能讨论"></a>3 线程安全性能讨论</h1><p>在多线程环境中，一个类或者一个函数不管在何种运行时环境或交替执行方式，都能保证正确的行为，被安全的调用，就说明线程是安全的。</p><p>这个“正确的行为”通常包括原子性、可见性和有序性。</p><p>但是线程安全不是非真即假，共享数据按照安全程度的强弱顺序可以分成以下五类:</p><ul><li>不可变</li><li>绝对线程安全</li><li>相对线程安全</li><li>线程兼容</li><li>线程对立</li></ul><p>按照线程安全性的强弱顺序，不可变 &gt; 绝对线程安全 &gt; 相对线程安全 &gt; 线程兼容 &gt; 线程对立。</p><h2 id="3-1-不可变（Immutable）"><a href="#3-1-不可变（Immutable）" class="headerlink" title="3.1 不可变（Immutable）"></a>3.1 不可变（Immutable）</h2><p>不可变的对象在创建后其状态就不能被修改，因此它们自然是线程安全的。任何线程在任何时候访问这些对象，都会看到相同的数据。</p><p>多线程环境下，应当尽量使对象成为不可变，来满足线程安全。</p><p>不可变的类型包括:</p><ul><li>final 关键字修饰的基本数据类型</li><li>String</li><li>枚举类型</li><li>Number 部分子类，如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等大数据类型。但同为 Number 的原子类 AtomicInteger 和 AtomicLong 则是可变的</li></ul><p>对于集合类型，可以使用 Collections.unmodifiableXXX() 方法来获取一个不可变的集合。</p><blockquote><p>XXX 可以是Map、List、Set</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImmutableClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;String, Integer&gt; testMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Map&lt;String, Integer&gt; testUnmodifiable = Collections.unmodifiableMap(testMap);</span><br><span class="line">        testUnmodifiable.put(<span class="string">&quot;input-a&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行时抛出异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.UnsupportedOperationException</span><br><span class="line">    at java.util.Collections$testUnmodifiable.put(Collections.java:<span class="number">1523</span>)</span><br><span class="line">    at ImmutableExample.main(ImmutableClass.java:<span class="number">9</span>)</span><br></pre></td></tr></table></figure><p>不可变状态还可以这么理解，外部无法对数据状态进行修改，比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImmutableClass</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> value;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ImmutableClass</span><span class="params">(<span class="type">int</span> value)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.value = value;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> value;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，ImmutableClass是不可变的，因为它的构造函数是私有的，外部无法修改其状态。因此，多个线程同时访问和获取ImmutableClass对象的值时，不会出现数据不一致的问题。</p><h2 id="3-2-绝对线程安全（Absolute-Thread-Safety）"><a href="#3-2-绝对线程安全（Absolute-Thread-Safety）" class="headerlink" title="3.2 绝对线程安全（Absolute Thread Safety）"></a>3.2 绝对线程安全（Absolute Thread Safety）</h2><p>绝对线程安全的对象无论运行时环境如何，调用者都不需要任何额外的同步措施。这通常需要付出较大的代价来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadSafeClass</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> value;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(<span class="type">int</span> value)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.value = value;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> value;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，ThreadSafeClass的每个方法都使用了synchronized关键字进行同步。这保证了无论多少个线程同时访问ThreadSafeClass的对象，每个线程的操作都会被串行执行，不会出现数据竞争的问题。</p><h2 id="3-3-相对线程安全（Relative-Thread-Safety）"><a href="#3-3-相对线程安全（Relative-Thread-Safety）" class="headerlink" title="3.3 相对线程安全（Relative Thread Safety）"></a>3.3 相对线程安全（Relative Thread Safety）</h2><p>相对线程安全的对象需要保证单个操作是线程安全的，在调用的时候不需要做额外的保障措施。但在连续调用时可能需要额外的同步措施来保证调用的正确性。</p><p>Java 语言中，大部分的线程安全类都属于这种类型，例如 Vector、HashTable、Collections 的 synchronizedCollection() 方法包装的集合等。</p><p>以Hashtable为例，因为它的每个方法都是同步的。但是，如果多个线程连续调用Hashtable的不同方法（如put和get），仍然可能出现竞态条件。为了避免这种情况，调用者需要在外部进行额外的同步。</p><p>在下面代码中，如果Vector中的一个元素被线程A删除，而线程B试图获取一个已经被删除的元素，那么就会抛出 ArrayIndexOutOfBoundsException。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VectorUnsafeExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Vector&lt;Integer&gt; vector = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                vector.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</span><br><span class="line">                    vector.remove(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</span><br><span class="line">                    vector.get(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            executorService.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Exception in thread <span class="string">&quot;Thread-159738&quot;</span> java.lang.ArrayIndexOutOfBoundsException: Array index out of range: <span class="number">3</span></span><br><span class="line">    at java.util.Vector.remove(Vector.java:<span class="number">831</span>)</span><br><span class="line">    at VectorUnsafeExample.lambda$main$<span class="number">0</span>(VectorUnsafeExample.java:<span class="number">14</span>)</span><br><span class="line">    at VectorUnsafeExample$$Lambda$<span class="number">1</span>/<span class="number">713338599.</span>run(Unknown Source)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br></pre></td></tr></table></figure><p>如果要保证上面的代码能正确执行下去，就需要对删除元素和获取元素的代码进行同步。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 独立线程A执行删除操作</span><br><span class="line">executorService.execute(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (vector) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</span><br><span class="line">            vector.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"># 独立线程B执行读取操作</span><br><span class="line">executorService.execute(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (vector) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</span><br><span class="line">            vector.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="3-4-线程兼容（Thread-Compatibility）"><a href="#3-4-线程兼容（Thread-Compatibility）" class="headerlink" title="3.4 线程兼容（Thread Compatibility）"></a>3.4 线程兼容（Thread Compatibility）</h2><p>线程兼容的对象本身不是线程安全的，但可以通过在调用端添加额外的同步措施来保证在多线程环境下的安全使用。<br>Java API 中大部分的类都是属于线程兼容的，比如ArrayList类就不是线程安全的。如果多个线程同时修改ArrayList，可能会导致数据不一致。但是，如果调用者在修改ArrayList时使用synchronized块或其他同步机制进行同步，就可以保证线程安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadCompatibleClass</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> value;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(<span class="type">int</span> value)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.value = value;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> value;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，ThreadCompatibleClass的方法没有使用synchronized关键字进行同步。因此，如果多个线程同时修改ThreadCompatibleClass的对象，可能会导致数据不一致。</p><h2 id="3-5-线程对立（Thread-Hostility）"><a href="#3-5-线程对立（Thread-Hostility）" class="headerlink" title="3.5 线程对立（Thread Hostility）"></a>3.5 线程对立（Thread Hostility）</h2><p>线程对立的对象无论如何都无法在多线程环境下并发使用，即使采取了同步措施。</p><p>一个典型的例子是Java中的ThreadLocalRandom类。这个类用于生成随机数，并且每个线程都有其自己的随机数生成器实例。由于每个线程使用不同的实例，因此无需担心线程安全问题。但是，如果尝试在没有正确初始化ThreadLocalRandom的情况下跨线程使用它，就可能导致问题。</p><p>这种情况下，即使添加了同步措施也无法保证线程安全。</p><h1 id="4-如何实现线程安全"><a href="#4-如何实现线程安全" class="headerlink" title="4 如何实现线程安全"></a>4 如何实现线程安全</h1><h2 id="4-1-synchronized关键字-ReentrantLock特性"><a href="#4-1-synchronized关键字-ReentrantLock特性" class="headerlink" title="4.1 synchronized关键字&#x2F;ReentrantLock特性"></a>4.1 synchronized关键字&#x2F;ReentrantLock特性</h2><ul><li>synchronized关键字</li></ul><p>在Java中，synchronized关键字是一种内置的同步机制，用于控制多个线程对共享资源的访问。它用于在并发环境中保护代码块，确保同一时刻只有一个线程可以执行该代码块。</p><p>synchronized关键字可以应用于方法或代码块。当它应用于方法时，它将锁住该方法的对象。当它应用于代码块时，它将锁住指定的锁对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedExample</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">incrementCount</span><span class="params">()</span> &#123;  </span><br><span class="line">        count++;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个例子中，incrementCount()方法使用了synchronized关键字。这意味着在任何时刻，只有一个线程可以执行该方法。如果有其他线程试图同时执行该方法，它们将会被阻塞，直到当前线程完成该方法的执行。</p><ul><li>ReentrantLock特性</li></ul><p>ReentrantLock 是 Java 中的一个可重入锁，它是一种比 synchronized 关键字更灵活的线程同步机制。ReentrantLock 允许一个线程多次获取同一个锁，而不会产生死锁。它也支持公平锁和非公平锁，可以根据实际需求进行选择。</p><p>下面是一个使用 ReentrantLock 的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLockExample</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">incrementCount</span><span class="params">()</span> &#123;  </span><br><span class="line">        lock.lock();  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            count++;  </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">            lock.unlock();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> count;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的这个例子中，我们定义了一个 ReentrantLock 和一个计数器 count。</p><p>incrementCount() 方法使用 lock.lock() 获取锁，然后增加计数器的值，最后使用 lock.unlock() 释放锁。</p><p>getCount() 方法直接返回计数器的值，无需获取锁。<br>这种方式比使用 synchronized 关键字更灵活，因为它可以细粒度地控制需要同步的代码块，而不是整个方法。</p><p>★ 后续的章节会详细的介绍 synchronized关键字和ReentrantLock特性，敬请期待</p><h2 id="4-2-非阻塞同步"><a href="#4-2-非阻塞同步" class="headerlink" title="4.2 非阻塞同步"></a>4.2 非阻塞同步</h2><p>在JAVA中，互斥同步最主要的问题就是线程阻塞和唤醒所带来的开销导致的性能问题，这种同步也称为阻塞同步，是一种悲观的并发策略，无论共享数据是否真的会出现竞争，它都要进行加锁，这样 用户态核心态转换、维护锁计数器和阻塞检查、线程唤醒等操作都会产生大量的开销。</p><p>非阻塞同步是指在多线程环境下，不需要使用阻塞等待的方式来实现同步控制，线程可以一直进行计算操作，而不会被阻塞。下面介绍几种手段实现非阻塞同步。</p><ol><li><p>CAS</p><p>​        随着硬件指令集水平的发展，我们经常使用基于冲突检测的乐观并发策略: 先执行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施(始终重试，直至成功)。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。</p><p>​        乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。硬件支持的原子性操作最典型的是: 比较并交换(Compare-and-Swap，CAS)。</p><p>​        CAS操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值（B）。如果内存位置V的值与预期原值A相匹配，则将内存位置的值更新为B，否则不进行任何操作。在并发环境中，CAS操作可以保证数据的一致性和线程安全性。、</p></li><li><p>AtomicInteger</p><p>​        AtomicInteger是Java中的一个原子整数类，它提供了原子操作的更新方法，可以在多线程环境下安全地更新共享的整数变量。</p><p>​        AtomicInteger的更新方法包括incrementAndGet()、getAndIncrement()、decrementAndGet()、getAndDecrement()、compareAndSet()等，它们使用了 Unsafe 类的 CAS 操作，保证对共享变量的操作是原子性的。</p></li></ol><p>以下代码使用了 AtomicInteger 执行了计数操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicIntegerExample</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="comment">// 启动10个线程，每个线程将计数器加10  </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;  </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;  </span><br><span class="line">                    counter.incrementAndGet();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;).start();  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 等待所有线程执行完毕  </span></span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 输出计数器的值  </span></span><br><span class="line">        System.out.println(<span class="string">&quot;Counter: &quot;</span> + counter);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们使用AtomicInteger来维护一个计数器的值，并启动了10个线程，每个线程将计数器加10次。由于AtomicInteger提供了原子操作的更新方法，因此即使多个线程同时更新计数器的值，也不会出现线程安全问题。最后，我们输出计数器的值，可以看到它应该是100（10个线程每个线程执行10次计数器加1操作）。</p><p>3.ABA</p><p>如果某个线程将变量A更改为B后再更改为A，那么另一个等待CAS操作的线程会认为该变量没有发生过改变，仍然是A，然后执行CAS操作。这样就可能导致数据的不一致。</p><p>J.U.C 包提供了一个带有标记的原子引用类 AtomicStampedReference 来解决这个问题，它可以通过控制变量值的版本来保证 CAS 的正确性。大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效。</p><p>另外，Java 8引入了一种新的原子类：LongAdder和LongAccumulator，它们内部采用了分段化的思想来解决高并发下的ABA问题。它们将内部变量分为一个数组，每个线程更新自己的分段，最后再合并结果。这种方式既解决了ABA问题，又提高了并发性能。</p><h2 id="4-3-无同步方案"><a href="#4-3-无同步方案" class="headerlink" title="4.3 无同步方案"></a>4.3 无同步方案</h2><p>换一个思路，如果没有方法的计算不涉及共享数据，不需要进行同步，是不是就不需要任何同步措施去保证正确性，也就没有线程安全的问题。</p><ul><li>栈封闭：多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的。</li><li>线程本地存储(Thread Local Storage)：如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。</li><li>可重入代码(Reentrant Code)：可以在代码执行的任何时刻中断它，转而去执行另外一段代码(包括递归调用它本身)，而在控制权返回后，原来的程序不会出现任何错误。</li></ul><p>这块简单介绍，后续会有专门的章节进行学习</p><h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h1><ul><li>了解了多线程产生的原因，以及线程不安全的原因</li><li>从 可见性，原子性和有序性 来阐述并发状态下线程不安全的原因</li><li>分析了Java是怎么解决并发问题的</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java核心系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java核心 </tag>
            
            <tag> Java基础 </tag>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java核心系列9：并发与多线程-线程基础</title>
      <link href="/2025/04/02/Java%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/Java%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%869-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2025/04/02/Java%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/Java%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%869-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="1-先导"><a href="#1-先导" class="headerlink" title="1 先导"></a>1 先导</h1><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAPPaUesL_F-r5So1LRpVkY_N4GVDFEAAu8LaxunpzhWBkV1X6uJ4hYBAAMCAAN5AAM2BA.png" alt="线程安全基础概览图"><br>Java线程基础主要包含如下知识点，相信我们再面试的过程中，经常会遇到类似的提问。</p><ol><li>线程有哪几种状态? 线程之间如何转变？</li><li>线程有哪几种实现方式? 各优缺点？</li><li>线程的基本操作（线程管理机制）有哪些?</li><li>线程如何中断?</li><li>线程有几种互斥同步方式? 如何选择?</li><li>线程之间的协作方式（通信和协调）?</li></ol><p>下面我们 一 一 解读。</p><h1 id="2-线程的状态和流转"><a href="#2-线程的状态和流转" class="headerlink" title="2 线程的状态和流转"></a>2 线程的状态和流转</h1><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAPOaUer6dvmjBFagfhkaXqEfpl3ui4AAu0LaxunpzhWc0KL_3hfiHIBAAMCAAN5AAM2BA.png" alt="线程的几种状态"></p><h2 id="2-1-新建-New"><a href="#2-1-新建-New" class="headerlink" title="2.1 新建(New)"></a>2.1 新建(New)</h2><p>如上图，创建完线程，但尚未启动。</p><h2 id="2-2-可运行-Runnable"><a href="#2-2-可运行-Runnable" class="headerlink" title="2.2 可运行(Runnable)"></a>2.2 可运行(Runnable)</h2><p>如上图，处于可运行阶段，正在运行，或者正在等待 CPU 时间片。包含了 <code>Running</code> 和 <code>Ready</code> 两种线程状态。</p><h2 id="2-3-阻塞-Blocking"><a href="#2-3-阻塞-Blocking" class="headerlink" title="2.3 阻塞(Blocking)"></a>2.3 阻塞(Blocking)</h2><p>如上图，正被Lock住，等待获取一个排它锁，如果其他的线程释放了锁，该状态就会结束。</p><h2 id="2-4-无限期等待-Waiting"><a href="#2-4-无限期等待-Waiting" class="headerlink" title="2.4 无限期等待(Waiting)"></a>2.4 无限期等待(Waiting)</h2><p>如上图，处在无限期等待阶段，等待其它线程显式地唤醒，否则不会被分配 CPU 时间片。<br>主要有两种方式进行释放：</p><ul><li>调用方的线程执行完成</li><li>使用 Object.notify() &#x2F; Object.notifyAll()进行显性唤醒</li></ul><h2 id="2-5-限期等待-Timed-Waiting"><a href="#2-5-限期等待-Timed-Waiting" class="headerlink" title="2.5 限期等待(Timed Waiting)"></a>2.5 限期等待(Timed Waiting)</h2><p>如上图，因为有时间控制，所以无需等待其它线程显式地唤醒，一定时间之后，系统会自动唤醒。<br>所以他有三种方式进行释放：<br>主要有两种方式进行释放：</p><ul><li>调用方的线程执行完成</li><li>使用 Object.notify() &#x2F; Object.notifyAll()进行显性唤醒</li><li>时间到结束<ul><li>Thread.sleep()</li><li>Object.wait() 方法，带Timeout参数</li><li>Thread.join() 方法，带Timeout参数</li></ul></li></ul><h2 id="2-6-死亡-Terminated"><a href="#2-6-死亡-Terminated" class="headerlink" title="2.6 死亡(Terminated)"></a>2.6 死亡(Terminated)</h2><ul><li>线程结束任务之后结束</li><li>产生了异常并结束</li></ul><h1 id="3-线程实现方式"><a href="#3-线程实现方式" class="headerlink" title="3 线程实现方式"></a>3 线程实现方式</h1><p>在Java中，线程的实现方式主要有两种：继承<code>Thread</code>类和实现<code>Runnable</code>接口。此外，Java 5开始，引入了<code>java.util.concurrent</code>包，提供了更多的并发工具，如<code>Callable</code>接口与<code>Future</code>接口，它们主要用于任务执行。</p><h2 id="3-1-继承Thread类"><a href="#3-1-继承Thread类" class="headerlink" title="3.1 继承Thread类"></a>3.1 继承Thread类</h2><p>通过继承<code>Thread</code>类来创建线程是最基本的方式。你需要创建一个扩展自<code>Thread</code>类的子类，并重写其<code>run()</code>方法。然后，可以创建该子类的实例来创建新的线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程运行中&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        t.start(); <span class="comment">// 调用start()方法来启动线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-实现Runnable接口"><a href="#3-2-实现Runnable接口" class="headerlink" title="3.2 实现Runnable接口"></a>3.2 实现Runnable接口</h2><p>另一种方式是让你的类实现<code>Runnable</code>接口，并实现<code>run()</code>方法。然后，你可以创建<code>Thread</code>类的实例，将实现了<code>Runnable</code>接口的类的实例作为构造参数传递给它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程运行中&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        t.start(); <span class="comment">// 调用start()方法来启动线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-使用Callable和Future"><a href="#3-3-使用Callable和Future" class="headerlink" title="3.3 使用Callable和Future"></a>3.3 使用Callable和Future</h2><p>虽然<code>Callable</code>和<code>Future</code>不是直接用于创建线程的，但它们提供了一种更灵活的方式来处理线程执行的结果。<code>Callable</code>类似于<code>Runnable</code>，但它可以返回一个结果，并且可以抛出异常。<code>Future</code>用于获取<code>Callable</code>执行的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;任务完成&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">        Future&lt;String&gt; future = executor.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>());</span><br><span class="line">        System.out.println(future.get()); <span class="comment">// 阻塞等待获取结果</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4-优缺点解读"><a href="#3-4-优缺点解读" class="headerlink" title="3.4 优缺点解读"></a>3.4 优缺点解读</h2><ul><li><strong>继承Thread类</strong>：简单直观，但Java不支持多重继承，如果类已经继承了其他类，则不能再用这种方式。另外继承整个 Thread 类开销过大，太重了。</li><li><strong>实现Runnable接口</strong>：更加灵活，推荐的方式。</li><li><strong>Callable和Future</strong>：提供了更为强大的功能，例如返回执行结果和抛出异常，但通常用于与<code>ExecutorService</code>等高级并发工具一起使用。</li></ul><h1 id="4-线程管理机制"><a href="#4-线程管理机制" class="headerlink" title="4 线程管理机制"></a>4 线程管理机制</h1><p>Java 中的线程管理机制非常强大，涵盖了从简单的线程创建到复杂的线程池管理等多个方面。</p><h2 id="4-1-Executor-框架"><a href="#4-1-Executor-框架" class="headerlink" title="4.1 Executor 框架"></a>4.1 Executor 框架</h2><p><code>Executor</code> 框架是 Java 并发包（<code>java.util.concurrent</code>）中的一个关键组件，它提供了一种更高级别的抽象来管理线程池。通过使用 <code>Executor</code>，你可以更容易地控制线程的创建、执行、调度、生命周期等。它主要有三种类型：</p><ol><li>CachedThreadPool: 一个任务创建一个线程</li><li>FixedThreadPool: 所有任务只能使用固定大小的线程</li><li>SingleThreadExecutor: 单个线程，相当于大小为 1 的 FixedThreadPool。</li></ol><ul><li><p><strong>优点</strong>：提高程序性能和响应速度，通过复用线程来减少线程创建和销毁的开销，简化并发编程。</p></li><li><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WorkerThread</span>(<span class="string">&quot;&quot;</span> + i);</span><br><span class="line">    executor.execute(worker);</span><br><span class="line">&#125;</span><br><span class="line">executor.shutdown();</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-2-守护线程（Daemon-Threads）"><a href="#4-2-守护线程（Daemon-Threads）" class="headerlink" title="4.2 守护线程（Daemon Threads）"></a>4.2 守护线程（Daemon Threads）</h2><p>守护线程是一种特殊的线程，它主要用于程序中“后台”任务的支持。守护线程与普通线程的区别在于，当程序中所有非守护线程结束时，JVM 会自动退出，即使还有守护线程在运行。守护线程常用于垃圾回收、JVM 内部的监控等任务。<br><strong>设置守护线程</strong>：通过调用线程对象的 <code>setDaemon(true)</code> 方法，在启动线程之前将其设置为守护线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">thread.setDaemon(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h2 id="4-3-sleep-方法"><a href="#4-3-sleep-方法" class="headerlink" title="4.3 sleep() 方法"></a>4.3 sleep() 方法</h2><p><code>sleep()</code> 方法是 <code>Thread</code> 类的一个静态方法，用于让当前正在执行的线程暂停执行指定的时间（毫秒），以毫秒为单位。在指定的时间过去后，线程将回到可运行状态，等待CPU的调度。</p><ul><li><strong>用途</strong>：常用于线程间的简单同步。</li><li><strong>注意</strong>：<code>sleep()</code> 方法不会释放锁（如果当前线程持有锁的话）。</li><li><strong>示例</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">       Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="4-4-yield-方法"><a href="#4-4-yield-方法" class="headerlink" title="4.4 yield() 方法"></a>4.4 yield() 方法</h2><p><code>yield()</code> 方法也是 <code>Thread</code> 类的一个静态方法，它告诉调度器当前线程愿意放弃当前处理器的使用，但这并不意味着线程会立即停止执行或进入等待&#x2F;阻塞状态。</p><p>调度器可以忽略这个提示，继续让当前线程运行。</p><ul><li><strong>用途</strong>：提示调度器让出CPU时间，但具体是否让出取决于调度器的实现。</li><li><strong>注意</strong>：<code>yield()</code> 方法不会使线程进入阻塞状态，也不会释放锁（如果持有的话）,类似仅建议。</li><li><strong>示例</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.<span class="keyword">yield</span>();</span><br></pre></td></tr></table></figure><h1 id="5-线程中断方式"><a href="#5-线程中断方式" class="headerlink" title="5 线程中断方式"></a>5 线程中断方式</h1><p>在Java中，线程中断是一种重要的线程间通信机制，用于通知线程应该停止当前正在执行的任务。线程中断的方式主要有以下几种：</p><h2 id="5-1-使用interrupt-方法"><a href="#5-1-使用interrupt-方法" class="headerlink" title="5.1 使用interrupt()方法"></a>5.1 使用<code>interrupt()</code>方法</h2><p><code>interrupt()</code>方法是Java推荐的线程中断方式。它并不会直接停止线程，而是设置线程的中断状态为true。线程需要定期检查这个中断状态（通过<code>isInterrupted()</code>方法），并根据需要自行决定如何响应中断请求，比如退出循环、释放资源等。</p><ul><li><p><strong>优点</strong>：安全、灵活，符合Java的并发编程理念。</p></li><li><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">        <span class="comment">// 执行任务</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 线程中断后的清理工作</span></span><br><span class="line">&#125;);</span><br><span class="line">thread.start();</span><br><span class="line"><span class="comment">// 稍后中断线程</span></span><br><span class="line">thread.interrupt();</span><br></pre></td></tr></table></figure></li></ul><h2 id="5-2-使用Executor的中断操作"><a href="#5-2-使用Executor的中断操作" class="headerlink" title="5.2 使用Executor的中断操作"></a>5.2 使用<code>Executor</code>的中断操作</h2><ol><li>调用 Executor 的 shutdown() 方法，会等待线程都执行完毕之后再关闭</li><li>调用 Executor 的 shutdownNow() 方法，则相当于直接调用具体线程的 interrupt() 方法</li></ol><h1 id="6-线程互斥同步方式"><a href="#6-线程互斥同步方式" class="headerlink" title="6 线程互斥同步方式"></a>6 线程互斥同步方式</h1><p>Java中的线程互斥同步是并发编程中的一个重要概念，用于保证多个线程在访问共享资源时的互斥性，即同一时间只有一个线程能够访问某个资源。Java提供了多种机制来实现线程的互斥同步，主要包括以下几种方式：</p><h2 id="6-1-synchronized关键字"><a href="#6-1-synchronized关键字" class="headerlink" title="6.1 synchronized关键字"></a>6.1 synchronized关键字</h2><p><strong>1. 基本概念</strong>：synchronized是Java中最基本的同步机制，它可以用来修饰方法或代码块。当一个线程访问一个被synchronized修饰的方法或代码块时，其他试图访问该方法或代码块的线程将被阻塞，直到当前线程执行完毕释放锁。<br><strong>2. 使用方法</strong>：</p><ul><li>修饰方法：直接在方法声明上加上synchronized关键字，例如<code>public synchronized void method() &#123;...&#125;</code>。</li><li>修饰代码块：将需要同步的代码放在synchronized(对象) {…}中，这里的对象就是锁对象，例如<code>synchronized(this) &#123;...&#125;</code>或<code>synchronized(某个对象) &#123;...&#125;</code>。</li></ul><p><strong>3. 特性</strong>：</p><ul><li>可见性：synchronized不仅保证了互斥性，还保证了变量的可见性。当一个线程释放锁时，会将锁变量的值刷新到主存储器中，从而使其他线程可以看到最新的变量值。</li><li>可重入性：synchronized支持可重入性，即同一个线程可以多次获取同一个锁，而不会导致死锁。</li></ul><p><strong>4. 示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// synchronized修饰方法  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;  </span><br><span class="line">        count++;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> count;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSynchronized</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;  </span><br><span class="line">        <span class="type">Counter</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Counter</span>();  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;  </span><br><span class="line">                counter.increment();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;  </span><br><span class="line">                counter.increment();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">  </span><br><span class="line">        t1.start();  </span><br><span class="line">        t2.start();  </span><br><span class="line">  </span><br><span class="line">        t1.join();  </span><br><span class="line">        t2.join();  </span><br><span class="line">  </span><br><span class="line">        System.out.println(<span class="string">&quot;Final count: &quot;</span> + counter.getCount());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-2-ReentrantLock类"><a href="#6-2-ReentrantLock类" class="headerlink" title="6.2 ReentrantLock类"></a>6.2 ReentrantLock类</h2><ul><li><p><strong>基本概念</strong>：ReentrantLock是java.util.concurrent.locks包中的一个可重入锁，它提供了比synchronized更灵活的锁定机制。</p></li><li><p>使用方法</p><p>：</p><ul><li>创建锁对象：<code>ReentrantLock lock = new ReentrantLock();</code></li><li>加锁：<code>lock.lock();</code></li><li>释放锁：通常将释放锁的代码放在finally块中，以确保锁一定会被释放，例如<code>try &#123;...&#125; finally &#123; lock.unlock(); &#125;</code>。</li></ul></li><li><p>特性</p><p>：</p><ul><li>支持公平锁和非公平锁：通过构造器参数可以指定使用哪种锁，默认是非公平锁。</li><li>支持尝试获取锁：提供了<code>tryLock()</code>等方法，尝试获取锁，如果获取不到则不会阻塞线程。</li><li>支持中断锁定的线程：与synchronized不同，ReentrantLock的锁可以被中断。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CounterWithLock</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(); <span class="comment">// 创建ReentrantLock对象  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;  </span><br><span class="line">        lock.lock(); <span class="comment">// 加锁  </span></span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            count++;  </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">            lock.unlock(); <span class="comment">// 释放锁，放在finally块中确保一定会被释放  </span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;  </span><br><span class="line">        lock.lock(); <span class="comment">// 加锁  </span></span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="keyword">return</span> count;  </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">            lock.unlock(); <span class="comment">// 释放锁  </span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestReentrantLock</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;  </span><br><span class="line">        <span class="type">CounterWithLock</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CounterWithLock</span>();  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;  </span><br><span class="line">                counter.increment();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;  </span><br><span class="line">                counter.increment();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">  </span><br><span class="line">        t1.start();  </span><br><span class="line">        t2.start();  </span><br><span class="line">  </span><br><span class="line">        t1.join();  </span><br><span class="line">        t2.join();  </span><br><span class="line">  </span><br><span class="line">        System.out.println(<span class="string">&quot;Final count: &quot;</span> + counter.getCount());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-3-对比"><a href="#6-3-对比" class="headerlink" title="6.3 对比"></a>6.3 对比</h2><p>对于大多数简单场景，synchronized关键字是最直接、最简单的选择；而对于需要更灵活控制锁的场景，则可以考虑使用ReentrantLock等高级同步机制。</p><h1 id="7-线程协作（通信）方案"><a href="#7-线程协作（通信）方案" class="headerlink" title="7 线程协作（通信）方案"></a>7 线程协作（通信）方案</h1><p>Java中线程之间的协作主要可以通过多种机制实现，其中等待&#x2F;通知机制（<code>wait/notify/notifyAll</code>）和<code>join</code>方法是两种常用的方式。下面我将分别给出这两种方式的简单代码示例。</p><h2 id="7-1-等待-通知机制（wait-notify-notifyAll）"><a href="#7-1-等待-通知机制（wait-notify-notifyAll）" class="headerlink" title="7.1 等待&#x2F;通知机制（wait&#x2F;notify&#x2F;notifyAll）"></a>7.1 等待&#x2F;通知机制（wait&#x2F;notify&#x2F;notifyAll）</h2><p>等待&#x2F;通知机制依赖于Java中的<code>Object</code>类，因为<code>wait()</code>, <code>notify()</code>, 和 <code>notifyAll()</code> 方法都定义在<code>Object</code>类中。这些方法必须在同步块或同步方法中被调用，因为它们是用来控制对某个对象的访问的。</p><p><strong>示例代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitNotifyExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">ready</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doWait</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!ready) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.wait(); <span class="comment">// 当前线程等待</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt(); <span class="comment">// 保持中断状态</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当ready为true时，继续执行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doNotify</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            ready = <span class="literal">true</span>;</span><br><span class="line">            lock.notify(); <span class="comment">// 唤醒在此对象监视器上等待的单个线程</span></span><br><span class="line">            <span class="comment">// 或者使用 lock.notifyAll(); 唤醒所有等待的线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">WaitNotifyExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WaitNotifyExample</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread 1 is waiting&quot;</span>);</span><br><span class="line">            example.doWait();</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread 1 is proceeding&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>); <span class="comment">// 假设t2需要一些时间来完成准备工作</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread 2 is notifying&quot;</span>);</span><br><span class="line">            example.doNotify();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>t1</code>线程在<code>doWait()</code>方法中等待，直到<code>t2</code>线程调用<code>doNotify()</code>方法并设置<code>ready</code>为<code>true</code>。<code>t2</code>线程模拟了一些准备工作，并在之后唤醒<code>t1</code>。</p><h2 id="7-2-Join-方法"><a href="#7-2-Join-方法" class="headerlink" title="7.2 Join 方法"></a>7.2 Join 方法</h2><p><code>join</code>方法是<code>Thread</code>类的一个方法，用于让当前线程等待另一个线程完成其执行。</p><p><strong>示例代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JoinExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>); <span class="comment">// 假设t1执行需要一些时间</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread 1 completed&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t1.join(); <span class="comment">// 当前线程（main线程）等待t1完成</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Thread 1 has joined, continuing main thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>main</code>线程启动了一个新线程<code>t1</code>，并通过调用<code>t1.join()</code>等待<code>t1</code>完成。<code>t1</code>线程在完成后会打印一条消息，而<code>main</code>线程会在<code>t1</code>完成后继续执行并打印另一条消息。</p><h1 id="8-总结"><a href="#8-总结" class="headerlink" title="8 总结"></a>8 总结</h1><p>总结一下，我们讲了让如下内容</p><ol><li>线程流转状态</li><li>线程实现方式</li><li>线程基本操作</li><li>线程中断方案</li><li>线程互斥同步方法</li><li>线程协作（通信）方案</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java核心系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java核心 </tag>
            
            <tag> Java基础 </tag>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MQ系列1：消息中间件执行原理</title>
      <link href="/2025/03/22/MQ%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/MQ%E7%B3%BB%E5%88%971-%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/"/>
      <url>/2025/03/22/MQ%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/MQ%E7%B3%BB%E5%88%971-%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="1-关于消息中间件"><a href="#1-关于消息中间件" class="headerlink" title="1 关于消息中间件"></a>1 关于消息中间件</h1><h2 id="1-1-什么是消息中间件？"><a href="#1-1-什么是消息中间件？" class="headerlink" title="1.1 什么是消息中间件？"></a>1.1 什么是消息中间件？</h2><p>消息中间件是指在分布式系统中完成消息的发送和接收的基础软件。消息中间件也可以称消息队列（Message Queue &#x2F; MQ），用高效可靠的消息传递机制进行与平台无关的数据交流，并基于数据通信来进行分布式系统的集成。通过提供消息传递和消息队列模型，可以在分布式环境下扩展进程的通信。简而言之，互联网场景中经常使用消息中间件进行消息路由、订阅发布、异步处理等操作，来缓解系统的压力。</p><h2 id="1-2-它解决了我们哪些痛点？"><a href="#1-2-它解决了我们哪些痛点？" class="headerlink" title="1.2 它解决了我们哪些痛点？"></a>1.2 它解决了我们哪些痛点？</h2><p>1、<strong>解耦：</strong> 比如说系统A会交给系统B去处理一些事情，但是A不想直接跟B有关联，避免耦合太强，就可以通过在A，B中间加入消息队列，A将要任务的事情交给消息队列 ,B订阅消息队列来执行任务。</p><blockquote><p>这种场景很常见，比如A是订单系统，B是库存系统，可以通过消息队列把削减库存的工作交予B系统去处理。如果A系统同时想让B、C、D…多个系统处理问题的时候，这种优势就更加明显了。</p></blockquote><p>2、<strong>有序性：</strong> 先进先出原理，先来先处理，比如一个系统处理某件事需要很长一段时间，但是在处理这件事情时候，有其他人也发出了请求，可以把请求放在消息队里，一个一个来处理。</p><blockquote><p>对数据的顺序性和一致性有强需求的业务，比如同一张银行卡同时被多个入口使用，需要保证入账出账的顺序性，避免出现数据不一致。</p></blockquote><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAObaUYFJLQ7pjsv_wjaQZJkTuTV9YYAAkcLaxvRfjBWuagVQAkXvcABAAMCAAN4AAM2BA.png" alt="image"></p><p>3、<strong>消息路由：</strong> 按照不同的规则，将队列中消息发送到不同的其他队列中</p><blockquote><p>通过消息队列将不同染色的请求发送到不同的服务去操作。这样达成了流量按照业务拆分的目的。</p></blockquote><p>4、<strong>异步处理：</strong> 处理一项任务的时候，有3个步骤A、B、C，需要先完成A操作, 然后做B、C 操作。任务执行成功与否强依赖A的结果，但不依赖B、C 的结果。如果我们使用串行的执行方式，那处理任务的周期就会变长，系统的整体吞吐能力也会降低（在同一个系统中做异步其实也是比较大的开销），所以使用消息队列是比较好的办法。</p><blockquote><p>登录操作就是典型的场景：A：执行登录并得到结果、B：记录登录日志、C：将用户信息和Token写入缓存。 执行完A就可以从登录页跳到首页了，B、C让服务慢慢去消化，不阻塞当前操作。</p></blockquote><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAOcaUYF3hhpBJCSvYLoNydEDNNgk7gAAkgLaxvRfjBWcos2dsS1RTsBAAMCAAN4AAM2BA.png" alt="image"></p><p>5、<strong>削峰：</strong> 将峰值期间的操作削减，比如A同学的整个操作流程包含12个步骤，后续的11个步骤是不需要强关注结果的数据，可以放在消息队列中。</p><h1 id="2-消息中间件的执行原理"><a href="#2-消息中间件的执行原理" class="headerlink" title="2 消息中间件的执行原理"></a>2 消息中间件的执行原理</h1><h2 id="2-1-消息中间件的组成"><a href="#2-1-消息中间件的组成" class="headerlink" title="2.1 消息中间件的组成"></a>2.1 消息中间件的组成</h2><ul><li><strong>Broker：</strong> 消息服务器，作为Server提供消息核心服务</li><li><strong>Producer：</strong> 消息生产者，业务的发起方，负责生产消息传输给broker，</li><li><strong>Consumer：</strong> 消息消费者，业务的处理方，负责从broker获取消息并进行业务逻辑处理</li><li><strong>Topic：</strong> 主题，发布&#x2F;订阅模式下的消息统一汇集地，不同生产者向topic发送消息，由MQ服务器分发到不同的订阅者，实现消息的广播</li><li><strong>Queue：</strong> 队列，PTP模式下，特定生产者向特定queue发送消息，消费者订阅特定的queue完成指定消息的接收</li><li><strong>Message：</strong> 消息体，根据不同通信协议定义的固定格式进行编码的数据包，来封装业务数据，实现消息的传输</li></ul><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAOdaUYGc99pOnZuhSaO9erCk8pIDeMAAkkLaxvRfjBW10jlP04Fyd0BAAMCAAN4AAM2BA.png" alt="image"><br>这边以kafka为例子，这是典型的集群模式，Kafka通过Zookeeper管理集群配置，选举leader，以及在Consumer Group发生变化时进行rebalance。Producer使用push模式将消息发布到broker，Consumer使用pull模式从broker订阅并消费消息。</p><ul><li><strong>producer</strong> 负责生产消息</li><li><strong>consumer</strong> 负责消费消息</li><li><strong>broker</strong> 消息服务器，提供消息核心的处理工作</li><li><strong>zookeeper</strong> 用于生产者和消费者的注册与发现</li></ul><h2 id="2-2-消息中间件的模式分类"><a href="#2-2-消息中间件的模式分类" class="headerlink" title="2.2 消息中间件的模式分类"></a>2.2 消息中间件的模式分类</h2><h3 id="2-2-1-PTP点对点"><a href="#2-2-1-PTP点对点" class="headerlink" title="2.2.1 PTP点对点"></a>2.2.1 PTP点对点</h3><p>使用queue作为通信载体，消息生产者生产消息发送到queue中，然后消息消费者从queue中取出并且消费消息。消息被消费以后，queue中不再存储，所以消息消费者不可能消费到已经被消费的消息。 Queue支持存在多个消费者，但是对一个消息而言，只会有一个消费者可以消费。<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAOeaUYGhAWXlrbyHRPNw_QEDewk5mUAAkoLaxvRfjBWUaEvDZIELJMBAAMCAAN4AAM2BA.png" alt="image"><br><strong>点对点模式包含三个角色：</strong></p><ul><li>消息队列（Queue）</li><li>发送者(Sender)</li><li>接收者(Receiver)</li></ul><p>每个消息都被发送到一个特定的队列，接收者从队列中获取消息。队列保留着消息，可以放在内存 中也可以持久化，直到他们被消费或超时。</p><p><strong>特点：</strong></p><ul><li>每个消息只有一个消费者（Consumer）(即一旦被消费，消息就不再在消息队列中)</li><li>发送者和接收者之间在时间上没有依赖性</li><li>接收者在成功接收消息之后需向队列应答成功</li><li>利用FIFO先进先出的特性，可以保证消息的顺序性。</li></ul><h3 id="2-2-2-Pub-Sub发布订阅（广播）"><a href="#2-2-2-Pub-Sub发布订阅（广播）" class="headerlink" title="2.2.2 Pub&#x2F;Sub发布订阅（广播）"></a>2.2.2 Pub&#x2F;Sub发布订阅（广播）</h3><p>使用topic作为通信载体，消息生产者（发布）将消息发布到topic中，同时有多个消息消费者（订阅）消费该消息。和点对点方式不同，发布到topic的消息会被所有订阅者消费。queue实现了负载均衡，将producer生产的消息发送到消息队列中，由多个消费者消费。但一个消息只能被一个消费者接受，当没有消费者可用时，这个消息会被保存直到有一个可用的消费者。<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAOfaUYGl4tpXVUOCO8GCYZtIPP5nYMAAksLaxvRfjBWwtPeSF0tmvwBAAMCAAN4AAM2BA.png" alt="image"><br><strong>发布订阅模型包含三个角色：</strong></p><ul><li>主题（Topic）</li><li>发布者（Publisher）</li><li>订阅者（Subscriber）</li></ul><p>多个发布者将消息发送到Topic，系统将这些消息传递给多个订阅者。</p><p><strong>特点：</strong></p><ul><li>每个消息可以有多个消费者：和点对点方式不同，发布消息可以被所有订阅者消费</li><li>发布者和订阅者之间有时间上的依赖性。</li><li>针对某个主题（Topic）的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息。</li><li>为了消费消息，订阅者必须保持运行的状态。</li></ul><h2 id="2-3-消息中间件的优势"><a href="#2-3-消息中间件的优势" class="headerlink" title="2.3 消息中间件的优势"></a>2.3 消息中间件的优势</h2><p>系统解耦：交互系统之间没有直接的调用关系，只是通过消息传输，故系统侵入性不强，耦合度低。提高系统响应时间：例如原来的一套逻辑，可将紧急重要（需要立刻响应）的业务放到该调用方法中，响应要求不高的使用消息队列，放到MQ队列中，供消费者处理。为大数据处理架构提供服务：通过消息作为整合，大数据的背景下，消息队列还与实时处理架构整合，为数据处理提供性能支持。</p><h2 id="2-4-消息中间件常用协议"><a href="#2-4-消息中间件常用协议" class="headerlink" title="2.4 消息中间件常用协议"></a>2.4 消息中间件常用协议</h2><p>AMQP协议、MQTT协议、STOMP协议、XMPP协议、其他基于TCP&#x2F;IP自定义的协议消息中间件的组成</p><h3 id="2-4-1-AMQP"><a href="#2-4-1-AMQP" class="headerlink" title="2.4.1 AMQP"></a>2.4.1 AMQP</h3><p>AMQP即Advanced Message Queuing Protocol，是应用层协议的一个开放标准，为面向消息的中间件设计。消息中间件主要用于组件之间的解耦，消息的发送者无需知道消息使用者的存在，反之亦然。</p><p>AMQP 的主要特征是面向消息、队列、路由（包括点对点和发布&#x2F;订阅）、可靠性、安全。优点：可靠、通用。</p><h3 id="2-4-2-MQTT"><a href="#2-4-2-MQTT" class="headerlink" title="2.4.2 MQTT"></a>2.4.2 MQTT</h3><p>MQTT（Message Queuing Telemetry Transport，消息队列遥测传输）是IBM开发的一个即时通讯协议，有可能成为物联网的重要组成部分。该协议支持所有平台，几乎可以把所有联网物品和外部连接起来，被用来当做传感器和致动器（比如通过Twitter让房屋联网）的通信协议。优点：格式简洁、占用带宽小、移动端通信、PUSH、嵌入式系统。</p><h3 id="2-4-3-STOMP"><a href="#2-4-3-STOMP" class="headerlink" title="2.4.3 STOMP"></a>2.4.3 STOMP</h3><p>STOMP（Streaming Text Orientated Message Protocol）是流文本定向消息协议，是一种为MOM(Message Oriented Middleware，面向消息的中间件)设计的简单文本协议。STOMP提供一个可互操作的连接格式，允许客户端与任意STOMP消息代理（Broker）进行交互。优点：命令模式（非topic\queue模式）。</p><h3 id="2-4-4-XMPP"><a href="#2-4-4-XMPP" class="headerlink" title="2.4.4 XMPP"></a>2.4.4 XMPP</h3><p>XMPP（可扩展消息处理现场协议，Extensible Messaging and Presence Protocol）是基于可扩展标记语言（XML）的协议，多用于即时消息（IM）以及在线现场探测。适用于服务器之间的准即时操作。核心是基于XML流传输，这个协议可能最终允许因特网用户向因特网上的其他任何人发送即时消息，即使其操作系统和浏览器不同。优点：通用公开、兼容性强、可扩展、安全性高，但XML编码格式占用带宽大。</p><h2 id="2-5-主流的消息中间件"><a href="#2-5-主流的消息中间件" class="headerlink" title="2.5 主流的消息中间件"></a>2.5 主流的消息中间件</h2><p>常见的消息中间件包括：RabbitMQ、RocketMQ、kafka 等，后面我们会有一篇专门对这几种中间件的能力和技术参数做一项完整的对比，并给出不同业务场景下的技术选型建议。</p>]]></content>
      
      
      <categories>
          
          <category> MQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
            <tag> RabbitMQ </tag>
            
            <tag> RocketMQ </tag>
            
            <tag> kafka </tag>
            
            <tag> 消息中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MQ系列2：消息中间件的技术选型</title>
      <link href="/2025/03/22/MQ%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/MQ%E7%B3%BB%E5%88%972-%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/"/>
      <url>/2025/03/22/MQ%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/MQ%E7%B3%BB%E5%88%972-%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 背景</h1><p>在高并发、高消息吞吐的互联网场景中，我们经常会使用消息队列（Message Queue）作为基础设施，在服务端架构中担当消息中转、消息削峰、事务异步处理 等职能。</p><p>对于那些不需要实时响应的的业务，我们都可以放在消息队列中进行传输。下面是用户在进行系统注册的时候场景，充分体现MQ的作用</p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAOkaUYXIKdHP4S4Rn-G0tyLfxGu8tsAAmgLaxvRfjBWoOG_jBZSoEABAAMCAAN4AAM2BA.png"></p><p>可以看到用户注册的过程步骤1+步骤2，从请求到响应总共耗时 55 ms。消息消费+短信发送的时间比较长，从上面看花了5s多，一般让消息队列服务去处理，用户静静等待短信送达即可。</p><p>消息队列中间件（简称消息中间件）是指利用高效可靠的消息传递机制进行与平台无关的数据交流，并基于数据通信来进行分布式系统的集成。通过提供消息传递和消息排队模型，它可以在分布式环境下提供应用解耦、</p><p>弹性伸缩、冗余存储、流量削峰、异步通信、数据同步等等功能，其作为分布式系统架构中的一个重要组件，有着举足轻重的地位。</p><h1 id="2-消息中间件的组成"><a href="#2-消息中间件的组成" class="headerlink" title="2 消息中间件的组成"></a>2 消息中间件的组成</h1><ul><li><strong>Broker</strong>：消息服务器，以服务的形式运行在server端，给各个业务系统提供核心消息数据的中转服务。</li><li><strong>Producer</strong>：消息生产者，业务的发起方，负责生产消息传输给broker。</li><li><strong>Consumer</strong>：消息消费者，业务的处理方，负责从broker获取消息并进行业务逻辑处理</li><li><strong>Topic</strong>：主题模块，发布&#x2F;订阅模式下的消息统一汇集地，不同生产者向topic发送消息，由MQ服务器分发到不同的订阅者，实现消息的广播</li><li><strong>Queue</strong>：队列，PTP模式下，特定生产者向特定queue发送消息，消费者订阅特定的queue完成指定消息的接收。</li><li><strong>Message</strong>：消息体，根据不同通信协议定义的固定格式进行编码的数据包，来封装业务数据，实现消息的传输。</li></ul><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAOlaUYXKjClRSGkqaaP9RxK7q8ZhygAAmkLaxvRfjBWR4AgghyTq_EBAAMCAAN4AAM2BA.png" alt="消息中间件的组成部分"></p><p> 这边以kafka为例子，这是典型的集群模式，Kafka通过Zookeeper管理集群配置，选举leader，以及在Consumer Group发生变化时进行rebalance。Producer使用push模式将消息发布到broker，Consumer使用pull模式从broker订阅并消费消息。</p><ul><li><strong>producer</strong> 负责生产消息</li><li><strong>consumer</strong> 负责消费消息</li><li><strong>broker</strong> 消息服务器，提供消息核心的处理工作</li><li><strong>zookeeper</strong> 用于生产者和消费者的注册与发现</li></ul><h1 id="3-消息中间件的模式分类"><a href="#3-消息中间件的模式分类" class="headerlink" title="3 消息中间件的模式分类"></a>3 消息中间件的模式分类</h1><p>PTP点对点：使用queue作为通信载体 </p><p>消息生产者生产消息发送到queue中，然后消息消费者从queue中取出并且消费消息。 </p><p>不可重复消费，消息被消费以后，queue中不再存储，所以消息消费者不可能消费到已经被消费的消息。 Queue支持存在多个消费者，但是对一个消息而言，只会有一个消费者可以消费。</p><p>Pub&#x2F;Sub发布订阅（广播）：使用topic作为通信载体 </p><p>消息生产者（发布）将消息发布到topic中，同时有多个消息消费者（订阅）消费该消息。和点对点方式不同，发布到topic的消息会被所有订阅者消费，所以从1到N个订阅者都能得到这个消息的拷贝。</p><h1 id="4-消息中间件的优势"><a href="#4-消息中间件的优势" class="headerlink" title="4 消息中间件的优势"></a>4 消息中间件的优势</h1><p>系统解耦：交互系统之间没有直接的调用关系，只是通过消息传输，故系统侵入性不强，耦合度低。</p><p>削峰、提高系统响应时间：例如原来的一套逻辑，可将紧急重要（需要立刻响应）的业务放到该调用方法中，响应要求不高的使用消息队列，放到MQ队列中，供消费者处理。</p><p>业务的有序性处理：先来先处理，比如一个系统处理某件事需要很长一段时间，但是在处理这件事情时候，有其他人也发出了请求，可以把请求放在消息队里，一个一个来处理</p><p>为大数据处理架构提供服务：通过消息作为整合，大数据的背景下，消息队列还与实时处理架构整合，为数据处理提供性能支持。 </p><h1 id="5-消息中间件常用协议"><a href="#5-消息中间件常用协议" class="headerlink" title="5 消息中间件常用协议"></a>5 消息中间件常用协议</h1><p>AMQP协议、MQTT协议、STOMP协议、XMPP协议、其他基于TCP&#x2F;IP自定义的协议。</p><h1 id="6-丰富强大的消息中间件生态"><a href="#6-丰富强大的消息中间件生态" class="headerlink" title="6 丰富强大的消息中间件生态"></a>6 丰富强大的消息中间件生态</h1><p>目前开源的消息中间还是很丰富的，大家用的比较多的比如 ActiveMQ、RabbitMQ、Kafka、RocketMQ、ZeroMQ 等。</p><p>但是每个人的业务场景不一样，受限于系统的规模，业务的取舍（如延迟容忍度，死信、重试的需求，可持久化需求），并不是每一款消息中间件都能满足你的需求。</p><p>除了个别大厂会进行自研（如 阿里的Rocket MQ、滴滴的DD MQ）之外，大部分同学还是要对选型有一些思考的。各自都有各自的侧重点，选择合适自己、扬长避短无疑是最好的方式。</p><h2 id="6-1-主流MQ介绍"><a href="#6-1-主流MQ介绍" class="headerlink" title="6.1 主流MQ介绍"></a>6.1 主流MQ介绍</h2><p>下面基于受众程度，对三款主流的MQ做介绍，通过各项指标上的对比，给出我们在实际应用场景中的建议。</p><p><strong>RabbitMQ：</strong></p><p>采用 Erlang 语言实现的 AMQP 协议的消息中间件，起源于金融系统，广泛应用在分布式系统中，承担消息转发的职责。RabbitMQ 发展历史比较久远，影响范围比较大，被很多开发者认可，在可靠性、可用性、可扩展性、功能性方面有着非凡表现。</p><p><strong>RocketMQ：</strong></p><p>阿里开源的消息中间件，目前已经捐献给 Apache 基金会，它是由 Java 语言开发的，具备高吞吐量、高可用性、适合大规模分布式系统应用等特点。并且在阿里的双11、618等重要活动中经受住了考验。</p><p><strong>Kafka：</strong></p><p>起初是由 LinkedIn 公司采用 Scala 语言开发的一个分布式、多分区、多副本且基于 zookeeper 协调的分布式消息系统，现已捐献给 Apache 基金会。它是一种高吞吐量的分布式发布订阅消息系统，以可水平扩展和高吞吐率而被广泛使用。</p><p>目前越来越多的开源分布式处理系统如 Cloudera、Apache Storm、Spark、Flink 等都支持与 Kafka 集成。</p><h2 id="6-2-主流MQ对比"><a href="#6-2-主流MQ对比" class="headerlink" title="6.2 主流MQ对比"></a>6.2 主流MQ对比</h2><table><thead><tr><th><strong>特性</strong></th><th><strong>RabbitMQ</strong></th><th><strong>RocketMQ</strong></th><th><strong>kafka</strong></th></tr></thead><tbody><tr><td><strong>开发语言</strong></td><td>erlang</td><td>java</td><td>scala</td></tr><tr><td><strong>支持协议</strong></td><td>AMQP</td><td>自定义</td><td>基于TCP 自定义</td></tr><tr><td><strong>消息存储能力</strong></td><td>内存、磁盘。支持少量堆积。</td><td>磁盘。支持大量堆积。</td><td>内存、磁盘、数据库。支持大量堆积。</td></tr><tr><td><strong>消息事务性</strong></td><td>支持（信道设置事务模式，性能有影响）</td><td>支持</td><td>支持</td></tr><tr><td><strong>单机吞吐量</strong></td><td>万级</td><td>10万级+</td><td>10万级+</td></tr><tr><td><strong>时效性</strong></td><td>us级</td><td>ms级</td><td>ms级以内</td></tr><tr><td><strong>消息重复</strong></td><td>支持at least once、at most once</td><td>支持at least once</td><td>支持at least once、at most once</td></tr><tr><td><strong>消息回溯</strong></td><td>不支持</td><td>支持指定时间点的回溯</td><td>支持指定分区offset位置的回溯</td></tr><tr><td><strong>消息重试</strong></td><td>不支持，但可以设置autoACK&#x3D;false,未收到确认的会重入队列</td><td>支持</td><td>不支持，但可以通过消息回溯的方式来实现</td></tr><tr><td><strong>可用性</strong></td><td>高(主从架构)</td><td>非常高(分布式架构)</td><td>非常高(分布式架构)</td></tr><tr><td><strong>功能特性说明</strong></td><td>基于erlang开发，所以并发能力很强，性能极其好，延时很低;管理界面较丰富</td><td>MQ功能比较完备，扩展性佳</td><td>只支持主要的MQ功能，像一些消息查询，消息回溯等功能支持的不是很强，在大数据领域应用广。</td></tr></tbody></table><h2 id="6-3-选型建议"><a href="#6-3-选型建议" class="headerlink" title="6.3 选型建议"></a>6.3 选型建议</h2><h3 id="6-3-1-系统建设规模角度"><a href="#6-3-1-系统建设规模角度" class="headerlink" title="6.3.1 系统建设规模角度"></a>6.3.1 系统建设规模角度</h3><p>中小型系统建议选用RabbitMQ，数据量相对较小，选型应首选功能比较完备的，所以kafka排除。RocketMQ是阿里出品，如果阿里放弃维护，中小型公司一般很难投入人力进行RocketMQ的定制化开发，因此不推荐。</p><h3 id="6-3-2-业务规模角度"><a href="#6-3-2-业务规模角度" class="headerlink" title="6.3.2 业务规模角度"></a>6.3.2 业务规模角度</h3><p>根据具体使用规模在RocketMQ和kafka之间二选一。</p><p>大型业务系统：有实际的业务体量需求，比如足够大规模的分布式环境，以及足够大的数据量。这时候 RocketMQ 和 kafka 都是10w+的吞吐量，都可以在考虑范围内。</p><p>如果你有业务定制需求，可以优先选用RocketMQ，毕竟是开源的，大的业务系统也愿意花精力去优化JAVA源码的。至于kafka，根据业务方向选择，类似日志采集功能，首选kafka，因为他在日志上报、监控数据采集方面有着大规模的实践经验，这也是他们主打的应用场景。</p><p>具体该选哪个，看使用场景。引入MQ之后，也会有一定的弊端，必然一定程度上降低系统可用性，增加复杂性。</p><h3 id="6-3-3-功能性层面选型"><a href="#6-3-3-功能性层面选型" class="headerlink" title="6.3.3 功能性层面选型"></a>6.3.3 功能性层面选型</h3><table><thead><tr><th><strong>功能项</strong></th><th><strong>Kafka（1.1.0+）</strong></th><th><strong>RabbitMQ（3.6.10+）</strong></th></tr></thead><tbody><tr><td><strong>优先级队列</strong></td><td>不支持</td><td>支持：具有优先被消费的特权，建议优先级大小设置在10以内，否则价值不大</td></tr><tr><td><strong>延迟队列</strong></td><td>不支持</td><td>支持</td></tr><tr><td><strong>死信队列</strong></td><td>不支持</td><td>支持：保存无法被正确投递的消息，避免消息被无端丢弃。</td></tr><tr><td><strong>重试模式</strong></td><td>不支持</td><td>不支持：RabbitMQ中可以参考延迟队列实现一个重试队列，需要再封装一下，也不是太难。如果要在kafka中实现重试队列，首先要实现延迟队列的功能，相对比较复杂。</td></tr><tr><td><strong>消费模式</strong></td><td>拉 模式</td><td>推+拉 模式</td></tr><tr><td><strong>广播消费（pub&#x2F;sub）</strong></td><td>支持：kafka对广播消费的支持比较强大</td><td>支持：能力相比较kafka 弱一些</td></tr><tr><td><strong>消息回溯</strong></td><td>支持：kafka可以按照 offset（偏移量）和 timestamp（时间戳） 两种维度进行消息回溯。</td><td>不支持：RabbitMQ消息一旦被确认消费便丢弃</td></tr><tr><td><strong>消息堆积</strong></td><td>支持</td><td>支持：内存堆积过大会影响性能，如果仅考虑吞吐量因素，kafka的堆积效率比RabbitMQ总体高很多。</td></tr><tr><td><strong>持久化</strong></td><td>支持</td><td>支持</td></tr><tr><td><strong>消息追踪</strong></td><td>不支持：消息追踪可以通过外部系统来支持，但是支持粒度肯定没有内置的细腻</td><td>支持：RabbitMQ中可以采用Firehose 或者 rabbitmq_tracing插件实现。开启rabbitmq_tracing插件会大幅度影响性能，不建议在生产环境启用。使用 Firehose 与 外部 trace 系统结合的模式来提供更稳健的消息追踪能力。</td></tr><tr><td><strong>消息过滤</strong></td><td>客户端级别的支持</td><td>不支持，可以定制化封装</td></tr><tr><td><strong>多租户</strong></td><td>不支持</td><td>支持</td></tr><tr><td><strong>多协议支持</strong></td><td>只支持自定义协议，目前几个主流版本中存在兼容性问题。</td><td>RabbitMQ本身就是AMQP协议的实现，同时支持MQTT、STOMP等协议</td></tr><tr><td><strong>跨语言支持</strong></td><td>采用Scala和Java编写，支持多种语言的客户端</td><td>采用Erlang编写，支持多种语言的客户端</td></tr><tr><td><strong>流量控制</strong></td><td>支持client和user级别，可将流控配置在生产者和消费者层面</td><td>RabbitMQ的流控基于 Credit-Based 算法，是内部被动触发的保护机制，仅用于生产者层面。</td></tr><tr><td><strong>消息顺序性</strong></td><td>支持单分区（partition）级别的顺序性，在各自的分区中排序</td><td>顺序性消费的条件比较苛刻，需要单线程发送、单线程消费，这样吞吐量就下来了。而且无法使用延迟队列、优先队列等一些高级功能，所以一般不使用。</td></tr><tr><td><strong>安全机制</strong></td><td>（TLS&#x2F;SSL、SASL）身份认证和（读&#x2F;写）权限控制</td><td>与kafka相似</td></tr><tr><td><strong>幂等性</strong></td><td>单个生产者+单partition + 单会话 场景下，支持幂等性</td><td>不支持</td></tr><tr><td><strong>事务性消息</strong></td><td>支持</td><td>支持</td></tr></tbody></table><ul><li><p>**优先级队列：**可配置优先级，优先级高的消息具备优先被消费的特权，这样可以为下游服务提供不同消息级别的保证。这种模式只是在生产效率高于消费效率的时候才有效果。如果消费者的消费速度大于生产者的速度，消息中间件服务器（Broker）中没有消息堆积，就不存在对待消费数据进行优先级排序的需求了。</p></li><li><p><strong>延迟队列：</strong></p><p>延迟队列会存储对应的延迟消息，延迟消息是指消息被生产后，并不马上消费，而是等待一定时间后，消费者才拿到消息进行消费。延迟队列的模式分为两种，基于消息的延迟和基于队列的延迟。</p><ul><li>基于消息的延迟是指为每条消息设置不同的延迟时间，那么每当队列中有新消息进入的时候就会重新根据延迟时间排序，但是这会对性能造成很大的影响。</li><li>基于队列的延迟，设置不同延迟级别的队列，如 15s、30s、1m、10m 等，每个队列中消息的延迟时间都是相同的，这样不需要消耗大量性能去做延迟时间排序，每个消息都有固定的投递时间。</li></ul></li><li><p>**死信队列：**由于某些原因消息无法被正确的投递，为了确保消息不会被无故的丢弃，一般会存储到一个特殊的队列中，我们称之为死信队列。与此对应的还有一个“回退队列”的概念，试想如果消费者在消费时发生了异常，那么就不会对这一次消费进行确认（Ack）, 进而发生回滚消息的操作之后消息始终会放在队列的顶部，然后不断被处理和回滚，导致队列陷入死循环。为了解决这个问题，可以为每个队列设置一个回退队列，它和死信队列都是为异常的处理提供的一种机制保障。实际情况下，回退队列的角色可以由死信队列和重试队列来扮演。 </p></li><li><p>**重试队列：**重试队列其实可以看成是一种回退队列，具体指消费端消费消息失败时，为防止消息无故丢失而重新将消息回滚到 Broker 中。与回退队列不同的是重试队列一般分成多个重试等级，每个重试等级一般也会设置重新投递延时，重试次数越多投递延时就越大。比如第一次重试延迟时间为5s，再次消费失败后延迟重试时间为10s，以此类推，重试越多次重新投递的时间就越久。为了避免延迟时间被无限放大，需要有个重试次数限制，超过就写入死信队列。这边需要注意：延迟队列动作由内部触发，重试队列动作由外部消费端触发。 </p></li><li><p>**消费模式：**消费模式分为推（push）模式和拉（pull）模式。推模式是指由 Broker 主动推送消息至消费端，实时性较好，不过需要保证服务端推送的消息不会严重超过消费端消化能力。而拉模式是指消费端定时定量主动向 Broker 端请求拉取消息，虽然实时性较差，但是可以根据自身的消费能力来拉取。</p></li><li><p>**广播消费：**消息一般有两种发送模式：</p><ul><li><strong>点对点</strong>（P2P，Point-to-Point）模式和发布&#x2F;订阅（Pub&#x2F;Sub）模式。对于P2P模式而言，消息被消费以后，队列中不会再存储，即使有多个消费者，一条消息只会被一个消费者消费。</li><li>而发布订阅（Pub&#x2F;Sub）模式定义了如何向一个内容节点发布和订阅消息，这个内容节点称为主题（topic），主题可以认为是消息传递的中介，消息发布者将消息发布到某个主题，而消息订阅者则从主题中订阅消息。主题使得消息的订阅者与消息的发布者互相保持独立，不需要进行接触即可保证消息的传递，发布 &#x2F; 订阅模式在消息的一对多广播时采用。RabbitMQ 是一种典型的点对点模式，而 Kafka 是一种典型的发布订阅模式。</li></ul></li><li><p>**消息回溯：**一般消息在消费完成之后就被处理了，之后再也不能消费到该条消息。消息回溯正好相反，是指消息在消费完成之后，还能追溯到之前被消费掉的消息。</p></li><li><p>**消息堆积 + 持久化：**进行流量的削峰填谷是消息中间件的一个核心功能，实现的能力主要体现在消息堆积能力上。消息堆积分内存式堆积和磁盘式堆积。RabbitMQ 是典型的内存式堆积，可以通过一些方式持久化到磁盘中，但是会降低一些性能。Kafka 是典型的磁盘式堆积，所有的消息都存储在磁盘中，存储容量是有了很大的提升，但是磁盘性能会比内存差很多。</p></li><li><p>**消息追踪：**在消息中间件中，消息的链路追踪非常重要，它可以对生产和消费过的消息进行trace追踪。这样，在出现故障的时候，就可以快速的定位问题。</p></li><li><p>**消息过滤：**消息过滤是指按照既定的过滤规则为下游用户提供指定类别的消息。就以 kafka 而言，完全可以将不同类别的消息发送至不同的 topic 中，由此可以实现某种意义的消息过滤，或者 Kafka 还可以根据分区对同一个 topic 中的消息进行分类。不过更加严格意义上的消息过滤应该是对既定的消息采取一定的方式按照一定的过滤规则进行过滤。同样以 Kafka 为例，可以通过客户端提供的 ConsumerInterceptor 接口或者 Kafka Stream 的 filter 功能进行消息过滤。</p></li><li><p>**流量控制：**flow control，当生产者和消费者 处理速度不均衡问题，通过对生产者和消费者的限流，来保障两者的均衡。通常的流控方法有 Stop-and-wait、滑动窗口以及令牌桶等。</p></li><li><p>**消息顺序性：**顺序性是指保证消息有序，特别是分布式场景下，有序的执行，是保证一致性 (Consistency)的前提。</p></li><li><p>**消息幂等性：**对于确保消息在生产者和消费者之间进行传输而言一般有三种传输保障（delivery guarantee）：At most once，至多一次，消息可能丢失，但绝不会重复传输；At least once，至少一次，消息绝不会丢，但是可能会重复；Exactly once，精确一次，每条消息肯定会被传输一次且仅一次。对于大多数消息中间件而言，一般只提供 At most once 和 At least once 两种传输保障，对于第三种一般很难做到，由此消息幂等性也很难保证。</p></li><li><p>**事务性消息：**原子性事务中的操作为一个整体，要么都做，要么都不做。即一旦出错，就回滚事务，事务是由事务开始（Begin Transaction）和事务结束（End Transaction）之间执行的全体操作组成。Kafka 和 RabbitMQ 都支持，不过仅仅指的是生产者发送消息是一个事务性操作，要么发送成功，要么发送失败。</p></li></ul><h3 id="6-3-4-性能层面"><a href="#6-3-4-性能层面" class="headerlink" title="6.3.4 性能层面"></a>6.3.4 性能层面</h3><p>功能维度是消息中间件选型中的一个重要的参考维度，但性能也是考虑的一个重要环节。</p><p>吞吐量角度：Kafka 在开启幂等、事务功能的时候会使其性能降低，RabbitMQ 在开启 rabbitmq_tracing 插件的时候也会极大的影响其性能。消息中间件的性能一般是指其吞吐量，虽然从功能维度上来说，RabbitMQ 的优势要大于 Kafka，但是 Kafka 的吞吐量要比 RabbitMQ 高出 1 至 2 个数量级，一般 RabbitMQ 的单机 QPS 在万级别之内，而 Kafka 的单机 QPS 可以维持在十万级别，甚至可以达到百万级。</p><p>时延角度：另外一个是时延，作为性能维度的一个重要指标，却往往在消息中间件领域所被忽视，因为一般使用消息中间件的场景对时效性的要求并不是很高，如果要求时效性完全可以采用 RPC 的方式实现。消息中间件具备消息堆积的能力。Kafka是ms以内，RabbitMQ是us级别的。 </p><h3 id="6-3-5-高可用角度"><a href="#6-3-5-高可用角度" class="headerlink" title="6.3.5 高可用角度"></a>6.3.5 高可用角度</h3><p>高可用角度是指系统的出错概率和无故障运行时长。</p><p>如消息丢失，是使用消息中间件时所不得不面对的一个同点，其背后消息可靠性也是衡量消息中间件好坏的一个关键因素。尤其是在金融支付领域，消息可靠性尤为重要。然而说到可靠性必然要说到可用性，注意这两者之间的区别，消息中间件的可靠性是指对消息不丢失的保障程度；</p><p>而消息中间件的可用性是指无故障运行的时间百分比，通常用几个 9 来衡量，如 99.99% 就是一个不错的指标。</p><p>对应的 RabbitMQ 是通过镜像环形队列实现多副本及强一致性语义的。多副本可以保证在 master 节点宕机异常之后可以提升 slave 作为新的 master 而继续提供服务来保障可用性。</p><h3 id="6-3-6-运维管理层面"><a href="#6-3-6-运维管理层面" class="headerlink" title="6.3.6 运维管理层面"></a>6.3.6 运维管理层面</h3><p>消息中间件一个很重要的考虑层面是运维管理，比如：申请、审核、监控、告警、管理、容灾、部署等。</p><p>对消息中间件的使用 从使用、接入规范、全方位的监控、流量统计和分析等方面，提供有效的基准数据，也可以在检测到异常的情况配合告警，以便运维、开发人员的迅速介入。除了一般的监控项（比如硬件、GC 等）之外，对于消息中间件还需要关注端到端时延、消息审计、消息堆积等方面。</p><p>对于 RabbitMQ 而言，最正统的监控管理工具莫过于 rabbitmq_management 插件了，另外还有 AppDynamics, Collectd, DataDog, Ganglia 等多种优秀的产品。</p><p>Kafka 丰富的管理工具，比如：Kafka Manager, Kafka Monitor, Kafka Offset Monitor 等产品，其中 Cruise 还可以提供自动化运维的功能。</p><h3 id="6-3-7-社区力度及生态发展"><a href="#6-3-7-社区力度及生态发展" class="headerlink" title="6.3.7 社区力度及生态发展"></a>6.3.7 社区力度及生态发展</h3><p>Kafka 和 RabbitMQ 都有一系列开源的监控管理产品，社区活跃，产品生态都很不错。</p>]]></content>
      
      
      <categories>
          
          <category> MQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
            <tag> RabbitMQ </tag>
            
            <tag> RocketMQ </tag>
            
            <tag> kafka </tag>
            
            <tag> 消息中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL系列：SELECT COUNT的不同用法</title>
      <link href="/2025/03/22/MySQL%E7%B3%BB%E5%88%97/MySQL-SELECT%20COUNT%E7%9A%84%E4%B8%8D%E5%90%8C%E7%94%A8%E6%B3%95/"/>
      <url>/2025/03/22/MySQL%E7%B3%BB%E5%88%97/MySQL-SELECT%20COUNT%E7%9A%84%E4%B8%8D%E5%90%8C%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>今天团队在做线下代码评审的时候，发现同学们在代码中出现了select count(1) 、 select count(*)，和具体的select count(字段)的不同写法，本着分析的目的在会议室讨论了起来，那这几种写法究竟孰优孰劣呢，我们一起来看一下。</p><h3 id="讨论归纳"><a href="#讨论归纳" class="headerlink" title="讨论归纳"></a>讨论归纳</h3><p>先来看看MySQL官方对SELECT COUNT的定义：</p><p>传送门：<a href="https://dev.mysql.com/doc/refman/5.6/en/aggregate-functions.html#function_count">https://dev.mysql.com/doc/refman/5.6/en/aggregate-functions.html#function_count</a></p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAPTaUeyQJI5YwZkE0BpUfsJTR_GLPQAAgsMaxunpzhWdHtL9nXsFLcBAAMCAAN3AAM2BA.png"></p><p> 大概可以分下面这几个步骤讨论。</p><h4 id="COUNT-expr-的分析"><a href="#COUNT-expr-的分析" class="headerlink" title="COUNT(expr)的分析"></a>COUNT(expr)的分析</h4><p>COUNT(expr)函数返回的值是由SELECT语句检索的行中expr表达式非null的计数值，一个BIGINT的值。 如果没有匹配到数据，COUNT(expr)将返回0，通常有下面这三种用法：</p><p>1、COUNT(字段) 会统计该字段在表中出现的次数，忽略字段为null 的情况。即不统计字段为null 的记录。 </p><p>2、COUNT(*) 则不同，它执行时返回检索到的行数的计数，不管这些行是否包含null值，</p><p>3、COUNT(1)跟COUNT(*)类似，不将任何列是否null列入统计标准，仅用1代表代码行，所以在统计结果的时候，不会忽略列值为NULL的行。</p><p>所以执行以下数据会出现这样的结果（这边是故意给component字段设置了几个null值）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 select COUNT(*),COUNT(1),COUNT(component) from worklog;</span><br></pre></td></tr></table></figure><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAPUaUeyUAh8raHr4YfZn3b5uGX9h80AAg4MaxunpzhWOZxB8ShOZhUBAAMCAAN5AAM2BA.png"></p><p>归纳如下： </p><table><thead><tr><th>count(*)</th><th>包括了所有的列，相当于行数，在统计结果的时候，<strong>不会忽略列值为NULL</strong></th></tr></thead><tbody><tr><td>count(1)</td><td>包括了忽略所有列，用1代表代码行，在统计结果的时候，<strong>不会忽略列值为NULL</strong></td></tr><tr><td>count(字段)</td><td>只包括字段那一列，在统计结果的时候，会忽略列值为null的计数，<strong>即某个字段值为NULL时，不统计</strong>。</td></tr></tbody></table><h4 id="关于-COUNT-和-COUNT-1"><a href="#关于-COUNT-和-COUNT-1" class="headerlink" title="关于 COUNT(*) 和 COUNT(1)"></a>关于 COUNT(*) 和 COUNT(1)</h4><p>先看看COUNT(*)，MyISAM 引擎会把一个表的总行数记录了下来，所以在执行 COUNT<code>(*)</code> 的时候会直接返回数量，执行效率很高。对于InnoDB这样的事务性存储引擎， 因为增加了版本控制(MVCC)的原因，同时有多个事务访问数据并且有更新操作的时候，每个事务需要维护自己的可见性，那么每个事务查询到的行数也是不同的，所以不能缓存具体的行数，他每次都需要 <code>count</code> 计算一下所有的行数。</p><p>至于 COUNT(1) 和 COUNT(*)有什么区别呢，根据官网的内容（即上述截图倒数第二段），两种实现上其实一样：</p><p><strong><code>InnoDB handles SELECT COUNT(\*) and SELECT COUNT(1) operations in the same way. There is no performance difference.</code></strong> </p><p>因为COUNT(<em>) 不care返回值是否为空都会将改行纳入计算，所以他count了所有行数，而 COUNT(1) 中的 1 ，则是遇到了行的时候为恒真表达式，所以 COUNT(</em>) 还是 COUNT(1) 都是对所有的结果集进行 count，他们本质上没有什么区别。姑且认为 COUNT(*) ≈ COUNT(1)。 </p><h4 id="关于COUNT-字段"><a href="#关于COUNT-字段" class="headerlink" title="关于COUNT(字段)"></a>关于COUNT(字段)</h4><p>我们再来看看的COUNT(字段)，他的查询就简单粗暴了，就是进行全表扫描，然后判断拿到的字段的值是不是为NULL，不为NULL则累加。</p><p>相比COUNT(<em>)，COUNT(字段)多了一个步骤就是判断所查询的字段是否为NULL，所以他的性能要比COUNT(</em>)和COUNT(1)慢。 </p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>综上，COUNT(1)和 COUNT(*)表示的是直接查询符合条件的数据库表的行数。而COUNT(字段)表示的是查询符合条件的列的值，并判断不为NULL的行数的累计，效率自然会低一点,</p><p>除了查询得到结果集有区别之外，相比COUNT(1) 和 COUNT(字段)来讲，COUNT(*)是SQL92定义的标准统计数的语法，是官方提供的标准方案，基于此，MySQL数据库对他进行过很多优化。</p><p><strong>注：SQL92，是数据库的一个ANSI&#x2F;ISO标准。它定义了一种语言（SQL）以及数据库的行为（事务、隔离级别等）。</strong></p><p><strong>下面是对一张具有3400W数据的表的统计过程，comid是整型，可以对比下执行效率差异：</strong> </p><p> <img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAPWaUeypfGNji0XlT-j0CsOG9IpA04AAg8MaxunpzhWEFvCHoJfNnYBAAMCAAN5AAM2BA.png"></p><h4 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h4><p>根据总结的内容，从效率层面说，COUNT(<em>) ≈ COUNT(1) &gt; COUNT(字段)，又因为 COUNT(</em>)是SQL92定义的标准统计数的语法，<strong>我们建议使用 COUNT(*)。</strong></p><p>我们再来看看MySQL数据库做了哪些优化：以MySQL中比较常用的执行引擎InnoDB和MyISAM为例子。</p><p><strong>1、MyISAM不支持事务，MyISAM中的锁是表级锁；</strong></p><p>因为MyISAM的锁是表级锁，所以同一张表上面的操作是串行执行的，MyISAM把表的总行数单独记录下来，如果只是使用COUNT(*)对表进行查询的时候，可以直接返回这个记录的数值就可以了。</p><p>这样表中总行数记录即可提供给COUNT(*)查询使用，又因MyISAM数据库是表级锁，数据库行数不会被并行修改，所以行数是准确无误的。</p><p><strong>2、InnoDB支持事务，其中大部分操作都是行级锁。</strong></p><p>这样就不能愉快的做这种缓存操作了，因为表的行数可能会被并发修改，缓存记录下来的总行数就不准确了。</p><p>在InnoDB中，使用COUNT(<em>)查询行数的时候，不需要进行扫表，只要获取记录行数而已。所以官方在针对InnoDB的 SELECT COUNT(</em>) FROM 语句执行过程，会自动选择一个成本较低的索引进行的话，这样就可以大大节省时间。</p><p>InnoDB中索引分为聚簇索引（主键索引）和非聚簇索引（非主键索引），聚簇索引的叶子节点中保存的是整行记录，而非聚簇索引的叶子节点中保存的是该行记录的主键的值，非聚簇索引要比聚簇索引小很多，MySQL会优先选择最小的非聚簇索引来扫表，这样可以保证COUNT(*)的最优效率。</p><p>当查询语句中包含WHERE以及GROUP BY条件，会有一些其他的因素影响，所以要综合考虑。</p><h3 id="判断数据在否-COUNT怎么用？"><a href="#判断数据在否-COUNT怎么用？" class="headerlink" title="判断数据在否,COUNT怎么用？"></a>判断数据在否,COUNT怎么用？</h3><p>上面那种很获取COUNT数的场景多用于数据分页，数据统计的场景，有很多的情况则是直接判断数据是否存在，这种情况下，其实是不关心有多少数据。但是我们CoreReview的时候还是会很经常看到这种做法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">select COUNT(*) from test_ucsyncdetail where comid&gt;520;</span><br><span class="line"></span><br><span class="line">int count = testDao.CountByComId(comId);</span><br><span class="line">if(count&gt;0)&#123;</span><br><span class="line">   //存在，则执行存在分支的代码</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">  //不存在，则执行存在分支的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更好的写法应该是这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">select 1 from test_ucsyncdetail where comid&gt;520 limit 1;</span><br><span class="line"></span><br><span class="line">Object tda= testDao.checkExit(comId);</span><br><span class="line">if(tda != null)&#123;</span><br><span class="line">    //存在，则执行存在分支的代码</span><br><span class="line">&#125;</span><br><span class="line"> else&#123;</span><br><span class="line">   //不存在，则执行存在分支的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>规避了SQL使用COUNT表达式扫表的操作，而是改用SELECT 1 … LIMIT 1，数据库查询时遇到一条就返回，不会再继续查找和执行，如果存在传输回一条结果为1的数据 ，否则为null，业务代码中直接判断是否非空即可 </p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>细节把握的好不好，真的影响很大，接下来准备重新撸一下 《高性能MySQL》和《MySql笔记》。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis系列：聊聊布隆过滤器</title>
      <link href="/2025/03/20/Redis%E7%B3%BB%E5%88%97/Redis%E7%B3%BB%E5%88%97-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8(%E5%8E%9F%E7%90%86)/"/>
      <url>/2025/03/20/Redis%E7%B3%BB%E5%88%97/Redis%E7%B3%BB%E5%88%97-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8(%E5%8E%9F%E7%90%86)/</url>
      
        <content type="html"><![CDATA[<h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h1><p>布隆过滤器（Bloom Filter）是 Redis 4.0 版本之后提供的新功能，我们一般将它当做插件加载到 Redis Service服务器中，给 Redis 提供强大的滤重功能。</p><p>它是一种概率性数据结构，可用于判断一个元素是否存在于一个集合中。相比较之 Set 集合的去重功能，布隆过滤器空间上能节省90% +，不足之处是去重率大约在 99% 左右，那就是有 1% 左右的误判率，这种误差是由布隆过滤器的自身结构决定的。它有如下优缺点：</p><ul><li>优点：空间效率和查询时间都比一般的算法要好的多</li><li>缺点：有一定的误识别率和删除困难</li></ul><p>详细的原理可以参考笔者的这一篇 《<a href="https://yeoh.de5.net/2025/03/20/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%8E%9F%E7%90%86/">聊聊布隆过滤器（原理） | 数根朽木，</a>》。</p><h1 id="2-应用场景说明"><a href="#2-应用场景说明" class="headerlink" title="2 应用场景说明"></a>2 应用场景说明</h1><p>我们在遇到数据量大的时候，为了去重并避免大批量的重复计算，可以考虑使用 Bloom Filter 进行过滤。<br>具体常用的经典场景如下：</p><ul><li>解决大流量下缓存穿透的问题，参考笔者这篇 《<a href="https://yeoh.de5.net/2025/03/20/%E7%94%9F%E4%BA%A7%E4%BA%8B%E6%95%85%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E9%9B%AA%E5%B4%A9%E7%9A%84%E7%81%BE%E9%9A%BE%E5%A4%8D%E7%9B%98/">生产事故记录-一次雪崩的灾难复盘-转载 | 数根朽木，</a>》。</li><li>过滤被屏蔽、拉黑、减少推荐的信息，一般你在浏览抖音或者百度App的时候，看到不喜欢的会设置减少推荐、屏蔽此类信息等，都可以采用这种原理设计。</li><li>各种名单过滤，使用布隆过滤器实现第一层的白名单或者黑名单过滤，可用于各种AB场景。</li></ul><p>下面以缓存穿透为解决目标进行案例介绍。</p><h1 id="3-案例分析"><a href="#3-案例分析" class="headerlink" title="3 案例分析"></a>3 案例分析</h1><p>布隆过滤器的一个经典应用场景就是解决缓存穿透问题!</p><blockquote><p>缓存穿透是指访问一个不存在的key，缓存不起作用，请求会穿透到DB，流量井喷时会导致DB挂掉。</p></blockquote><p>比如 我们查询用户的信息，程序会根据用户的编号去缓存中检索，如果找不到，再到数据库中搜索。如果你给了一个不存在的编号：XXXXXXXX，那么每次都比对不到，就透过缓存进入数据库。这样风险很大，如果因为某些原因导致大量不存在的编号被查询，甚至被恶意伪造编号进行大规模攻击，那将是灾难。</p><p>解决方案质疑就是在缓存之前在加一层 BloomFilter ：</p><ul><li>把存在的key记录在BloomFilter中，在查询的时候先去 BloomFilter 去查询 key 是否存在，如果不存在则说明数据库和缓存都没有，就直接返回，</li><li>存在再走查缓存 ，投入数据库去查询，这样减轻了数据库的压力。</li></ul><h2 id="3-1-巨量查询场景"><a href="#3-1-巨量查询场景" class="headerlink" title="3.1 巨量查询场景"></a>3.1 巨量查询场景</h2><p>下面以火车票订购和查询为案例进行说明，如果火车票被恶意攻击，模拟了一样结构的火车票订单编号，那很可能通过大量的请求穿透过缓存层把数据库打雪崩了，所以使用布隆过滤器为服务提供一层保障。具体的做法就是，我们在购买火车票成功的时候，把订单号的ID写入（异步或者消息队列的方式）到布隆过滤器中，保障后续的查询都在布隆过滤器中走一遍再进到缓存中去查询。</p><h2 id="3-2-创建Bloom-Filter"><a href="#3-2-创建Bloom-Filter" class="headerlink" title="3.2 创建Bloom Filter"></a>3.2 创建Bloom Filter</h2><p>创建 Bloom Filter 的语法如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># BF<span class="selector-class">.RESERVE</span> &#123;key&#125; &#123;error_rate&#125; &#123;capacity&#125; <span class="selector-attr">[EXPANSION &#123;expansion&#125;]</span> <span class="selector-attr">[NONSCALING]</span></span><br><span class="line">BF<span class="selector-class">.RESERVE</span> ticket_orders <span class="number">0.01</span> <span class="number">1000000</span></span><br></pre></td></tr></table></figure><p>这边的命令是通过BF.RESERVE命令手动创建一个名字为 ticket_orders，错误率为 0.01 ，初始容量为 1000000 的布隆过滤器。<br>这边需要注意的一些点是：</p><ul><li>error_rate 越小，对碰撞的容忍度越小，需要的存储空间就越大。如果允许一定比例的不准确，对精确度要求不高的场景，error_rate 可以设的稍大一点。</li><li>capacity 设置的过大，会浪费存储空间，设置过小，准确度不高。所以评估的时候需要精准一点，既要避免浪费空间也要保证准确比例。</li></ul><p>原理不理解的请参考笔者的这一篇《<a href="https://yeoh.de5.net/2025/03/20/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%8E%9F%E7%90%86/">聊聊布隆过滤器（原理） | 数根朽木，</a>》。</p><h2 id="3-3-创建车票订单"><a href="#3-3-创建车票订单" class="headerlink" title="3.3 创建车票订单"></a>3.3 创建车票订单</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># BF.ADD &#123;key&#125;  &#123;value ... &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加单个订单号</span></span><br><span class="line">BF.ADD ticket_orders 1725681193-350000</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加多个订单号</span></span><br><span class="line">BF.MADD ticket_orders 1725681193-350000 1725681197-270001 1725681350-510007</span><br><span class="line">1) (<span class="built_in">integer</span>) 1</span><br><span class="line">2) (<span class="built_in">integer</span>) 1</span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><p>以上的语句是将已经订好的车票订单号存储到Bloom Filter中，包括一次存储单个和一次存储多个。</p><p>火车票订单同步到 Bloom Filter 的步骤如下：<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAOTaUNrqFO1x3979VDlGdz07_B594kAAoYLaxvvjBhWseNFeIUlOSoBAAMCAAN5AAM2BA.png"></p><h2 id="3-4-判断火车票订单Id是否存在"><a href="#3-4-判断火车票订单Id是否存在" class="headerlink" title="3.4 判断火车票订单Id是否存在"></a>3.4 判断火车票订单Id是否存在</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># BF.EXISTS &#123;key&#125; &#123;value&#125; ，存在的话返回 1，不存在返回 0</span></span><br><span class="line">BF.EXISTS ticket_orders 1725681193-350000</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量判断多个值是否存在于布隆过滤器，语句如下：</span></span><br><span class="line">BF.MEXISTS ticket_orders 1725681193-350000 1725681197-270001 1725681350-510007</span><br><span class="line">1) (<span class="built_in">integer</span>) 0</span><br><span class="line">2) (<span class="built_in">integer</span>) 1</span><br><span class="line">3) (<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><p>BF.EXISTS 判断一个元素是否存在于 Bloom Filter中，返回值 &#x3D; 1 表示存在，返回值 &#x3D; 0 表示不存在。可以一次性判断单个元素，或者一次性判断多个元素。</p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAOUaUNrum1KtVOS4VuDWgqATDOL_skAAocLaxvvjBhWsreKUiM0LsABAAMCAAN5AAM2BA.png"></p><p>综上，我们通过几个指令就能实现布隆过滤器的建设，避免缓存穿透的情况发生。如果你要查询缓存信息，必须先到Bloom Filter中先跑一次，不存在的直接过滤掉，这样就不会因为无效的key把缓存打穿。</p><h1 id="4-程序实现说明"><a href="#4-程序实现说明" class="headerlink" title="4 程序实现说明"></a>4 程序实现说明</h1><p>可以在 Golang 中使用 <code>go-redis/redis</code> 库来封装布隆过滤器功能。你需要先确保你的 Redis 服务器已经安装了 <code>RedisBloom</code> 模块，因为 Redis 本身并不直接支持布隆过滤器。一旦 <code>RedisBloom</code> 安装并配置好，你就可以在 Go 代码中通过 <code>go-redis/redis</code> 库来调用相关的 <code>RedisBloom</code> 命令。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> bloomfilter  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;context&quot;</span>  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span>  </span><br><span class="line">    <span class="string">&quot;github.com/go-redis/redis/v8&quot;</span>  </span><br><span class="line">)  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// BloomFilter 封装了与布隆过滤器相关的操作  </span></span><br><span class="line"><span class="keyword">type</span> BloomFilter <span class="keyword">struct</span> &#123;  </span><br><span class="line">    rdb  *redis.Client  </span><br><span class="line">    name <span class="type">string</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// NewBloomFilter 创建一个新的布隆过滤器实例  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBloomFilter</span><span class="params">(rdb *redis.Client, name <span class="type">string</span>)</span></span> *BloomFilter &#123;  </span><br><span class="line">    <span class="keyword">return</span> &amp;BloomFilter&#123;  </span><br><span class="line">        rdb:  rdb,  </span><br><span class="line">        name: name,  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Add 将元素添加到布隆过滤器中  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bf *BloomFilter)</span></span> Add(ctx context.Context, item <span class="type">string</span>, capacity <span class="type">int64</span>, errorRate <span class="type">float64</span>) <span class="type">error</span> &#123;  </span><br><span class="line">    <span class="comment">// 注意：RedisBloom 的 BF.ADD 命令通常不需要显式设置容量和错误率，  </span></span><br><span class="line">    <span class="comment">// 因为这些是在创建布隆过滤器时设置的。这里我们简化为只添加元素。  </span></span><br><span class="line">    <span class="comment">// 如果需要动态调整这些参数，你可能需要重新创建布隆过滤器。  </span></span><br><span class="line">    <span class="comment">// 但为了示例，我们假设这些参数在创建布隆过滤器时已经设置好了。  </span></span><br><span class="line">    _, err := bf.rdb.Do(ctx, <span class="string">&quot;BF.ADD&quot;</span>, bf.name, item).Result()  </span><br><span class="line">    <span class="keyword">return</span> err  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Exists 检查元素是否可能存在于布隆过滤器中  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bf *BloomFilter)</span></span> Exists(ctx context.Context, item <span class="type">string</span>) (<span class="type">bool</span>, <span class="type">error</span>) &#123;  </span><br><span class="line">    result, err := bf.rdb.Do(ctx, <span class="string">&quot;BF.EXISTS&quot;</span>, bf.name, item).Int()  </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>, err  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// BF.EXISTS 返回 1 表示可能存在，0 表示一定不存在  </span></span><br><span class="line">    <span class="keyword">return</span> result == <span class="number">1</span>, <span class="literal">nil</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 注意：在实际应用中，你可能还需要封装更多操作，比如删除布隆过滤器（虽然布隆过滤器通常不支持删除单个元素）  </span></span><br><span class="line"><span class="comment">// 或者调整布隆过滤器的容量和错误率（这通常意味着需要重新创建布隆过滤器）。  </span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    rdb := redis.NewClient(&amp;redis.Options&#123;  </span><br><span class="line">        Addr:     <span class="string">&quot;localhost:6379&quot;</span>, <span class="comment">// Redis 地址  </span></span><br><span class="line">        Password: <span class="string">&quot;&quot;</span>,              <span class="comment">// 密码（如果有的话）  </span></span><br><span class="line">        DB:       <span class="number">0</span>,               <span class="comment">// 使用的数据库  </span></span><br><span class="line">    &#125;)  </span><br><span class="line">  </span><br><span class="line">    bf := NewBloomFilter(rdb, <span class="string">&quot;myBloomFilter&quot;</span>)  </span><br><span class="line">  </span><br><span class="line">    ctx := context.Background()  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 添加元素  </span></span><br><span class="line">    err := bf.Add(ctx, <span class="string">&quot;item1&quot;</span>, <span class="number">100000</span>, <span class="number">0.01</span>) <span class="comment">// 注意：BF.ADD 命令通常不需要 capacity 和 errorRate  </span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">        <span class="built_in">panic</span>(err)  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 检查元素是否存在  </span></span><br><span class="line">    exists, err := bf.Exists(ctx, <span class="string">&quot;item1&quot;</span>)  </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">        <span class="built_in">panic</span>(err)  </span><br><span class="line">    &#125;  </span><br><span class="line">    fmt.Println(<span class="string">&quot;Exists:&quot;</span>, exists)  </span><br><span class="line">  </span><br><span class="line">    exists, err = bf.Exists(ctx, <span class="string">&quot;item2&quot;</span>)  </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">        <span class="built_in">panic</span>(err)  </span><br><span class="line">    &#125;  </span><br><span class="line">    fmt.Println(<span class="string">&quot;Exists:&quot;</span>, exists)  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 注意：上面的 Add 方法中的 capacity 和 errorRate 参数在 BF.ADD 命令中并不直接使用，  </span></span><br><span class="line"><span class="comment">// 因为 RedisBloom 的 BF.ADD 命令主要用于添加元素到已存在的布隆过滤器中。  </span></span><br><span class="line"><span class="comment">// 容量和错误率通常在创建布隆过滤器时通过 BF.RESERVE 命令设置。</span></span><br><span class="line">GO 折叠 复制 全屏</span><br></pre></td></tr></table></figure><p><strong>重要提示</strong>：</p><ul><li>在上面的代码中，<code>Add</code> 方法的 <code>capacity</code> 和 <code>errorRate</code> 参数并未直接用于 <code>BF.ADD</code> 命令，因为 <code>BF.ADD</code> 只是用于向已存在的布隆过滤器中添加元素。如果你需要设置布隆过滤器的容量和错误率，你应该在创建布隆过滤器时使用 <code>BF.RESERVE</code> 命令。</li><li>布隆过滤器不支持传统意义上的“删除”操作，因为一旦一个位被设置为 1，它就不能再被设置为 0（除非重新创建布隆过滤器）。</li><li>在实际部署之前，请确保你的 Redis 服务器已经安装了 RedisBloom 模块，并且 <code>go-redis/redis</code> 库与你的 Redis 服务器版本兼容。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 布隆过滤器 </tag>
            
            <tag> Boolean filter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>聊聊布隆过滤器（原理）</title>
      <link href="/2025/03/20/Redis%E7%B3%BB%E5%88%97/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%8E%9F%E7%90%86/"/>
      <url>/2025/03/20/Redis%E7%B3%BB%E5%88%97/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Bloom-Filter-介绍"><a href="#1-Bloom-Filter-介绍" class="headerlink" title="1 Bloom Filter 介绍"></a>1 Bloom Filter 介绍</h1><p>布隆过滤器（Bloom Filter）是 Redis 4.0 版本提供的新功能，我们一般将它当做插件加载到 Redis 服务器中，给 Redis 提供强大的去重功能。</p><p>它是一种概率性数据结构，可用于判断一个元素是否存在于一个集合中。相比较之 Set 集合的去重功能，布隆过滤器空间上能节省 90% +，不足之处是去重率大约在 99% 左右，那就是有 1% 左右的误判率，这种误差是由布隆过滤器的自身结构决定的。</p><ul><li>优点：空间效率和查询时间都比一般的算法要好的多</li><li>缺点：有一定的误识别率和删除困难</li></ul><h1 id="2-原理分析"><a href="#2-原理分析" class="headerlink" title="2 原理分析"></a>2 原理分析</h1><p>布隆过滤器（Bloom Filter）是一个高空间利用率的概率性数据结构，由二进制向量（即位数组）和一系列随机映射函数（即哈希函数）两部分组成。</p><p>通过使用exists()来判断某个元素是否存在于自身结构中。当布隆过滤器判定某个值存在时，其实这个值只是有可能存在；当它说某个值不存在时，那这个值肯定不存在，这个误判概率大约在 1% 左右。<br>原理拆解如下：</p><ul><li>在一个很长的二进制向量和一系列随机映射函数的基础上，将元素哈希成不同的位置，每个位置对应二进制向量中的一个比特位。</li><li>当加入一个元素时，采用 n 个相互独立的 Hash 函数计算key，然后将元素 Hash 映射的 n 个位置全部设置为 1。</li><li>检测 key 是否存在，仍然用 Hash 函数计算出这 n 个位置，如果元素key 存在于集合中，则对应的位置为1，否则为0。</li><li>如果n个位置均为1的话，可以确定元素key可能存在于集合中；如果有一个为0，那么元素的key一定不存在于集合中，下面会详细分析这句话。</li><li>这种判断机制会存在误判的可能，但它以较小的空间代价和极简的时间复杂度来近似解决集合交、并、差等操作。</li></ul><h2 id="2-1-添加元素步骤"><a href="#2-1-添加元素步骤" class="headerlink" title="2.1 添加元素步骤"></a>2.1 添加元素步骤</h2><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAOKaUNkuNITT55NuHtBB_hHjsqWRmAAAnULaxvvjBhWPEGSVEcrxqwBAAMCAAN4AAM2BA.png"></p><p>当使用布隆过滤器添加 key 时，会使用不同的 hash 函数对 key 存储的元素值进行哈希计算，从而会得到多个哈希值。根据哈希值计算出一个整数索引值，将该索引值与位数组长度做取余运算，最终得到一个位数组位置，并将该位置的值变为 1。每个 hash 函数都会计算出一个不同的位置，然后把数组中与之对应的位置变为 1。这边可能出现元素碰撞的情况，比如位置3，a元素和b元素的hash计算位置一致，所以出现了碰撞。</p><h2 id="2-2-判定元素是否存在步骤"><a href="#2-2-判定元素是否存在步骤" class="headerlink" title="2.2 判定元素是否存在步骤"></a>2.2 判定元素是否存在步骤</h2><p>如果我们要判定一个元素是否存在，需要如下步骤：</p><ul><li>首先对给定元素key执行哈希计算，这样可以得到元素增加时的bit位数组位置</li><li>判断这些位置是否都为 1，如果其中有一个为 0，那么说明元素不存在</li><li>若全部位置都为 1，则说明元素有可能存在。</li></ul><p>为啥说是可能存在呢，因为上面说过了，哈希函数出的结果会出现碰撞，所以布隆过滤器会存在误判。<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAOJaUNkqUSOem2FWjXrb5BATTLzKSYAAnQLaxvvjBhWbkntPOpsnD0BAAMCAAN3AAM2BA.png"><br>如上图c，他的位置被其他元素的位置完全覆盖，即使c没有存储，对应位置上也被a和b的Hash函数设置为1，这时候就可能误判为c是有存储的。</p><p>有概率存在这样的 key，它们内容不同，但多次 Hash 后的 Hash 值都相同。</p><h2 id="2-3-元素删除步骤"><a href="#2-3-元素删除步骤" class="headerlink" title="2.3 元素删除步骤"></a>2.3 元素删除步骤</h2><p>一般不会删除元素，我们上面说了，因为可能存在碰撞情况，所以也有可能存在误删除情况。<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAOIaUNkmx3bJvYuDMhX_IP1XLiWrB0AAnMLaxvvjBhWJf1kEcE_z_ABAAMCAAN4AAM2BA.png"><br>删除意味着需要将对应的 n 个 bits 位置设置为 0，其中有可能是其他元素对应的位。</p><p>比如图中的b删除之后，位置3的值也被设置为0，这样a也可能会被判定为不存在。</p><h1 id="3-使用场景介绍"><a href="#3-使用场景介绍" class="headerlink" title="3 使用场景介绍"></a>3 使用场景介绍</h1><p>我们在遇到数据量大的时候，为了去重并避免大批量的重复计算，可以考虑使用 Bloom Filter 进行过滤。<br>具体常用的经典场景如下：</p><ul><li>解决大流量下缓存穿透的问题，参考笔者这篇《<a href="https://yeoh.qzz.io/2025/03/20/%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%80%9D%E7%BB%B4/%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%80%9D%E7%BB%B4-%E4%B8%80%E6%AC%A1%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E7%9A%84%E7%81%BE%E9%9A%BE%E5%A4%8D%E7%9B%98/">架构与思维-一次缓存雪崩的灾难复盘-转载 | 数根朽木，</a>》。</li><li>过滤被屏蔽、拉黑、减少推荐的信息，一般你在浏览抖音或者百度App的时候，看到不喜欢的会设置减少推荐、屏蔽此类信息等，都可以采用这种原理设计。</li><li>各种名单过滤，使用布隆过滤器实现第一层的白名单或者黑名单过滤，可用于各种AB场景。</li></ul><h1 id="4-安装集成"><a href="#4-安装集成" class="headerlink" title="4 安装集成"></a>4 安装集成</h1><p>如果是自己编译安装，可以从 github 下载，目前的latest 的 release 版本是 v2.8.17，下载地址如下：<br><a href="https://github.com/RedisBloom/RedisBloom/releases">Releases · RedisBloom&#x2F;RedisBloom</a><br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAOHaUNkXoVEDrksPnJjc9DMY8Awp18AAnILaxvvjBhWl6pyugEha7UBAAMCAAN3AAM2BA.png"></p><p>直接按照编译的方式进行安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解压文件：</span></span><br><span class="line">tar -zxvf tar -zxvf RedisBloom-2.4.5.tar.gz</span><br><span class="line"><span class="comment"># 进入目录：</span></span><br><span class="line"><span class="built_in">cd</span> RedisBloom-2.4.5</span><br><span class="line"><span class="comment"># 执行编译命令，生成redisbloom.so 文件：</span></span><br><span class="line">make</span><br><span class="line"><span class="comment"># 拷贝至指定目录：</span></span><br><span class="line"><span class="built_in">cp</span> redisbloom.so /usr/local/redis/RedisBloom-2.4.5/redisbloom.so</span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要修改 redis.conf 文件，新增 loadmodule配置，并重启 Redis。</span></span><br><span class="line"><span class="comment"># 在redis配置文件里加入以下配置：</span></span><br><span class="line">loadmodule /usr/local/redis/RedisBloom-2.4.5/redisbloom.so</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置完成后重启redis服务：</span></span><br><span class="line">redis-server /usr/local/redis/RedisBloom-2.4.5/redis.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试是否安装成功</span></span><br><span class="line">127.0.0.1:6379&gt; bf.add user brand</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; bf.exists user brand</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 布隆过滤器 </tag>
            
            <tag> Boolean filter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生产事故记录-一次缓存雪崩的灾难复盘-转载</title>
      <link href="/2025/03/20/%E6%8E%92%E5%BF%A7%E8%A7%A3%E9%9A%BE/%E7%94%9F%E4%BA%A7%E4%BA%8B%E6%95%85%E8%AE%B0%E5%BD%95-%E4%B8%80%E6%AC%A1%E9%9B%AA%E5%B4%A9%E7%9A%84%E7%81%BE%E9%9A%BE%E5%A4%8D%E7%9B%98/"/>
      <url>/2025/03/20/%E6%8E%92%E5%BF%A7%E8%A7%A3%E9%9A%BE/%E7%94%9F%E4%BA%A7%E4%BA%8B%E6%95%85%E8%AE%B0%E5%BD%95-%E4%B8%80%E6%AC%A1%E9%9B%AA%E5%B4%A9%E7%9A%84%E7%81%BE%E9%9A%BE%E5%A4%8D%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<h3 id="1-真实案例"><a href="#1-真实案例" class="headerlink" title="1 真实案例"></a>1 真实案例</h3><p>云办公系统用户实时信息查询功能优化发布之后，系统发生宕机事件（系统挂起，页面无法加载）。</p><h4 id="1-1-背景"><a href="#1-1-背景" class="headerlink" title="1.1 背景"></a>1.1 背景</h4><p>我们IM原有的一个功能，当鼠标移动到用户头像的时候，会显示出用户的基本信息。信息比较简单，只包含简单的用户名、昵称、性别、邮箱、电话等基本数据，</p><p>这是一个典型的数据查询，大概过程如下左侧，访问用户基本信息的时候会先去Redis中查一下，如果不存在，就把大约2W左右的用户数据一次性取出来，保存在Redis中，因为用户基本信息在同一张表上，用户信息表的数据量也很少，所以一直也没什么问题。</p><p>过程如下图左侧所示。</p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAOSaUNrStEM8GAZEw1aXHsLidz7AAEdAAKFC2sb74wYVpM-hgZIuF_XAQADAgADeQADNgQ.png" alt="点击查看大图"> </p><p>后续对功能做了优化，原有采集的信息除了用户的基本信息之外，还采集了教育经历、工作经历、所获勋章等。</p><p>这些信息存储在不同的表里面，所以采集过程是一个复杂的联表查询，特别是有些基础表数据量比较大，执行效率也是比较慢的。</p><p>如果把所有用户全部取出来并存储在一个Redis节点中，明显已经不适用，一个是批量查询导致数据库执行效率慢，一个是Redis单节点数据太大。</p><p>所以开发同学做了下优化，每次只取单个用户的综合信息存在Redis中，一个用户建一个缓存，如上图右侧所示。 </p><h4 id="1-2-问题处理"><a href="#1-2-问题处理" class="headerlink" title="1.2 问题处理"></a>1.2 问题处理</h4><p>这种做法看着没啥问题，当晚发布后，在第二天的上午10点~11点就发生了系统瓶颈卡顿，最后挂起的情况，数据库的内存、CPU全部飙上去了。</p><p>第一时间的处理方法是降级，程序回滚到之前只提供基本信息的阶段，其他的前端默认显示空信息。接着就是对问题进行分析了，后确认原因是产生了 缓存雪崩了。</p><p>新发布的系统，缓存池是空的，在早上10点高峰期的时候，大量的人员到IM上进行访问，系统开始初次建立每个人的缓存信息，大量的请求查询不到缓存，直接透过缓存池投向数据库，造成瞬时DB请求量井喷。这是典型的缓存雪崩了。 </p><p>同时因为，失效时间相近（8小时失效），所以也有潜在的缓存雪崩。</p><p>应急处理方案：适当处理缓存的机制，采用布隆过滤器、空初始值、随机缓存失效时间方式来预防缓存击穿和缓存雪崩的产生。</p><p>最终解决方案：改回原来缓存全公司员工信息的方式，根据执行计划和SlowLog，优化获取员工信息的SQL脚本，去掉不需要的字段和无意义的连接。  </p><h3 id="2-缓存雪崩"><a href="#2-缓存雪崩" class="headerlink" title="2 缓存雪崩"></a>2 缓存雪崩</h3><h4 id="2-1-概念"><a href="#2-1-概念" class="headerlink" title="2.1 概念"></a>2.1 概念</h4><p>缓存雪崩是指大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。</p><p>上面的哪个问题，初次访问的数据都是未建立缓存的，跟同时失效的情况一样，当峰值期到来的时候，会大量的请求查询不到缓存，直接透过缓存池投向数据库，造成瞬时DB请求量井喷。</p><h4 id="2-2-解决方案分析"><a href="#2-2-解决方案分析" class="headerlink" title="2.2 解决方案分析"></a>2.2 解决方案分析</h4><h5 id="2-2-1-缓存集群-数据库集群"><a href="#2-2-1-缓存集群-数据库集群" class="headerlink" title="2.2.1 缓存集群+数据库集群"></a>2.2.1 缓存集群+数据库集群</h5><p>在系统容量设计的时候，应该能够预见后期会有大量的请求，所以在发生雪崩前对缓存集群实现高可用，如果是使用 Redis，可以使用 主从+哨兵 ，Redis Cluster 来避免 Redis 全盘崩溃的情况。</p><p>同样的，也需要对数据库进行高可用保障，因为透过缓存之后，真正考验的是数据库的抗压能力。所以 1主N从 甚至 数据库集群 是我们需要重点去考虑的。</p><h5 id="2-2-2-适当的限流、降级"><a href="#2-2-2-适当的限流、降级" class="headerlink" title="2.2.2 适当的限流、降级"></a>2.2.2 适当的限流、降级</h5><p>可以使用 Hystrix进行限流 + 降级 ，比如像上面那种情况，一下子来了1W个请求，不是当前系统的吞吐能力能够承受的，假设单秒TPS的能力只能是 5000个，那么剩余的 5000 请求就可以走限流逻辑。</p><p>可以设置一些默认值，然后调用我们自己降级逻辑去FallBack，保护最后的 MySQL 不会被大量的请求挂起。 除了Hystrix之外，阿里的Sentinel 和 Google的RateLimiter 都是不错的选择。</p><p>Sentinel 漏桶算法</p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAORaUNo2vGaEIssuWq0s3YTfWIgg7IAAoELaxvvjBhWeZNiSpfK6CMBAAMCAAN4AAM2BA.png" alt="漏桶算法示意图"></p><p>RateLimiter 令牌桶算法</p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAOQaUNo0Kyo6SNINz3yCJwE49w_YHQAAoALaxvvjBhWf9cbHvF-SrYBAAMCAAN4AAM2BA.png" alt="令牌桶算法"> </p><p>另外可以考虑使用用本地缓存来进行缓冲，在 Redis Cluster 不可用的时候，不至于全线崩溃。</p><h5 id="2-2-3-随机过期时间"><a href="#2-2-3-随机过期时间" class="headerlink" title="2.2.3 随机过期时间"></a>2.2.3 随机过期时间</h5><p>可以给缓存设置过期时间时加上一个随机值时间，使得每个key的过期时间分布开来，不会集中在同一时刻失效。</p><p>随机值我们团队的做法是：n * 3&#x2F;4 + n * random() 。所以，比如你原本计划对一个缓存建立的过期时间为8小时，那就是6小时 + 0~2小时的随机值。</p><p>这样保证了均匀分布在 6~8小时之间。如图： </p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAOPaUNosuZTM5re2ZEgCalk6Tr-h2kAAn8LaxvvjBhWkQxl3WUd_04BAAMCAAN5AAM2BA.png"> </p><h5 id="2-2-4-缓存预热"><a href="#2-2-4-缓存预热" class="headerlink" title="2.2.4 缓存预热"></a>2.2.4 缓存预热</h5><p>类似上面的那个案例，并不是还没过期，而是新功能发布，压根还没建设过缓存，所以可以在峰值期之前先做好部分缓存，避免瞬时压力太大。</p><p>所以如果10点是峰值期，那么可以预先在8~10点期间，可以逐渐的把大部分缓存建立起来。如图：</p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAOOaUNoMFfGNqeYWe_ajj1hCecCLvEAAn4LaxvvjBhWV8TGUBYzJQABAQADAgADeQADNgQ.png" alt="缓存预热"></p><h3 id="3-缓存穿透"><a href="#3-缓存穿透" class="headerlink" title="3 缓存穿透"></a>3 缓存穿透</h3><h4 id="3-1-概念"><a href="#3-1-概念" class="headerlink" title="3.1 概念"></a>3.1 概念</h4><p>缓存穿透是指访问一个不存在的key，缓存不起作用，请求会穿透到DB，流量井喷时会导致DB挂掉。</p><p>比如 我们查询用户的信息，程序会根据用户的编号去缓存中检索，如果找不到，再到数据库中搜索。如果你给了一个不存在的编号：XXXXXXXX，那么每次都比对不到，就透过缓存进入数据库。</p><p>这样风险很大，如果因为某些原因导致大量不存在的编号被查询，甚至被恶意伪造编号进行攻击，那将是灾难。</p><h4 id="3-2-解决方案分析"><a href="#3-2-解决方案分析" class="headerlink" title="3.2 解决方案分析"></a>3.2 解决方案分析</h4><h5 id="3-2-1-缓存空值"><a href="#3-2-1-缓存空值" class="headerlink" title="3.2.1 缓存空值"></a>3.2.1 缓存空值</h5><p>发生穿透的原因是缓存中没有存储这些空数据的key，或者压根这个数据的key是不会存在的，从而导致每次查询都进入数据库中。</p><p>我们就可以将这些key的值设置为null，并写到缓存池中。后面再出现查询这个key 的请求的时候，直接返回null，这样就在缓存池中就被判断返回了，压力在缓存层中，不会转移到数据库上。</p><h5 id="3-2-2-BloomFilter"><a href="#3-2-2-BloomFilter" class="headerlink" title="3.2.2 BloomFilter"></a>3.2.2 BloomFilter</h5><p>我们称作布隆过滤器，BloomFilter 类似于一个hbase set 用来判断某个元素（key）是否存在于某个集合中。</p><p>这种方式在大数据场景应用比较多，比如 Hbase 中使用它去判断数据是否在磁盘上。还有在爬虫场景判断url 是否已经被爬取过。</p><p>这种方案可以加在第一种方案中，在缓存之前在加一层 BloomFilter ，把存在的key记录在BloomFilter中，在查询的时候先去 BloomFilter 去查询 key 是否存在，如果不存在就直接返回，存在再走查缓存 ，投入数据库去查询，这样减轻了数据库的压力。</p><p>流程图如下：</p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAONaUNn-RoiZBilZC2JiE4w-2KQuVAAAn0LaxvvjBhW7zzsEn3GhWIBAAMCAAN5AAM2BA.png" alt="布隆过滤器"></p><h5 id="3-2-3-两种方案的选择判断"><a href="#3-2-3-两种方案的选择判断" class="headerlink" title="3.2.3 两种方案的选择判断"></a>3.2.3 两种方案的选择判断</h5><p>前面说过，可能会存在一些恶意攻击，伪造出大量不存在的key ，这种情况下如果我们如果采用缓存空值的办法，就会产生大量不存在key的null数据。显然是不合适的，这时我们完全可以使用第二种方案进行过滤掉这些key。</p><p>所以，判断的依据是：</p><ul><li>针对key非常多、请求重复率比较低的数据，我们就没有必要进行缓存，使用 BloomFilter 直接过滤掉。</li><li>而对于空数据的key有限的，重复率比较高的，我们则可以采用 缓存空值的办法 进行处理。</li></ul><h3 id="4-缓存击穿"><a href="#4-缓存击穿" class="headerlink" title="4 缓存击穿"></a>4 缓存击穿</h3><h4 id="4-1-概念"><a href="#4-1-概念" class="headerlink" title="4.1 概念"></a>4.1 概念</h4><p>一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到DB，造成瞬时DB请求量大、压力骤增。（注意跟上面两种的区别）</p><h4 id="4-2-解决方案"><a href="#4-2-解决方案" class="headerlink" title="4.2 解决方案"></a>4.2 解决方案</h4><h5 id="4-2-1-锁的方式"><a href="#4-2-1-锁的方式" class="headerlink" title="4.2.1 锁的方式"></a>4.2.1 锁的方式</h5><p>分布式锁场景，在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。</p><p>这种现象是多个线程同时去查询数据库的这条数据，那么我们可以在第一个查询数据的请求上使用一个 互斥锁来锁住它。</p><p>其他的线程走到这一步拿不到锁就等着，等第一个线程查询到了数据，然后做缓存。后面的线程进来发现已经有缓存了，就直接走缓存。</p><p>锁不好的地方就是在其他线程在拿不到锁的时候就等待，这个会造成系统整体吞吐量降低，用户体验度也不好。</p><h5 id="4-2-2-空初始值"><a href="#4-2-2-空初始值" class="headerlink" title="4.2.2 空初始值"></a>4.2.2 空初始值</h5><p>这是一种短暂降级的方式：</p><p>如果一个缓存失效的时候，有无数个请求狂奔而来，而第一个请求从进入缓存池，判空，再到数据库检索，再查询出结果并返回设置缓存的这个过程里，缓存是不存在的。</p><p>这个就很危险，超高并发下这个短暂的过程足已让千千万万请求投向数据库。更别提这可能是个慢查询，整个过程可能长达2s以上，那对数据库是一种非常大的伤害。</p><p>业内有一种做法叫<strong>做空初始值</strong>，短暂的局部降级来保证整个数据库系统不被击穿。大概流程如下：</p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAOMaUNnx-aLS7RqNCWuzgeYFQ5SINEAAnwLaxvvjBhWYxUFS6a-V9MBAAMCAAN3AAM2BA.png" alt="空初始值"> </p><p>可以看出，整个过程中我们牺牲了A、B、C、D的请求，他们拿回了一个空值或者默认值，但是这局部的降级却保证整个数据库系统不被拥堵的请求击穿。</p>]]></content>
      
      
      <categories>
          
          <category> 调优排查 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维调优 </tag>
            
            <tag> Redis缓存 </tag>
            
            <tag> 缓存雪崩 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>是什么，为什么，怎么做? —— 谈谈 DNS 泄漏、CDN 访问优化与 Fake IP</title>
      <link href="/2025/03/17/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/DNS%20%E6%B3%84%E6%BC%8F%E3%80%81CDN%20%E8%AE%BF%E9%97%AE%E4%BC%98%E5%8C%96%E4%B8%8E%20Fake%20IP/"/>
      <url>/2025/03/17/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/DNS%20%E6%B3%84%E6%BC%8F%E3%80%81CDN%20%E8%AE%BF%E9%97%AE%E4%BC%98%E5%8C%96%E4%B8%8E%20Fake%20IP/</url>
      
        <content type="html"><![CDATA[<h1 id="深度解析Fake-IP与Real-IP：网络分流的最佳实践"><a href="#深度解析Fake-IP与Real-IP：网络分流的最佳实践" class="headerlink" title="深度解析Fake IP与Real IP：网络分流的最佳实践"></a>深度解析Fake IP与Real IP：网络分流的最佳实践</h1><p>2001 年 4 月 IETF 通过的 <strong>RFC 3089</strong>中描述的 <strong>Fake IP</strong>，是四层代理分流场景下性能相对最佳、体验相对最好、实现相对最简单的「最佳实践」。相比之下，Real IP模式为了接近其性能，需要付出大量的额外配置代价。</p><hr><h2 id="1-拆解「DNS-泄漏」的迷思"><a href="#1-拆解「DNS-泄漏」的迷思" class="headerlink" title="1. 拆解「DNS 泄漏」的迷思"></a>1. 拆解「DNS 泄漏」的迷思</h2><p>在许多三层 VPN 提供商（如 ExpressVPN, NordVPN）及 KOL 的宣传下，「DNS 泄漏」被渲染成洪水猛兽。但要理解它，首先要理解 DNS 解析的参与者：</p><ol><li><p><strong>发起查询的用户</strong></p></li><li><p><strong>递归 DNS（Local DNS）</strong>：如运营商 DNS、公共 DNS（1.1.1.1 等）。</p></li><li><p><strong>权威 DNS（Authoritative DNS）</strong>：最终决定域名指向的服务器。</p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAOEaUJ9ZPQAAXIvLGMNuzB-BOBU5nWeAAL8C2sb74wQVr6Qb72hSPmkAQADAgADdwADNgQ.png"></p></li></ol><h3 id="DNS-泄漏的原理"><a href="#DNS-泄漏的原理" class="headerlink" title="DNS 泄漏的原理"></a>DNS 泄漏的原理</h3><p>「DNS 泄漏」本质上查询的是 <strong>递归 DNS 请求权威 DNS 时所使用的出口 IP</strong>。</p><p>查询工具通过让用户请求完全随机的域名（绕开缓存），迫使递归 DNS 请求权威 DNS，从而记录下递归 DNS 的出口 IP。</p><h3 id="为什么-DNS-泄漏不值得恐慌？"><a href="#为什么-DNS-泄漏不值得恐慌？" class="headerlink" title="为什么 DNS 泄漏不值得恐慌？"></a>为什么 DNS 泄漏不值得恐慌？</h3><ol><li><strong>地理位置难以关联</strong>：Cloudflare 等公共 DNS 在全球有数百个 PoP 点，其出口 IP 无法精准对应用户实际位置。</li><li><strong>无法作为风控因子</strong>：DNS 递归流程长、失败率相对高，且无法代表用户真实 IP，主流网站不会仅凭此标记「可疑用户」。</li></ol><p>**真正值得关注的是：**域名的 DNS 查询，一定要通过实际使用的网络出口发送。</p><hr><h2 id="2-CDN-调度与-GeoDNS"><a href="#2-CDN-调度与-GeoDNS" class="headerlink" title="2. CDN 调度与 GeoDNS"></a>2. CDN 调度与 GeoDNS</h2><p>CDN（内容传输网络）通过全球部署的节点将网站带到用户附近。其分配策略主要依赖 <strong>GeoDNS</strong>：权威 DNS 根据递归 DNS 的出口 IP，返回距离用户最近的节点。</p><ul><li><strong>痛点</strong>：如果你用新加坡节点访问 Netflix，却分配了美国的 CDN 节点，体验将大幅下降。</li><li><strong>核心需求</strong>：为了保证 CDN 调度准确，不论 Fake IP 还是 Real IP 模式，都必须确保 DNS 查询走实际的网络出口。</li></ul><hr><h2 id="3-Fake-IP-vs-Real-IP：实现原理对比"><a href="#3-Fake-IP-vs-Real-IP：实现原理对比" class="headerlink" title="3. Fake IP vs Real IP：实现原理对比"></a>3. Fake IP vs Real IP：实现原理对比</h2><h3 id="Fake-IP-模式"><a href="#Fake-IP-模式" class="headerlink" title="Fake IP 模式"></a>Fake IP 模式</h3><ul><li><strong>逻辑</strong>：DNS 解析责任从客户端转移到了代理服务器。</li><li><strong>流程</strong>：<ol><li>客户端拦截 DNS 请求，直接返回一个伪造的 IP（Fake IP）。</li><li>浏览器与 Fake IP 建立连接。</li><li>代理客户端反推出域名，将域名发往代理服务器。</li><li><strong>代理服务器</strong>进行真正的 DNS 解析。</li></ol></li><li><strong>优势</strong>：天然无视本地 DNS 污染，且 CDN 调度由远程服务器完成，自动优化。</li></ul><h3 id="Real-IP-模式"><a href="#Real-IP-模式" class="headerlink" title="Real IP 模式"></a>Real IP 模式</h3><ul><li><strong>逻辑</strong>：所有 DNS 解析发生在本地。</li><li><strong>局限性</strong>：<ol><li>为了分流，客户端必须解析出 Real IP。</li><li>需要复杂的嗅探手段（HTTP Host &#x2F; TLS SNI）来识别域名，且无法处理 ECH 加密。</li><li>需要手动配置大量的 DNS 转发规则，以确保不同地区的域名由对应的出口解析。</li></ol></li></ul><hr><h2 id="4-关于-EDNS-Client-Subnet-ECS"><a href="#4-关于-EDNS-Client-Subnet-ECS" class="headerlink" title="4. 关于 EDNS Client Subnet (ECS)"></a>4. 关于 EDNS Client Subnet (ECS)</h2><p>RFC 7871 定义了 ECS，允许递归 DNS 携带客户端子网信息，帮助权威 DNS 优化调度。</p><p><strong>现状与挑战：</strong></p><ul><li><strong>兼容性极差</strong>：Cloudflare 等出于隐私拒绝支持；部分 CDN（如移动、某些国外节点）虽然兼容但不读取。</li><li><strong>安全风险</strong>：增加了 DoS 攻击和缓存投毒的风险（如 CVE-2025-5994）。</li><li><strong>配置繁琐</strong>：在 Real IP 模式下，你需要为每个网络出口手动分配对应的美国&#x2F;英国等子网段。</li></ul><hr><h2 id="5-性能优势：Fake-IP-「快」在哪里？"><a href="#5-性能优势：Fake-IP-「快」在哪里？" class="headerlink" title="5. 性能优势：Fake IP 「快」在哪里？"></a>5. 性能优势：Fake IP 「快」在哪里？</h2><h3 id="减少-DNS-RTT"><a href="#减少-DNS-RTT" class="headerlink" title="减少 DNS RTT"></a>减少 DNS RTT</h3><p>在理想的网络环境下（如上海到美西专线）：</p><ul><li><strong>Fake IP</strong>：客户端立刻返回结果，总准备耗时约 <strong>58ms</strong>。</li><li><strong>Real IP</strong>：需要等待一个完整的远程 DNS 查询往返，总耗时约 <strong>170ms</strong>。</li></ul><p>[Image comparing Fake IP and Real IP latency workflow]</p><h3 id="TCP-并发握手（Happy-Eyeballs）"><a href="#TCP-并发握手（Happy-Eyeballs）" class="headerlink" title="TCP 并发握手（Happy Eyeballs）"></a>TCP 并发握手（Happy Eyeballs）</h3><p>当 DNS 返回多个 IP 时，Fake IP 模式下的代理客户端可以同时向所有 IP 发送 <strong>TCP SYN</strong>。谁先响应就用谁，这能有效规避单个节点连接超时（可能长达 20-180s）导致的卡顿。这是 Real IP 模式难以透明实现的优化。</p><hr><h2 id="6-配置建议与结论"><a href="#6-配置建议与结论" class="headerlink" title="6. 配置建议与结论"></a>6. 配置建议与结论</h2><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><blockquote><p><strong>Fake IP 模式是目前的最佳实践。</strong></p></blockquote><h3 id="配置清单"><a href="#配置清单" class="headerlink" title="配置清单"></a>配置清单</h3><table><thead><tr><th><strong>场景</strong></th><th><strong>Fake IP 模式</strong></th><th><strong>Real IP 模式</strong></th></tr></thead><tbody><tr><td><strong>DNS 服务器</strong></td><td>仅需配置国内 DNS</td><td>需同时配置国内和海外 DNS</td></tr><tr><td><strong>解析行为</strong></td><td>仅解析直连网站&#x2F;代理服务器域名</td><td>解析所有网站</td></tr><tr><td><strong>分流复杂度</strong></td><td>简单，自动处理</td><td>极高，需配置 DNS 转发与分流</td></tr><tr><td><strong>CDN 优化</strong></td><td>服务器端自动优化</td><td>需手动配置 ECS 或多出口 DNS</td></tr></tbody></table><p><strong>简单来说：</strong></p><ul><li><strong>Fake IP 用户</strong>：只需配置国内 DNS 即可享受最佳体验。</li><li><strong>Real IP 用户</strong>：需手动管理复杂的 DNS 转发规则，否则会面临 DNS 污染或 CDN 调度劣化。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络优化 </tag>
            
            <tag> DNS泄露 </tag>
            
            <tag> Fake IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis系列：使用List实现消息队列</title>
      <link href="/2025/03/11/Redis%E7%B3%BB%E5%88%97/Redis%E7%B3%BB%E5%88%97-%E4%BD%BF%E7%94%A8List%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
      <url>/2025/03/11/Redis%E7%B3%BB%E5%88%97/Redis%E7%B3%BB%E5%88%97-%E4%BD%BF%E7%94%A8List%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h1><p>在分布式系统中，很重要的一个能力就是消息中间件。我们通过消息队列实现 功能解耦、消息有序性、消息路由、异步处理、流量削峰 等能力。目前主流的Mq主要有 RabbitMQ 、RocketMQ、kafka，可以参考这篇《<a href="https://yeoh.qzz.io/2025/03/22/MQ%E7%B3%BB%E5%88%972-%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/">MQ系列2：消息中间件的技术选型 | 数根朽木，</a>》。除了这些主流MQ之外，Redis也具备实现消息队列的能力。这一篇记录一下消息队列主要实现哪些能力，原理是什么，以及如何在 Redission 中应用。</p><h1 id="2-关于消息队列"><a href="#2-关于消息队列" class="headerlink" title="2 关于消息队列"></a>2 关于消息队列</h1><h2 id="2-1-什么是消息队列"><a href="#2-1-什么是消息队列" class="headerlink" title="2.1 什么是消息队列"></a>2.1 什么是消息队列</h2><p>消息中间件是指在分布式系统中完成消息的发送和接收的基础软件。消息中间件也可以称消息队列（Message Queue &#x2F; MQ），用高效可靠的消息传递机制进行与平台无关的数据交流，并基于数据通信来进行分布式系统的集成。通过提供消息传递和消息队列模型，可以在分布式环境下扩展进程的通信。简而言之，互联网场景中经常使用消息中间件进行消息路由、订阅发布、异步处理等操作，来缓解系统的压力。</p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAANmaUI1LlcaNdvMQXz_qvLpyuVCb8kAAmoLaxvvjBBWK8VN3mP0XQYBAAMCAAN4AAM2BA.png" alt="image"></p><ul><li>Broker： 消息服务器，作为Server提供消息核心服务，一般会包含多个Q。</li><li>Producer： 消息生产者，业务的发起方，负责生产消息传输给broker，</li><li>Consumer： 消息消费者，业务的处理方，负责从broker获取消息并进行业务逻辑处理</li></ul><h2 id="2-2-它解决了我们哪些问题"><a href="#2-2-它解决了我们哪些问题" class="headerlink" title="2.2 它解决了我们哪些问题"></a>2.2 它解决了我们哪些问题</h2><p>1、<strong>解耦：</strong> 比如说系统A会交给系统B去处理一些事情，但是A不想直接跟B有关联，避免耦合太强，就可以通过在A，B中间加入消息队列，A将要任务的事情交给消息队列 ,B订阅消息队列来执行任务。</p><blockquote><p>这种场景很常见，比如A是订单系统，B是库存系统，可以通过消息队列把削减库存的工作交予B系统去处理。如果A系统同时想让B、C、D…多个系统处理问题的时候，这种优势就更加明显了。</p></blockquote><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAANnaUJPcxv-YkSK_PCwY5VtvX9hxsIAAowLaxvvjBBW1z6ajNZJsawBAAMCAAN4AAM2BA.png" alt="image"></p><p>2、<strong>有序性：</strong> 先进先出原理，先来先处理，比如一个系统处理某件事需要很长一段时间，但是在处理这件事情时候，有其他人也发出了请求，可以把请求放在消息队里，一个一个来处理。</p><blockquote><p>对数据的顺序性和一致性有强需求的业务，比如同一张银行卡同时被多个入口使用，需要保证入账出账的顺序性，避免出现数据不一致。</p></blockquote><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAANoaUJPor3AC8QQ7zhiwg6zhj6T5iQAAo0LaxvvjBBWDKdd0Fr6eMcBAAMCAAN4AAM2BA.png" alt="image"></p><p>3、<strong>消息路由：</strong> 按照不同的规则，将队列中消息发送到不同的其他队列中</p><blockquote><p>通过消息队列将不同染色的请求发送到不同的服务去操作。这样达成了流量按照业务拆分的目的。</p></blockquote><p>4、<strong>异步处理：</strong> 处理一项任务的时候，有3个步骤A、B、C，需要先完成A操作, 然后做B、C 操作。任务执行成功与否强依赖A的结果，但不依赖B、C 的结果。<br>如果我们使用串行的执行方式，那处理任务的周期就会变长，系统的整体吞吐能力也会降低（在同一个系统中做异步其实也是比较大的开销），所以使用消息队列是比较好的办法。</p><blockquote><p>登录操作就是典型的场景：A：执行登录并得到结果、B：记录登录日志、C：将用户信息和Token写入缓存。 执行完A就可以从登录页跳到首页了，B、C让服务慢慢去消化，不阻塞当前操作。</p></blockquote><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAANpaUJP2buiGENSgOom9LmVqifDoVcAAo4LaxvvjBBWn9KIi-qZ7BwBAAMCAAN4AAM2BA.png"></p><p>5、<strong>削峰：</strong> 将峰值期间的操作削减，比如A同学的整个操作流程包含12个步骤，后续的11个步骤是不需要强关注结果的数据，可以放在消息队列中。</p><p>详细可参考笔者这篇《<a href="https://yeoh.qzz.io/2025/03/22/MQ%E7%B3%BB%E5%88%971-%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/">MQ系列1：消息中间件执行原理 | 数根朽木，</a>》。</p><h2 id="2-3-消息队列满足的业务特性"><a href="#2-3-消息队列满足的业务特性" class="headerlink" title="2.3 消息队列满足的业务特性"></a>2.3 消息队列满足的业务特性</h2><h3 id="2-3-1-消息有序性"><a href="#2-3-1-消息有序性" class="headerlink" title="2.3.1 消息有序性"></a>2.3.1 消息有序性</h3><p>正如上面提到的有序性一样，他能够保证消息按照生产的顺序进行处理和消费，避免消息被无序处理的情况发生。</p><h3 id="2-3-2-消息去重"><a href="#2-3-2-消息去重" class="headerlink" title="2.3.2 消息去重"></a>2.3.2 消息去重</h3><p>同样的，生产和消费的消息需要保证幂等性原理。避免出现重复执行的情况，而消息队列的去重机制，也需要确保避免消息被重复消费的问题。</p><h3 id="2-3-3-消息的可靠性传输"><a href="#2-3-3-消息的可靠性传输" class="headerlink" title="2.3.3 消息的可靠性传输"></a>2.3.3 消息的可靠性传输</h3><p>消息队列的数据可以实现重试、持久化存储、死信队列记录等，以避免消息无法成功传递所产生的不一致现象。当消息服务器或者消费者恢复健康的时候，可以继续读取消息进行处理，防止消息遗漏。</p><h1 id="3-使用Redis的List实现消息队列"><a href="#3-使用Redis的List实现消息队列" class="headerlink" title="3 使用Redis的List实现消息队列"></a>3 使用Redis的List实现消息队列</h1><p>稍微学过数据结构都知道。我们经常说Queue（队列），他的存储和使用规则是【先进先出】，栈的存储和使用规则是【先进后出】。<br>所以List本质上是一个线性的有序结构，也就是Queue的存储关系，它能够保证消费的有序性，按照顺序进行处理。</p><h2 id="3-1-入列操作-LPUSH"><a href="#3-1-入列操作-LPUSH" class="headerlink" title="3.1 入列操作 LPUSH"></a>3.1 入列操作 LPUSH</h2><p>即进行消息生产，入列操作语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LPUSH key element<span class="selector-attr">[element...]</span> </span><br></pre></td></tr></table></figure><p>如果key存在，Producer 通过 LPUSH 将消息插入该队列的头部；如果 key 不存在，则是先创建一个空队列，然后在进行数据插入。<br>下面举个例子，往队列中插入几个消息，然后得到的返回值是插入消息的个数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; LPUSH msg_queue msg1 msg2 msg3</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure><p>这边往 key 为 msg_queue 的队列中插入了三个消息 msg1、msg2、msg3。</p><h2 id="3-2-出列操作-RPOP"><a href="#3-2-出列操作-RPOP" class="headerlink" title="3.2 出列操作 RPOP"></a>3.2 出列操作 RPOP</h2><p>即进行消息消费，消费的顺序是先进先出（先生产先消费），出列使用的语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; RPOP msg_queue</span><br><span class="line"><span class="string">&quot;msg1&quot;</span></span><br><span class="line">&gt; RPOP msg_queue</span><br><span class="line"><span class="string">&quot;msg2&quot;</span></span><br><span class="line">&gt; RPOP msg_queue</span><br><span class="line"><span class="string">&quot;msg3&quot;</span></span><br><span class="line">&gt; RPOP msg_queue</span><br><span class="line">(<span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>都消费完成之后，就是nil了。</p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAANqaUJQKdg5p-1dV5s6yMRa2CbGLqwAAo8LaxvvjBBW62hPVyB65lwBAAMCAAN5AAM2BA.png"></p><h2 id="3-3-消费及时性问题"><a href="#3-3-消费及时性问题" class="headerlink" title="3.3 消费及时性问题"></a>3.3 消费及时性问题</h2><p>不同于常规的MQ，具备订阅模式，消费者可以感知到有新的消息生产出来了，再进行消费。List的问题在于，生产者向队列插入数据的时候，List 并不会主动通知消费者，所以消费者做不到及时消费。</p><p>为了保证消费的及时，可能需要做一个心跳包（1秒执行一次），不断地执行 RPOP 指令，当探测到有新消息就会取出消息进行消费，没有消息的时候就返回nil。但是这种也存在明显的短板，就是不断的调用 RPOP 指令，占用 I&#x2F;O 资源和CPU资源。</p><p>比较好的解决办法就是在队列为空队列的时候，暂停读取，等有消息入列的时候，恢复取数和消费的工作，这样也避免了无效的资源浪费。Redis 提供了 BLPOP、BRPOP ，无数据的时候自动阻塞读取的命令，有新消息进入的时候，恢复消息取数，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">BRPOP  key  <span class="built_in">timeout</span></span> </span><br><span class="line">BRPOP  msg_queue  0</span><br></pre></td></tr></table></figure><p>命令最后一个参数 timeout 是超时时间，单位是秒，如果 timeout 大于0，则到达指定的秒数即使没有弹出成功也会返回，如果 timeout 的值为0，则会一直阻塞等待其他连接向列表中插入元素， timeout 参数不允许为负数。</p><h2 id="3-4-消息的重复消费问题"><a href="#3-4-消息的重复消费问题" class="headerlink" title="3.4 消息的重复消费问题"></a>3.4 消息的重复消费问题</h2><p>目前 List 没有纯幂等的鉴别能力，但是可以通过以下两种方法来实现：</p><ul><li>List为每一条消息生成一个 Glocal ID，重复的Glocal ID 不进行重复消费。</li><li>Producer在生产消息的时候在消息中创建一个Glocal ID，当消费的时候把Glocal ID Record一下，后续的消费先判断再消费，避免重复消费同一个消息。<br>这样就保证了对于同一条消息，消费者始终只处理一次，结果始终保持一致。</li></ul><h2 id="3-5-消息的可靠性传输问题"><a href="#3-5-消息的可靠性传输问题" class="headerlink" title="3.5 消息的可靠性传输问题"></a>3.5 消息的可靠性传输问题</h2><p>可靠性传输我们在MQ篇章用了一整节来介绍持久化存储、消息ACK 、二次记录保障。</p><p>这边我们也来看看Redis List中的可靠性传输的保障。Redis中缺少了一个消息确认（ACK）的机制，如果消费数据的时候运行崩溃了，没有确认机制，很可能这条消息就被错过了，无法保证数据的一致性。</p><p>解决方案：Redis 提供了 <code>RPOPLPUSH</code> 指令，当List读取消息的时候，会同步的把该消息复制到另外一个List以作备份。整个操作过程是具备原子性的，避免读取消息了，但是同步备份不成功。</p><p>如果出现处理消息出现故障的情况，在故障回复之后，可以从备份的List中复制消息继续消费。操作如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生产消息 msg1 msg2</span></span><br><span class="line">&gt; LPUSH list_queue msg1 msg2  </span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"><span class="comment"># 消费消息并同步到备份</span></span><br><span class="line">&gt; RPOPLPUSH list_queue list_queue_bak</span><br><span class="line"><span class="string">&quot;msg1&quot;</span></span><br><span class="line"><span class="comment"># 当发生故障的时候去消费备份的数据，可以消费到</span></span><br><span class="line">&gt; RPOP list_queue_bak</span><br><span class="line"><span class="string">&quot;msg1&quot;</span></span><br></pre></td></tr></table></figure><p>如果消费成功则把 list_queue_bak 消息删除即可，如果发生故障，则可以继续从 list_queue_bak 再次读取消息处理。</p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAANraUJQbY2betIEdAdZd_kAAYrXJdM9AAKQC2sb74wQVl4J6ZeZvQduAQADAgADeQADNgQ.png"></p><h1 id="4-使用-Redission-实现队列能力"><a href="#4-使用-Redission-实现队列能力" class="headerlink" title="4 使用 Redission 实现队列能力"></a>4 使用 Redission 实现队列能力</h1><p>这边以Java SpringBoot为例子进行说明，<a href="https://github.com/redisson/redisson/wiki/7.-Distributed-collections">可以点击参考官方文档</a>。</p><h2 id="4-1-添加maven依赖-和-配置基本连接"><a href="#4-1-添加maven依赖-和-配置基本连接" class="headerlink" title="4.1 添加maven依赖 和 配置基本连接"></a>4.1 添加maven依赖 和 配置基本连接</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># maven信息</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.16.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本配置</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">redission_test</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">x.x.x.x</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">ssl:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">xxxx.xxxx</span></span><br></pre></td></tr></table></figure><h2 id="4-2-Java程序实现"><a href="#4-2-Java程序实现" class="headerlink" title="4.2 Java程序实现"></a>4.2 Java程序实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisQueueService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">REDIS_QUEUE</span> <span class="operator">=</span> <span class="string">&quot;listQueue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息生产</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">msgProduce</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        RBlockingDeque&lt;String&gt; blockDeque = redissonClient.getBlockingDeque(REDIS_QUEUE);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            blockDeque.putFirst(msg); <span class="comment">// 消息写入队列头部</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(e.printStackTrace());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息消费：阻塞</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">msgConsume</span><span class="params">()</span> &#123;</span><br><span class="line">        RBlockingDeque&lt;String&gt; blockDeque = redissonClient.getBlockingDeque(REDIS_QUEUE);</span><br><span class="line"><span class="type">Boolen</span> <span class="variable">isCheck</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (isCheck) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> blockDeque.takeLast();  <span class="comment">// 从队列中取出消息</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                log.error(e.printStackTrace());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h1><ul><li>Redis中使用List 数据结构实现消息队列，满足FIFO的处理机制，使用 RPOP 进行消息读取。</li><li>使用 BRPOP 指令处理消费及时性问题</li><li>使用 BRPOPLPUSH 命令进行消息数据备份，解决消息可靠性传输问题。</li><li>相对于专业的MQ，如kafka和RocketMQ，处理能力会差很多。所以在在消息量不大的场景中使用，可以作为一个比较不错的消息队列解决方案。但是过于复杂的场景容易造成消息堆积。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis系列：使用List实现消息队列</title>
      <link href="/2025/03/11/Redis%E7%B3%BB%E5%88%97/Redis%E7%B3%BB%E5%88%97-%E4%BD%BF%E7%94%A8Stream%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%20%EF%BC%88%E5%9B%BE%E6%96%87%E6%80%BB%E7%BB%93+Go%E6%A1%88%E4%BE%8B%EF%BC%89/"/>
      <url>/2025/03/11/Redis%E7%B3%BB%E5%88%97/Redis%E7%B3%BB%E5%88%97-%E4%BD%BF%E7%94%A8Stream%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%20%EF%BC%88%E5%9B%BE%E6%96%87%E6%80%BB%E7%BB%93+Go%E6%A1%88%E4%BE%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="1-先导"><a href="#1-先导" class="headerlink" title="1 先导"></a>1 先导</h1><p>我们在《<a href="https://yeoh.qzz.io/2025/03/11/Redis%E7%B3%BB%E5%88%97/Redis%E7%B3%BB%E5%88%97-%E4%BD%BF%E7%94%A8List%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">Redis系列：使用List实现消息队列 | 数根朽木，</a>》这一篇中详细讨论了如何使用List实现消息队列，但同时也看到很多局限性，比如：</p><ul><li>不支持消息确认机制，没有很好的ACK应答</li><li>不支持消息回溯，无法排查问题和做消息分析</li><li>List按照FIFO机制执行，所以存在消息堆积的风险。</li><li>查询效率低，作为线性结构，List中定位一个数据需要进行遍历，O(N)的时间复杂度</li><li>不存在消费组（Consumer Group）的概念，无法实现多个消费者组成分组进行消费</li></ul><h1 id="2-关于Stream"><a href="#2-关于Stream" class="headerlink" title="2 关于Stream"></a>2 关于Stream</h1><p>Redis Stream是Redis 5.0版本中引入的一种新的数据结构，它主要用于高效地处理流式数据，特别适用于消息队列、日志记录和实时数据分析等场景。<br>以下是对Redis Stream的 <strong>主要特征：</strong></p><p><strong>1. 数据结构</strong>：Redis Stream是一个由有序消息组成的日志数据结构，每个消息都有一个全局唯一的ID，确保消息的顺序性和可追踪性。</p><p><strong>2. 消息ID</strong>：消息的ID由两部分组成，分别是毫秒级时间戳和序列号。这种设计确保了消息ID的单调递增性，即新消息的ID总是大于旧消息的ID。</p><p><strong>3. 消费者组</strong>：Redis Stream支持消费者组的概念，允许多个消费者以组的形式订阅Stream，并且每个消息只会被组内的一个消费者处理，避免了消息的重复消费。</p><p><strong>以及主要优势:</strong></p><ol><li>持久化存储：Stream中的消息可以被持久化存储，确保数据不会丢失，即使在Redis服务器重启后也能恢复消息.</li><li>** 有序性**：消息按照产生顺序生成消息ID, 被添加到Stream中，并且可以按照指定的条件检索消息，保证了消息的有序性。<strong>多播与分组消费</strong>：支持多个消费者同时消费同一流中的消息，并且可以将消费者组织成消费组，实现消息的分组消费。**</li><li>消息确认机制**：消费者可以通过XACK命令确认是否成功消费消息，保证消息至少背消费一次,确保消息不会被重复处理。**</li><li>阻塞读取**：消费者可以选择阻塞读取模式，当没有新消息时，消费者会等待直至新消息到达。**</li><li>消息可回溯**: 方便补数、特殊数据处理, 以及问题回溯查询</li></ol><h1 id="3-主要命令"><a href="#3-主要命令" class="headerlink" title="3 主要命令"></a>3 主要命令</h1><p><strong>1. XADD</strong>：向Stream中添加消息。如果指定的Stream不存在，则会自动创建。</p><p><strong>2. XREAD</strong>：以阻塞&#x2F;非阻塞方式获取Stream中的消息列表。</p><p><strong>3. XREADGROUP</strong>：从消费者组中读取消息，支持阻塞读取。</p><p><strong>4. XACK</strong>：确认消费者已经成功处理了消息。</p><p><strong>5. XGROUP</strong>：用于管理消费者组，包括创建、设置ID、销毁消费者组等操作。</p><p><strong>6. XPENDING</strong>：查询消费者组中的待处理消息。</p><h2 id="3-1-XADD-消息记录"><a href="#3-1-XADD-消息记录" class="headerlink" title="3.1 XADD 消息记录"></a>3.1 XADD 消息记录</h2><p>XADD命令用于向Redis Stream（流）数据结构中添加消息。</p><h3 id="3-1-1-XADD-命令的基本语法"><a href="#3-1-1-XADD-命令的基本语法" class="headerlink" title="3.1.1 XADD 命令的基本语法"></a>3.1.1 XADD 命令的基本语法</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XADD stream_name <span class="selector-attr">[MAXLEN maxlen]</span> <span class="selector-attr">[ID id]</span> field1 value1 <span class="selector-attr">[field2 value2 ...]</span></span><br></pre></td></tr></table></figure><p><strong>1. stream_name</strong>：指定要添加消息的Stream的名字。<br><strong>2. MAXLEN maxlen</strong>：可选参数，用于限制Stream的最大长度。当Stream的长度达到maxlen时，旧的消息会被自动删除。<br><strong>3. ID id</strong>：可选参数，用于指定消息的ID。如果不指定该参数，Redis会自动生成一个唯一的ID。<br><strong>4. field1 value1 [field2 value2 …]</strong>：消息的字段和值，消息的内容以key-value的形式存在。</p><p>XADD命令的一个重要用途是实现消息发布功能，发布者可以使用XADD命令向Stream中添加消息。</p><h3 id="3-1-2-XADD-示例"><a href="#3-1-2-XADD-示例" class="headerlink" title="3.1.2 XADD 示例"></a>3.1.2 XADD 示例</h3><p>假设我们有一个名为<code>userinfo_stream</code>的Stream，并希望向其中添加一个包含<code>sensor_id</code>和<code>temperature</code>字段的消息，我们可以使用以下命令：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">XADD</span> userinfo_stream * user_name brand age <span class="number">18</span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>*</code>表示让Redis自动生成一个唯一的消息ID。消息包含两个字段：<code>username</code>和<code>age</code>，它们的值分别是<code>brand</code>和<code>18</code>。所以这边记录了一个用户信息，姓名为<code>brand</code>， 年龄<code>18</code>岁。</p><h3 id="3-1-3-有啥需要注意的呢"><a href="#3-1-3-有啥需要注意的呢" class="headerlink" title="3.1.3 有啥需要注意的呢"></a>3.1.3 有啥需要注意的呢</h3><ul><li>如果指定的Stream<strong>不存在</strong>，XADD命令会<strong>创建一个新的Stream</strong>。</li><li>消息的ID是唯一的，并且Redis会保证Stream中消息的ID是单调递增的。如果指定了ID，则新消息的ID必须大于Stream中现有的所有消息的ID。</li><li>使用MAXLEN参数可以限制Stream的大小，这在处理大量消息时非常有用，可以避免Stream占用过多的内存或磁盘空间。</li></ul><h2 id="3-2-XREAD-消息消费"><a href="#3-2-XREAD-消息消费" class="headerlink" title="3.2 XREAD 消息消费"></a>3.2 XREAD 消息消费</h2><p>即将消息从队列中读取出来（消费）</p><h3 id="3-2-1-XREAD-命令的基本语法"><a href="#3-2-1-XREAD-命令的基本语法" class="headerlink" title="3.2.1 XREAD 命令的基本语法"></a>3.2.1 XREAD 命令的基本语法</h3><p>XREAD命令的基本语法如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XREAD <span class="selector-attr">[COUNT count]</span> <span class="selector-attr">[BLOCK milliseconds]</span> STREAMS key <span class="selector-attr">[key ...]</span> ID <span class="selector-attr">[ID ...]</span></span><br></pre></td></tr></table></figure><p><strong>1. COUNT count</strong>：这是一个可选参数，用于指定一次读取的最大消息数量。如果不指定，默认为1。</p><p><strong>2. BLOCK milliseconds</strong>：这也是一个可选参数，用于指定阻塞的时间（以毫秒为单位）。如果指定了阻塞时间，并且当前没有可消费的消息，客户端将在指定的时间内阻塞等待。如果不设置该参数或设置为0，则命令将立即返回，无论是否有可消费的消息。</p><p><strong>3. STREAMS key [key …] ID [ID …]</strong>：这部分指定了要消费的流（Streams）和对应的起始消息ID。可以一次指定多个流和对应的起始ID。</p><p><strong>XREAD命令的工作机制</strong></p><p><strong>1. 读取指定ID之后的消息</strong>：XREAD命令会返回指定ID之后的消息（不包含指定ID的消息本身）。如果没有指定ID，或者指定的ID不存在于流中，那么命令将从流的开始或结束处读取消息，具体取决于ID的值（如“0-0”表示从流的开始处读取，“$”表示从流的当前最大ID处读取）。</p><p><strong>2. 阻塞读取</strong>：当设置了BLOCK参数后，如果当前没有可消费的消息，客户端将进入阻塞状态，直到有新的消息到达或阻塞时间超时。这种机制非常适合实现消费者等待生产者产生新消息的场景。</p><p><strong>3. 支持多个流</strong>：XREAD命令支持同时从多个流中读取消息，只需在命令中指定多个流和对应的起始ID即可。</p><h3 id="3-2-2-XREAD-示例"><a href="#3-2-2-XREAD-示例" class="headerlink" title="3.2.2 XREAD 示例"></a>3.2.2 XREAD 示例</h3><p>假设我们有一个名为<code>userinfo_stream</code>的流，并且想要从该流中读取消息。以下是一些示例：<br><strong>1. 非阻塞读取最新消息</strong>：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">XREAD</span> <span class="variable constant_">COUNT</span> <span class="number">1</span> <span class="variable constant_">STREAMS</span> userinfo_stream $</span><br></pre></td></tr></table></figure><p>这条命令会尝试从<code>userinfo_stream</code>流中读取最新的消息（如果有的话）。<code>$</code>是一个特殊ID，表示流的当前最大ID。</p><p><strong>2. 阻塞读取最新消息</strong>：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XREAD <span class="built_in">COUNT</span> <span class="number">1</span> <span class="keyword">BLOCK </span><span class="number">1000</span> STREAMS userinfo_stream $</span><br></pre></td></tr></table></figure><p>这条命令会阻塞1000毫秒，等待<code>userinfo_stream</code>流中出现新的消息。如果在1000毫秒内有新消息到达，则命令会返回该消息；否则，命令将超时并返回nil。</p><p><strong>3. 从特定ID开始读取</strong>：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">XREAD <span class="built_in">COUNT</span> <span class="number">2</span> STREAMS userinfo_stream <span class="number">1722159931000</span><span class="number">-0</span></span><br><span class="line"><span class="number">1</span>) <span class="number">1</span>) <span class="string">&quot;userinfo_stream&quot;</span></span><br><span class="line">    <span class="number">2</span>)  <span class="number">1</span>) <span class="number">1</span>) <span class="string">&quot;1722159931000-0&quot;</span></span><br><span class="line">         <span class="number">2</span>) <span class="number">1</span>) <span class="string">&quot;user_name&quot;</span></span><br><span class="line">             <span class="number">2</span>) <span class="string">&quot;brand&quot;</span></span><br><span class="line">             <span class="number">3</span>) <span class="string">&quot;age&quot;</span></span><br><span class="line">             <span class="number">4</span>) <span class="string">&quot;18&quot;</span></span><br></pre></td></tr></table></figure><p>这条命令会从<code>userinfo_stream</code>流中读取ID大于或等于<code>1722159931000-0</code>的消息，最多返回数据。</p><h3 id="3-2-3-需要注意啥呢？"><a href="#3-2-3-需要注意啥呢？" class="headerlink" title="3.2.3 需要注意啥呢？"></a>3.2.3 需要注意啥呢？</h3><p><strong>1. 消息ID的唯一性</strong>：在Redis Streams中，每个消息都有一个全局唯一的消息ID，这个消息ID由两部分组成：时间戳和序列号。时间戳表示消息被添加到流中的时间，序列号表示在同一时间戳内添加的消息的顺序。</p><p><strong>2. 消费者组</strong>：虽然XREAD命令本身不直接涉及消费者组的概念，但Redis Streams还支持消费者组模式，允许一组消费者协作消费同一流中的消息。在消费者组模式下，通常会使用XREADGROUP命令而不是XREAD命令来读取消息。</p><p><strong>3. 性能考虑</strong>：XREAD命令在读取大量消息时可能会消耗较多的CPU和内存资源。因此，在实际应用中需要根据实际情况合理设置COUNT参数的值，避免一次性读取过多消息导致性能问题。</p><h2 id="3-3-Consumer-Group-消费组模式"><a href="#3-3-Consumer-Group-消费组模式" class="headerlink" title="3.3 Consumer Group 消费组模式"></a>3.3 Consumer Group 消费组模式</h2><p>典型的多播模式，在实时性要求比较高的场景，如果你想加快对消息的处理。那这是一个不错的选择，我们让队列在逻辑上进行分区，用不同的消费组来隔离消费。所以：</p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAIBFmlIvRJOjaGmLMEWJvm_XI38vxw4AAJkDGsbp6dAVpjka6W8m4ZaAQADAgADdwADNgQ.png"></p><p>消费者组允许多个消费者（client 或 process）协同处理同一个流（Stream）中的消息。每个消费者组维护自己的消费偏移量（即已处理消息的位置），以支持消费者之间的负载均衡和容错。</p><h3 id="3-3-1-创建消费者组"><a href="#3-3-1-创建消费者组" class="headerlink" title="3.3.1 创建消费者组"></a>3.3.1 创建消费者组</h3><p>使用 XGROUP CREATE 命令创建消费者组。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># stream_name：队列名称</span></span><br><span class="line"><span class="comment"># consumer_group：消费者组</span></span><br><span class="line"><span class="comment"># msgIdStartIndex：消息Id开始位置</span></span><br><span class="line"><span class="comment"># msgIdStartIndex：消息Id结束位置</span></span><br><span class="line"><span class="comment"># $ 表示从流的当前末尾（即最新消息）开始创建消费者组。如果流不存在，MKSTREAM 选项将自动创建流</span></span><br><span class="line"><span class="variable constant_">XGROUP</span> <span class="variable constant_">CREATE</span> stream_name consumer_group msgIdStartIndex-msgIdStartIndex</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="variable constant_">XGROUP</span> <span class="variable constant_">CREATE</span> stream_name consumer_group <span class="variable">$ </span><span class="variable constant_">MKSTREAM</span></span><br></pre></td></tr></table></figure><p>下面是具体实现示例，为队列 userinfo_stream 创建了消费组1（consumer_group1）和 消费组2（consumer_group2）：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; xgroup <span class="built_in">create</span> userinfo_stream consumer_group1 <span class="number">0</span><span class="number">-0</span></span><br><span class="line">OK</span><br><span class="line">&gt; xgroup <span class="built_in">create</span> userinfo_stream consumer_group2 <span class="number">0</span><span class="number">-0</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure><h3 id="3-3-2-读取消息"><a href="#3-3-2-读取消息" class="headerlink" title="3.3.2 读取消息"></a>3.3.2 读取消息</h3><p>消费者可以通过 <code>XREADGROUP</code> 命令从消费者组中读取消息。<code>XREADGROUP</code> 命令不仅读取消息，还会更新消费者组中的消费者状态，即标记哪些消息已被读取。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># group_name: 消费者群组名</span></span><br><span class="line"><span class="comment"># consumer_name: 消费者名称</span></span><br><span class="line"><span class="comment"># COUNT number: count 消费个数</span></span><br><span class="line"><span class="comment"># BLOCK ms: 表示如果流中没有新消息，则命令将阻塞最多 xx 毫秒，0则无限阻塞</span></span><br><span class="line"><span class="comment"># stream_name: 队列名称 </span></span><br><span class="line"><span class="comment"># id: 消息消费ID</span></span><br><span class="line"><span class="comment"># []：代表可选参数</span></span><br><span class="line"><span class="comment"># `&gt;`：放在命令参数的最后面，表示从尚未被消费的消息开始读取；</span></span><br><span class="line"></span><br><span class="line">XREADGROUP GROUP group_name consumer_name [<span class="built_in">COUNT</span> number] [<span class="keyword">BLOCK </span>ms] STREAMS stream_name [stream ...] id [id ...]</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">XREADGROUP GROUP group_name consumer_name <span class="built_in">COUNT</span> <span class="number">1</span> <span class="keyword">BLOCK </span><span class="number">2000</span> STREAMS stream_name &gt;</span><br></pre></td></tr></table></figure><p>下面是具体实现示例，消费组 consumer_group1 的消费者 consumer1 从 userinfo_stream 中以阻塞的方式读取一条消息：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">XREADGROUP GROUP consumer_group1 consumer1 <span class="built_in">COUNT</span> <span class="number">1</span> <span class="keyword">BLOCK </span><span class="number">0</span> STREAMS userinfo_stream &gt;</span><br><span class="line"><span class="number">1</span>) <span class="number">1</span>) <span class="string">&quot;userinfo_stream&quot;</span></span><br><span class="line">   <span class="number">2</span>) <span class="number">1</span>) <span class="number">1</span>) <span class="string">&quot;1722159931000-0&quot;</span></span><br><span class="line">         <span class="number">2</span>) <span class="number">1</span>) <span class="string">&quot;user_name&quot;</span></span><br><span class="line">            <span class="number">2</span>) <span class="string">&quot;brand&quot;</span></span><br><span class="line">            <span class="number">3</span>) <span class="string">&quot;age&quot;</span></span><br><span class="line">            <span class="number">4</span>) <span class="string">&quot;18&quot;</span></span><br></pre></td></tr></table></figure><h3 id="3-3-3-确认消息"><a href="#3-3-3-确认消息" class="headerlink" title="3.3.3 确认消息"></a>3.3.3 确认消息</h3><p>处理完消息后，消费者需要发送 XACK 命令来确认消息。这告诉 Redis 这条消息已经被成功处理，并且可以从消费者组的待处理消息列表中移除</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># stream_name: 队列名称 </span></span><br><span class="line"><span class="comment"># group_name: 消费者群组名</span></span><br><span class="line"><span class="comment"># &lt;message-id&gt; 是要确认的消息的 ID。</span></span><br><span class="line"></span><br><span class="line">XACK stream_name group_name &lt;message-<span class="built_in">id</span>&gt;</span><br><span class="line"><span class="comment"># ACK 确认两条消息</span></span><br><span class="line">XACK userinfo_stream consumer_group1 <span class="number">1722159931000</span>-<span class="number">0</span> <span class="number">1722159932000</span>-<span class="number">0</span></span><br><span class="line">(integer) <span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="3-3-4-PLE：消息可靠性保障"><a href="#3-3-4-PLE：消息可靠性保障" class="headerlink" title="3.3.4 PLE：消息可靠性保障"></a>3.3.4 PLE：消息可靠性保障</h3><p>PEL（Pending Entries List）记录了当前被消费者读取但尚未确认（ACK）的消息。这些消息在消费者成功处理并发送ACK命令之前，会一直保留在PEL中。如果消费者崩溃或未能及时发送ACK命令，Redis将确保这些消息能够被重新分配给其他消费者进行处理，从而实现消息的可靠传递。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XPENDING stream_name group_name</span><br></pre></td></tr></table></figure><p>以下的例子中，我们查看 <code>userinfo_stream</code> 中的 消费组 <code>consumer_group1</code> 中各个消费者已读取但未确认的消息信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">XPENDING userinfo_stream consumer_group1</span><br><span class="line">1) (<span class="built_in">integer</span>) 2   <span class="comment"># 未确认消息条数</span></span><br><span class="line">2) <span class="string">&quot;1722159931000-0&quot;</span></span><br><span class="line">3) <span class="string">&quot;1722159932000-0&quot;</span></span><br></pre></td></tr></table></figure><p>详细的stream操作见官网文档：<a href="https://redis.io/docs/data-types/streams-tutorial/">https://redis.io/docs/data-types/streams-tutorial/</a></p><h1 id="4-使用Golang实现Stream队列能力"><a href="#4-使用Golang实现Stream队列能力" class="headerlink" title="4 使用Golang实现Stream队列能力"></a>4 使用Golang实现Stream队列能力</h1><h2 id="4-1-先安装go-redis-redis库"><a href="#4-1-先安装go-redis-redis库" class="headerlink" title="4.1 先安装go-redis&#x2F;redis库"></a>4.1 先安装go-redis&#x2F;redis库</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">go</span> get github.com/<span class="keyword">go</span>-redis/redis/v8</span><br><span class="line"><span class="keyword">go</span>: downloading github.com/<span class="keyword">go</span>-redis/redis v6<span class="number">.15</span><span class="number">.9</span>+incompatible</span><br><span class="line"><span class="keyword">go</span>: downloading github.com/<span class="keyword">go</span>-redis/redis/v8 v8<span class="number">.11</span><span class="number">.5</span></span><br><span class="line"><span class="keyword">go</span>: downloading github.com/dgryski/<span class="keyword">go</span>-rendezvous v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20200823014737</span><span class="number">-9</span>f7001d12a5f</span><br><span class="line"><span class="keyword">go</span>: downloading github.com/cespare/xxhash/v2 v2<span class="number">.1</span><span class="number">.2</span></span><br><span class="line"><span class="keyword">go</span>: added github.com/cespare/xxhash/v2 v2<span class="number">.1</span><span class="number">.2</span></span><br><span class="line"><span class="keyword">go</span>: added github.com/dgryski/<span class="keyword">go</span>-rendezvous v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20200823014737</span><span class="number">-9</span>f7001d12a5f</span><br><span class="line"><span class="keyword">go</span>: added github.com/<span class="keyword">go</span>-redis/redis/v8 v8<span class="number">.11</span><span class="number">.5</span></span><br></pre></td></tr></table></figure><p>注意：这里的v8是库的版本号，你可以根据实际情况进行调整</p><h2 id="逻辑实现"><a href="#逻辑实现" class="headerlink" title="逻辑实现"></a>逻辑实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line"><span class="string">&quot;context&quot;</span>  </span><br><span class="line"><span class="string">&quot;fmt&quot;</span>  </span><br><span class="line"><span class="string">&quot;log&quot;</span>  </span><br><span class="line"><span class="string">&quot;time&quot;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="string">&quot;github.com/go-redis/redis/v8&quot;</span>  </span><br><span class="line">)  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line"><span class="comment">// 连接到Redis  </span></span><br><span class="line">rdb := redis.NewClient(&amp;redis.Options&#123;  </span><br><span class="line">Addr:     <span class="string">&quot;localhost:6379&quot;</span>, <span class="comment">// Redis地址  </span></span><br><span class="line">Password: <span class="string">&quot;&quot;</span>,               <span class="comment">// 密码（如果有的话）  </span></span><br><span class="line">DB:       <span class="number">0</span>,                <span class="comment">// 使用默认DB  </span></span><br><span class="line">&#125;)  </span><br><span class="line">  </span><br><span class="line">ctx := context.Background()  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 创建Stream  </span></span><br><span class="line">_, err := rdb.XAdd(ctx, &amp;redis.XAddArgs&#123;  </span><br><span class="line">Stream: <span class="string">&quot;mystream&quot;</span>,  </span><br><span class="line">Values: <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;  </span><br><span class="line"><span class="string">&quot;field1&quot;</span>: <span class="string">&quot;value1&quot;</span>,  </span><br><span class="line"><span class="string">&quot;field2&quot;</span>: <span class="string">&quot;value2&quot;</span>,  </span><br><span class="line">&#125;,  </span><br><span class="line">&#125;).Result()  </span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">log.Fatalf(<span class="string">&quot;Failed to add message to stream: %v&quot;</span>, err)  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 创建Consumer Group  </span></span><br><span class="line">_, err = rdb.XGroupCreate(ctx, <span class="string">&quot;mystream&quot;</span>, <span class="string">&quot;mygroup&quot;</span>, <span class="string">&quot;$&quot;</span>).Result()  </span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; err != redis.Nil &#123;  </span><br><span class="line">log.Fatalf(<span class="string">&quot;Failed to create consumer group: %v&quot;</span>, err)  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 消费者读取消息  </span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;  </span><br><span class="line"><span class="keyword">for</span> &#123;  </span><br><span class="line">msgs, err := rdb.XReadGroup(ctx, &amp;redis.XReadGroupArgs&#123;  </span><br><span class="line">Group:    <span class="string">&quot;mygroup&quot;</span>,  </span><br><span class="line">Consumer: <span class="string">&quot;myconsumer&quot;</span>,  </span><br><span class="line">Streams:  []<span class="type">string</span>&#123;<span class="string">&quot;mystream&quot;</span>, <span class="string">&quot;&gt;&quot;</span>&#125;,  </span><br><span class="line">Count:    <span class="number">1</span>,  </span><br><span class="line">Block:    <span class="number">1000</span>, <span class="comment">// 阻塞1000毫秒  </span></span><br><span class="line">&#125;).Result()  </span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line"><span class="keyword">if</span> err == redis.Nil &#123;  </span><br><span class="line"><span class="comment">// 超时，没有新消息  </span></span><br><span class="line"><span class="keyword">continue</span>  </span><br><span class="line">&#125;  </span><br><span class="line">log.Fatalf(<span class="string">&quot;Failed to read from stream: %v&quot;</span>, err)  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> _, msg := <span class="keyword">range</span> msgs[<span class="number">0</span>].Messages &#123;  </span><br><span class="line">fmt.Printf(<span class="string">&quot;Received: %s %s\n&quot;</span>, msg.ID, msg.Values)  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 确认消息  </span></span><br><span class="line">_, err = rdb.XAck(ctx, <span class="string">&quot;mystream&quot;</span>, <span class="string">&quot;mygroup&quot;</span>, msg.ID).Result()  </span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">log.Fatalf(<span class="string">&quot;Failed to ack message: %v&quot;</span>, err)  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;()  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 模拟生产者继续发送消息  </span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;  </span><br><span class="line">_, err := rdb.XAdd(ctx, &amp;redis.XAddArgs&#123;  </span><br><span class="line">Stream: <span class="string">&quot;mystream&quot;</span>,  </span><br><span class="line">Values: <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;  </span><br><span class="line"><span class="string">&quot;field1&quot;</span>: fmt.Sprintf(<span class="string">&quot;value%d&quot;</span>, i+<span class="number">1</span>),  </span><br><span class="line"><span class="string">&quot;field2&quot;</span>: <span class="string">&quot;another value&quot;</span>,  </span><br><span class="line">&#125;,  </span><br><span class="line">MaxLen:     <span class="number">100</span>,  </span><br><span class="line">Approximate: <span class="literal">true</span>,  </span><br><span class="line">&#125;).Result()  </span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">log.Fatalf(<span class="string">&quot;Failed to add message to stream: %v&quot;</span>, err)  </span><br><span class="line">&#125;  </span><br><span class="line">time.Sleep(<span class="number">2</span> * time.Second) <span class="comment">// 模拟生产间隔  </span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 注意：在实际应用中，主goroutine通常不会立即退出，而是会等待某些触发条件</span></span><br></pre></td></tr></table></figure><h1 id="5-应用场景"><a href="#5-应用场景" class="headerlink" title="5 应用场景"></a>5 应用场景</h1><p><strong>1. 消息队列</strong>：Redis Stream可以作为消息队列使用，支持消息的发布、订阅和消费。</p><p><strong>2. 日志记录</strong>：将日志信息写入Redis Stream，方便后续的查询和分析。</p><p><strong>3. 实时数据分析</strong>：结合Redis的其他数据结构（如Sorted Set、Hash等），对Stream中的数据进行实时分析。</p><h1 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a>6 总结</h1><p>Redis Stream是Redis在消息队列和流式数据处理领域的一个重要补充，它提供了简单但功能强大的数据流处理能力，为开发者提供了更多的选择和灵活性。相对List，Stream的优势如下：</p><ul><li>支持消息确认机制（ACK应答确认）</li><li>支持消息回溯，方便排查问题和做消息分析</li><li>存在消费组（Consumer Group）的概念，可以进行分组消费和批量消费，可以负载多个消费实例</li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis系列：内存淘汰策略</title>
      <link href="/2025/03/11/Redis%E7%B3%BB%E5%88%97/Redis%E7%B3%BB%E5%88%97-%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/"/>
      <url>/2025/03/11/Redis%E7%B3%BB%E5%88%97/Redis%E7%B3%BB%E5%88%97-%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>通过前面的一些文章我们知道，Redis的各项能力是基于内存实现的，相对其他的持久化存储（如MySQL、File等，数据持久化在磁盘上），性能会高很多，这也是高速缓存的一个优势。</p><p>但是问题来了，每一台机器内存终归是有限的，即使是集群模式，总的内存空间也是有限的，不能无限制的消耗。而在Redis的使用过程中，很有可能出现使用消耗超过内存实际大小的情况。比如以下几种情况：</p><ul><li>未设置过期时间，Redis的Key将一直存在，直至我们明确将它删除。</li><li>过度跟不合理的持久化（无论是RDB快照 或是 AOF日志），都会在内存和磁盘中反复操作，需要一定的内存空间进行处理。</li><li>不及时清理过期缓存：清理过期缓存的方式主要有以下两种，并不是实时或者准实时，所以存在部分过期缓存依旧存在的问题。<ul><li>主动定期删除： Redis 默认每 1 秒运行 10 次（平均每 100 ms 执行一次），每次随机抽取部分设置过期时间的 key，检查是否过期，若是过期就直接删除，直至过期的 key 比率低于 1&#x2F;4。</li><li>被动惰性删除：缓存过期并不马上清理，当客户端的请求查询该 key 的时候，检查下 key 是否过期，如果过期，则删除该 key，重新获取。如果长时间未请求，就会有过期缓存滞留。</li></ul></li><li>不合理不规范的使用缓存，导致内存耗尽，比如：<ul><li>过度使用缓存，既缓存冷数据也能缓存热数据，导致内存占用过多，性能也没有得到有效提高</li><li>缓存数量过多或者单个缓存的Value体积过大</li><li>缓存过期时间设置过长或者根本不设置</li></ul></li></ul><h1 id="2-Redis内存淘汰策略"><a href="#2-Redis内存淘汰策略" class="headerlink" title="2 Redis内存淘汰策略"></a>2 Redis内存淘汰策略</h1><p>所以，如果放任上面的那几种情况，内存终归会满的，Redis自身有一套比较完善的内存淘汰策略来专门应对这个问题，在Redis Memory占用超过我们配置的阈值的时候触发策略执行。</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># redis.conf 配置最大内存空间占用为2gb，超过则执行内存淘汰策略</span></span><br><span class="line">redis &gt; CONFIG <span class="keyword">SET</span> maxmemory <span class="number">2</span>gb</span><br></pre></td></tr></table></figure><p>内存淘汰策略一共有8中，除了一种不执行淘汰策略之外，其他7种都是按照各自不一的算法对内存中现有的数据进行处理。<br>我们下面详细来看一下这些淘汰策略，把他们分成三大类，8小类来逐一讲解：</p><h2 id="2-1-不淘汰策略"><a href="#2-1-不淘汰策略" class="headerlink" title="2.1 不淘汰策略"></a>2.1 不淘汰策略</h2><h3 id="2-1-1-noeviction-不淘汰策略"><a href="#2-1-1-noeviction-不淘汰策略" class="headerlink" title="2.1.1 noeviction 不淘汰策略"></a>2.1.1 noeviction 不淘汰策略</h3><p>noeviction指的是即使资源超过 maxmemory 限制的值也不会执行淘汰，只是不允许创建新的缓存了。</p><p>当Redis内存占用达到我们上面的配置的阈值（比如 5gb）之后，就不允许新增缓存key了，当有新的缓存要创建的时候，Redis 直接返回error。</p><h2 id="2-2-仅淘汰配置过期时间key"><a href="#2-2-仅淘汰配置过期时间key" class="headerlink" title="2.2 仅淘汰配置过期时间key"></a>2.2 仅淘汰配置过期时间key</h2><p>这边仅针对配置了过期时间的数据进行淘汰</p><h3 id="2-3-1-volatile-lru-：删除最近最少使用的key"><a href="#2-3-1-volatile-lru-：删除最近最少使用的key" class="headerlink" title="2.3.1 volatile-lru ：删除最近最少使用的key"></a>2.3.1 volatile-lru ：删除最近最少使用的key</h3><p>LRU（Least Recently Used）是按照最近最少使用原则来筛选数据，即最不常用的数据会被筛选出来。</p><p>如果我们的服务中有冷热数据隔离需求，这无疑是一个比较好的办法。可以将缓存的一些不经常使用的冷数据，而且数据size比较大的，筛选出来清理掉。而近期频繁被使用的key就被保留下来了。<br>常见的场景如下：</p><ul><li>电商平台的冷热数据：比如冬季，保暖冬装、电暖设备的浏览次数就会升高，而相应的冷饮、制冷设备（冰箱、空调）的浏览次数就会降低，那么LRU策略下优先删除的就是最近一段时间未访问的缓存信息。</li><li>外卖平台：每天的1113点，1719点，一定是美食外卖品种的高频率访问时间段，而日用品、果蔬生鲜 大都会避开这个高峰期，这时如果内存不够用了，那么就会成为被优先删除的缓存类型。</li></ul><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAN7aUJgQS-lr-yWU93H9tsgXooREYcAArkLaxvvjBBWblIGAhfSvX8BAAMCAAN3AAM2BA.png"></p><h3 id="2-3-2-volatile-lfu：删除访问次数最少的key（4-0-之后新增的策略）"><a href="#2-3-2-volatile-lfu：删除访问次数最少的key（4-0-之后新增的策略）" class="headerlink" title="2.3.2 volatile-lfu：删除访问次数最少的key（4.0 之后新增的策略）"></a>2.3.2 volatile-lfu：删除访问次数最少的key（4.0 之后新增的策略）</h3><p>LRU算法的不足之处在于，一个本身很少被访问的key，只是刚刚被访问了1次，就被认为是最近有使用的热点数据，导致短时间内不会被淘汰。</p><p>而LFU弥补了这个不足，LFU（Least Frequently Used）淘汰策略会根据key的最近访问频率进行淘汰，解决上面说的这个不足。</p><ul><li>LFU在LRU的基础上，为每个数据增加了一个计数器，用于统计该数据的访问次数。</li><li>当使用LFU策略淘汰数据时，会根据数据的访问次数进行筛选，把访问次数最低的数据淘汰出内存。</li><li>如果两个缓存数据的访问次数相同，LFU再比较这两个key最近一次的访问时间，把访问时间更早的缓存key淘汰出内存。</li></ul><p>常见的应用场景：</p><ul><li>对于电商平台中的冷门的商品，电子书App中热度较低、阅读量较低的书籍。这种类型的缓存会优先被淘汰掉。</li></ul><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAN8aUJgXugz0AsS23qOscWqD7a931UAAroLaxvvjBBW4uzhtwMwXPcBAAMCAAN3AAM2BA.png"></p><h3 id="2-3-3-volatile-random：随机删除过期key"><a href="#2-3-3-volatile-random：随机删除过期key" class="headerlink" title="2.3.3 volatile-random：随机删除过期key"></a>2.3.3 volatile-random：随机删除过期key</h3><p>针对有配置过期时间，但没有明显的冷热访问频率区别，所有的查询分布比较均衡的数据。这时候就使用 allkeys-random 策略吧，让它随机选择需要淘汰数据，也相对公平。<br>常见的使用场景有：</p><ul><li>电商平台：常规时段的商品浏览。</li><li>钉钉之类工具：老师无差别抽查学生的作业。</li></ul><h3 id="2-3-4-volatile-ttl：删除过期时间内剩余时间最短的key"><a href="#2-3-4-volatile-ttl：删除过期时间内剩余时间最短的key" class="headerlink" title="2.3.4 volatile-ttl：删除过期时间内剩余时间最短的key"></a>2.3.4 volatile-ttl：删除过期时间内剩余时间最短的key</h3><p>这个特性仅限于配置过期时间的场景，它是根据当前时间 跟 过期时间的差额进行由短到长的排序，较短的优先淘汰。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">asc_sort</span>(validate_time - current_time)</span><br></pre></td></tr></table></figure><p>这种算法相对来说也不考虑缓存的访问频率和重要程度，仅按照创建的先后进行清理，越早的缓存越早清理。所以不具备明显特征的业务场景都适用。</p><h3 id="2-3-5-补充说明"><a href="#2-3-5-补充说明" class="headerlink" title="2.3.5 补充说明"></a>2.3.5 补充说明</h3><p>业务场景有一些数据始终不需要删除，比如置顶新闻、视频，还有我们自己置顶的weibo。为了保障它们不被清理掉，就给这些数据不设置过期时间，这样的话 volatile类型的淘汰策略就不会影响了。但如果是 allkeys 开头的策略依旧会影响到。</p><h2 id="2-3-淘汰所有缓存类型的key"><a href="#2-3-淘汰所有缓存类型的key" class="headerlink" title="2.3 淘汰所有缓存类型的key"></a>2.3 淘汰所有缓存类型的key</h2><p>无论是否配置了过期时间的数据均可进行淘汰。<br>从微服务拆分的角度说，不同的服务类型个方向的服务进行院子隔离会比较一点。这一点设计思维在缓存上依旧适用。<br>我们可以将不需要过期时间的缓存信息 和 需强制配置过期时间的缓存key分开。针对业务场景分别使用 volatile-xx策略 和 allkyes-xxx策略。</p><h3 id="2-3-1-allkeys-lru：删除最近最少使用的key"><a href="#2-3-1-allkeys-lru：删除最近最少使用的key" class="headerlink" title="2.3.1 allkeys-lru：删除最近最少使用的key"></a>2.3.1 allkeys-lru：删除最近最少使用的key</h3><p>保留最近有使用的key，类似volatile-lru</p><h3 id="2-3-2-allkeys-lfu：删除访问次数最少的key"><a href="#2-3-2-allkeys-lfu：删除访问次数最少的key" class="headerlink" title="2.3.2 allkeys-lfu：删除访问次数最少的key"></a>2.3.2 allkeys-lfu：删除访问次数最少的key</h3><p>最不经常使用的，类似volatile-lfu</p><h3 id="2-3-3-allkeys-random：随机删除过期key"><a href="#2-3-3-allkeys-random：随机删除过期key" class="headerlink" title="2.3.3 allkeys-random：随机删除过期key"></a>2.3.3 allkeys-random：随机删除过期key</h3><p>无差别随机删除，volatile-random，为添加新数据腾出空间</p><h2 id="2-4-策略命令的使用"><a href="#2-4-策略命令的使用" class="headerlink" title="2.4 策略命令的使用"></a>2.4 策略命令的使用</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 获取当前内存淘汰策略</span></span><br><span class="line">redis &gt; config <span class="keyword">get</span> maxmemory-policy</span><br><span class="line"></span><br><span class="line"><span class="meta"># 获取Redis能使用的最大内存大小：如果不设置最大内存大小或者设置最大内存大小为0，在64位操作系统下不限制内存大小，在32位操作系统下最多使用3GB内存。</span></span><br><span class="line">redis &gt; config <span class="keyword">get</span> maxmemory</span><br><span class="line"></span><br><span class="line"><span class="meta">#  通过命令配置淘汰策略</span></span><br><span class="line">redis &gt; config <span class="keyword">set</span> maxmemory-policy <span class="keyword">volatile</span>-lru</span><br><span class="line"></span><br><span class="line"><span class="meta"># 设置Redis最大占用内存大小，这边最大占用内存大小配置为2000M</span></span><br><span class="line">redis &gt; config <span class="keyword">set</span> maxmemory <span class="number">2000</span>mb</span><br></pre></td></tr></table></figure><h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h1><p>一张图总结<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAN9aUJglhgZft8f7NZz1DU7m_U8qCQAAr0LaxvvjBBWxeYChBm5c9UBAAMCAAN3AAM2BA.png"></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> Redis内存淘汰策略 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis系列：深刻理解高性能Redis的本质</title>
      <link href="/2025/03/11/Redis%E7%B3%BB%E5%88%97/Redis%E7%B3%BB%E5%88%97-%E6%B7%B1%E5%88%BB%E7%90%86%E8%A7%A3%E9%AB%98%E6%80%A7%E8%83%BDRedis%E7%9A%84%E6%9C%AC%E8%B4%A8/"/>
      <url>/2025/03/11/Redis%E7%B3%BB%E5%88%97/Redis%E7%B3%BB%E5%88%97-%E6%B7%B1%E5%88%BB%E7%90%86%E8%A7%A3%E9%AB%98%E6%80%A7%E8%83%BDRedis%E7%9A%84%E6%9C%AC%E8%B4%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 背景</h1><p>分布式系统绕不开的核心之一的就是数据缓存，有了缓存的支撑，系统的整体吞吐量会有很大的提升。通过使用缓存，我们把频繁查询的数据由磁盘调度到缓存中，保证数据的高效率读写。当然，除了在内存内运行还远远不够，我们今天就以具有代表性的缓存中间件Redis为例子，分析下，它是如何达到飞起的效率。</p><h1 id="2-Redis高效性能分析"><a href="#2-Redis高效性能分析" class="headerlink" title="2 Redis高效性能分析"></a>2 Redis高效性能分析</h1><p>Redis之所以能够提供超高的执行效率，主要从以下几个维度来实现的：<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAANsaUJahYhmpT20C3buqSiwwIky_9gAAp8LaxvvjBBWtjzhzL6BcHEBAAMCAAN3AAM2BA.png"></p><ul><li>存储模式：基于内存实现，而非磁盘</li><li>数据结构：基于不同业务场景的高效数据结构<ul><li>动态字符串(REDIS_STRING)：整数(REDIS_ENCODING_INT)、字符串(REDIS_ENCODING_RAW)</li><li>双端列表(REDIS_ENCODING_LINKEDLIST)</li><li>压缩列表(REDIS_ENCODING_ZIPLIST)</li><li>跳跃表(REDIS_ENCODING_SKIPLIST)</li><li>哈希表(REDIS_HASH)</li><li>整数集合(REDIS_ENCODING_INTSET)</li></ul></li><li>线程模型： Redis 的网络 IO 以及键值对指令读写是由单个线程来执行的，避免了不必要的contextswitch和竞选</li><li>I&#x2F;O 模型： 基于I&#x2F;O多路复用模型，非阻塞的I&#x2F;O模型</li><li>恰单的数据编码： 根据实际数据类型，选择合理的数据编码</li></ul><h2 id="2-1-官网的性能报告"><a href="#2-1-官网的性能报告" class="headerlink" title="2.1 官网的性能报告"></a>2.1 官网的性能报告</h2><p>Redis官方站点中，有对Redis性能做了比较详细的压测，可以参考官方这一篇 <a href="https://redis.io/topics/benchmarks">How fast is Redis?</a>，在较高的配置基准下（比如 8C 16G +），在连接数为0~10000的时候，最高QPS可达到120000。Redis以超过60000个连接为基准，仍然能够在这些条件下维持50000个q&#x2F;s，体现了超高的性能。下图中横轴是连接数，纵轴是QPS。<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAANuaUJb7Bn3HC0puG7nJ2BTm9ozbmoAAqILaxvvjBBWUInBLUSpaxABAAMCAAN4AAM2BA.png"><br>下面这张图为data size 与整体吞吐量之间的趋向关系：<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAANvaUJcBElaWK_iQhxNzRukOozjSfQAAqMLaxvvjBBWJf_W3gABf_3QAQADAgADeAADNgQ.png"></p><p>这个大概可以得出一个容量预估，比如你的服务用户量是多少，预估峰值QPS是多少，集群需要配置多少个实例（虽然实例的多少不能线性计算），可以大致推算出去。</p><h2 id="2-2-基于内存实现"><a href="#2-2-基于内存实现" class="headerlink" title="2.2 基于内存实现"></a>2.2 基于内存实现</h2><p>Redis的读写操作都是在内存中实现了，相对其他的持久化存储（如MySQL、File等，数据持久化在磁盘上），性能会高很多。因为在们在操作数据的时候，需要通过 IO 操作先将数据读取到内存里，增加工作成本。</p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAANwaUJcOIFjj2RpeyYEPEnUuhbS8iwAAqQLaxvvjBBWXIlT7ND9TucBAAMCAAN5AAM2BA.png"></p><p>上面那张图来源于网络，可以看看他的金字塔模型，越往上执行效率越高，价格也就越贵。下面给出每一层的执行耗时对比：</p><ul><li>寄存器：0.3 ns</li><li>L1高速缓存：0.9 ns</li><li>L2高速缓存：2.8 ns</li><li>L3高速缓存：12.9 ns</li><li>主存：120 ns</li><li>本地二级存储（SSD）：50~150 us</li><li>远程二级存储：30 ms<br>这样可能不直观，我们举个L1和SSD的对比，如果L1耗时1s的话，SSD中差不多要15~45小时。<br>因为 CPU 内部集成了内存控制器，所以CPU直接控制了内存，给予通信上的最优带宽。上面的部分数据引用自《<a href="http://product.dangdang.com/23762087.html">性能之巅：洞悉系统、企业与云计算</a>》。</li></ul><h2 id="2-3-适配多元场景的高效数据结构"><a href="#2-3-适配多元场景的高效数据结构" class="headerlink" title="2.3 适配多元场景的高效数据结构"></a>2.3 适配多元场景的高效数据结构</h2><p>在 Redis 缓存中，常用的主要数据类型有五种，如下：</p><ul><li>字符串&#x2F;REDIS_STRING：适用于 缓存、计数、共享Session、IP统计、分布式锁等。</li><li>列表&#x2F;REDIS_LIST： 链表、消息队列、栈、有序的对象列表（如朋友圈的点赞顺序列表、评论顺序列表）。</li><li>哈希表&#x2F;REDIS_HASH： 购物车信息、用户信息、Hash类型的(key, field, value)存储对象等。</li><li>集合&#x2F;REDIS_SET：无序的唯一的键值结构： 好友、关注、粉丝、感兴趣的人集合等。</li><li>有序集合&#x2F;REDIS_ZSET：访问排行榜、点赞排行、粉丝数排行等。</li></ul><p>上面这5种Redis 支持的数据类型，能够满足不同业务场景下的数据结构需求。而对于这几类数据类型的区分和支持，目的无非也是为了效率，具体的业务中使用恰当的数据结构才能保证得到应有的效率。</p><p>这5种数据类型都有一种或者多种数据结构来支撑，底层数据结构有 7 种。关系如下：<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAOhaUYTlCGnYtTmCbYAAR_OQK4XZAotAAJgC2sb0X4wVgvpselcoIZgAQADAgADdwADNgQ.png"><br>下面我们对这些数据结构一个个的分析。</p><h3 id="2-3-1-SDS-简单动态字符串"><a href="#2-3-1-SDS-简单动态字符串" class="headerlink" title="2.3.1 SDS 简单动态字符串"></a>2.3.1 SDS 简单动态字符串</h3><p>Redis使用简单动态字符串（simple dynamic string，SDS）来表示字符串，Redis中字符串类型包含的数据结构有：整数（R_INT） 、 字符串（R_RAW）。我们以字符串为例子，常规的字符串，如 “Brand”，如果要获取他的长度，需要从头开始遍历，直至遇到 \0 空字符代表结尾,如 C字符串。</p><p>C 字符串结构与 SDS 字符串结构 对比图 参照如下：<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAOiaUYTo38cOQ2RuhvRXvu5l0ZoXEsAAmELaxvRfjBW7KzW_lIkKqkBAAMCAAN5AAM2BA.png"></p><ul><li>free属性的值为0，表示这个SDS没有分配任何未使用空间。</li><li>len属性的值为5，表示这个SDS保存了一个5字节长度的字符串。</li><li>buf是一个char类型的数组，存储真实的字符串，数组的前五个字节分别保存了’B’、’r’、’a’、’n’、’d’五个字符，而最后一个字节则保存了空字符’\0’，代表结尾。<br>注意：SDS遵循C字符串的惯例以空字符结尾，保存空字符的1字节不计算在SDS的len属性中。</li></ul><p>比起C字符串，SDS具有以下优点：</p><ol><li><p>度获取字符串长度时间复杂度为O(1) 。C字符串不记录自身长度，获取C字符串长度时必须遍历整个字符串计数得到，复杂度是O(N)SDS字符串自身记录维护len长度属性，获得SDS字符串长度的复杂度是O(1)</p></li><li><p>杜绝缓冲区溢出。C字符串不记录长度，由于两个C字符串在内存存储上紧邻，在执行字符串拼接strcat时，如果不提前分配足够空间，很可能发生修改s1的数据溢出到s2所在的空间中（缓冲区溢出）。SDS杜绝了缓冲区溢出问题，它记录了长度，当修改SDS字符串之前，API都会检查SDS的空间是否满足修改的要求，不满足API会自动进行空间扩展。</p></li><li><p>空间预分配，减少修改时的内存重分配次数SDS 被修改后，程序不仅会为 SDS 分配所需要的空间，还会分配额外的未使用空间。这样，Redis可以减少连续执行字符串增长操作所需的内存重分配次数。具体分配未使用空间如下2种方式：</p><ul><li><p>如修改后长度len小于1MB，就分配和len属性相同大小的未使用空间：free&#x3D;len。</p></li><li><p>如修改后长度len大于等于1MB，就分配1M的未使用空间：free&#x3D;1MB。</p></li></ul></li><li><p>惰性空间释放，缩短操作时：SDS避免了缩短字符串时所需的内存重分配操作，并为将来可能有的增长操作提供了优化。当SDS做缩短操作，不会立刻使用内存重分配来收回缩短后多出来的字节，而是保持在free属性里。将来如果需要 append 操作，则直接使用 free 中未使用的空间，减少了内存的分配步骤。另外，SDS也提供了API手动进行释放SDS未使用空间，避免惰性释放策略会造成内存浪费。</p></li><li><p>二进制安全，C字符串的字符必须符合某种编码，除结尾空字符以外，字符串内部不允许有空字符串，存储有局限性。而在 Redis 中，不仅可以存储 String 类型的数据，也可能存储一些二进制数据。二进制数据并不是规则的字符串格式，其中会包含一些特殊的字符如 ‘\0’。在 C 中遇到 ‘\0’ 则表示字符串的结束，但SDS不是，它是以len长度标识结尾。</p></li><li><p>兼容部分C字符串函数。SDS虽然是二进制安全的，但还是秉承C字符串以空字符结尾的特性，很多函数与C字符串一致不需要重写。</p></li></ol><h3 id="2-3-2-zipList-压缩列表"><a href="#2-3-2-zipList-压缩列表" class="headerlink" title="2.3.2 zipList 压缩列表"></a>2.3.2 zipList 压缩列表</h3><p>通过上面的数据结构关系图，可以看出，压缩列表是 List 、Hash、 Set 三种数据类型底层实现之一。当我们的list列表数据量比较少的时候，且存储的数据轻量的（如小整数值、短字符串）时候， Redis 就会通过压缩列表来进行底层实现。ziplist 是由一系列特殊编码的连续内存块组成的顺序型的数据结构，在列表头有三个字段 zlbytes、zltail 和 zllen，列表中有多个entry，表尾还有一个 zlend，我们来具体拆解下：</p><ul><li>zlbytes：表示列表占用字节数</li><li>zltail：列表尾的偏移量</li><li>zllen：列表尾的偏移量：列表中的 entry 个数</li><li>entry：存储区，可以包含多个节点，每个节点可以存放整数或者字符串。</li><li>zlend：表示列表结束。</li></ul><p>参考代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ziplist</span>&lt;</span>T&gt; &#123;</span><br><span class="line">    <span class="comment">// 列表占用字节数</span></span><br><span class="line">    int32 zlbytes;</span><br><span class="line"><span class="comment">// 列表尾的偏移量，用于快速定位到最后一个节点</span></span><br><span class="line">    int32 zltail_offset; </span><br><span class="line"><span class="comment">// 列表entry元素个数</span></span><br><span class="line">    int16 zllength; </span><br><span class="line"><span class="comment">// 元素内容列表</span></span><br><span class="line">    T[] entries; </span><br><span class="line"><span class="comment">// 标志压缩列表的结束，值恒为 0xFF</span></span><br><span class="line">    int8 zlend; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAANxaUJdHsQpTQHDHm_jOJ3EBl3NbCsAAqULaxvvjBBWqf_yqAMxBjgBAAMCAAN4AAM2BA.png"><br>如果查找定位首个元素或最后1个元素，可以通过表头zlbytes、zltail_offset元素快速获取，复杂度是 O(1)。但是查找其他元素时，就没有这么高效了，只能逐个查找下去，比如 entry n 的复杂度就是 O(N)。</p><h3 id="2-3-3-linklist-双端列表"><a href="#2-3-3-linklist-双端列表" class="headerlink" title="2.3.3 linklist 双端列表"></a>2.3.3 linklist 双端列表</h3><p>Redis List 数据类型经常使用在链表、消息队列、栈、有序的对象列表（如朋友圈的点赞顺序列表、评论顺序列表、关注时间线）等场景，无论是队列（先进先出），还是栈（先进后出），双端列表都能很好的支持。<br>参考代码如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> list &#123;</span><br><span class="line"><span class="comment">// 表头</span></span><br><span class="line">listnode * head;</span><br><span class="line"><span class="comment">// 表尾</span></span><br><span class="line">listnode * tail;</span><br><span class="line"><span class="comment">// 链表所包含的节点数量</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> len;</span><br><span class="line"><span class="comment">// 函数：复制节点值</span></span><br><span class="line"><span class="type">void</span> *(*dup)(<span class="type">void</span> *ptr);</span><br><span class="line"><span class="comment">// 函数：释放节点值</span></span><br><span class="line"><span class="type">void</span> (*free)(<span class="type">void</span> *ptr);</span><br><span class="line"><span class="comment">// 函数：对比节点值</span></span><br><span class="line"><span class="type">int</span> (*match)(<span class="type">void</span> *ptr, <span class="type">void</span> *key);</span><br><span class="line">&#125; list;</span><br></pre></td></tr></table></figure><p>Redis 的链表实现的特性可以总结如下：</p><ul><li>双端：链表节点带有 prev 和 next 指针，获取某个节点的前一节点和后一节点的复杂度都是 O(1)。</li><li>无环：表头节点的 prev 指针和表尾节点的 next 指针都指向 NULL，对链表的访问以 NULL 为终点。</li><li>表头指针&#x2F;表尾指针：通过 list 结构的 head 指针和 tail 指针，获取链表的表头节点和表尾节点的复杂度为 O(1)。</li><li>链表长度计数器：通过 list 结构的 len 属性来对 list 的链表节点进行计数，获取节点数量的复杂度为O(1)。</li><li>多态：链表节点使用 void* 指针来保存节点值，并通过 list 结构的 dup、free、match 三个属性为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值。使用链表的附加空间相对太高，因为64bit系统中指针是8个字节，所以prev和next指针需要占据16个字节，且链表节点在内存中单独分配，会加剧内存的碎片化，影响内存管理效率。考虑到链表的以上缺点，Redis后续版本对列表数据结构进行改造，使用quicklist代替了ziplist和linkedlist。 作为ziplist 和 linkedlist 的混合体，它将 linkedlist 按段切分，每一段使用 ziplist 来紧凑存储，多个 ziplist 之间使用双向指针串接起来。<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAANyaUJdORu2Z5dHjG1QnGd8DVTNJGsAAqYLaxvvjBBWOCIIpvFHep0BAAMCAAN5AAM2BA.png"><br>这样，性能就的得到了更大的提升。</li></ul><h3 id="2-3-4-Hhash-字典"><a href="#2-3-4-Hhash-字典" class="headerlink" title="2.3.4 Hhash 字典"></a>2.3.4 Hhash 字典</h3><p>无论何种类型（string、list、hash、set、zset），Redis都是以一个Hash结构的形式来保存键值对的。整体是一个数组，数组中的每个元素都是一个独立的对象，被称为哈系桶，比如图中1 ~ n, 对应的entry保存着实际具体值的指针。<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAN0aUJdhO9sSstRoX1-wSq4wEzi4mIAAqcLaxvvjBBWOphPTIesHloBAAMCAAN3AAM2BA.png"><br>上图中的全局哈希表，它的时间复杂度是 O(1)，只需要计算每个键的哈希值，便知道对应的哈希桶位置，定位桶中的 entry ，并找到对应数据。这个执行效率就很高了。为了解决可能存在的冲突，采用了链式哈希的做法，也就是同一个桶里面的元素使用链表保存。</p><h3 id="2-3-5-intset-整数集合"><a href="#2-3-5-intset-整数集合" class="headerlink" title="2.3.5 intset 整数集合"></a>2.3.5 intset 整数集合</h3><p>如果你的集合只有整数值元素，并且数量是轻量的，这时候Redis会使用使用整数集合作为Redis集合的底层数据结构。参考如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">intset</span>&#123;</span><br><span class="line">     <span class="comment">// 编码格式</span></span><br><span class="line">     <span class="type">uint32_t</span> encoding;</span><br><span class="line">     <span class="comment">// 集合中的元素个数</span></span><br><span class="line">     <span class="type">uint32_t</span> length;</span><br><span class="line">     <span class="comment">// 保存元素数据</span></span><br><span class="line">     <span class="type">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure><p>我们拆解下：</p><ul><li><p><strong>encoding：</strong> 编码方式</p></li><li><p><strong>length：</strong> 数组中元素个数，也就是数组的整体长度</p></li><li><p><strong>contents</strong>[]：</p><p>整数集合，集合的每个元素都是数组的一个数组项（item）。具有以下特点：</p><ul><li>按值的大小增序排列</li><li>不包含任何重复项</li></ul></li></ul><h3 id="2-3-6-skipList跳跃表"><a href="#2-3-6-skipList跳跃表" class="headerlink" title="2.3.6 skipList跳跃表"></a>2.3.6 skipList跳跃表</h3><p>skiplist（即跳跃表）是一种有序数据结构，所以它也是ZSet数据类型中的一种，通过在每个节点中维持多个指向其他节点的指针，达到快速定位的目标。</p><p>跳跃表的平均的节点搜索，平均时间复杂度是 O(logN)、最差时间复杂度是 O(N)，还可以通过顺序性操作来批量处理节点。 跳跃表是基于链表的改良，在它基础上，增加了多层级索引，通过索引不断跳转，最终定好位到真实的数据项。这个方式是不是让大家想到b+tree，理念上有点接近，如下图所示：<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAN1aUJdtoyIZpPiLTEfnthBwv0PpH8AAqgLaxvvjBBW7NxZ_1Lb91UBAAMCAAN5AAM2BA.png"><br>可以看出，需要获取 68 这个元素需要经历3次查找，需要获取 97则需要经历4次查找。</p><h2 id="2-4-单线程模型"><a href="#2-4-单线程模型" class="headerlink" title="2.4 单线程模型"></a>2.4 单线程模型</h2><p><strong>Redis 的单线程主要是指Redis的网络IO和键值对读写是由一个线程来完成的，Redis在处理客户端的请求时包括获取 (socket 读)、解析、执行、内容返回 (socket 写) 等都由一个顺序串行的主线程处理，这就是所谓的“单线程”。这也是Redis对外提供键值存储服务的主要流程。</strong></p><p>但Redis的其他功能， 比如持久化、异步删除、集群数据同步等等，其实是由额外的线程执行的。 可以这么说，Redis工作线程是单线程的。但是，整个Redis来说，是多线程的。</p><h3 id="2-4-1-为何是单线程？"><a href="#2-4-1-为何是单线程？" class="headerlink" title="2.4.1 为何是单线程？"></a>2.4.1 为何是单线程？</h3><p>那在主流程中使用单线程，主要是出于什么原因呢？</p><ul><li><strong>整体吞吐量降低</strong><br>适当的扩增线程，是为了有效的利用cpu的性能，让它跟内存达到一个利用的最优值。但频繁的Redis读写，如果没有对线程进行有效管理，不但对系统的吞吐量没有提升，反而可能导致下降。<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAN2aUJd2pA6an-IpSvAE_RXCSA7IpsAAqwLaxvvjBBWfYIom8xRJ6IBAAMCAAN4AAM2BA.png"></li><li><strong>CPU上下文切换</strong><br>在运行任务的时候，CPU需要把任务加载到CPU寄存器中进行计算，当切换到其他thread时，需要将当前上下文存储在系统内核中，以便后续重新执行计算时再次加载。就像你做专心做一件事时，频繁切换，频繁被打断，这个代价是非常高的。<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAN3aUJd5ZJEBMoeY0Ewzn3p5w3WoxQAAq0LaxvvjBBWviQxgPH9LdIBAAMCAAN4AAM2BA.png"><br>如图中，切换上下文时，我们需要完成一系列工作，save context、switch、restore context等，这种操作越频繁越是耗费资源。</li><li><strong>共享资源的并发控制问题</strong><br>引入了程序执行顺序的不确定性，带来了并发读写的一系列问题，增加了系统复杂度。同时可能存在线程切换、甚至加锁解锁、死锁造成的性能损耗。</li><li><strong>内存才是核心关注点</strong><br>对于 Redis 框架来说， 主要的性能瓶颈是内存或者网络带宽，而非 CPU。</li></ul><h3 id="2-4-2-单线程的好处"><a href="#2-4-2-单线程的好处" class="headerlink" title="2.4.2 单线程的好处"></a>2.4.2 单线程的好处</h3><ol><li>避免线程创建过多导致的性能消耗，反而降低整体吞吐能力。</li><li>避免上下文切换引起的 CPU 额外的开销。</li><li>避免了线程之间的竞争问题，如加锁、解锁、死锁等，都会造成性能损耗。</li><li>无需额外考虑多线程带来的程序复杂度，代码更清晰，处理逻辑简单。</li></ol><h3 id="2-4-3-单线程是否有效利用CPU"><a href="#2-4-3-单线程是否有效利用CPU" class="headerlink" title="2.4.3 单线程是否有效利用CPU"></a>2.4.3 单线程是否有效利用CPU</h3><p>官方这么说</p><blockquote><p>It’s not very frequent that CPU becomes your bottleneck with Redis, as usually Redis is either memory or network bound. For instance, using pipelining Redis running on an average Linux system can deliver even 1 million requests per second, so if your application mainly uses O(N) or O(log(N)) commands, it is hardly going to use too much CPU.</p></blockquote><p>大概意思是，Redis是完全的纯内存操作，执行速度是非常快的，CPU通常不会是瓶颈，因为大多数请求不会是CPU密集型的。<a href="https://redis.io/docs/getting-started/faq/">参考</a>，Redis真正的性能瓶颈在网络IO，也就是客户端和服务端之间的网络传输延迟，因此Redis选择了单线程的IO多路复用来实现它的核心网络模型。</p><h2 id="2-5-I-O-多路复用模型"><a href="#2-5-I-O-多路复用模型" class="headerlink" title="2.5 I&#x2F;O 多路复用模型"></a>2.5 I&#x2F;O 多路复用模型</h2><p>服务端网络编程常见的 I&#x2F;O 模型有四种：同步阻塞IO（Blocking IO）、同步非阻塞IO（Non-blocking IO）、IO多路复用（IO Multiplexing）、异步IO（Asynchronous IO）。</p><p>Redis 采用的是 I&#x2F;O 多路复用技术，并发的去处理连接，它的多路复用程序函数有 select、poll、epoll、kqueue。以 epoll （目前最新的也是最好的多路复用技术）函数为例，当客服端执行 read、write、accept、close 等操作命令时，它会将命令封装成一个个事件，然后利用 epoll 多路复用的特性来避免 I&#x2F;O 阻塞。</p><p>下面我们看看普通 I&#x2F;O 模型 和 Redis的 I&#x2F;O 多路复模型的的区别，来分析Redis高频请求下如何保持高效执行。</p><h3 id="2-5-1-普通-I-O-模型"><a href="#2-5-1-普通-I-O-模型" class="headerlink" title="2.5.1 普通 I&#x2F;O 模型"></a>2.5.1 普通 I&#x2F;O 模型</h3><p>先来看一下传统的阻塞 I&#x2F;O 模型到底是如何工作的：当使用 read 或者 write 对某一个文件描述符（File Descriptor：FD)进行读写时，如果当前 FD 不可读或不可写，整个 Redis 服务就不会对其它的操作作出响应，导致整个服务不可用。</p><p>这也就是传统意义上的，也就是我们在编程中使用最多的阻塞模型：<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAN4aUJeEhrgpcra_YyBw2UE9X7lgOEAAq4LaxvvjBBWXAQx6qsoQQUBAAMCAAN5AAM2BA.png"><br>阻塞模型虽然开发中非常常见也非常易于理解，但是由于它会影响其他 FD 对应的服务，所以在需要处理多个客户端任务的时候，往往都不会使用阻塞模型。</p><h3 id="2-5-2-I-O-多路复用"><a href="#2-5-2-I-O-多路复用" class="headerlink" title="2.5.2 I&#x2F;O 多路复用"></a>2.5.2 I&#x2F;O 多路复用</h3><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAN5aUJeNM-4Qy4_DSMvUuDND5uRxyUAArALaxvvjBBW0dgCHSXOrvABAAMCAAN5AAM2BA.png"><br><strong>多路复用</strong>指的是：多个socket连接复用一个线程。这种模式下，内核不会去监视应用程序的连接，而是监视文件描述符.</p><p>当客户端发起请求的时候，会生成不同事件类型的套接字。而在服务端，因为使用了 I&#x2F;O 多路复用技术，所以不是阻塞式的同步执行，而是将消息放入 socket 队列（参考下图的 I&#x2F;O Multiplexing module），然后通过 File event Dispatcher 将其转发到不同的事件处理器上，如accept、read、send。<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAN6aUJebmReDkkjB5bvH9VPt3SFL7YAArELaxvvjBBWoqukEF6bwEwBAAMCAAN4AAM2BA.png"><br>综上，我们得出如下特性：</p><ul><li>单线程模式，内核持续监听 socket 上的连接及数据请求，一监听就交予Redis线程处理，达到单个线程处理多个I&#x2F;O 流的效果。</li><li>epoll 提供了基于事件的回调机制。不同事件调用对应的事件处理器。Redis可以持续性的高效处理事件，性能同步提升。</li><li>Redis 不阻塞任一客户端发起的请求，所以可以同时和多个客户端连接并处理请求，聚币并发执行的能力。</li></ul><h1 id="3-高性能Redis总结"><a href="#3-高性能Redis总结" class="headerlink" title="3 高性能Redis总结"></a>3 高性能Redis总结</h1><ul><li>基于内存实现，而非磁盘，大都是简单的存取操作，资源主要消耗在 IO 上，所以读取速度快。</li><li>数据结构：基于不同业务场景的高效数据结构<ul><li>动态字符串(REDIS_STRING)：整数(REDIS_ENCODING_INT)、字符串(REDIS_ENCODING_RAW)</li><li>双端列表(REDIS_ENCODING_LINKEDLIST)</li><li>压缩列表(REDIS_ENCODING_ZIPLIST)</li><li>跳跃表(REDIS_ENCODING_SKIPLIST)</li><li>哈希表(REDIS_HASH)</li><li>整数集合(REDIS_ENCODING_INTSET)</li></ul></li><li>线程模型：Redis 的网络 IO 以及键值对指令读写是由单个线程来执行的，避免了不必要的contextswitch和竞选</li><li>I&#x2F;O 模型：基于I&#x2F;O多路复用模型，非阻塞的I&#x2F;O模型</li><li>恰单的数据编码：根据实际数据类型，选择合理的数据编码</li><li>Redis 本身是一个全局 哈希表，他的时间复杂度是 O(1)，另外为了防止哈希冲突导致链表过长，执行 rehash 操作进行扩充，减少哈希冲突。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> Redis原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线上事故记录OOM-转载</title>
      <link href="/2025/03/11/%E6%8E%92%E5%BF%A7%E8%A7%A3%E9%9A%BE/%E7%94%9F%E4%BA%A7%E4%BA%8B%E6%95%85%E8%AE%B0%E5%BD%95-OOM/"/>
      <url>/2025/03/11/%E6%8E%92%E5%BF%A7%E8%A7%A3%E9%9A%BE/%E7%94%9F%E4%BA%A7%E4%BA%8B%E6%95%85%E8%AE%B0%E5%BD%95-OOM/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-案例一"><a href="#0x01-案例一" class="headerlink" title="0x01 案例一"></a>0x01 案例一</h2><p><strong>事故时间</strong>：2018年6月13日</p><p><strong>故障类型</strong>：<code>java.lang.OutOfMemoryError: Java heap space</code></p><p><strong>事故经过</strong>：某考务管理系统，前期收集考生报名信息时允许上传ZIP附件提交相关材料，后台服务会解析压缩包并从中获取相关文件。</p><p>系统运行后不久，考务群就陆续有人反馈报名网站打不开，无法访问等等。让运维重启系统后，又恢复正常，跑了一段时间以后，又有人说无法访问。仔细检查故障时的日志，发现故障时间点都是发生在有人上传ZIP文件的时候。</p><p>从服务器上提取了一部分样本，发现压缩文件里面包含若干个TXT文件，TXT文件中是重复的字符，类似AAA…该TXT文件原始数据巨大且单调重复，导致压缩后的ZIP却非常小，真是个天才！直觉告诉我们这是被恶意攻击了，遂暂时关闭了文件上传接口，改为通过表单录入信息报名。</p><p>事后复盘当时的代码，发现处理ZIP文件时没有释放到磁盘临时文件，都是在内存中直接解压并读取解压后的文本数据，这就给了攻击者可乘之机。但是后来专门去研究了下这方面的安全漏洞，发现这是一种ZIP炸弹（ZIP of Death or ZIP Bomb），即使是释放到磁盘，也有可能造成磁盘资源耗尽。除了构造简单重复内容，还能通过递归嵌套，目录穿越等构造恶意的ZIP并释放巨量数据，有兴趣的朋友可以去自行查阅。</p><p><strong>解决方案</strong>：禁止上传嵌套压缩包，只允许上传单级压缩文件；检查文件大小；检查文件路径。</p><h2 id="0x02-案例二"><a href="#0x02-案例二" class="headerlink" title="0x02 案例二"></a>0x02 案例二</h2><p><strong>事故时间</strong>：2021年6月30日</p><p><strong>故障类型</strong>：<code>java.lang.OutOfMemoryError: Metaspace</code></p><p><strong>事故经过</strong>：某报文处理服务，需要同时处理多种渠道的<code>XML</code>报文，使用了 JAXB (Java Architecture for XML Binding) 和 XSD (XML Schema Definition) 进行报文编&#x2F;解组和格式检查。</p><p>随着业务越来越繁重，某次上线后，生产服务频繁出现<code>java.lang.OutOfMemoryError: Metaspace</code>内存异常。最后经查是因为应用启动时，一次性加载了全量的XSD和<code>Document</code>对象，大量的加载类填满了Metaspace。</p><p>应用JVM参数<code>-XX:MaxMetaspaceSize</code>、<code>-XX:MetaspaceSize</code>均设置为256MB，当时的加载代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SchemaFactory</span> <span class="variable">schemaFactory</span></span><br><span class="line">        <span class="operator">=</span> SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);</span><br><span class="line"><span class="keyword">return</span> schemaFactory.newSchema(schemaSources);</span><br></pre></td></tr></table></figure><p>一次性初始化了所有的XSD源。老规矩，先救命再治病：</p><ul><li><strong>临时解决方案</strong>：评估最大Metaspace并扩容</li><li><strong>最终解决方案</strong>：服务拆分，分块加载</li></ul><h2 id="0x03-案例三"><a href="#0x03-案例三" class="headerlink" title="0x03 案例三"></a>0x03 案例三</h2><p><strong>事故时间</strong>：2022年3月17日</p><p><strong>故障类型</strong>：<code>java.lang.StackOverflowError</code></p><p><strong>事故经过</strong>：某营销管理系统对接第三方接口上送的数据，并进行解析处理，触发对应的业务流程。其中一个业务处理是给编号为0-N的直连机构推送通知，按照接口约定，其中N由第三方接口指定，且最大值不会超过255。</p><p>管理后台采用了类似这样的代码进行处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span> corpNum)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送通知给企业，当前编号: &quot;</span> + corpNum);</span><br><span class="line">        sendSms(corpNum);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;发送通知给企业失败，当前编号: &quot;</span> + corpNum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (corpNum != <span class="number">0</span>) &#123;</span><br><span class="line">        process(corpNum - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上线之后系统一直运行良好，直到有一天，第三方接口上送数据时传了个-1，嚯！系统直接崩了，打电话过去对方说是配置有误，导致参数填写错误。这边喜提<code>java.lang.StackOverflowError</code>。</p><p>其实测试之初应该可以避免的，但是负责该业务的开发过于信任第三方上送的数据，没有考虑到意外的参数范围，狠狠的交了一笔学费。</p><p><strong>解决方案</strong>：增加严格的参数校验，同时修改尾递归写法为循环发送。</p><h2 id="0x04-案例四"><a href="#0x04-案例四" class="headerlink" title="0x04 案例四"></a>0x04 案例四</h2><p><strong>事故时间</strong>：2022年4月15日</p><p><strong>故障类型</strong>：<code>java.lang.OutOfMemoryError: unable to create new native thread</code></p><p><strong>事故经过</strong>：某接口服务配置了无界线程池作为业务线程池。该接口业务非常简单，收集各个上游服务的度量指标 (Metrics) ，简单记录日志并写入数据库，轻量、高频、无长时间阻塞，一切都那么完美。</p><p>然而，某天突然运维报告服务不可用，查询日志发现服务已经凉了有段时间，死因是<code>java.lang.OutOfMemoryError: unable to create new native thread</code>。还好留下了堆栈，一通分析，发现是有段时间应用日志所在磁盘空间写满，导致线程得不到释放，高频调用之下，最终无法创建新线程，导致服务被压垮。</p><p>那么为什么写日志会阻塞线程呢？当时应用使用的是logback日志实现，查看其配置，使用的是<code>AsyncAppender</code>异步记录器：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;file.async&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.AsyncAppender&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 不丢失日志 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">discardingThreshold</span>&gt;</span>0<span class="tag">&lt;/<span class="name">discardingThreshold</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;file.log&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里的配置正是压死骆驼的最后一根稻草。日志首先被写入<code>BlockingQueue</code>内存队列，再由工作线程异步写入磁盘。如果磁盘写满导致下游<code>FileAppender</code>无法正常工作，而<code>AsyncAppender</code>的队列又被填满，就会导致对<code>Logger</code>的调用发生阻塞。</p><p>官方文档里对于<code>discardingThreshold</code>是这样描述的：</p><blockquote><p>In light of the discussion above and in order to reduce blocking, by default, when less than 20% of the queue capacity remains, AsyncAppender will drop events of level TRACE, DEBUG and INFO keeping only events of level WARN and ERROR. This strategy ensures non-blocking handling of logging events (hence excellent performance) at the cost loosing events of level TRACE, DEBUG and INFO when the queue has less than 20% capacity. Event loss can be prevented by setting the discardingThreshold property to 0 (zero).</p></blockquote><p>设置为0，虽然可以防丢，但也让logback没有退路可言。</p><p><strong>解决方案</strong>：为接口配置有界线程池，并调整<code>discardingThreshold</code>为合理数值。</p><h2 id="0x05-案例五"><a href="#0x05-案例五" class="headerlink" title="0x05 案例五"></a>0x05 案例五</h2><p><strong>事故时间</strong>：2022年5月25日</p><p><strong>故障类型</strong>：<code>java.lang.OutOfMemoryError: Java heap space</code></p><p><strong>事故经过</strong>：某后台管理系统，由于存在敏感数据，需要在本地安装安全控件来辅助访问，该系统在首页上提供了多个版本的控件安装包下载。</p><p>上线之初系统运行都挺正常，但是某天突然有用户反馈系统无法访问，浏览器提示502网关错误。查阅发现服务已挂，应用日志提示<code>java.lang.OutOfMemoryError: Java heap space</code>，使用MAT(Memory Analyzer Tool)工具分析dump文件，发现存在大量的<code>byte[]</code>内存占用。</p><p>结合应用日志，发现服务异常之时正在调用某个文件下载方法，该方法使用<code>FileInputStream</code>读取文件到内存中，并使用<code>byte[]</code>数组存储文件内容， subsequent to将该<code>byte[]</code>数组写入到<code>Response</code>的输出流完成下载，关键代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] readFileContent(File file) &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">fileLength</span> <span class="operator">=</span> file.length();</span><br><span class="line">    <span class="type">byte</span>[] fileContent = <span class="keyword">new</span> <span class="title class_">byte</span>[(<span class="type">int</span>) fileLength];</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file)) &#123;</span><br><span class="line">        in.read(fileContent);</span><br><span class="line">        <span class="keyword">return</span> fileContent;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.error(e.getMessage(), e);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>短短几行代码却让人虎躯一震，没有判断文件的大小就直接完整读取，危险！而且没有使用缓冲流的方式进行读写。事实证明问题恰恰就是出在这里，某个版本的控件由于打包时体积偏大（约200多MB），导致多个用户同时下载时，堆区内存一下子就被控件文件数据填满，进而发生OOM异常。</p><p><strong>解决方案</strong>：将控件安装包文件挂载到FTP上并提供外链，不经过应用服务器下载。</p><h2 id="0x06-案例六"><a href="#0x06-案例六" class="headerlink" title="0x06 案例六"></a>0x06 案例六</h2><p><strong>事故时间</strong>：2023年3月10日</p><p><strong>故障类型</strong>：<code>java.lang.OutOfMemoryError: Java heap space</code></p><p><strong>事故经过</strong>：A公司开发人员在开发某开放接口时，需要调用C公司的一个基础数据接口服务。然而，从14时许开始，A公司的接口调用就开始出现异常，返回错误码<code>500</code>，错误信息为<code>java.lang.OutOfMemoryError: Java heap space</code>。</p><p>C公司开发人员向A公司开发人员反映某开放接口从14时许开始无法访问和使用。该系统为某基础数据接口服务，基于HTTP协议进行通信。</p><p>按照惯例，首先排查网络是否异常，经运维人员检查，证明网络连通性没有问题。A公司开发组于14时30分通知运维人员重启应用服务，期间短暂恢复正常。但是，很快，十分钟后，电话再次响起，告知服务又出现异常，无法访问。</p><p>在日志中搜索，找到了若干处内存溢出错误<code>java.lang.OutOfMemoryError: Java heap space</code>，但是令人费解的是每次出现OOM错误的位置居然都不一样。最后发现是应用启动脚本中，<code>-Xmn</code>参数设置成与<code>-Xmx</code>参数一样的大小，导致堆区大小失衡，进而引发内存异常。</p><p>该问题的排查过程在<a href="https://www.cnblogs.com/mylibs/p/production-accident-0002.html">生产事故-记一次特殊的OOM排查</a>一文中有详细的分析过程，这里就不再赘述了。</p><h2 id="0x07-案例七"><a href="#0x07-案例七" class="headerlink" title="0x07 案例七"></a>0x07 案例七</h2><p><strong>事故时间</strong>：2024年4月28日</p><p><strong>故障类型</strong>：<code>java.lang.OutOfMemoryError: Java heap space</code></p><p><strong>事故经过</strong>：某报表分析系统，其业务大体上为导入各种CSV&#x2F;XLS&#x2F;XLSX文件进行解析，校验并计算各项统计数据，对于异常的数据可以在首页上监控告警并提示。</p><p>有天运营的妹子突然找过来说她登录不了系统了，刚开始听到的我认为只是简单的浏览器问题，可以秀一波操作了，结果到了工位上一看，发现登录页面验证码出不来了。做过前后端分离项目的朋友都知道，这种情况下，后端服务非死即伤。强装镇定，安抚一下妹子，说我得去查查日志看看咋回事。</p><p>远程到服务器，发现后端应用确实已经灰飞烟灭，查看GC日志，发现有若干<code>java.lang.OutOfMemoryError: Java heap space</code>错误。找到那段时间的应用日志，最终问题定位到了某个<code>SQL</code>语句上，该<code>SQL</code>是个单表查询语句，但是返回的记录行数竟然有10w+。</p><p>追查源头，发现就是首页上的监控告警。前端定时器每隔20秒调用一次后端服务扫描该表的记录，筛选出状态异常的数据并返回，但是没有做分页限制，导致某个业务人员上传了一个超大的Excel表，但是有个关键数据项填写错误，该批数据10w+行记录全部被系统标记为异常，当有多个运营人员登录系统并进入首页后，就会反复触发该查询语句，进而导致内存溢出。</p><p><strong>解决方案</strong>：限制首页监控查询行数，同时优化监控逻辑，建立查询缓存，防止短时间内重复扫描业务表。</p><h2 id="0x08-案例八"><a href="#0x08-案例八" class="headerlink" title="0x08 案例八"></a>0x08 案例八</h2><p><strong>事故时间</strong>：2024年12月5日</p><p><strong>故障类型</strong>：<code>java.lang.OutOfMemoryError: GC Overhead limit exceeded</code></p><p><strong>事故经过</strong>：某查询接口服务，上线后基本稳定运行，三个月后有用户反映查询缓慢。</p><p>遂查之，发现GC日志中频繁出现<code>java.lang.OutOfMemoryError: GC Overhead limit exceeded</code>报告。第一时间做了堆栈快照，发现内存中有大量的<code>List</code>容器未释放，MAT分析Incoming references指向了<code>ThreadLocalMap</code>，基本可以定位到是<code>ThreadLocal</code>中的数据没有及时清理，无法被GC回收，导致的内存泄露，最终频繁Full GC也无法回收足够空间。</p><p><strong>解决方案</strong>：严格遵循使用后释放的原则，及时移除<code>ThreadLocal</code>中的数据引用。</p>]]></content>
      
      
      <categories>
          
          <category> 调优排查 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OOM </tag>
            
            <tag> 线上事故 </tag>
            
            <tag> 运维调优 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线上事故记录-接口超时&amp;锁表--转载</title>
      <link href="/2025/03/11/%E6%8E%92%E5%BF%A7%E8%A7%A3%E9%9A%BE/%E7%94%9F%E4%BA%A7%E4%BA%8B%E6%95%85%E8%AE%B0%E5%BD%95-%E5%8C%BB%E7%96%97%E9%A1%B9%E7%9B%AE/"/>
      <url>/2025/03/11/%E6%8E%92%E5%BF%A7%E8%A7%A3%E9%9A%BE/%E7%94%9F%E4%BA%A7%E4%BA%8B%E6%95%85%E8%AE%B0%E5%BD%95-%E5%8C%BB%E7%96%97%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>年前放假的几个月内，公司项目发生了两次事故，虽然与我无关，但事故发生后整个团队都受到影响，主管需要给客户写事故报告，客户甚至打电话给公司领导严肃批评，我想经历过这种事的朋友不在少数，但很多刚入行的朋友可能不太清楚其中利害，这里我分享出来希望对大家有所帮助。</p></blockquote><h3 id="事故经过"><a href="#事故经过" class="headerlink" title="事故经过"></a>事故经过</h3><blockquote><p>三个月内一共发生两次生产环境事故，一个是接口超时导致服务雪崩，一个是锁表导致核心功能停滞一小时。</p></blockquote><h4 id="1、接口超时事故"><a href="#1、接口超时事故" class="headerlink" title="1、接口超时事故"></a>1、接口超时事故</h4><h5 id="1）现象"><a href="#1）现象" class="headerlink" title="1）现象"></a>1）现象</h5><p>2021年12月某周一上午，负责管理网络的同事(俗称网管)一大早巡检过程中发现有一个服务挂掉了，他当时没在意，直接重启就好了，但到了10点左右，忽然三四个服务：挂号服务、门诊服务、检查报告服务等一起挂掉了，而且重启十几分钟后又会挂掉，瞬间公司就炸锅了，网管、开发人员、技术主管集体冒汗，在紧急处理过程中，还不断有院方电话打给主管、总经理直到大老板，领导就站在我们背后着急的等待我们处理，我想很多人应该有画面了。</p><h5 id="2原因"><a href="#2原因" class="headerlink" title="2原因"></a>2原因</h5><p>大概到中午都没解决，因为没有日志平台的情况下，定位问题是一件不容易的事情，后来在中午休息时间技术主管和我们终于发现了门诊服务中调用某软his接口出现超时，而周一上午的流量又很大，平常偶尔超时也没问题没人在意，这次一个小小的接口超时竟然直接把服务全部堵塞，调用该接口的挂号和门诊服务全部挂掉，而和门诊服务有一点耦合的检查报告服务也在疯狂的超时等待又超时又等待中挂掉了。</p><p>最终，紧急联系院方找厂商服务团队查找该接口问题，同时我们临时把几个服务全部重启，总算在所有人惶惶不安的努力下3点之前恢复了正常。</p><h5 id="3）总结及处理"><a href="#3）总结及处理" class="headerlink" title="3）总结及处理"></a>3）总结及处理</h5><p>事后，老板大发雷霆，并召开批斗大会点出了团队没有危机处理预案等等种种问题，据说是被院方碉堡了。我们怀着谦虚忐忑的心情在小本上疯狂做笔记(做样子)，算是挺过去了，唯独主管比较难受，要亲自写好几个事故报告给甲方，懂的都懂。</p><p>接口超时时间之后发现设置为60秒，真特么离谱啊，之前竟没一个人关注(包括我)，没问题的情况下自然万事大吉，但凡出了问题，60秒的超时时间这是人干的事么，有什么接口若需要60秒，那本身就是一枚定时炸弹，必须一开始就拆掉。</p><p>很多公司的项目其实都存在这个问题，碍于调用第三方接口难以预估超时时间，所以就设置的比较长，可实际上，这会给项目带来莫大的隐患，处理方式很简单：</p><blockquote><ul><li>一定要和对接的厂商确定接口的大概超时时间，有个基本的范围，因为你很难要求其他公司给你做好接口的完善，很多是不会搭理你的，你也看不见人家接口怎么写的，那么就要知道个大概，然后自己这边才好设置；</li><li>在预估项目上线后流量会成倍增长的情况下，一定要对项目主要接口做压测，这是公司的测试团队必须要做的事情，我们公司这次就是测试人员不会压测，也没人重视，所以功能没问题就上线了，事后所有测试人员都被要求参加压测培训；</li><li>只要是微服务，请一定<strong>引入熔断机制</strong> ，这次事故过后，团队深刻反思，明明用了SpringCloud，但调用第三方接口的位置都没有做熔断处理，如果一开始做了，那么这次事故至少我们可以抽身，服务熔断降级后，既不会出现雪崩影响到其他服务，主要责任也在某软，给自己公司更多弹性处理的空间，而不是现在反而担负了主要责任。</li></ul></blockquote><h4 id="2、锁表事故"><a href="#2、锁表事故" class="headerlink" title="2、锁表事故"></a>2、锁表事故</h4><h5 id="1）现象-1"><a href="#1）现象-1" class="headerlink" title="1）现象"></a>1）现象</h5><p>这个事故和前面的相比算是小事故了，但依然令人心惊胆战，毕竟快过年了，谁也不想出问题。墨菲定律讲过，越是你害怕的事情越是会到来，果不其然，年前大概就是前一两周的样子，某天下午一家三甲医院的挂号服务未响应，在前端的效果就是，你打开了小程序，点击了挂号服务，然后某个功能一直加载中，最后页面未响应或假死。</p><h5 id="2）原因"><a href="#2）原因" class="headerlink" title="2）原因"></a>2）原因</h5><p>锁表，因为负责维护该医院的同事，在下午四点中的时候给挂号表新增了一个可以为空的字段，而挂号表是百万数据的大表，直接执行SQL新增字段还附带部分条件，直接导致整个表都锁掉了，前端发来的请求就一直无法对该表执行其他操作，最终未响应及假死。</p><p>既然锁了就要解，操作很简单，但集成同事刚好一时联系不上，开发人员又不熟悉内网环境，前后花了一个小时时间才解锁恢复正常，在一堆病患使用过程中，一个小时时间内都无法挂号，这背后的凶残你可想而知。</p><h5 id="3）总结及处理-1"><a href="#3）总结及处理-1" class="headerlink" title="3）总结及处理"></a>3）总结及处理</h5><p>给该表迅速解锁，有条件的话最好让本公司专业DBA或集成同事来操作，他们更熟悉数据库服务及项目部署，操作更安全，如果公司没有这样的同事，只能百度一下咯。</p><p>MySQL解锁方式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1.</span> 查看当前数据库锁表的情况 </span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.INNODB_TRX; </span><br><span class="line"># <span class="number">2.</span> 杀掉查询结果中锁表的trx_mysql_thread_id </span><br><span class="line">kill trx_mysql_thread_id</span><br></pre></td></tr></table></figure><p>Oracle解锁方式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 查看被锁的表ct</span><br><span class="line"><span class="keyword">select</span> b.owner, b.object_name, a.session_id, a.locked_mode</span><br><span class="line"><span class="keyword">from</span> v$locked_object a, dba_objects b <span class="keyword">where</span> b.OBJECT_ID <span class="operator">=</span> a.OBJECT_ID</span><br><span class="line"></span><br><span class="line"># 查看连接的进程</span><br><span class="line"><span class="keyword">select</span> sid, serial#, username, osuser <span class="keyword">from</span> v$session;</span><br><span class="line"></span><br><span class="line"># 杀掉进程 sid, serial#</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> kill session <span class="string">&#x27;678,983&#x27;</span>;</span><br></pre></td></tr></table></figure><blockquote><p><strong>切记，给大表新增字段以及其他操作，一定要选择流量最小的时间段，比如凌晨以后，这样可以避免造成生产环境事故。</strong></p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>1）首先，接口超时时间的设置不是小问题，希望大家引以为戒，一是要充分和对接厂商沟通，对接口情况有底，一个接口的响应时间理论上是毫秒级的，大厂甚至对接口超时时间都有明确规范，小厂因为身不由己，只能曲线救国，设置一个合理的范围； <strong>其次</strong>，一定要在测试阶段进行核心接口的压测，某种程度上可以提前暴露问题；<strong>最后</strong>，微服务一定要引入<strong>熔断机制</strong>，并且重视使用；</p><p>2）大表操作要谨慎，要么选择合适的工具来实时操作大表(可以百度非常多)，要么就选择流量最少的时间去操作，无非也就是凌晨，因为没啥人用，而且执行SQL操作大表时最好不要附带条件比如设置默认值之类的，这样会明显提升速度，把复杂的语句分段执行效果更佳，大家可以试试。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 调优排查 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维调优 </tag>
            
            <tag> 接口超时 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8新特性</title>
      <link href="/2025/02/18/Java%E5%9B%9E%E9%A1%BE%E7%AF%87/Java8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2025/02/18/Java%E5%9B%9E%E9%A1%BE%E7%AF%87/Java8%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<!-- markdownlint-disable MD024 --><p>Oracle 于 2014 发布了 Java8（jdk1.8），它较 jdk7 有很多变化或者说是优化，比如 interface 里可以有静态方法，并且可以有方法体，这一点就颠覆了之前的认知；<code>java.util.HashMap</code> 数据结构里增加了红黑树；还有众所周知的 Lambda 表达式等等。本文不能把所有的新特性都给大家一一分享，只列出比较常用的新特性给大家做详细讲解。更多相关内容请看<a href="https://www.oracle.com/java/technologies/javase/8-whats-new.html">官网关于 Java8 的新特性的介绍</a>。</p><h2 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h2><p>interface 的设计初衷是面向抽象，提高扩展性。这也留有一点遗憾，Interface 修改的时候，实现它的类也必须跟着改。</p><p>为了解决接口的修改与现有的实现不兼容的问题。新 interface 的方法可以用<code>default</code> 或 <code>static</code>修饰，这样就可以有方法体，实现类也不必重写此方法。</p><p>一个 interface 中可以有多个方法被它们修饰，这 2 个修饰符的区别主要也是普通方法和静态方法的区别。</p><ol><li><code>default</code>修饰的方法，是普通实例方法，可以用<code>this</code>调用，可以被子类继承、重写。</li><li><code>static</code>修饰的方法，使用上和一般类静态方法一样。但它不能被子类继承，只能用<code>Interface</code>调用。</li></ol><p>我们来看一个实际的例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InterfaceNew</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sm</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;interface提供的方式实现&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sm2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;interface提供的方式实现&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">def</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;interface default方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">def2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;interface default2方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//须要实现类重写</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InterfaceNew1</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">def</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;InterfaceNew1 default方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有一个类既实现了 <code>InterfaceNew</code> 接口又实现了 <code>InterfaceNew1</code>接口，它们都有<code>def()</code>，并且 <code>InterfaceNew</code> 接口和 <code>InterfaceNew1</code>接口没有继承关系的话，这时就必须重写<code>def()</code>。不然的话，编译的时候就会报错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterfaceNewImpl</span> <span class="keyword">implements</span> <span class="title class_">InterfaceNew</span> , InterfaceNew1&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">InterfaceNewImpl</span> <span class="variable">interfaceNew</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterfaceNewImpl</span>();</span><br><span class="line">        interfaceNew.def();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">def</span><span class="params">()</span> &#123;</span><br><span class="line">        InterfaceNew1.<span class="built_in">super</span>.def();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在 Java 8 ，接口和抽象类有什么区别的？</strong></p><p>很多小伙伴认为：“既然 interface 也可以有自己的方法实现，似乎和 abstract class 没多大区别了。”</p><p>其实它们还是有区别的</p><ol><li><p>interface 和 class 的区别，好像是废话，主要有：</p><ul><li>接口多实现，类单继承</li><li>接口的方法是 public abstract 修饰，变量是 public static final 修饰。 abstract class 可以用其他修饰符</li></ul></li><li><p>interface 的方法是更像是一个扩展插件。而 abstract class 的方法是要继承的。</p></li></ol><p>开始我们也提到，interface 新增<code>default</code>和<code>static</code>修饰的方法，为了解决接口的修改与现有的实现不兼容的问题，并不是为了要替代<code>abstract class</code>。在使用上，该用 abstract class 的地方还是要用 abstract class，不要因为 interface 的新特性而将之替换。</p><p><strong>记住接口永远和类不一样。</strong></p><h2 id="functional-interface-函数式接口"><a href="#functional-interface-函数式接口" class="headerlink" title="functional interface 函数式接口"></a>functional interface 函数式接口</h2><p><strong>定义</strong>：也称 SAM 接口，即 Single Abstract Method interfaces，有且只有一个抽象方法，但可以有多个非抽象方法的接口。</p><p>在 java 8 中专门有一个包放函数式接口<code>java.util.function</code>，该包下的所有接口都有 <code>@FunctionalInterface</code> 注解，提供函数式编程。</p><p>在其他包中也有函数式接口，其中一些没有<code>@FunctionalInterface</code> 注解，但是只要符合函数式接口的定义就是函数式接口，与是否有<code>@FunctionalInterface</code>注解无关，注解只是在编译时起到强制规范定义的作用。其在 Lambda 表达式中有广泛的应用。</p><h2 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h2><p>接下来谈众所周知的 Lambda 表达式。它是推动 Java 8 发布的最重要新特性。是继泛型(<code>Generics</code>)和注解(<code>Annotation</code>)以来最大的变化。</p><p>使用 Lambda 表达式可以使代码变的更加简洁紧凑。让 java 也能支持简单的<em>函数式编程</em>。</p><blockquote><p>Lambda 表达式是一个匿名函数，java 8 允许把函数作为参数传递进方法中。</p></blockquote><h3 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(parameters) -&gt; expression 或</span><br><span class="line">(parameters) -&gt;&#123; statements; &#125;</span><br></pre></td></tr></table></figure><h3 id="Lambda-实战"><a href="#Lambda-实战" class="headerlink" title="Lambda 实战"></a>Lambda 实战</h3><p>我们用常用的实例来感受 Lambda 带来的便利</p><h4 id="替代匿名内部类"><a href="#替代匿名内部类" class="headerlink" title="替代匿名内部类"></a>替代匿名内部类</h4><p>过去给方法传动态参数的唯一方法是使用内部类。比如</p><p><strong>1.<code>Runnable</code> 接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;The runable now is using!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"><span class="comment">//用lambda</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; System.out.println(<span class="string">&quot;It&#x27;s a lambda function!&quot;</span>)).start();</span><br></pre></td></tr></table></figure><p><strong>2.<code>Comparator</code> 接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; strings = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">Collections.sort(strings, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> o1 - o2;&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Lambda</span></span><br><span class="line">Collections.sort(strings, (Integer o1, Integer o2) -&gt; o1 - o2);</span><br><span class="line"><span class="comment">//分解开</span></span><br><span class="line">Comparator&lt;Integer&gt; comparator = (Integer o1, Integer o2) -&gt; o1 - o2;</span><br><span class="line">Collections.sort(strings, comparator);</span><br></pre></td></tr></table></figure><p><strong>3.<code>Listener</code> 接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">JButton</span> <span class="variable">button</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>();</span><br><span class="line">button.addItemListener(<span class="keyword">new</span> <span class="title class_">ItemListener</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">itemStateChanged</span><span class="params">(ItemEvent e)</span> &#123;</span><br><span class="line">   e.getItem();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//lambda</span></span><br><span class="line">button.addItemListener(e -&gt; e.getItem());</span><br></pre></td></tr></table></figure><p><strong>4.自定义接口</strong></p><p>上面的 3 个例子是我们在开发过程中最常见的，从中也能体会到 Lambda 带来的便捷与清爽。它只保留实际用到的代码，把无用代码全部省略。那它对接口有没有要求呢？我们发现这些匿名内部类只重写了接口的一个方法，当然也只有一个方法须要重写。这就是我们上文提到的<strong>函数式接口</strong>，也就是说只要方法的参数是函数式接口都可以用 Lambda 表达式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparator</span>&lt;T&gt;&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>我们自定义一个函数式接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LambdaInterface</span> &#123;</span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">forEg</span><span class="params">()</span> &#123;</span><br><span class="line">        lambdaInterfaceDemo(()-&gt; System.out.println(<span class="string">&quot;自定义函数式接口&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//函数式接口参数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">lambdaInterfaceDemo</span><span class="params">(LambdaInterface i)</span>&#123;</span><br><span class="line">        i.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="集合迭代"><a href="#集合迭代" class="headerlink" title="集合迭代"></a>集合迭代</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">lamndaFor</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>);</span><br><span class="line">        <span class="comment">//传统foreach</span></span><br><span class="line">        <span class="keyword">for</span> (String s : strings) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Lambda foreach</span></span><br><span class="line">        strings.forEach((s) -&gt; System.out.println(s));</span><br><span class="line">        <span class="comment">//or</span></span><br><span class="line">        strings.forEach(System.out::println);</span><br><span class="line">     <span class="comment">//map</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.forEach((k,v)-&gt;System.out.println(v));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法的引用"><a href="#方法的引用" class="headerlink" title="方法的引用"></a>方法的引用</h4><p>Java 8 允许使用 <code>::</code> 关键字来传递方法或者构造函数引用，无论如何，表达式返回的类型必须是 functional-interface。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaClassSuper</span> &#123;</span><br><span class="line">    LambdaInterface <span class="title function_">sf</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaClass</span> <span class="keyword">extends</span> <span class="title class_">LambdaClassSuper</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LambdaInterface <span class="title function_">staticF</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> LambdaInterface <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1.调用静态函数，返回类型必须是functional-interface</span></span><br><span class="line">        <span class="type">LambdaInterface</span> <span class="variable">t</span> <span class="operator">=</span> LambdaClass::staticF;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.实例方法调用</span></span><br><span class="line">        <span class="type">LambdaClass</span> <span class="variable">lambdaClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LambdaClass</span>();</span><br><span class="line">        <span class="type">LambdaInterface</span> <span class="variable">lambdaInterface</span> <span class="operator">=</span> lambdaClass::f;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.超类上的方法调用</span></span><br><span class="line">        <span class="type">LambdaInterface</span> <span class="variable">superf</span> <span class="operator">=</span> <span class="built_in">super</span>::sf;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 构造方法调用</span></span><br><span class="line">        <span class="type">LambdaInterface</span> <span class="variable">tt</span> <span class="operator">=</span> LambdaClassSuper::<span class="keyword">new</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="访问变量"><a href="#访问变量" class="headerlink" title="访问变量"></a>访问变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">Collections.sort(strings, (Integer o1, Integer o2) -&gt; o1 - i);</span><br><span class="line"><span class="comment">//i =3;</span></span><br></pre></td></tr></table></figure><p>lambda 表达式可以引用外边变量，但是该变量默认拥有 final 属性，不能被修改，如果修改，编译时就报错。</p><h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><p>java 新增了 <code>java.util.stream</code> 包，它和之前的流大同小异。之前接触最多的是资源流，比如<code>java.io.FileInputStream</code>，通过流把文件从一个地方输入到另一个地方，它只是内容搬运工，对文件内容不做任何<em>CRUD</em>。</p><p><code>Stream</code>依然不存储数据，不同的是它可以检索(Retrieve)和逻辑处理集合数据、包括筛选、排序、统计、计数等。可以想象成是 Sql 语句。</p><p>它的源数据可以是 <code>Collection</code>、<code>Array</code> 等。由于它的方法参数都是函数式接口类型，所以一般和 Lambda 配合使用。</p><h3 id="流类型"><a href="#流类型" class="headerlink" title="流类型"></a>流类型</h3><ol><li>stream 串行流</li><li>parallelStream 并行流，可多线程执行</li></ol><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p>接下来我们看<code>java.util.stream.Stream</code>常用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回一个串行流</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title function_">stream</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回一个并行流</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title function_">parallelStream</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回T的流</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title function_">of</span><span class="params">(T t)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回其元素是指定值的顺序流。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title function_">of</span><span class="params">(T... values)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.stream(values);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 过滤，返回由与给定predicate匹配的该流的元素组成的流</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Stream&lt;T&gt; <span class="title function_">filter</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 此流的所有元素是否与提供的predicate匹配。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">allMatch</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 此流任意元素是否有与提供的predicate匹配。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">anyMatch</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回一个 Stream的构建器。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Builder&lt;T&gt; <span class="title function_">builder</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 使用 Collector对此流的元素进行归纳</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&lt;R, A&gt; R <span class="title function_">collect</span><span class="params">(Collector&lt;? <span class="built_in">super</span> T, A, R&gt; collector)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回此流中的元素数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">count</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回由该流的不同元素（根据 Object.equals(Object) ）组成的流。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Stream&lt;T&gt; <span class="title function_">distinct</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 遍历</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 用于获取指定数量的流，截短长度不能超过 maxSize 。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Stream&lt;T&gt; <span class="title function_">limit</span><span class="params">(<span class="type">long</span> maxSize)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 用于映射每个元素到对应的结果</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&lt;R&gt; Stream&lt;R&gt; <span class="title function_">map</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, ? extends R&gt; mapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 根据提供的 Comparator进行排序。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Stream&lt;T&gt; <span class="title function_">sorted</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> T&gt; comparator)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 在丢弃流的第一个 n元素后，返回由该流的 n元素组成的流。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Stream&lt;T&gt; <span class="title function_">skip</span><span class="params">(<span class="type">long</span> n)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回一个包含此流的元素的数组。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Object[] toArray();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 使用提供的 generator函数返回一个包含此流的元素的数组，以分配返回的数组，以及分区执行或调整大小可能需要的任何其他数组。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&lt;A&gt; A[] toArray(IntFunction&lt;A[]&gt; generator);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 合并流</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Stream&lt;T&gt; <span class="title function_">concat</span><span class="params">(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)</span></span><br></pre></td></tr></table></figure><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>本文列出 <code>Stream</code> 具有代表性的方法之使用，更多的使用方法还是要看 Api。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">  List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;gkh&quot;</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    <span class="comment">//返回符合条件的stream</span></span><br><span class="line">    Stream&lt;String&gt; stringStream = strings.stream().filter(s -&gt; <span class="string">&quot;abc&quot;</span>.equals(s));</span><br><span class="line">    <span class="comment">//计算流符合条件的流的数量</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> stringStream.count();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//forEach遍历-&gt;打印元素</span></span><br><span class="line">    strings.stream().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//limit 获取到1个元素的stream</span></span><br><span class="line">    Stream&lt;String&gt; limit = strings.stream().limit(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//toArray 比如我们想看这个limitStream里面是什么，比如转换成String[],比如循环</span></span><br><span class="line">    String[] array = limit.toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//map 对每个元素进行操作返回新流</span></span><br><span class="line">    Stream&lt;String&gt; map = strings.stream().map(s -&gt; s + <span class="string">&quot;22&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//sorted 排序并打印</span></span><br><span class="line">    strings.stream().sorted().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Collectors collect 把abc放入容器中</span></span><br><span class="line">    List&lt;String&gt; collect = strings.stream().filter(string -&gt; <span class="string">&quot;abc&quot;</span>.equals(string)).collect(Collectors.toList());</span><br><span class="line">    <span class="comment">//把list转为string，各元素用，号隔开</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">mergedString</span> <span class="operator">=</span> strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.joining(<span class="string">&quot;,&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对数组的统计，比如用</span></span><br><span class="line">    List&lt;Integer&gt; number = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">IntSummaryStatistics</span> <span class="variable">statistics</span> <span class="operator">=</span> number.stream().mapToInt((x) -&gt; x).summaryStatistics();</span><br><span class="line">    System.out.println(<span class="string">&quot;列表中最大的数 : &quot;</span>+statistics.getMax());</span><br><span class="line">    System.out.println(<span class="string">&quot;列表中最小的数 : &quot;</span>+statistics.getMin());</span><br><span class="line">    System.out.println(<span class="string">&quot;平均数 : &quot;</span>+statistics.getAverage());</span><br><span class="line">    System.out.println(<span class="string">&quot;所有数之和 : &quot;</span>+statistics.getSum());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//concat 合并流</span></span><br><span class="line">    List&lt;String&gt; strings2 = Arrays.asList(<span class="string">&quot;xyz&quot;</span>, <span class="string">&quot;jqx&quot;</span>);</span><br><span class="line">    Stream.concat(strings2.stream(),strings.stream()).count();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意 一个Stream只能操作一次，不能断开，否则会报错。</span></span><br><span class="line">    <span class="type">Stream</span> <span class="variable">stream</span> <span class="operator">=</span> strings.stream();</span><br><span class="line">    <span class="comment">//第一次使用</span></span><br><span class="line">    stream.limit(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//第二次使用</span></span><br><span class="line">    stream.forEach(System.out::println);</span><br><span class="line">    <span class="comment">//报错 java.lang.IllegalStateException: stream has already been operated upon or closed</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//但是可以这样, 连续使用</span></span><br><span class="line">    stream.limit(<span class="number">2</span>).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="延迟执行"><a href="#延迟执行" class="headerlink" title="延迟执行"></a>延迟执行</h3><p>在执行返回 <code>Stream</code> 的方法时，并不立刻执行，而是等返回一个非 <code>Stream</code> 的方法后才执行。因为拿到 <code>Stream</code> 并不能直接用，而是需要处理成一个常规类型。这里的 <code>Stream</code> 可以想象成是二进制流（2 个完全不一样的东东），拿到也看不懂。</p><p>我们下面分解一下 <code>filter</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">laziness</span><span class="params">()</span>&#123;</span><br><span class="line">  List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;gkh&quot;</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">  Stream&lt;Integer&gt; stream = strings.stream().filter(<span class="keyword">new</span> <span class="title class_">Predicate</span>() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Predicate.test 执行&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">   System.out.println(<span class="string">&quot;count 执行&quot;</span>);</span><br><span class="line">   stream.count();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*-------执行结果--------*/</span></span><br><span class="line">count 执行</span><br><span class="line">Predicate.test 执行</span><br><span class="line">Predicate.test 执行</span><br><span class="line">Predicate.test 执行</span><br><span class="line">Predicate.test 执行</span><br></pre></td></tr></table></figure><p>按执行顺序应该是先打印 4 次「<code>Predicate.test</code> 执行」，再打印「<code>count</code> 执行」。实际结果恰恰相反。说明 filter 中的方法并没有立刻执行，而是等调用<code>count()</code>方法后才执行。</p><p>上面都是串行 <code>Stream</code> 的实例。并行 <code>parallelStream</code> 在使用方法上和串行一样。主要区别是 <code>parallelStream</code> 可多线程执行，是基于 ForkJoin 框架实现的，有时间大家可以了解一下 <code>ForkJoin</code> 框架和 <code>ForkJoinPool</code>。这里可以简单的理解它是通过线程池来实现的，这样就会涉及到线程安全，线程消耗等问题。下面我们通过代码来体验一下并行流的多线程执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parallelStreamTest</span><span class="params">()</span>&#123;</span><br><span class="line">   List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>);</span><br><span class="line">   numbers.parallelStream() .forEach(num-&gt;System.out.println(Thread.currentThread().getName()+<span class="string">&quot;&gt;&gt;&quot;</span>+num));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line">main&gt;&gt;<span class="number">5</span></span><br><span class="line">ForkJoinPool.commonPool-worker-<span class="number">2</span>&gt;&gt;<span class="number">4</span></span><br><span class="line">ForkJoinPool.commonPool-worker-<span class="number">11</span>&gt;&gt;<span class="number">1</span></span><br><span class="line">ForkJoinPool.commonPool-worker-<span class="number">9</span>&gt;&gt;<span class="number">2</span></span><br></pre></td></tr></table></figure><p>从结果中我们看到，for-each 用到的是多线程。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>从源码和实例中我们可以总结出一些 stream 的特点</p><ol><li>通过简单的链式编程，使得它可以方便地对遍历处理后的数据进行再处理。</li><li>方法参数都是函数式接口类型</li><li>一个 Stream 只能操作一次，操作完就关闭了，继续使用这个 stream 会报错。</li><li>Stream 不保存数据，不改变数据源</li></ol><h2 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h2><p>在<a href="https://share.weiyun.com/ThuqEbD5">阿里巴巴开发手册关于 Optional 的介绍</a>中这样写到：</p><blockquote><p>防止 NPE，是程序员的基本修养，注意 NPE 产生的场景：</p><p>1） 返回类型为基本数据类型，return 包装数据类型的对象时，自动拆箱有可能产生 NPE。</p><p>反例：public int f() { return Integer 对象}， 如果为 null，自动解箱抛 NPE。</p><p>2） 数据库的查询结果可能为 null。</p><p>3） 集合里的元素即使 isNotEmpty，取出的数据元素也可能为 null。</p><p>4） 远程调用返回对象时，一律要求进行空指针判断，防止 NPE。</p><p>5） 对于 Session 中获取的数据，建议进行 NPE 检查，避免空指针。</p><p>6） 级联调用 obj.getA().getB().getC()；一连串调用，易产生 NPE。</p><p>正例：使用 JDK8 的 Optional 类来防止 NPE 问题。</p></blockquote><p>他建议使用 <code>Optional</code> 解决 NPE（<code>java.lang.NullPointerException</code>）问题，它就是为 NPE 而生的，其中可以包含空值或非空值。下面我们通过源码逐步揭开 <code>Optional</code> 的红盖头。</p><p>假设有一个 <code>Zoo</code> 类，里面有个属性 <code>Dog</code>，需求要获取 <code>Dog</code> 的 <code>age</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Zoo</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> Dog dog;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传统解决 NPE 的办法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Zoo</span> <span class="variable">zoo</span> <span class="operator">=</span> getZoo();</span><br><span class="line"><span class="keyword">if</span>(zoo != <span class="literal">null</span>)&#123;</span><br><span class="line">   <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> zoo.getDog();</span><br><span class="line">   <span class="keyword">if</span>(dog != <span class="literal">null</span>)&#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> dog.getAge();</span><br><span class="line">      System.out.println(age);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>层层判断对象非空，有人说这种方式很丑陋不优雅，我并不这么认为。反而觉得很整洁，易读，易懂。你们觉得呢？</p><p><code>Optional</code> 是这样的实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optional.ofNullable(zoo).map(o -&gt; o.getDog()).map(d -&gt; d.getAge()).ifPresent(age -&gt;</span><br><span class="line">    System.out.println(age)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>是不是简洁了很多呢？</p><h3 id="如何创建一个-Optional"><a href="#如何创建一个-Optional" class="headerlink" title="如何创建一个 Optional"></a>如何创建一个 Optional</h3><p>上例中<code>Optional.ofNullable</code>是其中一种创建 Optional 的方式。我们先看一下它的含义和其他创建 Optional 的源码方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Common instance for &#123;<span class="doctag">@code</span> empty()&#125;. 全局EMPTY对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Optional&lt;?&gt; EMPTY = <span class="keyword">new</span> <span class="title class_">Optional</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Optional维护的值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> T value;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 如果value是null就返回EMPTY，否则就返回of(T)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Optional&lt;T&gt; <span class="title function_">ofNullable</span><span class="params">(T value)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> value == <span class="literal">null</span> ? empty() : of(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回 EMPTY 对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Optional&lt;T&gt; <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">   Optional&lt;T&gt; t = (Optional&lt;T&gt;) EMPTY;</span><br><span class="line">   <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回Optional对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Optional&lt;T&gt; <span class="title function_">of</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Optional</span>&lt;&gt;(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 私有构造方法，给value赋值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Optional</span><span class="params">(T value)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.value = Objects.requireNonNull(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 所以如果of(T value) 的value是null，会抛出NullPointerException异常，这样貌似就没处理NPE问题</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">requireNonNull</span><span class="params">(T obj)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (obj == <span class="literal">null</span>)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ofNullable</code> 方法和<code>of</code>方法唯一区别就是当 value 为 null 时，<code>ofNullable</code> 返回的是<code>EMPTY</code>，of 会抛出 <code>NullPointerException</code> 异常。如果需要把 <code>NullPointerException</code> 暴漏出来就用 <code>of</code>，否则就用 <code>ofNullable</code>。</p><p><strong><code>map()</code> 和 <code>flatMap()</code> 有什么区别的？</strong></p><p><code>map</code> 和 <code>flatMap</code> 都是将一个函数应用于集合中的每个元素，但不同的是<code>map</code>返回一个新的集合，<code>flatMap</code>是将每个元素都映射为一个集合，最后再将这个集合展平。</p><p>在实际应用场景中，如果<code>map</code>返回的是数组，那么最后得到的是一个二维数组，使用<code>flatMap</code>就是为了将这个二维数组展平变成一个一维数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapAndFlatMapExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String[]&gt; listOfArrays = Arrays.asList(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;cherry&quot;</span>&#125;,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;orange&quot;</span>, <span class="string">&quot;grape&quot;</span>, <span class="string">&quot;pear&quot;</span>&#125;,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;kiwi&quot;</span>, <span class="string">&quot;melon&quot;</span>, <span class="string">&quot;pineapple&quot;</span>&#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        List&lt;String[]&gt; mapResult = listOfArrays.stream()</span><br><span class="line">                .map(array -&gt; Arrays.stream(array).map(String::toUpperCase).toArray(String[]::<span class="keyword">new</span>))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Using map:&quot;</span>);</span><br><span class="line">        mapResult.forEach(arrays-&gt; System.out.println(Arrays.toString(arrays)));</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; flatMapResult = listOfArrays.stream()</span><br><span class="line">                .flatMap(array -&gt; Arrays.stream(array).map(String::toUpperCase))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Using flatMap:&quot;</span>);</span><br><span class="line">        System.out.println(flatMapResult);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Using map:</span><br><span class="line">[[APPLE, BANANA, CHERRY], [ORANGE, GRAPE, PEAR], [KIWI, MELON, PINEAPPLE]]</span><br><span class="line"></span><br><span class="line">Using flatMap:</span><br><span class="line">[APPLE, BANANA, CHERRY, ORANGE, GRAPE, PEAR, KIWI, MELON, PINEAPPLE]</span><br></pre></td></tr></table></figure><p>最简单的理解就是<code>flatMap()</code>可以将<code>map()</code>的结果展开。</p><p>在<code>Optional</code>里面，当使用<code>map()</code>时，如果映射函数返回的是一个普通值，它会将这个值包装在一个新的<code>Optional</code>中。而使用<code>flatMap</code>时，如果映射函数返回的是一个<code>Optional</code>，它会将这个返回的<code>Optional</code>展平，不再包装成嵌套的<code>Optional</code>。</p><p>下面是一个对比的示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">userId</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用flatMap的代码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">cityUsingFlatMap</span> <span class="operator">=</span> getUserById(userId)</span><br><span class="line">                .flatMap(OptionalExample::getAddressByUser)</span><br><span class="line">                .map(Address::getCity)</span><br><span class="line">                .orElse(<span class="string">&quot;Unknown&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;User&#x27;s city using flatMap: &quot;</span> + cityUsingFlatMap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不使用flatMap的代码</span></span><br><span class="line">        Optional&lt;Optional&lt;Address&gt;&gt; optionalAddress = getUserById(userId)</span><br><span class="line">                .map(OptionalExample::getAddressByUser);</span><br><span class="line"></span><br><span class="line">        String cityWithoutFlatMap;</span><br><span class="line">        <span class="keyword">if</span> (optionalAddress.isPresent()) &#123;</span><br><span class="line">            Optional&lt;Address&gt; addressOptional = optionalAddress.get();</span><br><span class="line">            <span class="keyword">if</span> (addressOptional.isPresent()) &#123;</span><br><span class="line">                <span class="type">Address</span> <span class="variable">address</span> <span class="operator">=</span> addressOptional.get();</span><br><span class="line">                cityWithoutFlatMap = address.getCity();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cityWithoutFlatMap = <span class="string">&quot;Unknown&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cityWithoutFlatMap = <span class="string">&quot;Unknown&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;User&#x27;s city without flatMap: &quot;</span> + cityWithoutFlatMap);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在<code>Stream</code>和<code>Optional</code>中正确使用<code>flatMap</code>可以减少很多不必要的代码。</p><h3 id="判断-value-是否为-null"><a href="#判断-value-是否为-null" class="headerlink" title="判断 value 是否为 null"></a>判断 value 是否为 null</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* value是否为null</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPresent</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 如果value不为null执行consumer.accept</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ifPresent</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; consumer)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (value != <span class="literal">null</span>)</span><br><span class="line">    consumer.accept(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取-value"><a href="#获取-value" class="headerlink" title="获取 value"></a>获取 value</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Return the value if present, otherwise invoke &#123;<span class="doctag">@code</span> other&#125; and return</span></span><br><span class="line"><span class="comment">* the result of that invocation.</span></span><br><span class="line"><span class="comment">* 如果value != null 返回value，否则返回other的执行结果</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">orElseGet</span><span class="params">(Supplier&lt;? extends T&gt; other)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value != <span class="literal">null</span> ? value : other.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 如果value != null 返回value，否则返回T</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">orElse</span><span class="params">(T other)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value != <span class="literal">null</span> ? value : other;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 如果value != null 返回value，否则抛出参数返回的异常</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> &lt;X <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt; T <span class="title function_">orElseThrow</span><span class="params">(Supplier&lt;? extends X&gt; exceptionSupplier)</span> <span class="keyword">throws</span> X &#123;</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> exceptionSupplier.get();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* value为null抛出NoSuchElementException，不为空返回value。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>(<span class="string">&quot;No value present&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="过滤值"><a href="#过滤值" class="headerlink" title="过滤值"></a>过滤值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 1. 如果是empty返回empty</span></span><br><span class="line"><span class="comment">* 2. predicate.test(value)==true 返回this，否则返回empty</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> Optional&lt;T&gt; <span class="title function_">filter</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(predicate);</span><br><span class="line">        <span class="keyword">if</span> (!isPresent())</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> predicate.test(value) ? <span class="built_in">this</span> : empty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>看完 <code>Optional</code> 源码，<code>Optional</code> 的方法真的非常简单，值得注意的是如果坚决不想看见 <code>NPE</code>，就不要用 <code>of()</code>、 <code>get()</code>、<code>flatMap(..)</code>。最后再综合用一下 <code>Optional</code> 的高频方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional.ofNullable(zoo).map(o -&gt; o.getDog()).map(d -&gt; d.getAge()).filter(v-&gt;v==<span class="number">1</span>).orElse(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><h2 id="Date-Time-API"><a href="#Date-Time-API" class="headerlink" title="Date-Time API"></a>Date-Time API</h2><p>这是对<code>java.util.Date</code>强有力的补充，解决了 Date 类的大部分痛点：</p><ol><li>非线程安全</li><li>时区处理麻烦</li><li>各种格式化、和时间计算繁琐</li><li>设计有缺陷，Date 类同时包含日期和时间；还有一个 java.sql.Date，容易混淆。</li></ol><p>我们从常用的时间实例来对比 java.util.Date 和新 Date 有什么区别。用<code>java.util.Date</code>的代码该改改了。</p><h3 id="java-time-主要类"><a href="#java-time-主要类" class="headerlink" title="java.time 主要类"></a>java.time 主要类</h3><p><code>java.util.Date</code> 既包含日期又包含时间，而 <code>java.time</code> 把它们进行了分离</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime.class <span class="comment">//日期+时间 format: yyyy-MM-ddTHH:mm:ss.SSS</span></span><br><span class="line">LocalDate.class <span class="comment">//日期 format: yyyy-MM-dd</span></span><br><span class="line">LocalTime.class <span class="comment">//时间 format: HH:mm:ss</span></span><br></pre></td></tr></table></figure><h3 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h3><p><strong>Java 8 之前:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">oldFormat</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Date</span> <span class="variable">now</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="comment">//format yyyy-MM-dd</span></span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">date</span>  <span class="operator">=</span> sdf.format(now);</span><br><span class="line">    System.out.println(String.format(<span class="string">&quot;date format : %s&quot;</span>, date));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//format HH:mm:ss</span></span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">sdft</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;HH:mm:ss&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">time</span> <span class="operator">=</span> sdft.format(now);</span><br><span class="line">    System.out.println(String.format(<span class="string">&quot;time format : %s&quot;</span>, time));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//format yyyy-MM-dd HH:mm:ss</span></span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">sdfdt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">datetime</span> <span class="operator">=</span> sdfdt.format(now);</span><br><span class="line">    System.out.println(String.format(<span class="string">&quot;dateTime format : %s&quot;</span>, datetime));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Java 8 之后:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">newFormat</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//format yyyy-MM-dd</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">date</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">    System.out.println(String.format(<span class="string">&quot;date format : %s&quot;</span>, date));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//format HH:mm:ss</span></span><br><span class="line">    <span class="type">LocalTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalTime.now().withNano(<span class="number">0</span>);</span><br><span class="line">    System.out.println(String.format(<span class="string">&quot;time format : %s&quot;</span>, time));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//format yyyy-MM-dd HH:mm:ss</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">dateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="type">DateTimeFormatter</span> <span class="variable">dateTimeFormatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">dateTimeStr</span> <span class="operator">=</span> dateTime.format(dateTimeFormatter);</span><br><span class="line">    System.out.println(String.format(<span class="string">&quot;dateTime format : %s&quot;</span>, dateTimeStr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符串转日期格式"><a href="#字符串转日期格式" class="headerlink" title="字符串转日期格式"></a>字符串转日期格式</h3><p><strong>Java 8 之前:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//已弃用</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&quot;2021-01-26&quot;</span>);</span><br><span class="line"><span class="comment">//替换为</span></span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line"><span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> sdf.parse(<span class="string">&quot;2021-01-26&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>Java 8 之后:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDate</span> <span class="variable">date</span> <span class="operator">=</span> LocalDate.of(<span class="number">2021</span>, <span class="number">1</span>, <span class="number">26</span>);</span><br><span class="line">LocalDate.parse(<span class="string">&quot;2021-01-26&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">dateTime</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2021</span>, <span class="number">1</span>, <span class="number">26</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">22</span>);</span><br><span class="line">LocalDateTime.parse(<span class="string">&quot;2021-01-26 12:12:22&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">LocalTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalTime.of(<span class="number">12</span>, <span class="number">12</span>, <span class="number">22</span>);</span><br><span class="line">LocalTime.parse(<span class="string">&quot;12:12:22&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>Java 8 之前</strong> 转换都需要借助 <code>SimpleDateFormat</code> 类，而<strong>Java 8 之后</strong>只需要 <code>LocalDate</code>、<code>LocalTime</code>、<code>LocalDateTime</code>的 <code>of</code> 或 <code>parse</code> 方法。</p><h3 id="日期计算"><a href="#日期计算" class="headerlink" title="日期计算"></a>日期计算</h3><p>下面仅以<strong>一周后日期</strong>为例，其他单位（年、月、日、1&#x2F;2 日、时等等）大同小异。另外，这些单位都在 <em>java.time.temporal.ChronoUnit</em> 枚举中定义。</p><p><strong>Java 8 之前:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterDay</span><span class="params">()</span>&#123;</span><br><span class="line">     <span class="comment">//一周后的日期</span></span><br><span class="line">     <span class="type">SimpleDateFormat</span> <span class="variable">formatDate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">     <span class="type">Calendar</span> <span class="variable">ca</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">     ca.add(Calendar.DATE, <span class="number">7</span>);</span><br><span class="line">     <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> ca.getTime();</span><br><span class="line">     <span class="type">String</span> <span class="variable">after</span> <span class="operator">=</span> formatDate.format(d);</span><br><span class="line">     System.out.println(<span class="string">&quot;一周后日期：&quot;</span> + after);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//算两个日期间隔多少天，计算间隔多少年，多少月方法类似</span></span><br><span class="line">     <span class="type">String</span> <span class="variable">dates1</span> <span class="operator">=</span> <span class="string">&quot;2021-12-23&quot;</span>;</span><br><span class="line">   <span class="type">String</span> <span class="variable">dates2</span> <span class="operator">=</span> <span class="string">&quot;2021-02-26&quot;</span>;</span><br><span class="line">     <span class="type">SimpleDateFormat</span> <span class="variable">format</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">     <span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> format.parse(dates1);</span><br><span class="line">     <span class="type">Date</span> <span class="variable">date2</span> <span class="operator">=</span> format.parse(dates2);</span><br><span class="line">     <span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> (<span class="type">int</span>) ((date1.getTime() - date2.getTime()) / (<span class="number">1000</span> * <span class="number">3600</span> * <span class="number">24</span>));</span><br><span class="line">     System.out.println(dates1 + <span class="string">&quot;和&quot;</span> + dates2 + <span class="string">&quot;相差&quot;</span> + day + <span class="string">&quot;天&quot;</span>);</span><br><span class="line">     <span class="comment">//结果：2021-02-26和2021-12-23相差300天</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Java 8 之后:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushWeek</span><span class="params">()</span>&#123;</span><br><span class="line">     <span class="comment">//一周后的日期</span></span><br><span class="line">     <span class="type">LocalDate</span> <span class="variable">localDate</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">     <span class="comment">//方法1</span></span><br><span class="line">     <span class="type">LocalDate</span> <span class="variable">after</span> <span class="operator">=</span> localDate.plus(<span class="number">1</span>, ChronoUnit.WEEKS);</span><br><span class="line">     <span class="comment">//方法2</span></span><br><span class="line">     <span class="type">LocalDate</span> <span class="variable">after2</span> <span class="operator">=</span> localDate.plusWeeks(<span class="number">1</span>);</span><br><span class="line">     System.out.println(<span class="string">&quot;一周后日期：&quot;</span> + after);</span><br><span class="line"></span><br><span class="line">     <span class="comment">//算两个日期间隔多少天，计算间隔多少年，多少月</span></span><br><span class="line">     <span class="type">LocalDate</span> <span class="variable">date1</span> <span class="operator">=</span> LocalDate.parse(<span class="string">&quot;2021-02-26&quot;</span>);</span><br><span class="line">     <span class="type">LocalDate</span> <span class="variable">date2</span> <span class="operator">=</span> LocalDate.parse(<span class="string">&quot;2021-12-23&quot;</span>);</span><br><span class="line">     <span class="type">Period</span> <span class="variable">period</span> <span class="operator">=</span> Period.between(date1, date2);</span><br><span class="line">     System.out.println(<span class="string">&quot;date1 到 date2 相隔：&quot;</span></span><br><span class="line">                + period.getYears() + <span class="string">&quot;年&quot;</span></span><br><span class="line">                + period.getMonths() + <span class="string">&quot;月&quot;</span></span><br><span class="line">                + period.getDays() + <span class="string">&quot;天&quot;</span>);</span><br><span class="line">   <span class="comment">//打印结果是 “date1 到 date2 相隔：0年9月27天”</span></span><br><span class="line">     <span class="comment">//这里period.getDays()得到的天是抛去年月以外的天数，并不是总天数</span></span><br><span class="line">     <span class="comment">//如果要获取纯粹的总天数应该用下面的方法</span></span><br><span class="line">     <span class="type">long</span> <span class="variable">day</span> <span class="operator">=</span> date2.toEpochDay() - date1.toEpochDay();</span><br><span class="line">     System.out.println(date1 + <span class="string">&quot;和&quot;</span> + date2 + <span class="string">&quot;相差&quot;</span> + day + <span class="string">&quot;天&quot;</span>);</span><br><span class="line">     <span class="comment">//打印结果：2021-02-26和2021-12-23相差300天</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取指定日期"><a href="#获取指定日期" class="headerlink" title="获取指定日期"></a>获取指定日期</h3><p>除了日期计算繁琐，获取特定一个日期也很麻烦，比如获取本月最后一天，第一天。</p><p><strong>Java 8 之前:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDay</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">format</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">        <span class="comment">//获取当前月第一天：</span></span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">c</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        c.set(Calendar.DAY_OF_MONTH, <span class="number">1</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">first</span> <span class="operator">=</span> format.format(c.getTime());</span><br><span class="line">        System.out.println(<span class="string">&quot;first day:&quot;</span> + first);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取当前月最后一天</span></span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">ca</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        ca.set(Calendar.DAY_OF_MONTH, ca.getActualMaximum(Calendar.DAY_OF_MONTH));</span><br><span class="line">        <span class="type">String</span> <span class="variable">last</span> <span class="operator">=</span> format.format(ca.getTime());</span><br><span class="line">        System.out.println(<span class="string">&quot;last day:&quot;</span> + last);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当年最后一天</span></span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">currCal</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        calendar.clear();</span><br><span class="line">        calendar.set(Calendar.YEAR, currCal.get(Calendar.YEAR));</span><br><span class="line">        calendar.roll(Calendar.DAY_OF_YEAR, -<span class="number">1</span>);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">time</span> <span class="operator">=</span> calendar.getTime();</span><br><span class="line">        System.out.println(<span class="string">&quot;last day:&quot;</span> + format.format(time));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Java 8 之后:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDayNew</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">today</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">    <span class="comment">//获取当前月第一天：</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">firstDayOfThisMonth</span> <span class="operator">=</span> today.with(TemporalAdjusters.firstDayOfMonth());</span><br><span class="line">    <span class="comment">// 取本月最后一天</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">lastDayOfThisMonth</span> <span class="operator">=</span> today.with(TemporalAdjusters.lastDayOfMonth());</span><br><span class="line">    <span class="comment">//取下一天：</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">nextDay</span> <span class="operator">=</span> lastDayOfThisMonth.plusDays(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//当年最后一天</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">lastday</span> <span class="operator">=</span> today.with(TemporalAdjusters.lastDayOfYear());</span><br><span class="line">    <span class="comment">//2021年最后一个周日，如果用Calendar是不得烦死。</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">lastMondayOf2021</span> <span class="operator">=</span> LocalDate.parse(<span class="string">&quot;2021-12-31&quot;</span>).with(TemporalAdjusters.lastInMonth(DayOfWeek.SUNDAY));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>java.time.temporal.TemporalAdjusters</code> 里面还有很多便捷的算法，这里就不带大家看 Api 了，都很简单，看了秒懂。</p><h3 id="JDBC-和-java8"><a href="#JDBC-和-java8" class="headerlink" title="JDBC 和 java8"></a>JDBC 和 java8</h3><p>现在 jdbc 时间类型和 java8 时间类型对应关系是</p><ol><li><code>Date</code> —&gt; <code>LocalDate</code></li><li><code>Time</code> —&gt; <code>LocalTime</code></li><li><code>Timestamp</code> —&gt; <code>LocalDateTime</code></li></ol><p>而之前统统对应 <code>Date</code>，也只有 <code>Date</code>。</p><h3 id="时区"><a href="#时区" class="headerlink" title="时区"></a>时区</h3><blockquote><p>时区：正式的时区划分为每隔经度 15° 划分一个时区，全球共 24 个时区，每个时区相差 1 小时。但为了行政上的方便，常将 1 个国家或 1 个省份划在一起，比如我国幅员宽广，大概横跨 5 个时区，实际上只用东八时区的标准时即北京时间为准。</p></blockquote><p><code>java.util.Date</code> 对象实质上存的是 1970 年 1 月 1 日 0 点（ GMT）至 Date 对象所表示时刻所经过的毫秒数。也就是说不管在哪个时区 new Date，它记录的毫秒数都一样，和时区无关。但在使用上应该把它转换成当地时间，这就涉及到了时间的国际化。<code>java.util.Date</code> 本身并不支持国际化，需要借助 <code>TimeZone</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//北京时间：Wed Jan 27 14:05:29 CST 2021</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">bjSdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="comment">//北京时区</span></span><br><span class="line">bjSdf.setTimeZone(TimeZone.getTimeZone(<span class="string">&quot;Asia/Shanghai&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;毫秒数:&quot;</span> + date.getTime() + <span class="string">&quot;, 北京时间:&quot;</span> + bjSdf.format(date));</span><br><span class="line"></span><br><span class="line"><span class="comment">//东京时区</span></span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">tokyoSdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">tokyoSdf.setTimeZone(TimeZone.getTimeZone(<span class="string">&quot;Asia/Tokyo&quot;</span>));  <span class="comment">// 设置东京时区</span></span><br><span class="line">System.out.println(<span class="string">&quot;毫秒数:&quot;</span> + date.getTime() + <span class="string">&quot;, 东京时间:&quot;</span> + tokyoSdf.format(date));</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果直接print会自动转成当前时区的时间</span></span><br><span class="line">System.out.println(date);</span><br><span class="line"><span class="comment">//Wed Jan 27 14:05:29 CST 2021</span></span><br></pre></td></tr></table></figure><p>在新特性中引入了 <code>java.time.ZonedDateTime</code> 来表示带时区的时间。它可以看成是 <code>LocalDateTime + ZoneId</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前时区时间</span></span><br><span class="line"><span class="type">ZonedDateTime</span> <span class="variable">zonedDateTime</span> <span class="operator">=</span> ZonedDateTime.now();</span><br><span class="line">System.out.println(<span class="string">&quot;当前时区时间: &quot;</span> + zonedDateTime);</span><br><span class="line"></span><br><span class="line"><span class="comment">//东京时间</span></span><br><span class="line"><span class="type">ZoneId</span> <span class="variable">zoneId</span> <span class="operator">=</span> ZoneId.of(ZoneId.SHORT_IDS.get(<span class="string">&quot;JST&quot;</span>));</span><br><span class="line"><span class="type">ZonedDateTime</span> <span class="variable">tokyoTime</span> <span class="operator">=</span> zonedDateTime.withZoneSameInstant(zoneId);</span><br><span class="line">System.out.println(<span class="string">&quot;东京时间: &quot;</span> + tokyoTime);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ZonedDateTime 转 LocalDateTime</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> tokyoTime.toLocalDateTime();</span><br><span class="line">System.out.println(<span class="string">&quot;东京时间转当地时间: &quot;</span> + localDateTime);</span><br><span class="line"></span><br><span class="line"><span class="comment">//LocalDateTime 转 ZonedDateTime</span></span><br><span class="line"><span class="type">ZonedDateTime</span> <span class="variable">localZoned</span> <span class="operator">=</span> localDateTime.atZone(ZoneId.systemDefault());</span><br><span class="line">System.out.println(<span class="string">&quot;本地时区时间: &quot;</span> + localZoned);</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line">当前时区时间: <span class="number">2021</span>-<span class="number">01</span>-27T14:<span class="number">43</span>:<span class="number">58.735</span>+08:<span class="number">00</span>[Asia/Shanghai]</span><br><span class="line">东京时间: <span class="number">2021</span>-<span class="number">01</span>-27T15:<span class="number">43</span>:<span class="number">58.735</span>+09:<span class="number">00</span>[Asia/Tokyo]</span><br><span class="line">东京时间转当地时间: <span class="number">2021</span>-<span class="number">01</span>-27T15:<span class="number">43</span>:<span class="number">58.735</span></span><br><span class="line">当地时区时间: <span class="number">2021</span>-<span class="number">01</span>-27T15:<span class="number">53</span>:<span class="number">35.618</span>+08:<span class="number">00</span>[Asia/Shanghai]</span><br></pre></td></tr></table></figure><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>通过上面比较新老 <code>Date</code> 的不同，当然只列出部分功能上的区别，更多功能还得自己去挖掘。总之 date-time-api 给日期操作带来了福利。在日常工作中遇到 date 类型的操作，第一考虑的是 date-time-api，实在解决不了再考虑老的 Date。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们梳理总结的 java 8 新特性有</p><ul><li>Interface &amp; functional Interface</li><li>Lambda</li><li>Stream</li><li>Optional</li><li>Date time-api</li></ul><p>这些都是开发当中比较常用的特性。梳理下来发现它们真香，而我却没有更早的应用。总觉得学习 java 8 新特性比较麻烦，一直使用老的实现方式。其实这些新特性几天就可以掌握，一但掌握，效率会有很大的提高。其实我们涨工资也是涨的学习的钱，不学习终究会被淘汰，35 岁危机会提前来临。</p><!-- @include: @article-footer.snippet.md -->]]></content>
      
      
      <categories>
          
          <category> Java核心系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java核心 </tag>
            
            <tag> Java版本新特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础</title>
      <link href="/2025/02/18/Java%E5%9B%9E%E9%A1%BE%E7%AF%87/Java%E5%9B%9E%E9%A1%BE-%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
      <url>/2025/02/18/Java%E5%9B%9E%E9%A1%BE%E7%AF%87/Java%E5%9B%9E%E9%A1%BE-%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><blockquote><p><em><strong>基础篇要点：算法、数据结构、基础设计模式</strong></em></p></blockquote><h2 id="1-二分查找"><a href="#1-二分查找" class="headerlink" title="1. 二分查找"></a>1. 二分查找</h2><p><strong>要求</strong></p><ul><li>能够用自己语言描述二分查找算法</li><li>能够手写二分查找代码</li><li>能够解答一些变化后的考法</li></ul><p><strong>算法描述</strong></p><ol><li><p>前提：有已排序数组 A（假设已经做好）</p></li><li><p>定义左边界 L、右边界 R，确定搜索范围，循环执行二分查找（3、4两步）</p></li><li><p>获取中间索引 M &#x3D; Floor((L+R) &#x2F;2)</p></li><li><p>中间索引的值  A[M] 与待搜索的值 T 进行比较</p><p>① A[M] &#x3D;&#x3D; T 表示找到，返回中间索引</p><p>② A[M] &gt; T，中间值右侧的其它元素都大于 T，无需比较，中间索引左边去找，M - 1 设置为右边界，重新查找</p><p>③ A[M] &lt; T，中间值左侧的其它元素都小于 T，无需比较，中间索引右边去找， M + 1 设置为左边界，重新查找</p></li><li><p>当 L &gt; R 时，表示没有找到，应结束循环</p></li></ol><blockquote><p><em>更形象的描述请参考：binary_search.html</em></p></blockquote><p><strong>算法实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = a.length - <span class="number">1</span>, m;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[m] == t) &#123;</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[m] &gt; t) &#123;</span><br><span class="line">            r = m - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] array = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">19</span>, <span class="number">22</span>, <span class="number">31</span>, <span class="number">35</span>, <span class="number">40</span>, <span class="number">45</span>, <span class="number">48</span>, <span class="number">49</span>, <span class="number">50</span>&#125;;</span><br><span class="line">    <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> <span class="number">47</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> binarySearch(array, target);</span><br><span class="line">    System.out.println(idx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解决整数溢出问题</strong></p><p>当 l 和 r 都较大时，<code>l + r</code> 有可能超过整数范围，造成运算错误，解决方法有两种：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> l + (r - l) / <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>还有一种是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (l + r) &gt;&gt;&gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><strong>其它考法</strong></p><ol><li><p>有一个有序表为 1,5,8,11,19,22,31,35,40,45,48,49,50 当二分查找值为 48 的结点时，查找成功需要比较的次数 </p></li><li><p>使用二分法在序列 1,4,6,7,15,33,39,50,64,78,75,81,89,96 中查找元素 81 时，需要经过（   ）次比较</p></li><li><p>在拥有128个元素的数组中二分查找一个数，需要比较的次数最多不超过多少次</p></li></ol><p>对于前两个题目，记得一个简要判断口诀：奇数二分取中间，偶数二分取中间靠左。对于后一道题目，需要知道公式：</p><p>$$n &#x3D; log_2N &#x3D; log_{10}N&#x2F;log_{10}2$$</p><p>其中 n 为查找次数，N 为元素个数</p><h2 id="2-冒泡排序"><a href="#2-冒泡排序" class="headerlink" title="2. 冒泡排序"></a>2. 冒泡排序</h2><p><strong>要求</strong></p><ul><li>能够用自己语言描述冒泡排序算法</li><li>能够手写冒泡排序代码</li><li>了解一些冒泡排序的优化手段</li></ul><p><strong>算法描述</strong></p><ol><li>依次比较数组中相邻两个元素大小，若 a[j] &gt; a[j+1]，则交换两个元素，两两都比较一遍称为一轮冒泡，结果是让最大的元素排至最后</li><li>重复以上步骤，直到整个数组有序</li></ol><blockquote><p><em>更形象的描述请参考：bubble_sort.html</em></p></blockquote><p><strong>算法实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubble</span><span class="params">(<span class="type">int</span>[] a)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; a.length - <span class="number">1</span>; j++) &#123;</span><br><span class="line">        <span class="comment">// 一轮冒泡</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">swapped</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 是否发生了交换</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length - <span class="number">1</span> - j; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;比较次数&quot;</span> + i);</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; a[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                Utils.swap(a, i, i + <span class="number">1</span>);</span><br><span class="line">                swapped = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;第&quot;</span> + j + <span class="string">&quot;轮冒泡&quot;</span></span><br><span class="line">                           + Arrays.toString(a));</span><br><span class="line">        <span class="keyword">if</span> (!swapped) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优化点1：每经过一轮冒泡，内层循环就可以减少一次</li><li>优化点2：如果某一轮冒泡没有发生交换，则表示所有数据有序，可以结束外层循环</li></ul><p><strong>进一步优化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubble_v2</span><span class="params">(<span class="type">int</span>[] a)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> a.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 表示最后一次交换索引位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;比较次数&quot;</span> + i);</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; a[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                Utils.swap(a, i, i + <span class="number">1</span>);</span><br><span class="line">                last = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        n = last;</span><br><span class="line">        System.out.println(<span class="string">&quot;第轮冒泡&quot;</span></span><br><span class="line">                           + Arrays.toString(a));</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>每轮冒泡时，最后一次交换索引可以作为下一轮冒泡的比较次数，如果这个值为零，表示整个数组有序，直接退出外层循环即可</li></ul><h2 id="3-选择排序"><a href="#3-选择排序" class="headerlink" title="3. 选择排序"></a>3. 选择排序</h2><p><strong>要求</strong></p><ul><li>能够用自己语言描述选择排序算法</li><li>能够比较选择排序与冒泡排序</li><li>理解非稳定排序与稳定排序</li></ul><p><strong>算法描述</strong></p><ol><li><p>将数组分为两个子集，排序的和未排序的，每一轮从未排序的子集中选出最小的元素，放入排序子集</p></li><li><p>重复以上步骤，直到整个数组有序</p></li></ol><blockquote><p><em>更形象的描述请参考：selection_sort.html</em></p></blockquote><p><strong>算法实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selection</span><span class="params">(<span class="type">int</span>[] a)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// i 代表每轮选择最小元素要交换到的目标索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> i; <span class="comment">// 代表最小元素的索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> s + <span class="number">1</span>; j &lt; a.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[s] &gt; a[j]) &#123; <span class="comment">// j 元素比 s 元素还要小, 更新 s</span></span><br><span class="line">                s = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s != i) &#123;</span><br><span class="line">            swap(a, s, i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优化点：为减少交换次数，每一轮可以先找最小的索引，在每轮最后再交换元素</li></ul><p><strong>与冒泡排序比较</strong></p><ol><li><p>二者平均时间复杂度都是 $O(n^2)$</p></li><li><p>选择排序一般要快于冒泡，因为其交换次数少</p></li><li><p>但如果集合有序度高，冒泡优于选择</p></li><li><p>冒泡属于稳定排序算法，而选择属于不稳定排序</p><ul><li>稳定排序指，按对象中不同字段进行多次排序，不会打乱同值元素的顺序</li><li>不稳定排序则反之</li></ul></li></ol><p><strong>稳定排序与不稳定排序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;=================不稳定================&quot;</span>);</span><br><span class="line">Card[] cards = getStaticCards();</span><br><span class="line">System.out.println(Arrays.toString(cards));</span><br><span class="line">selection(cards, Comparator.comparingInt((Card a) -&gt; a.sharpOrder).reversed());</span><br><span class="line">System.out.println(Arrays.toString(cards));</span><br><span class="line">selection(cards, Comparator.comparingInt((Card a) -&gt; a.numberOrder).reversed());</span><br><span class="line">System.out.println(Arrays.toString(cards));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;=================稳定=================&quot;</span>);</span><br><span class="line">cards = getStaticCards();</span><br><span class="line">System.out.println(Arrays.toString(cards));</span><br><span class="line">bubble(cards, Comparator.comparingInt((Card a) -&gt; a.sharpOrder).reversed());</span><br><span class="line">System.out.println(Arrays.toString(cards));</span><br><span class="line">bubble(cards, Comparator.comparingInt((Card a) -&gt; a.numberOrder).reversed());</span><br><span class="line">System.out.println(Arrays.toString(cards));</span><br></pre></td></tr></table></figure><p>都是先按照花色排序（♠♥♣♦），再按照数字排序（AKQJ…）</p><ul><li><p>不稳定排序算法按数字排序时，会打乱原本同值的花色顺序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[♠7], [♠2], [♠4], [♠5], [♥2], [♥5]]</span><br><span class="line">[[♠7], [♠5], [♥5], [♠4], [♥2], [♠2]]</span><br></pre></td></tr></table></figure><p>原来 ♠2 在前 ♥2 在后，按数字再排后，他俩的位置变了</p></li><li><p>稳定排序算法按数字排序时，会保留原本同值的花色顺序，如下所示 ♠2 与 ♥2 的相对位置不变</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[♠7], [♠2], [♠4], [♠5], [♥2], [♥5]]</span><br><span class="line">[[♠7], [♠5], [♥5], [♠4], [♠2], [♥2]]</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-插入排序"><a href="#4-插入排序" class="headerlink" title="4. 插入排序"></a>4. 插入排序</h2><p><strong>要求</strong></p><ul><li>能够用自己语言描述插入排序算法</li><li>能够比较插入排序与选择排序</li></ul><p><strong>算法描述</strong></p><ol><li><p>将数组分为两个区域，排序区域和未排序区域，每一轮从未排序区域中取出第一个元素，插入到排序区域（需保证顺序）</p></li><li><p>重复以上步骤，直到整个数组有序</p></li></ol><blockquote><p><em>更形象的描述请参考：insertion_sort.html</em></p></blockquote><p><strong>算法实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改了代码与希尔排序一致</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span>[] a)</span> &#123;</span><br><span class="line">    <span class="comment">// i 代表待插入元素的索引</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a[i]; <span class="comment">// 代表待插入的元素值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">        System.out.println(j);</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t &lt; a[j - <span class="number">1</span>]) &#123; <span class="comment">// j-1 是上一个元素索引，如果 &gt; t，后移</span></span><br><span class="line">                a[j] = a[j - <span class="number">1</span>];</span><br><span class="line">                j--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果 j-1 已经 &lt;= t, 则 j 就是插入位置</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a[j] = t;</span><br><span class="line">        System.out.println(Arrays.toString(a) + <span class="string">&quot; &quot;</span> + j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>与选择排序比较</strong></p><ol><li><p>二者平均时间复杂度都是 $O(n^2)$</p></li><li><p>大部分情况下，插入都略优于选择</p></li><li><p>有序集合插入的时间复杂度为 $O(n)$</p></li><li><p>插入属于稳定排序算法，而选择属于不稳定排序</p></li></ol><p><strong>提示</strong></p><blockquote><p><em>插入排序通常被同学们所轻视，其实它的地位非常重要。小数据量排序，都会优先选择插入排序</em></p></blockquote><h2 id="5-希尔排序"><a href="#5-希尔排序" class="headerlink" title="5. 希尔排序"></a>5. 希尔排序</h2><p><strong>要求</strong></p><ul><li>能够用自己语言描述希尔排序算法</li></ul><p><strong>算法描述</strong></p><ol><li><p>首先选取一个间隙序列，如 (n&#x2F;2，n&#x2F;4 … 1)，n 为数组长度</p></li><li><p>每一轮将间隙相等的元素视为一组，对组内元素进行插入排序，目的有二</p><p>① 少量元素插入排序速度很快</p><p>② 让组内值较大的元素更快地移动到后方</p></li><li><p>当间隙逐渐减少，直至为 1 时，即可完成排序</p></li></ol><blockquote><p><em>更形象的描述请参考：shell_sort.html</em></p></blockquote><p><strong>算法实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shell</span><span class="params">(<span class="type">int</span>[] a)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> a.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> n / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// i 代表待插入元素的索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> gap; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a[i]; <span class="comment">// 代表待插入的元素值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= gap) &#123;</span><br><span class="line">                <span class="comment">// 每次与上一个间隙为 gap 的元素进行插入排序</span></span><br><span class="line">                <span class="keyword">if</span> (t &lt; a[j - gap]) &#123; <span class="comment">// j-gap 是上一个元素索引，如果 &gt; t，后移</span></span><br><span class="line">                    a[j] = a[j - gap];</span><br><span class="line">                    j -= gap;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果 j-1 已经 &lt;= t, 则 j 就是插入位置</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            a[j] = t;</span><br><span class="line">            System.out.println(Arrays.toString(a) + <span class="string">&quot; gap:&quot;</span> + gap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>参考资料</strong></p><ul><li><a href="https://en.wikipedia.org/wiki/Shellsort">https://en.wikipedia.org/wiki/Shellsort</a></li></ul><h2 id="6-快速排序"><a href="#6-快速排序" class="headerlink" title="6. 快速排序"></a>6. 快速排序</h2><p><strong>要求</strong></p><ul><li>能够用自己语言描述快速排序算法</li><li>掌握手写单边循环、双边循环代码之一</li><li>能够说明快排特点</li><li>了解洛穆托与霍尔两种分区方案的性能比较</li></ul><p><strong>算法描述</strong></p><ol><li>每一轮排序选择一个基准点（pivot）进行分区<ol><li>让小于基准点的元素的进入一个分区，大于基准点的元素的进入另一个分区</li><li>当分区完成时，基准点元素的位置就是其最终位置</li></ol></li><li>在子分区内重复以上过程，直至子分区元素个数少于等于 1，这体现的是分而治之的思想 （<a href="https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm">divide-and-conquer</a>）</li><li>从以上描述可以看出，一个关键在于分区算法，常见的有洛穆托分区方案、双边循环分区方案、霍尔分区方案</li></ol><blockquote><p><em>更形象的描述请参考：quick_sort.html</em></p></blockquote><p><strong>单边循环快排（lomuto 洛穆托分区方案）</strong></p><ol><li><p>选择最右元素作为基准点元素</p></li><li><p>j 指针负责找到比基准点小的元素，一旦找到则与 i 进行交换</p></li><li><p>i 指针维护小于基准点元素的边界，也是每次交换的目标索引</p></li><li><p>最后基准点与 i 交换，i 即为分区位置</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quick</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> l, <span class="type">int</span> h)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= h) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> partition(a, l, h); <span class="comment">// p 索引值</span></span><br><span class="line">    quick(a, l, p - <span class="number">1</span>); <span class="comment">// 左边分区的范围确定</span></span><br><span class="line">    quick(a, p + <span class="number">1</span>, h); <span class="comment">// 左边分区的范围确定</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> l, <span class="type">int</span> h)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pv</span> <span class="operator">=</span> a[h]; <span class="comment">// 基准点元素</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> l; j &lt; h; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[j] &lt; pv) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != j) &#123;</span><br><span class="line">                swap(a, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i != h) &#123;</span><br><span class="line">        swap(a, h, i);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Arrays.toString(a) + <span class="string">&quot; i=&quot;</span> + i);</span><br><span class="line">    <span class="comment">// 返回值代表了基准点元素所在的正确索引，用它确定下一轮分区的边界</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>双边循环快排（不完全等价于 hoare 霍尔分区方案）</strong></p><ol><li>选择最左元素作为基准点元素</li><li>j 指针负责从右向左找比基准点小的元素，i 指针负责从左向右找比基准点大的元素，一旦找到二者交换，直至 i，j 相交</li><li>最后基准点与 i（此时 i 与 j 相等）交换，i 即为分区位置</li></ol><p>要点</p><ol><li><p>基准点在左边，并且要先 j 后 i</p></li><li><p>while( <strong>i</strong> **&lt; j** &amp;&amp; a[j] &gt; pv ) j– </p></li><li><p>while ( <strong>i</strong> <strong>&lt; j</strong> &amp;&amp; a[i] <strong>&lt;&#x3D;</strong> pv ) i++</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quick</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> l, <span class="type">int</span> h)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= h) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> partition(a, l, h);</span><br><span class="line">    quick(a, l, p - <span class="number">1</span>);</span><br><span class="line">    quick(a, p + <span class="number">1</span>, h);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> l, <span class="type">int</span> h)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pv</span> <span class="operator">=</span> a[l];</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> h;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="comment">// j 从右找小的</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; a[j] &gt; pv) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// i 从左找大的</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; a[i] &lt;= pv) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(a, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(a, l, j);</span><br><span class="line">    System.out.println(Arrays.toString(a) + <span class="string">&quot; j=&quot;</span> + j);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>快排特点</strong></p><ol><li><p>平均时间复杂度是 $O(nlog_2⁡n )$，最坏时间复杂度 $O(n^2)$</p></li><li><p>数据量较大时，优势非常明显</p></li><li><p>属于不稳定排序</p></li></ol><p><strong>洛穆托分区方案 vs 霍尔分区方案</strong></p><ul><li>霍尔的移动次数平均来讲比洛穆托少3倍</li><li><a href="https://qastack.cn/cs/11458/quicksort-partitioning-hoare-vs-lomuto">https://qastack.cn/cs/11458/quicksort-partitioning-hoare-vs-lomuto</a></li></ul><blockquote><p><em><strong>补充代码说明</strong></em></p><ul><li>day01.sort.QuickSort3 演示了空穴法改进的双边快排，比较次数更少</li><li>day01.sort.QuickSortHoare 演示了霍尔分区的实现</li><li>day01.sort.LomutoVsHoare 对四种分区实现的移动次数比较</li></ul></blockquote><h2 id="7-ArrayList"><a href="#7-ArrayList" class="headerlink" title="7. ArrayList"></a>7. ArrayList</h2><p><strong>要求</strong></p><ul><li>掌握 ArrayList 扩容规则</li></ul><p><strong>扩容规则</strong></p><ol><li><p>ArrayList() 会使用长度为零的数组</p></li><li><p>ArrayList(int initialCapacity) 会使用指定容量的数组</p></li><li><p>public ArrayList(Collection&lt;? extends E&gt; c) 会使用 c 的大小作为数组容量</p></li><li><p>add(Object o) 首次扩容为 10，再次扩容为上次容量的 1.5 倍</p></li><li><p>addAll(Collection c) 没有元素时，扩容为 Math.max(10, 实际元素个数)，有元素时为 Math.max(原容量 1.5 倍, 实际元素个数)</p></li></ol><p>其中第 4 点必须知道，其它几点视个人情况而定</p><p><strong>提示</strong></p><ul><li>测试代码见 <code>day01.list.TestArrayList</code> ，这里不再列出</li><li>要<strong>注意</strong>的是，示例中用反射方式来更直观地反映 ArrayList 的扩容特征，但从 JDK 9 由于模块化的影响，对反射做了较多限制，需要在运行测试代码时添加 VM 参数 <code>--add-opens java.base/java.util=ALL-UNNAMED</code> 方能运行通过，后面的例子都有相同问题</li></ul><blockquote><p><em><strong>代码说明</strong></em></p><ul><li>day01.list.TestArrayList#arrayListGrowRule 演示了 add(Object) 方法的扩容规则，输入参数 n 代表打印多少次扩容后的数组长度</li></ul></blockquote><h2 id="8-Iterator"><a href="#8-Iterator" class="headerlink" title="8. Iterator"></a>8. Iterator</h2><p><strong>要求</strong></p><ul><li>掌握什么是 Fail-Fast、什么是 Fail-Safe</li></ul><p>Fail-Fast 与 Fail-Safe</p><ul><li><p>ArrayList 是 fail-fast 的典型代表，遍历的同时不能修改，尽快失败</p></li><li><p>CopyOnWriteArrayList 是 fail-safe 的典型代表，遍历的同时可以修改，原理是读写分离</p></li></ul><p><strong>提示</strong></p><ul><li>测试代码见 <code>day01.list.FailFastVsFailSafe</code>，这里不再列出</li></ul><h2 id="9-LinkedList"><a href="#9-LinkedList" class="headerlink" title="9. LinkedList"></a>9. LinkedList</h2><p><strong>要求</strong></p><ul><li>能够说清楚 LinkedList 对比 ArrayList 的区别，并重视纠正部分错误的认知</li></ul><p><strong>LinkedList</strong></p><ol><li>基于双向链表，无需连续内存</li><li>随机访问慢（要沿着链表遍历）</li><li>头尾插入删除性能高</li><li>占用内存多</li></ol><p><strong>ArrayList</strong></p><ol><li>基于数组，需要连续内存</li><li>随机访问快（指根据下标访问）</li><li>尾部插入、删除性能可以，其它部分插入、删除都会移动数据，因此性能会低</li><li>可以利用 cpu 缓存，局部性原理</li></ol><blockquote><p><em><strong>代码说明</strong></em></p><ul><li>day01.list.ArrayListVsLinkedList#randomAccess 对比随机访问性能</li><li>day01.list.ArrayListVsLinkedList#addMiddle 对比向中间插入性能</li><li>day01.list.ArrayListVsLinkedList#addFirst 对比头部插入性能</li><li>day01.list.ArrayListVsLinkedList#addLast 对比尾部插入性能</li><li>day01.list.ArrayListVsLinkedList#linkedListSize 打印一个 LinkedList 占用内存</li><li>day01.list.ArrayListVsLinkedList#arrayListSize 打印一个 ArrayList 占用内存</li></ul></blockquote><h2 id="10-HashMap"><a href="#10-HashMap" class="headerlink" title="10. HashMap"></a>10. HashMap</h2><p><strong>要求</strong></p><ul><li>掌握 HashMap 的基本数据结构</li><li>掌握树化</li><li>理解索引计算方法、二次 hash 的意义、容量对索引计算的影响</li><li>掌握 put 流程、扩容、扩容因子</li><li>理解并发使用 HashMap 可能导致的问题</li><li>理解 key 的设计</li></ul><h3 id="1）基本数据结构"><a href="#1）基本数据结构" class="headerlink" title="1）基本数据结构"></a>1）基本数据结构</h3><ul><li>1.7 数组 + 链表</li><li>1.8 数组 + （链表 | 红黑树）</li></ul><blockquote><p>更形象的演示，见资料中的 hash-demo.jar，运行需要 jdk14 以上环境，进入 jar 包目录，执行下面命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar --add-exports java.base/jdk.internal.misc=ALL-UNNAMED hash-demo.jar</span><br></pre></td></tr></table></figure></blockquote><h3 id="2）树化与退化"><a href="#2）树化与退化" class="headerlink" title="2）树化与退化"></a>2）树化与退化</h3><p><strong>树化意义</strong></p><ul><li>红黑树用来避免 DoS 攻击，防止链表超长时性能下降，树化应当是偶然情况，是保底策略</li><li>hash 表的查找，更新的时间复杂度是 $O(1)$，而红黑树的查找，更新的时间复杂度是 $O(log_2⁡n )$，TreeNode 占用空间也比普通 Node 的大，如非必要，尽量还是使用链表</li><li>hash 值如果足够随机，则在 hash 表内按泊松分布，在负载因子 0.75 的情况下，长度超过 8 的链表出现概率是 0.00000006，树化阈值选择 8 就是为了让树化几率足够小</li></ul><p><strong>树化规则</strong></p><ul><li>当链表长度超过树化阈值 8 时，先尝试扩容来减少链表长度，如果数组容量已经 &gt;&#x3D;64，才会进行树化</li></ul><p><strong>退化规则</strong></p><ul><li>情况1：在扩容时如果拆分树时，树元素个数 &lt;&#x3D; 6 则会退化链表</li><li>情况2：remove 树节点时，若 root、root.left、root.right、root.left.left 有一个为 null ，也会退化为链表</li></ul><h3 id="3）索引计算"><a href="#3）索引计算" class="headerlink" title="3）索引计算"></a>3）索引计算</h3><p><strong>索引计算方法</strong></p><ul><li>首先，计算对象的 hashCode()</li><li>再进行调用 HashMap 的 hash() 方法进行二次哈希<ul><li>二次 hash() 是为了综合高位数据，让哈希分布更为均匀</li></ul></li><li>最后 &amp; (capacity – 1) 得到索引</li></ul><p><strong>数组容量为何是 2 的 n 次幂</strong></p><ol><li>计算索引时效率更高：如果是 2 的 n 次幂可以使用位与运算代替取模</li><li>扩容时重新计算索引效率更高： hash &amp; oldCap &#x3D;&#x3D; 0 的元素留在原来位置 ，否则新位置 &#x3D; 旧位置 + oldCap</li></ol><p><strong>注意</strong></p><ul><li>二次 hash 是为了配合 <strong>容量是 2 的 n 次幂</strong> 这一设计前提，如果 hash 表的容量不是 2 的 n 次幂，则不必二次 hash</li><li><strong>容量是 2 的 n 次幂</strong> 这一设计计算索引效率更好，但 hash 的分散性就不好，需要二次 hash 来作为补偿，没有采用这一设计的典型例子是 Hashtable</li></ul><h3 id="4）put-与扩容"><a href="#4）put-与扩容" class="headerlink" title="4）put 与扩容"></a>4）put 与扩容</h3><p><strong>put 流程</strong></p><ol><li>HashMap 是懒惰创建数组的，首次使用才创建数组</li><li>计算索引（桶下标）</li><li>如果桶下标还没人占用，创建 Node 占位返回</li><li>如果桶下标已经有人占用<ol><li>已经是 TreeNode 走红黑树的添加或更新逻辑</li><li>是普通 Node，走链表的添加或更新逻辑，如果链表长度超过树化阈值，走树化逻辑</li></ol></li><li>返回前检查容量是否超过阈值，一旦超过进行扩容</li></ol><p><strong>1.7 与 1.8 的区别</strong></p><ol><li><p>链表插入节点时，1.7 是头插法，1.8 是尾插法</p></li><li><p>1.7 是大于等于阈值且没有空位时才扩容，而 1.8 是大于阈值就扩容</p></li><li><p>1.8 在扩容计算 Node 索引时，会优化</p></li></ol><p><strong>扩容（加载）因子为何默认是 0.75f</strong></p><ol><li>在空间占用与查询时间之间取得较好的权衡</li><li>大于这个值，空间节省了，但链表就会比较长影响性能</li><li>小于这个值，冲突减少了，但扩容就会更频繁，空间占用也更多</li></ol><h3 id="5）并发问题"><a href="#5）并发问题" class="headerlink" title="5）并发问题"></a>5）并发问题</h3><p><strong>扩容死链（1.7 会存在）</strong></p><p>1.7 源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Entry[] newTable, <span class="type">boolean</span> rehash)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="literal">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>e 和 next 都是局部变量，用来指向当前节点和下一个节点</li><li>线程1（绿色）的临时变量 e 和 next 刚引用了这俩节点，还未来得及移动节点，发生了线程切换，由线程2（蓝色）完成扩容和迁移</li></ul><p><a href="https://imags-563.pages.dev/file/AgACAgUAAxkDAAMsZ7SUGnXmbtzlYLLgJOQS_q3C4MMAAp3BMRtiZKBVCRNvwcSPQtQBAAMCAAN5AAM2BA.png">图1</a><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAMsZ7SUGnXmbtzlYLLgJOQS_q3C4MMAAp3BMRtiZKBVCRNvwcSPQtQBAAMCAAN5AAM2BA.png"></p><ul><li><p>线程2 扩容完成，由于头插法，链表顺序颠倒。但线程1 的临时变量 e 和 next 还引用了这俩节点，还要再来一遍迁移</p></li><li><p>第一次循环</p><ul><li>循环接着线程切换前运行，注意此时 e 指向的是节点 a，next 指向的是节点 b</li><li>e 头插 a 节点，注意图中画了两份 a 节点，但事实上只有一个（为了不让箭头特别乱画了两份）</li><li>当循环结束是 e 会指向 next 也就是 b 节点</li></ul></li><li><p>第二次循环</p><ul><li>next 指向了节点 a</li><li>e 头插节点 b</li><li>当循环结束时，e 指向 next 也就是节点 a</li></ul></li><li><p>第三次循环</p><ul><li>next 指向了 null</li><li>e 头插节点 a，<strong>a 的 next 指向了 b</strong>（之前 a.next 一直是 null），b 的 next 指向 a，死链已成</li><li>当循环结束时，e 指向 next 也就是 null，因此第四次循环时会正常退出</li></ul></li></ul><p><strong>数据错乱（1.7，1.8 都会存在）</strong></p><ul><li>代码参考 <code>day01.map.HashMapMissData</code>，具体调试步骤参考视频</li></ul><blockquote><p><em><strong>补充代码说明</strong></em></p><ul><li>day01.map.HashMapDistribution 演示 map 中链表长度符合泊松分布</li><li>day01.map.DistributionAffectedByCapacity 演示容量及 hashCode 取值对分布的影响<ul><li>day01.map.DistributionAffectedByCapacity#hashtableGrowRule 演示了 Hashtable 的扩容规律</li><li>day01.sort.Utils#randomArray 如果 hashCode 足够随机，容量是否是 2 的 n 次幂影响不大</li><li>day01.sort.Utils#lowSameArray 如果 hashCode 低位一样的多，容量是 2 的 n 次幂会导致分布不均匀</li><li>day01.sort.Utils#evenArray 如果 hashCode 偶数的多，容量是 2 的 n 次幂会导致分布不均匀</li><li>由此得出对于容量是 2 的 n 次幂的设计来讲，二次 hash 非常重要</li></ul></li><li>day01.map.HashMapVsHashtable 演示了对于同样数量的单词字符串放入 HashMap 和 Hashtable 分布上的区别</li></ul></blockquote><h3 id="6）key-的设计"><a href="#6）key-的设计" class="headerlink" title="6）key 的设计"></a>6）key 的设计</h3><p><strong>key 的设计要求</strong></p><ol><li>HashMap 的 key 可以为 null，但 Map 的其他实现则不然</li><li>作为 key 的对象，必须实现 hashCode 和 equals，并且 key 的内容不能修改（不可变）</li><li>key 的 hashCode 应该有良好的散列性</li></ol><p>如果 key 可变，例如修改了 age 会导致再次查询时查询不到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapMutableKey</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        HashMap&lt;Student, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        map.put(stu, <span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line"></span><br><span class="line">        System.out.println(map.get(stu));</span><br><span class="line"></span><br><span class="line">        stu.age = <span class="number">19</span>;</span><br><span class="line">        System.out.println(map.get(stu));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">        String name;</span><br><span class="line">        <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="built_in">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) o;</span><br><span class="line">            <span class="keyword">return</span> age == student.age &amp;&amp; Objects.equals(name, student.name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>String 对象的 hashCode() 设计</strong></p><ul><li>目标是达到较为均匀的散列效果，每个字符串的 hashCode 足够独特</li><li>字符串中的每个字符都可以表现为一个数字，称为 $S_i$，其中 i 的范围是 0 ~ n - 1 </li><li>散列公式为： $S_0∗31^{(n-1)}+ S_1∗31^{(n-2)}+ … S_i ∗ 31^{(n-1-i)}+ …S_{(n-1)}∗31^0$</li><li>31 代入公式有较好的散列特性，并且 31 * h 可以被优化为 <ul><li>即 $32 ∗h -h $</li><li>即 $2^5  ∗h -h$</li><li>即 $h≪5  -h$</li></ul></li></ul><h2 id="11-单例模式"><a href="#11-单例模式" class="headerlink" title="11. 单例模式"></a>11. 单例模式</h2><p><strong>要求</strong></p><ul><li>掌握五种单例模式的实现方式</li><li>理解为何 DCL 实现时要使用 volatile 修饰静态变量</li><li>了解 jdk 中用到单例的场景</li></ul><p><strong>饿汉式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton1</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;单例对象不能重复创建&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;private Singleton1()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton1</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton1</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">otherMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;otherMethod()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">readResolve</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>构造方法抛出异常是防止反射破坏单例</li><li><code>readResolve()</code> 是防止反序列化破坏单例</li></ul><p><strong>枚举饿汉式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton2</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;private Singleton2()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">otherMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;otherMethod()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>枚举饿汉式能天然防止反射、反序列化破坏单例</li></ul><p><strong>懒汉式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton3</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton3</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;private Singleton3()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton3</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Singleton3.class</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton3 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">            INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton3</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">otherMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;otherMethod()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>其实只有首次创建单例对象时才需要同步，但该代码实际上每次调用都会同步</li><li>因此有了下面的双检锁改进</li></ul><p><strong>双检锁懒汉式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton4</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton4</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;private Singleton4()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">Singleton4</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 可见性，有序性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton4 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton4.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton4</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">otherMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;otherMethod()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为何必须加 volatile：</p><ul><li><code>INSTANCE = new Singleton4()</code> 不是原子的，分成 3 步：创建对象、调用构造、给静态变量赋值，其中后两步可能被指令重排序优化，变成先赋值、再调用构造</li><li>如果线程1 先执行了赋值，线程2 执行到第一个 <code>INSTANCE == null</code> 时发现 INSTANCE 已经不为 null，此时就会返回一个未完全构造的对象</li></ul><p><strong>内部类懒汉式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton5</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton5</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;private Singleton5()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Holder</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="type">Singleton5</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton5</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton5 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Holder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">otherMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;otherMethod()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>避免了双检锁的缺点</li></ul><p><strong>JDK 中单例的体现</strong></p><ul><li>Runtime 体现了饿汉式单例</li><li>Console 体现了双检锁懒汉式单例</li><li>Collections 中的 EmptyNavigableSet 内部类懒汉式单例</li><li>ReverseComparator.REVERSE_ORDER 内部类懒汉式单例</li><li>Comparators.NaturalOrderComparator.INSTANCE 枚举饿汉式单例</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java核心系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java核心 </tag>
            
            <tag> Java基础 </tag>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java核心编程-JVM</title>
      <link href="/2025/02/18/Java%E5%9B%9E%E9%A1%BE%E7%AF%87/Java%E5%9B%9E%E9%A1%BE-JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
      <url>/2025/02/18/Java%E5%9B%9E%E9%A1%BE%E7%AF%87/Java%E5%9B%9E%E9%A1%BE-JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="虚拟机篇"><a href="#虚拟机篇" class="headerlink" title="虚拟机篇"></a>虚拟机篇</h1><h2 id="1-JVM-内存结构"><a href="#1-JVM-内存结构" class="headerlink" title="1. JVM 内存结构"></a>1. JVM 内存结构</h2><p><strong>要求</strong></p><ul><li>掌握 JVM 内存结构划分</li><li>尤其要知道方法区、永久代、元空间的关系</li></ul><p><strong>结合一段 java 代码的执行理解内存划分</strong></p><ul><li>执行 javac 命令编译源代码为字节码</li><li>执行 java 命令<ol><li>创建 JVM，调用类加载子系统加载 class，将类的信息存入<strong>方法区</strong></li><li>创建 main 线程，使用的内存区域是 <strong>JVM 虚拟机栈</strong>，开始执行 main 方法代码</li><li>如果遇到了未见过的类，会继续触发类加载过程，同样会存入<strong>方法区</strong></li><li>需要创建对象，会使用<strong>堆</strong>内存来存储对象</li><li>不再使用的对象，会由<strong>垃圾回收器</strong>在内存不足时回收其内存</li><li>调用方法时，方法内的局部变量、方法参数所使用的是  <strong>JVM 虚拟机栈</strong>中的栈帧内存</li><li>调用方法时，先要到<strong>方法区</strong>获得到该方法的字节码指令，由<strong>解释器</strong>将字节码指令解释为机器码执行</li><li>调用方法时，会将要执行的指令行号读到<strong>程序计数器</strong>，这样当发生了线程切换，恢复时就可以从中断的位置继续</li><li>对于非 java 实现的方法调用，使用内存称为<strong>本地方法栈</strong>（见说明）</li><li>对于热点方法调用，或者频繁的循环代码，由 <strong>JIT 即时编译器</strong>将这些代码编译成机器码缓存，提高执行性能</li></ol></li></ul><p>说明</p><ul><li>加粗字体代表了 JVM 虚拟机组件</li><li>对于 Oracle 的 Hotspot 虚拟机实现，不区分虚拟机栈和本地方法栈</li></ul><p><strong>会发生内存溢出的区域</strong></p><ul><li>不会出现内存溢出的区域 – 程序计数器</li><li>出现 OutOfMemoryError 的情况<ul><li>堆内存耗尽 – 对象越来越多，又一直在使用，不能被垃圾回收</li><li>方法区内存耗尽 – 加载的类越来越多，很多框架都会在运行期间动态产生新的类</li><li>虚拟机栈累积 – 每个线程最多会占用 1 M 内存，线程个数越来越多，而又长时间运行不销毁时</li></ul></li><li>出现 StackOverflowError 的区域<ul><li>JVM 虚拟机栈，原因有方法递归调用未正确结束、反序列化 json 时循环引用</li></ul></li></ul><p><strong>方法区、永久代、元空间</strong></p><ul><li><strong>方法区</strong>是 JVM 规范中定义的一块内存区域，用来存储类元数据、方法字节码、即时编译器需要的信息等</li><li><strong>永久代</strong>是 Hotspot 虚拟机对 JVM 规范的实现（1.8 之前）</li><li><strong>元空间</strong>是 Hotspot 虚拟机对 JVM 规范的另一种实现（1.8 以后），使用本地内存作为这些信息的存储空间</li></ul><p>从这张图学到三点</p><ul><li>当第一次用到某个类是，由类加载器将 class 文件的类元信息读入，并存储于元空间</li><li>X，Y 的类元信息是存储于元空间中，无法直接访问</li><li>可以用 X.class，Y.class 间接访问类元信息，它们俩属于 java 对象，我们的代码中可以使用</li></ul><p>从这张图可以学到</p><ul><li>堆内存中：当一个<strong>类加载器对象</strong>，这个类加载器对象加载的所有<strong>类对象</strong>，这些类对象对应的所有<strong>实例对象</strong>都没人引用时，GC 时就会对它们占用的对内存进行释放</li><li>元空间中：内存释放<strong>以类加载器为单位</strong>，当堆中类加载器内存释放时，对应的元空间中的类元信息也会释放</li></ul><h2 id="2-JVM-内存参数"><a href="#2-JVM-内存参数" class="headerlink" title="2. JVM 内存参数"></a>2. JVM 内存参数</h2><p><strong>要求</strong> </p><ul><li>熟悉常见的 JVM 参数，尤其和大小相关的</li></ul><p><strong>堆内存，按大小设置</strong></p><p>解释：</p><ul><li>-Xms 最小堆内存（包括新生代和老年代）</li><li>-Xmx 最大对内存（包括新生代和老年代）</li><li>通常建议将 -Xms 与 -Xmx 设置为大小相等，即不需要保留内存，不需要从小到大增长，这样性能较好</li><li>-XX:NewSize 与 -XX:MaxNewSize 设置新生代的最小与最大值，但一般不建议设置，由 JVM 自己控制</li><li>-Xmn 设置新生代大小，相当于同时设置了 -XX:NewSize 与 -XX:MaxNewSize 并且取值相等</li><li>保留是指，一开始不会占用那么多内存，随着使用内存越来越多，会逐步使用这部分保留内存。下同</li></ul><p><strong>堆内存，按比例设置</strong></p><p>解释：</p><ul><li>-XX:NewRatio&#x3D;2:1 表示老年代占两份，新生代占一份</li><li>-XX:SurvivorRatio&#x3D;4:1 表示新生代分成六份，伊甸园占四份，from 和 to 各占一份</li></ul><p><strong>元空间内存设置</strong></p><p>解释：</p><ul><li>class space 存储类的基本信息，最大值受 -XX:CompressedClassSpaceSize 控制</li><li>non-class space 存储除类的基本信息以外的其它信息（如方法字节码、注解等）</li><li>class space 和 non-class space 总大小受 -XX:MaxMetaspaceSize 控制</li></ul><p>注意：</p><ul><li>这里 -XX:CompressedClassSpaceSize 这段空间还与是否开启了指针压缩有关，这里暂不深入展开，可以简单认为指针压缩默认开启</li></ul><p><strong>代码缓存内存设置</strong></p><p>解释：</p><ul><li>如果 -XX:ReservedCodeCacheSize &lt; 240m，所有优化机器代码不加区分存在一起</li><li>否则，分成三个区域（图中笔误 mthod 拼写错误，少一个 e）<ul><li>non-nmethods - JVM 自己用的代码</li><li>profiled nmethods - 部分优化的机器码</li><li>non-profiled nmethods - 完全优化的机器码</li></ul></li></ul><p><strong>线程内存设置</strong></p><blockquote><p><em><strong>官方参考文档</strong></em></p><ul><li><a href="https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE">https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE</a></li></ul></blockquote><h2 id="3-JVM-垃圾回收"><a href="#3-JVM-垃圾回收" class="headerlink" title="3. JVM 垃圾回收"></a>3. JVM 垃圾回收</h2><p><strong>要求</strong></p><ul><li>掌握垃圾回收算法</li><li>掌握分代回收思想</li><li>理解三色标记及漏标处理</li><li>了解常见垃圾回收器</li></ul><p><strong>三种垃圾回收算法</strong></p><p><strong>标记清除法</strong></p><p>解释：</p><ol><li>找到 GC Root 对象，即那些一定不会被回收的对象，如正执行方法内局部变量引用的对象、静态变量引用的对象</li><li>标记阶段：沿着 GC Root 对象的引用链找，直接或间接引用到的对象加上标记</li><li>清除阶段：释放未加标记的对象占用的内存</li></ol><p>要点：</p><ul><li>标记速度与存活对象线性关系</li><li>清除速度与内存大小线性关系</li><li>缺点是会产生内存碎片</li></ul><p>标记整理法</p><p>解释：</p><ol><li>前面的标记阶段、清理阶段与标记清除法类似</li><li>多了一步整理的动作，将存活对象向一端移动，可以避免内存碎片产生</li></ol><p>特点：</p><ul><li><p>标记速度与存活对象线性关系</p></li><li><p>清除与整理速度与内存大小成线性关系</p></li><li><p>缺点是性能上较慢</p></li></ul><p><strong>标记复制法</strong></p><p>解释：</p><ol><li>将整个内存分成两个大小相等的区域，from 和 to，其中 to 总是处于空闲，from 存储新创建的对象</li><li>标记阶段与前面的算法类似</li><li>在找出存活对象后，会将它们从 from 复制到 to 区域，复制的过程中自然完成了碎片整理</li><li>复制完成后，交换 from 和 to 的位置即可</li></ol><p>特点：</p><ul><li>标记与复制速度与存活对象成线性关系</li><li>缺点是会占用成倍的空间</li></ul><p><strong>GC 与分代回收算法</strong></p><p>GC 的目的在于实现无用对象内存自动释放，减少内存碎片、加快分配速度</p><p>GC 要点：</p><ul><li>回收区域是<strong>堆内存</strong>，不包括虚拟机栈</li><li>判断无用对象，使用<strong>可达性分析算法</strong>，<strong>三色标记法</strong>标记存活对象，回收未标记对象</li><li>GC 具体的实现称为<strong>垃圾回收器</strong></li><li>GC 大都采用了<strong>分代回收思想</strong><ul><li>理论依据是大部分对象朝生夕灭，用完立刻就可以回收，另有少部分对象会长时间存活，每次很难回收</li><li>根据这两类对象的特性将回收区域分为<strong>新生代</strong>和<strong>老年代</strong>，新生代采用标记复制法、老年代一般采用标记整理法</li></ul></li><li>根据 GC 的规模可以分成 <strong>Minor GC</strong>，<strong>Mixed GC</strong>，<strong>Full GC</strong></li></ul><p><strong>分代回收</strong></p><ol><li><p>伊甸园 eden，最初对象都分配到这里，与幸存区 survivor（分成 from 和 to）合称新生代，</p></li><li><p>当伊甸园内存不足，标记伊甸园与 from（现阶段没有）的存活对象</p></li><li><p>将存活对象采用复制算法复制到 to 中，复制完毕后，伊甸园和 from 内存都得到释放</p></li><li><p>将 from 和 to 交换位置</p></li><li><p>经过一段时间后伊甸园的内存又出现不足</p></li><li><p>标记伊甸园与 from（现阶段没有）的存活对象</p></li><li><p>将存活对象采用复制算法复制到 to 中</p></li><li><p>复制完毕后，伊甸园和 from 内存都得到释放</p></li><li><p>将 from 和 to 交换位置</p></li><li><p>老年代 old，当幸存区对象熬过几次回收（最多15次），晋升到老年代（幸存区内存不足或大对象会导致提前晋升）</p></li></ol><p><strong>GC 规模</strong></p><ul><li><p>Minor GC 发生在新生代的垃圾回收，暂停时间短</p></li><li><p>Mixed GC 新生代 + 老年代部分区域的垃圾回收，G1 收集器特有</p></li><li><p>Full GC 新生代 + 老年代完整垃圾回收，暂停时间长，<strong>应尽力避免</strong></p></li></ul><p><strong>三色标记</strong></p><p>即用三种颜色记录对象的标记状态</p><ul><li>黑色 – 已标记</li><li>灰色 – 标记中</li><li>白色 – 还未标记</li></ul><ol><li><p>起始的三个对象还未处理完成，用灰色表示</p></li><li><p>该对象的引用已经处理完成，用黑色表示，黑色引用的对象变为灰色</p></li><li><p>依次类推</p></li><li><p>沿着引用链都标记了一遍</p></li><li><p>最后为标记的白色对象，即为垃圾</p></li></ol><p><strong>并发漏标问题</strong></p><p>比较先进的垃圾回收器都支持<strong>并发标记</strong>，即在标记过程中，用户线程仍然能工作。但这样带来一个新的问题，如果用户线程修改了对象引用，那么就存在漏标问题。例如：</p><ol><li><p>如图所示标记工作尚未完成</p></li><li><p>用户线程同时在工作，断开了第一层 3、4 两个对象之间的引用，这时对于正在处理 3 号对象的垃圾回收线程来讲，它会将 4 号对象当做是白色垃圾</p></li><li><p>但如果其他用户线程又建立了 2、4 两个对象的引用，这时因为 2 号对象是黑色已处理对象了，因此垃圾回收线程不会察觉到这个引用关系的变化，从而产生了漏标</p></li><li><p>如果用户线程让黑色对象引用了一个新增对象，一样会存在漏标问题</p></li></ol><p>因此对于<strong>并发标记</strong>而言，必须解决漏标问题，也就是要记录标记过程中的变化。有两种解决方法：</p><ol><li>Incremental Update 增量更新法，CMS 垃圾回收器采用<ul><li>思路是拦截每次赋值动作，只要赋值发生，被赋值的对象就会被记录下来，在重新标记阶段再确认一遍</li></ul></li><li>Snapshot At The Beginning，SATB 原始快照法，G1 垃圾回收器采用<ul><li>思路也是拦截每次赋值动作，不过记录的对象不同，也需要在重新标记阶段对这些对象二次处理</li><li>新加对象会被记录</li><li>被删除引用关系的对象也被记录</li></ul></li></ol><p><strong>垃圾回收器 - Parallel GC</strong></p><ul><li><p>eden 内存不足发生 Minor GC，采用标记复制算法，需要暂停用户线程</p></li><li><p>old 内存不足发生 Full GC，采用标记整理算法，需要暂停用户线程</p></li><li><p><strong>注重吞吐量</strong></p></li></ul><p><strong>垃圾回收器 - ConcurrentMarkSweep GC</strong></p><ul><li><p>它是工作在 old 老年代，支持<strong>并发标记</strong>的一款回收器，采用<strong>并发清除</strong>算法</p><ul><li>并发标记时不需暂停用户线程</li><li>重新标记时仍需暂停用户线程</li></ul></li><li><p>如果并发失败（即回收速度赶不上创建新对象速度），会触发 Full GC</p></li><li><p><strong>注重响应时间</strong></p></li></ul><p><strong>垃圾回收器 - G1 GC</strong></p><ul><li><strong>响应时间与吞吐量兼顾</strong></li><li>划分成多个区域，每个区域都可以充当 eden，survivor，old， humongous，其中 humongous 专为大对象准备</li><li>分成三个阶段：新生代回收、并发标记、混合收集</li><li>如果并发失败（即回收速度赶不上创建新对象速度），会触发 Full GC</li></ul><p><strong>G1 回收阶段 - 新生代回收</strong></p><ol><li><p>初始时，所有区域都处于空闲状态</p></li><li><p>创建了一些对象，挑出一些空闲区域作为伊甸园区存储这些对象</p></li><li><p>当伊甸园需要垃圾回收时，挑出一个空闲区域作为幸存区，用复制算法复制存活对象，需要暂停用户线程</p></li><li><p>复制完成，将之前的伊甸园内存释放</p></li><li><p>随着时间流逝，伊甸园的内存又有不足</p></li><li><p>将伊甸园以及之前幸存区中的存活对象，采用复制算法，复制到新的幸存区，其中较老对象晋升至老年代</p></li><li><p>释放伊甸园以及之前幸存区的内存</p></li></ol><p><strong>G1 回收阶段 - 并发标记与混合收集</strong></p><ol><li><p>当老年代占用内存超过阈值后，触发并发标记，这时无需暂停用户线程</p></li><li><p>并发标记之后，会有重新标记阶段解决漏标问题，此时需要暂停用户线程。这些都完成后就知道了老年代有哪些存活对象，随后进入混合收集阶段。此时不会对所有老年代区域进行回收，而是根据<strong>暂停时间目标</strong>优先回收价值高（存活对象少）的区域（这也是 Gabage First 名称的由来）。</p></li><li><p>混合收集阶段中，参与复制的有 eden、survivor、old，下图显示了伊甸园和幸存区的存活对象复制</p></li><li><p>下图显示了老年代和幸存区晋升的存活对象的复制</p></li><li><p>复制完成，内存得到释放。进入下一轮的新生代回收、并发标记、混合收集</p></li></ol><h2 id="4-内存溢出"><a href="#4-内存溢出" class="headerlink" title="4. 内存溢出"></a>4. 内存溢出</h2><p><strong>要求</strong></p><ul><li>能够说出几种典型的导致内存溢出的情况</li></ul><p><strong>典型情况</strong></p><ul><li>误用线程池导致的内存溢出<ul><li>参考 day03.TestOomThreadPool</li></ul></li><li>查询数据量太大导致的内存溢出<ul><li>参考 day03.TestOomTooManyObject</li></ul></li><li>动态生成类导致的内存溢出<ul><li>参考 day03.TestOomTooManyClass</li></ul></li></ul><h2 id="5-类加载"><a href="#5-类加载" class="headerlink" title="5. 类加载"></a>5. 类加载</h2><p><strong>要求</strong></p><ul><li>掌握类加载阶段</li><li>掌握类加载器</li><li>理解双亲委派机制</li></ul><p><strong>类加载过程的三个阶段</strong></p><ol><li><p>加载</p><ol><li><p>将类的字节码载入方法区，并创建类.class 对象</p></li><li><p>如果此类的父类没有加载，先加载父类</p></li><li><p>加载是懒惰执行</p></li></ol></li><li><p>链接</p><ol><li>验证 – 验证类是否符合 Class 规范，合法性、安全性检查</li><li>准备 – 为 static 变量分配空间，设置默认值</li><li>解析 – 将常量池的符号引用解析为直接引用</li></ol></li><li><p>初始化</p><ol><li>静态代码块、static 修饰的变量赋值、static final 修饰的引用类型变量赋值，会被合并成一个 <code>&lt;cinit&gt;</code> 方法，在初始化时被调用</li><li>static final 修饰的基本类型变量赋值，在链接阶段就已完成</li><li>初始化是懒惰执行</li></ol></li></ol><blockquote><p><em><strong>验证手段</strong></em></p><ul><li>使用 jps 查看进程号</li><li>使用 jhsdb 调试，执行命令 <code>jhsdb.exe hsdb</code> 打开它的图形界面<ul><li>Class Browser 可以查看当前 jvm 中加载了哪些类</li><li>控制台的 universe 命令查看堆内存范围</li><li>控制台的 g1regiondetails 命令查看 region 详情</li><li><code>scanoops 起始地址 结束地址 对象类型</code> 可以根据类型查找某个区间内的对象地址</li><li>控制台的 <code>inspect 地址</code> 指令能够查看这个地址对应的对象详情</li></ul></li><li>使用 javap 命令可以查看 class 字节码</li></ul></blockquote><blockquote><p><em><strong>代码说明</strong></em></p><ul><li>day03.loader.TestLazy - 验证类的加载是懒惰的，用到时才触发类加载</li><li>day03.loader.TestFinal - 验证使用 final 修饰的变量不会触发类加载</li></ul></blockquote><p><strong>jdk 8 的类加载器</strong></p><table><thead><tr><th><strong>名称</strong></th><th><strong>加载哪的类</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>Bootstrap ClassLoader</td><td>JAVA_HOME&#x2F;jre&#x2F;lib</td><td>无法直接访问</td></tr><tr><td>Extension ClassLoader</td><td>JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext</td><td>上级为 Bootstrap，显示为  null</td></tr><tr><td>Application ClassLoader</td><td>classpath</td><td>上级为 Extension</td></tr><tr><td>自定义类加载器</td><td>自定义</td><td>上级为 Application</td></tr></tbody></table><p><strong>双亲委派机制</strong></p><p>所谓的双亲委派，就是指优先委派上级类加载器进行加载，如果上级类加载器</p><ul><li>能找到这个类，由上级加载，加载后该类也对下级加载器可见</li><li>找不到这个类，则下级类加载器才有资格执行加载</li></ul><p>双亲委派的目的有两点</p><ol><li><p>让上级类加载器中的类对下级共享（反之不行），即能让你的类能依赖到 jdk 提供的核心类</p></li><li><p>让类的加载有优先次序，保证核心类优先加载</p></li></ol><p><strong>对双亲委派的误解</strong></p><p>下面面试题的回答是错误的</p><p>错在哪了？</p><ul><li><p>自己编写类加载器就能加载一个假冒的 java.lang.System 吗? 答案是不行。</p></li><li><p>假设你自己的类加载器用双亲委派，那么优先由启动类加载器加载真正的 java.lang.System，自然不会加载假冒的</p></li><li><p>假设你自己的类加载器不用双亲委派，那么你的类加载器加载假冒的 java.lang.System 时，它需要先加载父类 java.lang.Object，而你没有用委派，找不到 java.lang.Object 所以加载会失败</p></li><li><p><strong>以上也仅仅是假设</strong>。事实上操作你就会发现，自定义类加载器加载以 java. 打头的类时，会抛安全异常，在 jdk9 以上版本这些特殊包名都与模块进行了绑定，更连编译都过不了</p></li></ul><blockquote><p><em><strong>代码说明</strong></em></p><ul><li>day03.loader.TestJdk9ClassLoader - 演示类加载器与模块的绑定关系</li></ul></blockquote><h2 id="6-四种引用"><a href="#6-四种引用" class="headerlink" title="6. 四种引用"></a>6. 四种引用</h2><p><strong>要求</strong></p><ul><li>掌握四种引用</li></ul><p><strong>强引用</strong></p><ol><li><p>普通变量赋值即为强引用，如 A a &#x3D; new A();</p></li><li><p>通过 GC Root 的引用链，如果强引用不到该对象，该对象才能被回收</p></li></ol><p><strong>软引用（SoftReference）</strong></p><ol><li><p>例如：SoftReference a &#x3D; new SoftReference(new A());</p></li><li><p>如果仅有软引用该对象时，首次垃圾回收不会回收该对象，如果内存仍不足，再次回收时才会释放对象</p></li><li><p>软引用自身需要配合引用队列来释放</p></li><li><p>典型例子是反射数据</p></li></ol><p><strong>弱引用（WeakReference）</strong></p><ol><li><p>例如：WeakReference a &#x3D; new WeakReference(new A());</p></li><li><p>如果仅有弱引用引用该对象时，只要发生垃圾回收，就会释放该对象</p></li><li><p>弱引用自身需要配合引用队列来释放</p></li><li><p>典型例子是 ThreadLocalMap 中的 Entry 对象</p></li></ol><p><strong>虚引用（PhantomReference）</strong></p><ol><li><p>例如： PhantomReference a &#x3D; new PhantomReference(new A(), referenceQueue);</p></li><li><p>必须配合引用队列一起使用，当虚引用所引用的对象被回收时，由 Reference Handler 线程将虚引用对象入队，这样就可以知道哪些对象被回收，从而对它们关联的资源做进一步处理</p></li><li><p>典型例子是 Cleaner 释放 DirectByteBuffer 关联的直接内存</p></li></ol><blockquote><p><em><strong>代码说明</strong></em></p><ul><li>day03.reference.TestPhantomReference - 演示虚引用的基本用法</li><li>day03.reference.TestWeakReference - 模拟 ThreadLocalMap, 采用引用队列释放 entry 内存</li></ul></blockquote><h2 id="7-finalize"><a href="#7-finalize" class="headerlink" title="7. finalize"></a>7. finalize</h2><p><strong>要求</strong></p><ul><li>掌握 finalize 的工作原理与缺点</li></ul><p><strong>finalize</strong></p><ul><li>它是 Object 中的一个方法，如果子类重写它，垃圾回收时此方法会被调用，可以在其中进行资源释放和清理工作</li><li>将资源释放和清理放在 finalize 方法中非常不好，非常影响性能，严重时甚至会引起 OOM，从 Java9 开始就被标注为 @Deprecated，不建议被使用了</li></ul><p><strong>finalize 原理</strong></p><ol><li><p>对 finalize 方法进行处理的核心逻辑位于 java.lang.ref.Finalizer 类中，它包含了名为 unfinalized 的静态变量（双向链表结构），Finalizer 也可被视为另一种引用对象（地位与软、弱、虚相当，只是不对外，无法直接使用）</p></li><li><p>当重写了 finalize 方法的对象，在构造方法调用之时，JVM 都会将其包装成一个 Finalizer 对象，并加入 unfinalized 链表中</p></li><li><p>Finalizer 类中还有另一个重要的静态变量，即 ReferenceQueue 引用队列，刚开始它是空的。当狗对象可以被当作垃圾回收时，就会把这些狗对象对应的 Finalizer 对象加入此引用队列</p></li><li><p>但此时 Dog 对象还没法被立刻回收，因为 unfinalized -&gt; Finalizer 这一引用链还在引用它嘛，为的是【先别着急回收啊，等我调完 finalize 方法，再回收】</p></li><li><p>FinalizerThread 线程会从 ReferenceQueue 中逐一取出每个 Finalizer 对象，把它们从链表断开并真正调用 finallize 方法</p></li><li><p>由于整个 Finalizer 对象已经从 unfinalized 链表中断开，这样没谁能引用到它和狗对象，所以下次 gc 时就被回收了</p></li></ol><p><strong>finalize 缺点</strong></p><ul><li>无法保证资源释放：FinalizerThread 是守护线程，代码很有可能没来得及执行完，线程就结束了</li><li>无法判断是否发生错误：执行 finalize 方法时，会吞掉任意异常（Throwable）</li><li>内存释放不及时：重写了 finalize 方法的对象在第一次被 gc 时，并不能及时释放它占用的内存，因为要等着 FinalizerThread 调用完 finalize，把它从 unfinalized 队列移除后，第二次 gc 时才能真正释放内存</li><li>有的文章提到【Finalizer 线程会和我们的主线程进行竞争，不过由于它的优先级较低，获取到的CPU时间较少，因此它永远也赶不上主线程的步伐】这个显然是错误的，FinalizerThread 的优先级较普通线程更高，原因应该是 finalize 串行执行慢等原因综合导致</li></ul><blockquote><p><em><strong>代码说明</strong></em></p><ul><li>day03.reference.TestFinalize - finalize 的测试代码</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java核心系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java核心 </tag>
            
            <tag> JVM虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java9新特性概览</title>
      <link href="/2025/02/18/Java%E5%9B%9E%E9%A1%BE%E7%AF%87/java9%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2025/02/18/Java%E5%9B%9E%E9%A1%BE%E7%AF%87/java9%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p><strong>Java 9</strong> 发布于 2017 年 9 月 21 日 。作为 Java 8 之后 3 年半才发布的新版本，Java 9 带来了很多重大的变化其中最重要的改动是 Java 平台模块系统的引入，其他还有诸如集合、<code>Stream</code> 流……。</p><p>你可以在 <a href="http://jdk.java.net/archive/">Archived OpenJDK General-Availability Releases</a> 上下载自己需要的 JDK 版本！官方的新特性说明文档地址：<a href="https://openjdk.java.net/projects/jdk/">https://openjdk.java.net/projects/jdk/</a> 。</p><p><strong>概览（精选了一部分）</strong>：</p><ul><li><a href="https://openjdk.java.net/jeps/222">JEP 222: Java 命令行工具</a></li><li><a href="https://openjdk.java.net/jeps/261">JEP 261: 模块化系统</a></li><li><a href="https://openjdk.java.net/jeps/248">JEP 248：G1 成为默认垃圾回收器</a></li><li><a href="https://openjdk.java.net/jeps/193">JEP 193: 变量句柄</a></li><li><a href="https://openjdk.java.net/jeps/254">JEP 254：字符串存储结构优化</a></li></ul><h2 id="JShell"><a href="#JShell" class="headerlink" title="JShell"></a>JShell</h2><p>JShell 是 Java 9 新增的一个实用工具。为 Java 提供了类似于 Python 的实时命令行交互工具。</p><p>在 JShell 中可以直接输入表达式并查看其执行结果。</p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAOoaUYcXrmBFRSTtWCc7jy3DsIz9MQAAm8LaxvRfjBWHNqAFiheQmYBAAMCAAN4AAM2BA.png"></p><p><strong>JShell 为我们带来了哪些好处呢？</strong></p><ol><li>降低了输出第一行 Java 版”Hello World！”的门槛，能够提高新手的学习热情。</li><li>在处理简单的小逻辑，验证简单的小问题时，比 IDE 更有效率（并不是为了取代 IDE，对于复杂逻辑的验证，IDE 更合适，两者互补）。</li><li>……</li></ol><p><strong>JShell 的代码和普通的可编译代码，有什么不一样？</strong></p><ol><li>一旦语句输入完成，JShell 立即就能返回执行的结果，而不再需要编辑器、编译器、解释器。</li><li>JShell 支持变量的重复声明，后面声明的会覆盖前面声明的。</li><li>JShell 支持独立的表达式比如普通的加法运算 <code>1 + 1</code>。</li><li>……</li></ol><h2 id="模块化系统"><a href="#模块化系统" class="headerlink" title="模块化系统"></a>模块化系统</h2><p>模块系统是<a href="https://openjdk.java.net/projects/jigsaw/">Jigsaw Project</a>的一部分，把模块化开发实践引入到了 Java 平台中，可以让我们的代码可重用性更好！</p><p><strong>什么是模块系统？</strong> 官方的定义是：</p><blockquote><p>A uniquely named, reusable group of related packages, as well as resources (such as images and XML files) and a module descriptor。</p></blockquote><p>简单来说，你可以将一个模块看作是一组唯一命名、可重用的包、资源和模块描述文件（<code>module-info.java</code>）。</p><p>任意一个 jar 文件，只要加上一个模块描述文件（<code>module-info.java</code>），就可以升级为一个模块。</p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAOnaUYcUuk-JQardrEnYCRXUh2SDDAAAm4LaxvRfjBW680bqHKORDwBAAMCAAN4AAM2BA.png"></p><p>在引入了模块系统之后，JDK 被重新组织成 94 个模块。Java 应用可以通过新增的 <strong><a href="http://openjdk.java.net/jeps/282">jlink</a> 工具</strong> (Jlink 是随 Java 9 一起发布的新命令行工具。它允许开发人员为基于模块的 Java 应用程序创建自己的轻量级、定制的 JRE)，创建出只包含所依赖的 JDK 模块的自定义运行时镜像。这样可以极大的减少 Java 运行时环境的大小。</p><p>我们可以通过 <code>exports</code> 关键词精准控制哪些类可以对外开放使用，哪些类只能内部使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> my.<span class="keyword">module</span> &#123;</span><br><span class="line">    <span class="comment">//exports 公开指定包的所有公共成员</span></span><br><span class="line">    <span class="keyword">exports</span> com.my.<span class="keyword">package</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> my.<span class="keyword">module</span> &#123;</span><br><span class="line">     <span class="comment">//exports…to 限制访问的成员范围</span></span><br><span class="line">    export com.my.<span class="keyword">package</span>.name to com.specific.<span class="keyword">package</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想要深入了解 Java 9 的模块化，可以参考下面这几篇文章：</p><ul><li><a href="https://openjdk.java.net/projects/jigsaw/quick-start">《Project Jigsaw: Module System Quick-Start Guide》</a></li><li><a href="https://stacktraceguru.com/java9/module-introduction">《Java 9 Modules: part 1》</a></li><li><a href="http://www.cnblogs.com/IcanFixIt/p/6947763.html">Java 9 揭秘（2. 模块化系统）</a></li></ul><h2 id="G1-成为默认垃圾回收器"><a href="#G1-成为默认垃圾回收器" class="headerlink" title="G1 成为默认垃圾回收器"></a>G1 成为默认垃圾回收器</h2><p>在 Java 8 的时候，默认垃圾回收器是 Parallel Scavenge（新生代）+Parallel Old（老年代）。到了 Java 9, CMS 垃圾回收器被废弃了，<strong>G1（Garbage-First Garbage Collector）</strong> 成为了默认垃圾回收器。</p><p>G1 还是在 Java 7 中被引入的，经过两个版本优异的表现成为成为默认垃圾回收器。</p><h2 id="快速创建不可变集合"><a href="#快速创建不可变集合" class="headerlink" title="快速创建不可变集合"></a>快速创建不可变集合</h2><p>增加了<code>List.of()</code>、<code>Set.of()</code>、<code>Map.of()</code> 和 <code>Map.ofEntries()</code>等工厂方法来创建不可变集合（有点参考 Guava 的味道）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List.of(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;C++&quot;</span>);</span><br><span class="line">Set.of(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;C++&quot;</span>);</span><br><span class="line">Map.of(<span class="string">&quot;Java&quot;</span>, <span class="number">1</span>, <span class="string">&quot;C++&quot;</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>使用 <code>of()</code> 创建的集合为不可变集合，不能进行添加、删除、替换、 排序等操作，不然会报 <code>java.lang.UnsupportedOperationException</code> 异常。</p><h2 id="String-存储结构优化"><a href="#String-存储结构优化" class="headerlink" title="String 存储结构优化"></a>String 存储结构优化</h2><p>Java 8 及之前的版本，<code>String</code> 一直是用 <code>char[]</code> 存储。在 Java 9 之后，<code>String</code> 的实现改用 <code>byte[]</code> 数组存储字符串，节省了空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable,Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">// @Stable 注解表示变量最多被修改一次，称为“稳定的”。</span></span><br><span class="line">    <span class="meta">@Stable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span>[] value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口私有方法"><a href="#接口私有方法" class="headerlink" title="接口私有方法"></a>接口私有方法</h2><p>Java 9 允许在接口中使用私有方法。这样的话，接口的使用就更加灵活了，有点像是一个简化版的抽象类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">methodPrivate</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="try-with-resources-增强"><a href="#try-with-resources-增强" class="headerlink" title="try-with-resources 增强"></a>try-with-resources 增强</h2><p>在 Java 9 之前，我们只能在 <code>try-with-resources</code> 块中声明变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;testRead.txt&quot;</span>));</span><br><span class="line">    <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;testWrite.txt&quot;</span>))) &#123;</span><br><span class="line">    <span class="comment">// omitted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Java 9 之后，在 <code>try-with-resources</code> 语句中可以使用 effectively-final 变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;testRead.txt&quot;</span>));</span><br><span class="line"><span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;testWrite.txt&quot;</span>))</span><br><span class="line"><span class="keyword">try</span> (scanner;writer) &#123;</span><br><span class="line">    <span class="comment">// omitted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>什么是 effectively-final 变量？</strong> 简单来说就是没有被 <code>final</code> 修饰但是值在初始化后从未更改的变量。</p><p>正如上面的代码所演示的那样，即使 <code>writer</code> 变量没有被显示声明为 <code>final</code>，但它在第一次被赋值后就不会改变了，因此，它就是 effectively-final 变量。</p><h2 id="Stream-Optional-增强"><a href="#Stream-Optional-增强" class="headerlink" title="Stream &amp; Optional 增强"></a>Stream &amp; Optional 增强</h2><p><code>Stream</code> 中增加了新的方法 <code>ofNullable()</code>、<code>dropWhile()</code>、<code>takeWhile()</code> 以及 <code>iterate()</code> 方法的重载方法。</p><p>Java 9 中的 <code>ofNullable()</code> 方 法允许我们创建一个单元素的 <code>Stream</code>，可以包含一个非空元素，也可以创建一个空 <code>Stream</code>。 而在 Java 8 中则不可以创建空的 <code>Stream</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stringStream = Stream.ofNullable(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">System.out.println(stringStream.count());<span class="comment">// 1</span></span><br><span class="line">Stream&lt;String&gt; nullStream = Stream.ofNullable(<span class="literal">null</span>);</span><br><span class="line">System.out.println(nullStream.count());<span class="comment">//0</span></span><br></pre></td></tr></table></figure><p><code>takeWhile()</code> 方法可以从 <code>Stream</code> 中依次获取满足条件的元素，直到不满足条件为止结束获取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; integerList = List.of(<span class="number">11</span>, <span class="number">33</span>, <span class="number">66</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">13</span>);</span><br><span class="line">integerList.stream().takeWhile(x -&gt; x &lt; <span class="number">50</span>).forEach(System.out::println);<span class="comment">// 11 33</span></span><br></pre></td></tr></table></figure><p><code>dropWhile()</code> 方法的效果和 <code>takeWhile()</code> 相反。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; integerList2 = List.of(<span class="number">11</span>, <span class="number">33</span>, <span class="number">66</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">13</span>);</span><br><span class="line">integerList2.stream().dropWhile(x -&gt; x &lt; <span class="number">50</span>).forEach(System.out::println);<span class="comment">// 66 8 9 13</span></span><br></pre></td></tr></table></figure><p><code>iterate()</code> 方法的新重载方法提供了一个 <code>Predicate</code> 参数 (判断条件)来决定什么时候结束迭代</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title function_">iterate</span><span class="params">(<span class="keyword">final</span> T seed, <span class="keyword">final</span> UnaryOperator&lt;T&gt; f)</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 新增加的重载方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title function_">iterate</span><span class="params">(T seed, Predicate&lt;? <span class="built_in">super</span> T&gt; hasNext, UnaryOperator&lt;T&gt; next)</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两者的使用对比如下，新的 <code>iterate()</code> 重载方法更加灵活一些。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用原始 iterate() 方法输出数字 1~10</span></span><br><span class="line">Stream.iterate(<span class="number">1</span>, i -&gt; i + <span class="number">1</span>).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line"><span class="comment">// 使用新的 iterate() 重载方法输出数字 1~10</span></span><br><span class="line">Stream.iterate(<span class="number">1</span>, i -&gt; i &lt;= <span class="number">10</span>, i -&gt; i + <span class="number">1</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure><p><code>Optional</code> 类中新增了 <code>ifPresentOrElse()</code>、<code>or()</code> 和 <code>stream()</code> 等方法</p><p><code>ifPresentOrElse()</code> 方法接受两个参数 <code>Consumer</code> 和 <code>Runnable</code> ，如果 <code>Optional</code> 不为空调用 <code>Consumer</code> 参数，为空则调用 <code>Runnable</code> 参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ifPresentOrElse</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action, Runnable emptyAction)</span></span><br><span class="line"></span><br><span class="line">Optional&lt;Object&gt; objectOptional = Optional.empty();</span><br><span class="line">objectOptional.ifPresentOrElse(System.out::println, () -&gt; System.out.println(<span class="string">&quot;Empty!!!&quot;</span>));<span class="comment">// Empty!!!</span></span><br></pre></td></tr></table></figure><p><code>or()</code> 方法接受一个 <code>Supplier</code> 参数 ，如果 <code>Optional</code> 为空则返回 <code>Supplier</code> 参数指定的 <code>Optional</code> 值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Optional&lt;T&gt; <span class="title function_">or</span><span class="params">(Supplier&lt;? extends Optional&lt;? extends T&gt;&gt; supplier)</span></span><br><span class="line"></span><br><span class="line">Optional&lt;Object&gt; objectOptional = Optional.empty();</span><br><span class="line">objectOptional.or(() -&gt; Optional.of(<span class="string">&quot;java&quot;</span>)).ifPresent(System.out::println);<span class="comment">//java</span></span><br></pre></td></tr></table></figure><h2 id="进程-API"><a href="#进程-API" class="headerlink" title="进程 API"></a>进程 API</h2><p>Java 9 增加了 <code>java.lang.ProcessHandle</code> 接口来实现对原生进程进行管理，尤其适合于管理长时间运行的进程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前正在运行的 JVM 的进程</span></span><br><span class="line"><span class="type">ProcessHandle</span> <span class="variable">currentProcess</span> <span class="operator">=</span> ProcessHandle.current();</span><br><span class="line"><span class="comment">// 输出进程的 id</span></span><br><span class="line">System.out.println(currentProcess.pid());</span><br><span class="line"><span class="comment">// 输出进程的信息</span></span><br><span class="line">System.out.println(currentProcess.info());</span><br></pre></td></tr></table></figure><p><code>ProcessHandle</code> 接口概览：</p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAOmaUYcQmAWoaBT0t6_gOyVBc1JKYUAAm0LaxvRfjBWZE_j89YTyiUBAAMCAAN4AAM2BA.png"></p><h2 id="响应式流-（-Reactive-Streams-）"><a href="#响应式流-（-Reactive-Streams-）" class="headerlink" title="响应式流 （ Reactive Streams ）"></a>响应式流 （ Reactive Streams ）</h2><p>在 Java 9 中的 <code>java.util.concurrent.Flow</code> 类中新增了反应式流规范的核心接口 。</p><p><code>Flow</code> 中包含了 <code>Flow.Publisher</code>、<code>Flow.Subscriber</code>、<code>Flow.Subscription</code> 和 <code>Flow.Processor</code> 等 4 个核心接口。Java 9 还提供了<code>SubmissionPublisher</code> 作为<code>Flow.Publisher</code> 的一个实现。</p><p>关于 Java 9 响应式流更详细的解读，推荐你看 <a href="https://www.cnblogs.com/IcanFixIt/p/7245377.html">Java 9 揭秘（17. Reactive Streams ）- 林本托</a> 这篇文章。</p><h2 id="变量句柄"><a href="#变量句柄" class="headerlink" title="变量句柄"></a>变量句柄</h2><p>变量句柄是一个变量或一组变量的引用，包括静态域，非静态域，数组元素和堆外数据结构中的组成部分等。</p><p>变量句柄的含义类似于已有的方法句柄 <code>MethodHandle</code> ，由 Java 类 <code>java.lang.invoke.VarHandle</code> 来表示，可以使用类 <code>java.lang.invoke.MethodHandles.Lookup</code> 中的静态工厂方法来创建 <code>VarHandle</code> 对象。</p><p><code>VarHandle</code> 的出现替代了 <code>java.util.concurrent.atomic</code> 和 <code>sun.misc.Unsafe</code> 的部分操作。并且提供了一系列标准的内存屏障操作，用于更加细粒度的控制内存排序。在安全性、可用性、性能上都要优于现有的 API。</p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ul><li><strong>平台日志 API 改进</strong>：Java 9 允许为 JDK 和应用配置同样的日志实现。新增了 <code>System.LoggerFinder</code> 用来管理 JDK 使 用的日志记录器实现。JVM 在运行时只有一个系统范围的 <code>LoggerFinder</code> 实例。我们可以通过添加自己的 <code>System.LoggerFinder</code> 实现来让 JDK 和应用使用 SLF4J 等其他日志记录框架。</li><li><strong><code>CompletableFuture</code>类增强</strong>：新增了几个新的方法（<code>completeAsync</code> ，<code>orTimeout</code> 等）。</li><li><strong>Nashorn 引擎的增强</strong>：Nashorn 是从 Java8 开始引入的 JavaScript 引擎，Java9 对 Nashorn 做了些增强，实现了一些 ES6 的新特性（Java 11 中已经被弃用）。</li><li><strong>I&#x2F;O 流的新特性</strong>：增加了新的方法来读取和复制 <code>InputStream</code> 中包含的数据。</li><li><strong>改进应用的安全性能</strong>：Java 9 新增了 4 个 SHA- 3 哈希算法，SHA3-224、SHA3-256、SHA3-384 和 SHA3-512。</li><li><strong>改进方法句柄（Method Handle）</strong>：方法句柄从 Java7 开始引入，Java9 在类<code>java.lang.invoke.MethodHandles</code> 中新增了更多的静态方法来创建不同类型的方法句柄。</li><li>……</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>Java version history：<a href="https://en.wikipedia.org/wiki/Java_version_history">https://en.wikipedia.org/wiki/Java_version_history</a></li><li>Release Notes for JDK 9 and JDK 9 Update Releases : <a href="https://www.oracle.com/java/technologies/javase/9-all-relnotes.html">https://www.oracle.com/java/technologies/javase/9-all-relnotes.html</a></li><li>《深入剖析 Java 新特性》-极客时间 - JShell：怎么快速验证简单的小问题？</li><li>New Features in Java 9: <a href="https://www.baeldung.com/new-java-9">https://www.baeldung.com/new-java-9</a></li><li>Java – Try with Resources：<a href="https://www.baeldung.com/java-try-with-resources">https://www.baeldung.com/java-try-with-resources</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java核心系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java核心 </tag>
            
            <tag> Java版本新特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程</title>
      <link href="/2025/02/18/Java%E5%9B%9E%E9%A1%BE%E7%AF%87/Java%E5%9B%9E%E9%A1%BE-%E5%B9%B6%E5%8F%91%E7%AF%87/"/>
      <url>/2025/02/18/Java%E5%9B%9E%E9%A1%BE%E7%AF%87/Java%E5%9B%9E%E9%A1%BE-%E5%B9%B6%E5%8F%91%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="并发篇"><a href="#并发篇" class="headerlink" title="并发篇"></a>并发篇</h1><h2 id="1-线程状态"><a href="#1-线程状态" class="headerlink" title="1. 线程状态"></a>1. 线程状态</h2><p><strong>要求</strong></p><ul><li>掌握 Java 线程六种状态</li><li>掌握 Java 线程状态转换</li><li>能理解五种状态与六种状态两种说法的区别</li></ul><p><strong>六种状态及转换</strong></p><p>分别是</p><ul><li>新建<ul><li>当一个线程对象被创建，但还未调用 start 方法时处于<strong>新建</strong>状态</li><li>此时未与操作系统底层线程关联</li></ul></li><li>可运行<ul><li>调用了 start 方法，就会由<strong>新建</strong>进入<strong>可运行</strong></li><li>此时与底层线程关联，由操作系统调度执行</li></ul></li><li>终结<ul><li>线程内代码已经执行完毕，由<strong>可运行</strong>进入<strong>终结</strong></li><li>此时会取消与底层线程关联</li></ul></li><li>阻塞<ul><li>当获取锁失败后，由<strong>可运行</strong>进入 Monitor 的阻塞队列<strong>阻塞</strong>，此时不占用 cpu 时间</li><li>当持锁线程释放锁时，会按照一定规则唤醒阻塞队列中的<strong>阻塞</strong>线程，唤醒后的线程进入<strong>可运行</strong>状态</li></ul></li><li>等待<ul><li>当获取锁成功后，但由于条件不满足，调用了 wait() 方法，此时从<strong>可运行</strong>状态释放锁进入 Monitor 等待集合<strong>等待</strong>，同样不占用 cpu 时间</li><li>当其它持锁线程调用 notify() 或 notifyAll() 方法，会按照一定规则唤醒等待集合中的<strong>等待</strong>线程，恢复为<strong>可运行</strong>状态</li></ul></li><li>有时限等待<ul><li>当获取锁成功后，但由于条件不满足，调用了 wait(long) 方法，此时从<strong>可运行</strong>状态释放锁进入 Monitor 等待集合进行<strong>有时限等待</strong>，同样不占用 cpu 时间</li><li>当其它持锁线程调用 notify() 或 notifyAll() 方法，会按照一定规则唤醒等待集合中的<strong>有时限等待</strong>线程，恢复为<strong>可运行</strong>状态，并重新去竞争锁</li><li>如果等待超时，也会从<strong>有时限等待</strong>状态恢复为<strong>可运行</strong>状态，并重新去竞争锁</li><li>还有一种情况是调用 sleep(long) 方法也会从<strong>可运行</strong>状态进入<strong>有时限等待</strong>状态，但与 Monitor 无关，不需要主动唤醒，超时时间到自然恢复为<strong>可运行</strong>状态</li></ul></li></ul><blockquote><p><em><strong>其它情况（只需了解）</strong></em></p><ul><li>可以用 interrupt() 方法打断<strong>等待</strong>、<strong>有时限等待</strong>的线程，让它们恢复为<strong>可运行</strong>状态</li><li>park，unpark 等方法也可以让线程等待和唤醒</li></ul></blockquote><p><strong>五种状态</strong></p><p>五种状态的说法来自于操作系统层面的划分</p><ul><li>运行态：分到 cpu 时间，能真正执行线程内代码的</li><li>就绪态：有资格分到 cpu 时间，但还未轮到它的</li><li>阻塞态：没资格分到 cpu 时间的<ul><li>涵盖了 java 状态中提到的<strong>阻塞</strong>、<strong>等待</strong>、<strong>有时限等待</strong></li><li>多出了阻塞 I&#x2F;O，指线程在调用阻塞 I&#x2F;O 时，实际活由 I&#x2F;O 设备完成，此时线程无事可做，只能干等</li></ul></li><li>新建与终结态：与 java 中同名状态类似，不再啰嗦</li></ul><h2 id="2-线程池"><a href="#2-线程池" class="headerlink" title="2. 线程池"></a>2. 线程池</h2><p><strong>要求</strong></p><ul><li>掌握线程池的 7 大核心参数</li></ul><p><strong>七大参数</strong></p><ol><li>corePoolSize 核心线程数目 - 池中会保留的最多线程数</li><li>maximumPoolSize 最大线程数目 - 核心线程+救急线程的最大数目</li><li>keepAliveTime 生存时间 - 救急线程的生存时间，生存时间内没有新任务，此线程资源会释放</li><li>unit 时间单位 - 救急线程的生存时间单位，如秒、毫秒等</li><li>workQueue - 当没有空闲核心线程时，新来任务会加入到此队列排队，队列满会创建救急线程执行任务</li><li>threadFactory 线程工厂 - 可以定制线程对象的创建，例如设置线程名字、是否是守护线程等</li><li>handler 拒绝策略 - 当所有线程都在繁忙，workQueue 也放满时，会触发拒绝策略<ol><li>抛异常 java.util.concurrent.ThreadPoolExecutor.AbortPolicy</li><li>由调用者执行任务 java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy</li><li>丢弃任务 java.util.concurrent.ThreadPoolExecutor.DiscardPolicy</li><li>丢弃最早排队任务 java.util.concurrent.ThreadPoolExecutor.DiscardOldestPolicy</li></ol></li></ol><blockquote><p><em><strong>代码说明</strong></em></p><p>day02.TestThreadPoolExecutor 以较为形象的方式演示了线程池的核心组成</p></blockquote><h2 id="3-wait-vs-sleep"><a href="#3-wait-vs-sleep" class="headerlink" title="3. wait vs sleep"></a>3. wait vs sleep</h2><p><strong>要求</strong></p><ul><li>能够说出二者区别</li></ul><p><strong>一个共同点，三个不同点</strong></p><p>共同点</p><ul><li>wait() ，wait(long) 和 sleep(long) 的效果都是让当前线程暂时放弃 CPU 的使用权，进入阻塞状态</li></ul><p>不同点</p><ul><li><p>方法归属不同</p><ul><li>sleep(long) 是 Thread 的静态方法</li><li>而 wait()，wait(long) 都是 Object 的成员方法，每个对象都有</li></ul></li><li><p>醒来时机不同</p><ul><li>执行 sleep(long) 和 wait(long) 的线程都会在等待相应毫秒后醒来</li><li>wait(long) 和 wait() 还可以被 notify 唤醒，wait() 如果不唤醒就一直等下去</li><li>它们都可以被打断唤醒</li></ul></li><li><p>锁特性不同（重点）</p><ul><li>wait 方法的调用必须先获取 wait 对象的锁，而 sleep 则无此限制</li><li>wait 方法执行后会释放对象锁，允许其它线程获得该对象锁（我放弃 cpu，但你们还可以用）</li><li>而 sleep 如果在 synchronized 代码块中执行，并不会释放对象锁（我放弃 cpu，你们也用不了）</li></ul></li></ul><h2 id="4-lock-vs-synchronized"><a href="#4-lock-vs-synchronized" class="headerlink" title="4. lock vs synchronized"></a>4. lock vs synchronized</h2><p><strong>要求</strong></p><ul><li>掌握 lock 与 synchronized 的区别</li><li>理解 ReentrantLock 的公平、非公平锁</li><li>理解 ReentrantLock 中的条件变量</li></ul><p><strong>三个层面</strong></p><p>不同点</p><ul><li>语法层面<ul><li>synchronized 是关键字，源码在 jvm 中，用 c++ 语言实现</li><li>Lock 是接口，源码由 jdk 提供，用 java 语言实现</li><li>使用 synchronized 时，退出同步代码块锁会自动释放，而使用 Lock 时，需要手动调用 unlock 方法释放锁</li></ul></li><li>功能层面<ul><li>二者均属于悲观锁、都具备基本的互斥、同步、锁重入功能</li><li>Lock 提供了许多 synchronized 不具备的功能，例如获取等待状态、公平锁、可打断、可超时、多条件变量</li><li>Lock 有适合不同场景的实现，如 ReentrantLock， ReentrantReadWriteLock</li></ul></li><li>性能层面<ul><li>在没有竞争时，synchronized 做了很多优化，如偏向锁、轻量级锁，性能不赖</li><li>在竞争激烈时，Lock 的实现通常会提供更好的性能</li></ul></li></ul><p><strong>公平锁</strong></p><ul><li>公平锁的公平体现<ul><li><strong>已经处在阻塞队列</strong>中的线程（不考虑超时）始终都是公平的，先进先出</li><li>公平锁是指<strong>未处于阻塞队列</strong>中的线程来争抢锁，如果队列不为空，则老实到队尾等待</li><li>非公平锁是指<strong>未处于阻塞队列</strong>中的线程来争抢锁，与队列头唤醒的线程去竞争，谁抢到算谁的</li></ul></li><li>公平锁会降低吞吐量，一般不用</li></ul><p><strong>条件变量</strong></p><ul><li>ReentrantLock 中的条件变量功能类似于普通 synchronized 的 wait，notify，用在当线程获得锁后，发现条件不满足时，临时等待的链表结构</li><li>与 synchronized 的等待集合不同之处在于，ReentrantLock 中的条件变量可以有多个，可以实现更精细的等待、唤醒控制</li></ul><blockquote><p><em><strong>代码说明</strong></em></p><ul><li>day02.TestReentrantLock 用较为形象的方式演示 ReentrantLock 的内部结构</li></ul></blockquote><h2 id="5-voltile"><a href="#5-voltile" class="headerlink" title="5. voltile"></a>5. voltile</h2><p><strong>要求</strong></p><ul><li>掌握线程安全要考虑的三个问题</li><li>掌握 volatile 能解决哪些问题</li></ul><p><strong>原子性</strong></p><ul><li>起因：多线程下，不同线程的<strong>指令发生了交错</strong>导致的共享变量的读写混乱</li><li>解决：用悲观锁或乐观锁解决，volatile 并不能解决原子性</li></ul><p><strong>可见性</strong></p><ul><li>起因：由于<strong>编译器优化、或缓存优化、或 CPU 指令重排序优化</strong>导致的对共享变量所做的修改另外的线程看不到</li><li>解决：用 volatile 修饰共享变量，能够防止编译器等优化发生，让一个线程对共享变量的修改对另一个线程可见</li></ul><p><strong>有序性</strong></p><ul><li>起因：由于<strong>编译器优化、或缓存优化、或 CPU 指令重排序优化</strong>导致指令的实际执行顺序与编写顺序不一致</li><li>解决：用 volatile 修饰共享变量会在读、写共享变量时加入不同的屏障，阻止其他读写操作越过屏障，从而达到阻止重排序的效果</li><li>注意：<ul><li><strong>volatile 变量写</strong>加的屏障是阻止上方其它写操作越过屏障排到 <strong>volatile 变量写</strong>之下</li><li><strong>volatile 变量读</strong>加的屏障是阻止下方其它读操作越过屏障排到 <strong>volatile 变量读</strong>之上</li><li>volatile 读写加入的屏障只能防止同一线程内的指令重排</li></ul></li></ul><blockquote><p><em><strong>代码说明</strong></em></p><ul><li>day02.threadsafe.AddAndSubtract 演示原子性</li><li>day02.threadsafe.ForeverLoop 演示可见性<ul><li>注意：本例经实践检验是编译器优化导致的可见性问题</li></ul></li><li>day02.threadsafe.Reordering 演示有序性<ul><li>需要打成 jar 包后测试</li></ul></li><li>请同时参考视频讲解</li></ul></blockquote><h2 id="6-悲观锁-vs-乐观锁"><a href="#6-悲观锁-vs-乐观锁" class="headerlink" title="6. 悲观锁 vs 乐观锁"></a>6. 悲观锁 vs 乐观锁</h2><p><strong>要求</strong></p><ul><li>掌握悲观锁和乐观锁的区别</li></ul><p><strong>对比悲观锁与乐观锁</strong></p><ul><li><p>悲观锁的代表是 synchronized 和 Lock 锁</p><ul><li>其核心思想是【线程只有占有了锁，才能去操作共享变量，每次只有一个线程占锁成功，获取锁失败的线程，都得停下来等待】</li><li>线程从运行到阻塞、再从阻塞到唤醒，涉及线程上下文切换，如果频繁发生，影响性能</li><li>实际上，线程在获取 synchronized 和 Lock 锁时，如果锁已被占用，都会做几次重试操作，减少阻塞的机会</li></ul></li><li><p>乐观锁的代表是 AtomicInteger，使用 cas 来保证原子性</p><ul><li>其核心思想是【无需加锁，每次只有一个线程能成功修改共享变量，其它失败的线程不需要停止，不断重试直至成功】</li><li>由于线程一直运行，不需要阻塞，因此不涉及线程上下文切换</li><li>它需要多核 cpu 支持，且线程数不应超过 cpu 核数</li></ul></li></ul><blockquote><p><em><strong>代码说明</strong></em></p><ul><li>day02.SyncVsCas 演示了分别使用乐观锁和悲观锁解决原子赋值</li><li>请同时参考视频讲解</li></ul></blockquote><h2 id="7-Hashtable-vs-ConcurrentHashMap"><a href="#7-Hashtable-vs-ConcurrentHashMap" class="headerlink" title="7. Hashtable vs ConcurrentHashMap"></a>7. Hashtable vs ConcurrentHashMap</h2><p><strong>要求</strong></p><ul><li>掌握 Hashtable 与 ConcurrentHashMap 的区别</li><li>掌握 ConcurrentHashMap 在不同版本的实现区别</li></ul><blockquote><p>更形象的演示，见资料中的 hash-demo.jar，运行需要 jdk14 以上环境，进入 jar 包目录，执行下面命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar --add-exports java.base/jdk.internal.misc=ALL-UNNAMED hash-demo.jar</span><br></pre></td></tr></table></figure></blockquote><p><strong>Hashtable 对比 ConcurrentHashMap</strong></p><ul><li>Hashtable 与 ConcurrentHashMap 都是线程安全的 Map 集合</li><li>Hashtable 并发度低，整个 Hashtable 对应一把锁，同一时刻，只能有一个线程操作它</li><li>ConcurrentHashMap 并发度高，整个 ConcurrentHashMap 对应多把锁，只要线程访问的是不同锁，那么不会冲突</li></ul><p><strong>ConcurrentHashMap 1.7</strong></p><ul><li>数据结构：<code>Segment(大数组) + HashEntry(小数组) + 链表</code>，每个 Segment 对应一把锁，如果多个线程访问不同的 Segment，则不会冲突</li><li>并发度：Segment 数组大小即并发度，决定了同一时刻最多能有多少个线程并发访问。Segment 数组不能扩容，意味着并发度在 ConcurrentHashMap 创建时就固定了</li><li>索引计算<ul><li>假设大数组长度是 $2^m$，key 在大数组内的索引是 key 的二次 hash 值的高 m 位</li><li>假设小数组长度是 $2^n$，key 在小数组内的索引是 key 的二次 hash 值的低 n 位</li></ul></li><li>扩容：每个小数组的扩容相对独立，小数组在超过扩容因子时会触发扩容，每次扩容翻倍</li><li>Segment[0] 原型：首次创建其它小数组时，会以此原型为依据，数组长度，扩容因子都会以原型为准</li></ul><p><strong>ConcurrentHashMap 1.8</strong></p><ul><li>数据结构：<code>Node 数组 + 链表或红黑树</code>，数组的每个头节点作为锁，如果多个线程访问的头节点不同，则不会冲突。首次生成头节点时如果发生竞争，利用 cas 而非 syncronized，进一步提升性能</li><li>并发度：Node 数组有多大，并发度就有多大，与 1.7 不同，Node 数组可以扩容</li><li>扩容条件：Node 数组满 3&#x2F;4 时就会扩容</li><li>扩容单位：以链表为单位从后向前迁移链表，迁移完成的将旧数组头节点替换为 ForwardingNode</li><li>扩容时并发 get<ul><li>根据是否为 ForwardingNode 来决定是在新数组查找还是在旧数组查找，不会阻塞</li><li>如果链表长度超过 1，则需要对节点进行复制（创建新节点），怕的是节点迁移后 next 指针改变</li><li>如果链表最后几个元素扩容后索引不变，则节点无需复制</li></ul></li><li>扩容时并发 put<ul><li>如果 put 的线程与扩容线程操作的链表是同一个，put 线程会阻塞</li><li>如果 put 的线程操作的链表还未迁移完成，即头节点不是 ForwardingNode，则可以并发执行</li><li>如果 put 的线程操作的链表已经迁移完成，即头结点是 ForwardingNode，则可以协助扩容</li></ul></li><li>与 1.7 相比是懒惰初始化</li><li>capacity 代表预估的元素个数，capacity &#x2F; factory 来计算出初始数组大小，需要贴近 $2^n$ </li><li>loadFactor 只在计算初始数组大小时被使用，之后扩容固定为 3&#x2F;4</li><li>超过树化阈值时的扩容问题，如果容量已经是 64，直接树化，否则在原来容量基础上做 3 轮扩容</li></ul><h2 id="8-ThreadLocal"><a href="#8-ThreadLocal" class="headerlink" title="8. ThreadLocal"></a>8. ThreadLocal</h2><p><strong>要求</strong></p><ul><li>掌握 ThreadLocal 的作用与原理</li><li>掌握 ThreadLocal 的内存释放时机</li></ul><p><strong>作用</strong></p><ul><li>ThreadLocal 可以实现【资源对象】的线程隔离，让每个线程各用各的【资源对象】，避免争用引发的线程安全问题</li><li>ThreadLocal 同时实现了线程内的资源共享</li></ul><p><strong>原理</strong></p><p>每个线程内有一个 ThreadLocalMap 类型的成员变量，用来存储资源对象</p><ul><li>调用 set 方法，就是以 ThreadLocal 自己作为 key，资源对象作为 value，放入当前线程的 ThreadLocalMap 集合中</li><li>调用 get 方法，就是以 ThreadLocal 自己作为 key，到当前线程中查找关联的资源值</li><li>调用 remove 方法，就是以 ThreadLocal 自己作为 key，移除当前线程关联的资源值</li></ul><p>ThreadLocalMap 的一些特点</p><ul><li>key 的 hash 值统一分配</li><li>初始容量 16，扩容因子 2&#x2F;3，扩容容量翻倍</li><li>key 索引冲突后用开放寻址法解决冲突</li></ul><p><strong>弱引用 key</strong></p><p>ThreadLocalMap 中的 key 被设计为弱引用，原因如下</p><ul><li>Thread 可能需要长时间运行（如线程池中的线程），如果 key 不再使用，需要在内存不足（GC）时释放其占用的内存</li></ul><p><strong>内存释放时机</strong></p><ul><li>被动 GC 释放 key<ul><li>仅是让 key 的内存释放，关联 value 的内存并不会释放</li></ul></li><li>懒惰被动释放 value<ul><li>get key 时，发现是 null key，则释放其 value 内存</li><li>set key 时，会使用启发式扫描，清除临近的 null key 的 value 内存，启发次数与元素个数，是否发现 null key 有关</li></ul></li><li>主动 remove 释放 key，value<ul><li>会同时释放 key，value 的内存，也会清除临近的 null key 的 value 内存</li><li>推荐使用它，因为一般使用 ThreadLocal 时都把它作为静态变量（即强引用），因此无法被动依靠 GC 回收。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java核心系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 高并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java核心系列1：泛型机制详解</title>
      <link href="/2025/02/18/Java%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/Java%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%861-%E6%B3%9B%E5%9E%8B%E6%9C%BA%E5%88%B6/"/>
      <url>/2025/02/18/Java%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/Java%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%861-%E6%B3%9B%E5%9E%8B%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="1-理解泛型的本质"><a href="#1-理解泛型的本质" class="headerlink" title="1 理解泛型的本质"></a>1 理解泛型的本质</h1><p>JDK 1.5开始引入Java泛型（generics）这个特性，该特性提供了编译时类型安全检测机制，允许程序员在编译时检测到非法的类型。</p><p>泛型的本质是参数化类型，即给类型指定一个参数，然后在使用时再指定此参数具体的值，那样这个类型就可以在使用时决定了。这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。为了兼容之前的版本，Java泛型的实现采取了“伪泛型”的策略，即Java在语法上支持泛型，但是在编译阶段会进行所谓的“类型擦除”（Type Erasure），将所有的泛型表示（尖括号中的内容）都替换为具体的类型（其对应的原生态类型）。<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAOpaUZCdbr-3Q4mRwABnz5OkXUcZaTZAAKfC2sb0X4wVpouh-KnjVvcAQADAgADeAADNgQ.png" alt="图1 泛型的语法"></p><h1 id="2-泛型的作用"><a href="#2-泛型的作用" class="headerlink" title="2 泛型的作用"></a>2 泛型的作用</h1><p>泛型有四个作用：类型安全、自动转换、性能提升、可复用性。即在编译的时候检查类型安全，将所有的强制转换都自动和隐式进行，同时提高代码的可复用性。<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAOqaUZCg4TYvcwFSxpxjtU0uT_K58kAAqALaxvRfjBWf6EQVcklU1YBAAMCAAN4AAM2BA.png" alt="图2 泛型的四个作用"></p><h2 id="2-1-泛型如何保证类型安全"><a href="#2-1-泛型如何保证类型安全" class="headerlink" title="2.1 泛型如何保证类型安全"></a>2.1 泛型如何保证类型安全</h2><p>在没有泛型之前，从集合中读取到的每一个对象都必须进行类型转换，如果不小心插入了错误的类型对象，在运行时的转换处理就会出错。比如：没有泛型的情况下使用集合：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">noGenericTest</span>()</span> &#123;</span><br><span class="line">        <span class="comment">// 编译正常通过，但是使用的时候可能转换处理出现问题</span></span><br><span class="line">        ArrayList arr = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        arr.<span class="keyword">add</span>(<span class="string">&quot;加入一个字符串&quot;</span>);</span><br><span class="line">        arr.<span class="keyword">add</span>(<span class="number">1</span>);</span><br><span class="line">        arr.<span class="keyword">add</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>有泛型的情况下使用集合：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">genericTest</span>()</span> &#123;</span><br><span class="line">        <span class="comment">// 编译不通过，直接提示异常，Required type：String</span></span><br><span class="line">        ArrayList&lt;String&gt; arr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        arr.<span class="keyword">add</span>(<span class="string">&quot;加入一个字符串&quot;</span>);</span><br><span class="line">        arr.<span class="keyword">add</span>(<span class="number">1</span>);</span><br><span class="line">        arr.<span class="keyword">add</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>有了泛型后，会对类型进行验证，所以集合arr在编译的时候add(1)、add(‘a’) 都会编译不通过。这个过程相当于告诉编译器每个集合接收的对象类型是什么，编译器在编译期就会做类型检查，告知是否插入了错误类型的对象，使得程序更加安全，增强了程序的健壮性。</p><h2 id="2-2-类型自动转换，消除强转"><a href="#2-2-类型自动转换，消除强转" class="headerlink" title="2.2 类型自动转换，消除强转"></a>2.2 类型自动转换，消除强转</h2><p>泛型的另一个好处是消除源代码中的强制类型转换，这样代码可读性更强，且减少了转换类型出错的可能性。以下面的代码为例子，以下代码段需要强制转换，否则编译会通不过：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList list  = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.<span class="keyword">add</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">int</span> i = (<span class="built_in">int</span>) list.<span class="keyword">get</span>(<span class="number">0</span>);  <span class="comment">// 需强转</span></span><br></pre></td></tr></table></figure><p>当重写为使用泛型时，代码不需要强制转换：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list  = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.<span class="keyword">add</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">int</span> i = list.<span class="keyword">get</span>(<span class="number">0</span>);  <span class="comment">// 无需转换</span></span><br></pre></td></tr></table></figure><h2 id="2-3-避免装箱、拆箱，提高性能"><a href="#2-3-避免装箱、拆箱，提高性能" class="headerlink" title="2.3 避免装箱、拆箱，提高性能"></a>2.3 避免装箱、拆箱，提高性能</h2><p>在非泛型编程中，将简单类型作为Object传递时会引起Boxing（装箱）和Unboxing（拆箱）操作，这两个过程都是具有很大开销的。引入泛型后，就不必进行Boxing和Unboxing操作了，所以运行效率相对较高，特别在对集合操作非常频繁的系统中，这个特点带来的性能提升更加明显。泛型变量固定了类型，使用的时候就已经知道是值类型还是引用类型，避免了不必要的装箱、拆箱操作。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">object</span> a=<span class="number">1</span>;<span class="comment">//由于是object类型，会自动进行装箱操作。</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">int</span> b=(<span class="built_in">int</span>)a;<span class="comment">//强制转换，拆箱操作。这样一去一来，当次数多了以后会影响程序的运行效率。</span></span><br></pre></td></tr></table></figure><p>使用泛型后</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">GetValue</span>&lt;<span class="title">T</span>&gt;(<span class="params">T a</span>)</span> &#123;</span><br><span class="line">　　<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span>&#123;</span><br><span class="line">　　<span class="built_in">int</span> b=GetValue&lt;<span class="built_in">int</span>&gt;(<span class="number">1</span>);<span class="comment">//使用这个方法的时候已经指定了类型是int，所以不会有装箱和拆箱的操作。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-提升程序可复用性"><a href="#2-4-提升程序可复用性" class="headerlink" title="2.4 提升程序可复用性"></a>2.4 提升程序可复用性</h2><p>引入泛型的另一个意义在于：适用于多种数据类型执行相同的代码（代码复用）我们通过下面的例子来说明，代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">add</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span> &#123;</span><br><span class="line">    System.<span class="keyword">out</span>.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a + b));</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">float</span> <span class="title">add</span>(<span class="params"><span class="built_in">float</span> a, <span class="built_in">float</span> b</span>)</span> &#123;</span><br><span class="line">    System.<span class="keyword">out</span>.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a + b));</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">double</span> <span class="title">add</span>(<span class="params"><span class="built_in">double</span> a, <span class="built_in">double</span> b</span>)</span> &#123;</span><br><span class="line">    System.<span class="keyword">out</span>.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a + b));</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有泛型，要实现不同类型的加法，每种类型都需要重载一个add方法；通过泛型，我们可以复用为一个方法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; double <span class="title function_">add</span>(<span class="params">T a, T b</span>) &#123;</span><br><span class="line">    <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a.<span class="title function_">doubleValue</span>() + b.<span class="title function_">doubleValue</span>()));</span><br><span class="line">    <span class="keyword">return</span> a.<span class="title function_">doubleValue</span>() + b.<span class="title function_">doubleValue</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-泛型的使用"><a href="#3-泛型的使用" class="headerlink" title="3 泛型的使用"></a>3 泛型的使用</h1><h2 id="3-1-泛型类"><a href="#3-1-泛型类" class="headerlink" title="3.1 泛型类"></a>3.1 泛型类</h2><p>泛型类是指把泛型定义在类上，具体的定义格式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> 类名 &lt;泛型类型<span class="number">1</span>,...&gt; &#123;</span><br><span class="line"><span class="comment">// todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意事项：泛型类型必须是引用类型，非基本数据类型定义泛型类，在类名后添加一对尖括号，并在尖括号中填写类型参数，参数可以有多个，多个参数使用逗号分隔：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GenericClass</span>&lt;<span class="title">ab</span>,<span class="title">a</span>,<span class="title">c</span>&gt; &#123;</span><br><span class="line">  <span class="comment">// todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，这个后面的参数类型也是有规范的，不能像上面一样随意，通常类型参数我们都使用大写的单个字母表，可以任意指定，但是还是建议使用有字面含义的，让人通俗易懂，下面的字母可以参考使用：</p><ul><li>T：任意类型 type</li><li>E：集合中元素的类型 element</li><li>K：key-value形式 key</li><li>V： key-value形式 value</li><li>N： Number（数值类型）</li><li>？： 表示不确定的java类型</li></ul><p>这边举个例子，假设我们写一个通用的返回对象，对象中的某个字段的类型不定：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Response</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> boolean status;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接口返回内容，不同的接口返回的内容不一致，使用泛型数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T <span class="keyword">data</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> status</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> code</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Response(boolean status,int code,String msg,T <span class="keyword">data</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.status = status;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">data</span> = <span class="keyword">data</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>做成泛型类，他的通用性就很强了，这时候他返回的情况可能如下：先定义一个用户信息对象</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserInfo</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户编号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> userCode;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> userName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尝试返回不同的数据类型：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">Response</span>&lt;<span class="type">String</span>&gt; responseStr <span class="operator">=</span> new <span class="type">Response</span>&lt;&gt;(<span class="literal">true</span>,<span class="number">200</span>,<span class="string">&quot;success&quot;</span>,<span class="string">&quot;Hello Word&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回用户对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">UserInfo</span> userInfo <span class="operator">=</span> new <span class="type">UserInfo</span>();</span><br><span class="line">userInfo.setUserCode(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">userInfo.setUserName(<span class="string">&quot;Brand&quot;</span>);</span><br><span class="line"><span class="type">Response</span>&lt;<span class="type">UserInfo</span>&gt; responseObj <span class="operator">=</span> new <span class="type">Response</span>&lt;&gt;(<span class="literal">true</span>,<span class="number">200</span>,<span class="string">&quot;success&quot;</span>,userInfo);</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">200</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;success&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Hello Word&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="comment">// 和</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">200</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;success&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;user_code&quot;</span><span class="punctuation">:</span> <span class="string">&quot;123456&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;user_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Brand&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="3-2-泛型接口"><a href="#3-2-泛型接口" class="headerlink" title="3.2 泛型接口"></a>3.2 泛型接口</h2><p>泛型方法概述：把泛型定义在接口上，他的格式如下</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> 接口名&lt;T&gt; &#123;</span><br><span class="line">  <span class="comment">// todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意点1：方法声明中定义的形参只能在该方法里使用，而接口、类声明中定义的类型形参则可以在整个接口、类中使用。当调用fun()方法时，根据传入的实际对象，编译器就会判断出类型形参T所代表的实际类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GenericInterface</span>&lt;T&gt; &#123;</span><br><span class="line"><span class="built_in">void</span> <span class="title function_">show</span>(T value);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringShowImpl</span> <span class="keyword">implements</span> <span class="title class_">GenericInterface</span>&lt;<span class="title class_">String</span>&gt; &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">show</span>(<span class="params"><span class="title class_">String</span> value</span>) &#123;</span><br><span class="line"><span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(value);</span><br><span class="line">&#125;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NumberShowImpl</span> <span class="keyword">implements</span> <span class="title class_">GenericInterface</span>&lt;<span class="title class_">Integer</span>&gt; &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">show</span>(<span class="params"><span class="title class_">Integer</span> value</span>) &#123;</span><br><span class="line"><span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(value);</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><p>注意点2：使用泛型的时候，前后定义的泛型类型必须保持一致，否则会出现编译异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译的时候会报错，因为前后类型不一致</span></span><br><span class="line">GenericInterface&lt;String&gt; genericInterface = <span class="keyword">new</span> <span class="title class_">NumberShowImpl</span>();</span><br><span class="line"><span class="comment">// 编译正常，前面泛型接口不指定类型，由new后面的实例化来推导。</span></span><br><span class="line"><span class="type">GenericInterface</span> <span class="variable">g1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NumberShowImpl</span>();</span><br><span class="line"><span class="type">GenericInterface</span> <span class="variable">g2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringShowImpl</span>();</span><br></pre></td></tr></table></figure><h2 id="3-3-泛型方法"><a href="#3-3-泛型方法" class="headerlink" title="3.3 泛型方法"></a>3.3 泛型方法</h2><p>泛型方法，是在调用方法的时候指明泛型的具体类型 。定义格式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;泛型类型&gt; 返回类型 方法名（泛型类型 变量名） &#123;</span><br><span class="line">   <span class="comment">// todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例说明，下面是一个典型的泛型方法，根据传入的对象，打印它的值和类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 泛型方法    </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; 泛型的类型</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> c 传入泛型的参数对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> T 返回值为T类型</span></span><br><span class="line"><span class="comment">     * 说明：</span></span><br><span class="line"><span class="comment">     *   1）public 与 返回值中间&lt;T&gt;非常重要，可以理解为声明此方法为泛型方法。</span></span><br><span class="line"><span class="comment">     *   2）只有声明了&lt;T&gt;的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。</span></span><br><span class="line"><span class="comment">     *   3）&lt;T&gt;表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。</span></span><br><span class="line"><span class="comment">     *   4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E等形式的参数常用于表示泛型。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">genercMethod</span>(<span class="params">T c</span>) &#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(c.<span class="title function_">getClass</span>());</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(c);</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">   &#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="title class_">String</span>[] args</span>) &#123;</span><br><span class="line">    <span class="title class_">GenericsClassDemo</span>&lt;<span class="title class_">String</span>&gt; genericString  = <span class="keyword">new</span> <span class="title class_">GenericsClassDemo</span>(<span class="string">&quot;Hello World&quot;</span>); <span class="comment">//这里的泛型跟下面调用的泛型方法可以不一样。</span></span><br><span class="line">    <span class="title class_">String</span> str = genericString.<span class="title function_">genercMethod</span>(<span class="string">&quot;brand&quot;</span>);<span class="comment">//传入的是String类型,返回的也是String类型</span></span><br><span class="line">    <span class="title class_">Integer</span> i = genericString.<span class="title function_">genercMethod</span>(<span class="number">100</span>);<span class="comment">//传入的是Integer类型,返回的也是Integer类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> java.lang.<span class="type">String</span></span><br><span class="line">brand </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> java.lang.<span class="type">Integer</span></span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure><p>从上面可以看出，泛型方法随着我们的传入参数类型不同，执行的效果不同，拿到的结果也不一样。泛型方法能使方法独立于类而产生变化。</p><h2 id="3-4-泛型通配符（上下界）"><a href="#3-4-泛型通配符（上下界）" class="headerlink" title="3.4 泛型通配符（上下界）"></a>3.4 泛型通配符（上下界）</h2><p>Java泛型的通配符是用于解决泛型之间引用传递问题的特殊语法, 主要有以下三类:</p><ul><li>无边界的通配符，使用精确的参数类型</li><li>关键字声明了类型的上界，表示参数化的类型可能是所指定的类型，或者是此类型的子类</li><li>关键字声明了类型的下界，表示参数化的类型可能是指定的类型，或者是此类型的父类</li></ul><p>结构如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示类型参数可以是任何类型</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">B&lt;?&gt;</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 上界：表示类型参数必须是A或者是A的子类</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">B&lt;T</span> <span class="keyword">extends</span> <span class="title">A&gt;</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 下界：表示类型参数必须是A或者是A的超类型</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">B&lt;T</span> <span class="title">supers</span> <span class="title">A&gt;</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上界示例：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Info</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt;&#123;    <span class="comment">// 此处泛型只能是数字类型</span></span><br><span class="line">    <span class="keyword">private</span> T <span class="keyword">var</span> ;        <span class="comment">// 定义泛型变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">setVar</span>(<span class="params">T <span class="keyword">var</span></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">var</span> = <span class="keyword">var</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getVar</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">var</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">String</span> <span class="title function_">toString</span>(<span class="params"></span>)&#123;    <span class="comment">// 直接打印</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">var</span>.<span class="title function_">toString</span>() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo1</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="title class_">String</span> args[]</span>)&#123;</span><br><span class="line">        <span class="title class_">Info</span>&lt;<span class="title class_">Integer</span>&gt; i1 = <span class="keyword">new</span> <span class="title class_">Info</span>&lt;<span class="title class_">Integer</span>&gt;() ;        <span class="comment">// 声明Integer的泛型对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下界示例：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Info</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> T <span class="keyword">var</span> ;        <span class="comment">// 定义泛型变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">setVar</span>(<span class="params">T <span class="keyword">var</span></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">var</span> = <span class="keyword">var</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getVar</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">var</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">String</span> <span class="title function_">toString</span>(<span class="params"></span>)&#123;    <span class="comment">// 直接打印</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">var</span>.<span class="title function_">toString</span>() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericsDemo21</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="title class_">String</span> args[]</span>)&#123;</span><br><span class="line">        <span class="title class_">Info</span>&lt;<span class="title class_">String</span>&gt; i1 = <span class="keyword">new</span> <span class="title class_">Info</span>&lt;<span class="title class_">String</span>&gt;() ;        <span class="comment">// 声明String的泛型对象</span></span><br><span class="line">        <span class="title class_">Info</span>&lt;<span class="title class_">Object</span>&gt; i2 = <span class="keyword">new</span> <span class="title class_">Info</span>&lt;<span class="title class_">Object</span>&gt;() ;        <span class="comment">// 声明Object的泛型对象</span></span><br><span class="line">        i1.<span class="title function_">setVar</span>(<span class="string">&quot;hello&quot;</span>) ;</span><br><span class="line">        i2.<span class="title function_">setVar</span>(<span class="keyword">new</span> <span class="title class_">Object</span>()) ;</span><br><span class="line">        <span class="title function_">fun</span>(i1) ;</span><br><span class="line">        <span class="title function_">fun</span>(i2) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">fun</span>(<span class="params"><span class="title class_">Info</span>&lt;? <span class="variable language_">super</span> <span class="title class_">String</span>&gt; temp</span>)&#123;    <span class="comment">// 只能接收String或Object类型的泛型，String类的父类只有Object类</span></span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">print</span>(temp + <span class="string">&quot;, &quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-泛型实现原理"><a href="#4-泛型实现原理" class="headerlink" title="4 泛型实现原理"></a>4 泛型实现原理</h1><p>Java泛型这个特性是从JDK 1.5才开始加入的，因此为了兼容之前的版本，Java泛型的实现采取了“伪泛型”的策略，即Java在语法上支持泛型，但是在编译阶段会进行所谓的“类型擦除”（Type Erasure），将所有的泛型表示（尖括号中的内容）都替换为具体的类型（其对应的原生态类型），就像完全没有泛型一样。泛型本质是将数据类型参数化，它通过擦除的方式来实现，即编译器会在编译期间「擦除」泛型语法并相应的做出一些类型转换动作。</p><h2 id="4-1-泛型的类型擦除原则"><a href="#4-1-泛型的类型擦除原则" class="headerlink" title="4.1 泛型的类型擦除原则"></a>4.1 泛型的类型擦除原则</h2><ul><li>消除类型参数声明，即删除&lt;&gt;及其包围的部分。</li><li>根据类型参数的上下界推断并替换所有的类型参数为原生态类型：如果类型参数是无限制通配符或没有上下界限定则替换为Object，如果存在上下界限定则根据子类替换原则取类型参数的最左边限定类型（即父类）。</li><li>为了保证类型安全，必要时插入强制类型转换代码。</li><li>自动产生“桥接方法”以保证擦除类型后的代码仍然具有泛型的“多态性”。</li></ul><h2 id="4-2-擦除的方式"><a href="#4-2-擦除的方式" class="headerlink" title="4.2 擦除的方式"></a>4.2 擦除的方式</h2><p>擦除类定义中的类型参数 - 无限制类型擦除当类定义中的类型参数没有任何限制时，在类型擦除中直接被替换为Object，即形如和&lt;?&gt;的类型参数都被替换为Object。<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAOuaUZEE7kXf-LskRyKeVD8U5gSW_MAAqQLaxvRfjBWhlqk_K2Zn5YBAAMCAAN4AAM2BA.png" alt="image"></p><p>擦除类定义中的类型参数 - 有限制类型擦除当类定义中的类型参数存在限制（上下界）时，在类型擦除中替换为类型参数的上界或者下界，比如形如和&lt;? extends Number&gt;的类型参数被替换为Number，&lt;? super Number&gt;被替换为Object。<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAOwaUZEbYG6OtsOFfmEjXV5RpPnMCMAAqYLaxvRfjBWFY3al3FhwbgBAAMCAAN4AAM2BA.png" alt="image"></p><p>擦除方法定义中的类型参数<br>擦除方法定义中的类型参数原则和擦除类定义中的类型参数是一样的，这里仅以擦除方法定义中的有限制类型参数为例。<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAOxaUZEjIuz4SZomFu9lisvA8Lfu4wAAqcLaxvRfjBWtquZ5GSxUg0BAAMCAAN5AAM2BA.png" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> Java核心系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java核心 </tag>
            
            <tag> Java基础 </tag>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java核心系列2：注解机制详解</title>
      <link href="/2025/02/18/Java%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/Java%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%862-%E6%B3%A8%E8%A7%A3%E6%9C%BA%E5%88%B6/"/>
      <url>/2025/02/18/Java%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/Java%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%862-%E6%B3%A8%E8%A7%A3%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Java注解基础"><a href="#1-Java注解基础" class="headerlink" title="1 Java注解基础"></a>1 Java注解基础</h1><p>注解是JDK1.5版本开始引入的一个特性，用于对程序代码的说明，可以对包、类、接口、字段、方法参数、局部变量等进行注解。<br>它主要的作用有以下四方面：</p><ul><li>生成javadoc文档，通过在代码里面标识元数据生成javadoc文档。</li><li>编译期的检查，通过标识的元数据让编译器在编译期间对代码进行验证。</li><li>编译时动态处理，编译时通过代码中标识的元数据动态处理，比如动态生成代码。</li><li>运行时动态处理，运行时通过代码中标识的元数据动态处理，比如使用反射技术注入实例。</li></ul><p>注解的常见分类有三种：</p><ul><li><p><strong>Java自带的标准注解</strong>，包括 @Override、@Deprecated和@SuppressWarnings，分别代表 方法重写、某个类或方法过时、以及忽略警告，用这些注解标明后编译器就会进行检查。</p></li><li><p><strong>元注解</strong>，元注解是用于定义注解的注解，包括@Retention、@Target、@Inherited、@Documented 等6种</p><ul><li>@Retention：指定其所修饰的注解的保留策略</li><li>@Document：该注解是一个标记注解，用于指示一个注解将被文档化</li><li>@Target：用来限制注解的使用范围</li><li>@Inherited：该注解使父类的注解能被其子类继承</li><li>@Repeatable：该注解是Java8新增的注解，用于开发重复注解</li><li>类型注解（Type Annotation）：该注解是Java8新增的注解，可以用在任何用到类型的地方</li></ul></li><li><p><strong>自定义注解</strong>，可以根据自己的需求定义注解，并可用元注解对自定义注解进行注解。</p></li></ul><p>接下来我们通过这三种分类来逐一理解注解。</p><h2 id="1-1-Java内置注解"><a href="#1-1-Java内置注解" class="headerlink" title="1.1 Java内置注解"></a>1.1 Java内置注解</h2><p>我们先从Java内置注解开始说起，先看下下面的代码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">rewriteMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Parent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 重载父类的 rewriteMethod() 方法</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">rewriteMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 被弃用的过时方法</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">oldMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 忽略告警</span></span><br><span class="line"><span class="comment">        * </span></span><br><span class="line"><span class="comment">        * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">&quot;keep run&quot;</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">List</span> <span class="title function_">infoList</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title class_">List</span> list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 1.5开始自带的标准注解，包括@Override、@Deprecated和@SuppressWarnings：</p><ul><li><code>@Override</code>：表示当前类中的方法定义将覆盖父类中的方法</li><li><code>@Deprecated</code>：表示该代码段被弃用，但是可以使用，只是编译器会发出警告而已</li><li><code>@SuppressWarnings</code>：表示关闭编译器的警告信息<br>我们再具体看下这几个内置注解，同时通过这几个内置注解中的元注解的定义来引出元注解。</li></ul><h3 id="1-1-1-内置注解-Override"><a href="#1-1-1-内置注解-Override" class="headerlink" title="1.1.1 内置注解 - @Override"></a>1.1.1 内置注解 - @Override</h3><p>我们先来看一下这个注解类型的定义：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="variable">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line">public <span class="variable">@interface</span> Override &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从它的定义我们可以看到，这个注解可以被用来修饰方法，并且它只在编译时有效，在编译后的class文件中便不再存在。这个注解的作用我们大家都不陌生，那就是告诉编译器被修饰的方法是重写的父类的中的相同签名的方法，编译器会对此做出检查，若发现父类中不存在这个方法或是存在的方法签名不同，则会报错。</p><h3 id="1-1-2-内置注解-Deprecated"><a href="#1-1-2-内置注解-Deprecated" class="headerlink" title="1.1.2 内置注解 - @Deprecated"></a>1.1.2 内置注解 - @Deprecated</h3><p>这个注解的定义如下：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Documented</span></span><br><span class="line"><span class="variable">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="variable">@Target</span>(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)</span><br><span class="line">public <span class="variable">@interface</span> Deprecated &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从它的定义我们可以知道，它会被文档化，能够保留到运行时，能够修饰构造方法、属性、局部变量、方法、包、参数、类型。这个注解的作用是告诉编译器被修饰的程序元素已被“废弃”，不再建议用户使用。</p><h3 id="1-1-3-内置注解-SuppressWarnings"><a href="#1-1-3-内置注解-SuppressWarnings" class="headerlink" title="1.1.3 内置注解 - @SuppressWarnings"></a>1.1.3 内置注解 - @SuppressWarnings</h3><p>这个注解我们也比较常用到，先来看下它的定义：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Target</span>(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</span><br><span class="line"><span class="variable">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line">public <span class="variable">@interface</span> SuppressWarnings &#123;</span><br><span class="line">    <span class="selector-tag">String</span><span class="selector-attr">[]</span> <span class="selector-tag">value</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它能够修饰的程序元素包括类型、属性、方法、参数、构造器、局部变量，只能存活在源码时，取值为String[]。它的作用是告诉编译器忽略指定的警告信息，它可以取的值如下所示：</p><table><thead><tr><th>参数</th><th>作用</th><th>原描述</th></tr></thead><tbody><tr><td>all</td><td>抑制所有警告</td><td>to suppress all warnings</td></tr><tr><td>boxing</td><td>抑制装箱、拆箱操作时候的警告</td><td>to suppress warnings relative to boxing&#x2F;unboxing operations</td></tr><tr><td>cast</td><td>抑制映射相关的警告</td><td>to suppress warnings relative to cast operations</td></tr><tr><td>dep-ann</td><td>抑制启用注释的警告</td><td>to suppress warnings relative to deprecated annotation</td></tr><tr><td>deprecation</td><td>抑制过期方法警告</td><td>to suppress warnings relative to deprecation</td></tr><tr><td>fallthrough</td><td>抑制确在switch中缺失breaks的警告</td><td>to suppress warnings relative to missing breaks in switch statements</td></tr><tr><td>finally</td><td>抑制finally模块没有返回的警告</td><td>to suppress warnings relative to finally block that don’t return</td></tr><tr><td>hiding</td><td>抑制与隐藏变数的区域变数相关的警告</td><td>to suppress warnings relative to locals that hide variable（）</td></tr><tr><td>incomplete-switch</td><td>忽略没有完整的switch语句</td><td>to suppress warnings relative to missing entries in a switch statement (enum case)</td></tr><tr><td>nls</td><td>忽略非nls格式的字符</td><td>to suppress warnings relative to non-nls string literals</td></tr><tr><td>null</td><td>忽略对null的操作</td><td>to suppress warnings relative to null analysis</td></tr><tr><td>rawtype</td><td>使用generics时忽略没有指定相应的类型</td><td>to suppress warnings relative to un-specific types when using</td></tr><tr><td>restriction</td><td>抑制与使用不建议或禁止参照相关的警告</td><td>to suppress warnings relative to usage of discouraged or</td></tr><tr><td>serial</td><td>忽略在serializable类中没有声明serialVersionUID变量</td><td>to suppress warnings relative to missing serialVersionUID field for a serializable class</td></tr><tr><td>static-access</td><td>抑制不正确的静态访问方式警告</td><td>to suppress warnings relative to incorrect static access</td></tr><tr><td>synthetic-access</td><td>抑制子类没有按最优方法访问内部类的警告</td><td>to suppress warnings relative to unoptimized access from inner classes</td></tr><tr><td>unchecked</td><td>抑制没有进行类型检查操作的警告</td><td>to suppress warnings relative to unchecked operations</td></tr><tr><td>unqualified-field-access</td><td>抑制没有权限访问的域的警告</td><td>to suppress warnings relative to field access unqualified</td></tr><tr><td>unused</td><td>抑制没被使用过的代码的警告</td><td>to suppress warnings relative to unused code</td></tr></tbody></table><h2 id="1-2-元注解"><a href="#1-2-元注解" class="headerlink" title="1.2 元注解"></a>1.2 元注解</h2><p>上述内置注解的定义中使用了一些元注解（注解类型进行注解的注解类），在JDK 1.5中提供了4个标准的元注解：@Target，@Retention，@Documented，@Inherited, 在JDK 1.8中提供了两个新的元注解 @Repeatable和@Native。</p><h3 id="1-2-1-元注解-Target"><a href="#1-2-1-元注解-Target" class="headerlink" title="1.2.1 元注解 - @Target"></a>1.2.1 元注解 - @Target</h3><blockquote><p>Target注解的作用是：描述注解的使用范围（即：被修饰的注解可以用在什么地方） 。</p></blockquote><p>Target注解用来说明那些被它所注解的注解类可修饰的对象范围：</p><ul><li>packages、types（类、接口、枚举、注解类）</li><li>类成员（方法、构造方法、成员变量、枚举值）</li><li>方法参数和本地变量（如循环变量、catch参数）<br>在定义注解类时使用了@Target 能够更加清晰的知道它能够被用来修饰哪些对象，它的取值范围定义在ElementType 枚举中。枚举信息如下：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ElementType</span> &#123; </span><br><span class="line">    TYPE, <span class="comment">// 类、接口、枚举类 </span></span><br><span class="line">    FIELD, <span class="comment">// 成员变量（包括：枚举常量） </span></span><br><span class="line">    METHOD, <span class="comment">// 成员方法 </span></span><br><span class="line">    PARAMETER, <span class="comment">// 方法参数 </span></span><br><span class="line">    CONSTRUCTOR, <span class="comment">// 构造方法 </span></span><br><span class="line">    LOCAL_VARIABLE, <span class="comment">// 局部变量 </span></span><br><span class="line">    ANNOTATION_TYPE, <span class="comment">// 注解类 </span></span><br><span class="line">    PACKAGE, <span class="comment">// 可用于修饰：包 </span></span><br><span class="line">    TYPE_PARAMETER, <span class="comment">// 类型参数，JDK 1.8 新增 </span></span><br><span class="line">    TYPE_USE <span class="comment">// 使用类型的任何地方，JDK 1.8 新增 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-2-元注解-Retention-RetentionTarget"><a href="#1-2-2-元注解-Retention-RetentionTarget" class="headerlink" title="1.2.2 元注解 - @Retention &amp; @RetentionTarget"></a>1.2.2 元注解 - @Retention &amp; @RetentionTarget</h3><blockquote><p>Reteniton注解的作用是：描述注解保留的时间范围（即：被描述的注解在它所修饰的类中可以被保留到何时） 。</p></blockquote><p>Reteniton注解用来限定那些被它所注解的注解类在注解到其他类上以后，可被保留到何时，一共有三种策略，定义在RetentionPolicy枚举中。枚举如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">RetentionPolicy</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="type">SOURCE</span>,    <span class="comment">// 源文件保留</span></span><br><span class="line">    <span class="type">CLASS</span>,       <span class="comment">// 编译期保留，默认为该值，CLASS</span></span><br><span class="line">    <span class="type">RUNTIME</span>   <span class="comment">// 运行期保留，可通过反射去获取注解信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们测试下这三种策略，在定义注解类的时候什么区别：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line">public <span class="variable">@interface</span> SourcePolicy &#123;</span><br><span class="line">  <span class="comment">// 源文件保留策略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">@Retention</span>(RetentionPolicy.CLASS)</span><br><span class="line">public <span class="variable">@interface</span> ClassPolicy &#123;</span><br><span class="line">  <span class="comment">// 编译器保留策略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line">public <span class="variable">@interface</span> RuntimePolicy &#123;</span><br><span class="line">  <span class="comment">// 运行期保留策略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面已经定义好了三个注解类，我们再用这三个注解类再去注解方法，如下：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">class</span> <span class="selector-tag">RetentionTest</span> &#123;</span><br><span class="line"> </span><br><span class="line"><span class="variable">@SourcePolicy</span></span><br><span class="line">public void <span class="built_in">sourcePolicy</span>() &#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="variable">@ClassPolicy</span></span><br><span class="line">public void <span class="built_in">classPolicy</span>() &#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="variable">@RuntimePolicy</span></span><br><span class="line">public void <span class="built_in">runtimePolicy</span>() &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过执行 javap -verbose RetentionTest命令获取到的RetentionTest 的 class 字节码内容如下。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">public</span> <span class="string">retention.RetentionTest();</span></span><br><span class="line">    <span class="attr">flags:</span> <span class="string">ACC_PUBLIC</span></span><br><span class="line">    <span class="attr">Code:</span></span><br><span class="line">      <span class="string">stack=1</span>, <span class="string">locals=1</span>, <span class="string">args_size=1</span></span><br><span class="line">         <span class="attr">0:</span> <span class="string">aload_0</span></span><br><span class="line">         <span class="attr">1:</span> <span class="string">invokespecial</span>   <span class="comment">#1            // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="attr">4:</span> <span class="string">return</span></span><br><span class="line">      <span class="attr">LineNumberTable:</span></span><br><span class="line">        <span class="attr">line 3:</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="string">public</span> <span class="string">void</span> <span class="string">sourcePolicy();</span></span><br><span class="line">    <span class="attr">flags:</span> <span class="string">ACC_PUBLIC</span></span><br><span class="line">    <span class="attr">Code:</span></span><br><span class="line">      <span class="string">stack=0</span>, <span class="string">locals=1</span>, <span class="string">args_size=1</span></span><br><span class="line">         <span class="attr">0:</span> <span class="string">return</span></span><br><span class="line">      <span class="attr">LineNumberTable:</span></span><br><span class="line">        <span class="attr">line 7:</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="string">public</span> <span class="string">void</span> <span class="string">classPolicy();</span></span><br><span class="line">    <span class="attr">flags:</span> <span class="string">ACC_PUBLIC</span></span><br><span class="line">    <span class="attr">Code:</span></span><br><span class="line">      <span class="string">stack=0</span>, <span class="string">locals=1</span>, <span class="string">args_size=1</span></span><br><span class="line">         <span class="attr">0:</span> <span class="string">return</span></span><br><span class="line">      <span class="attr">LineNumberTable:</span></span><br><span class="line">        <span class="attr">line 11:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">RuntimeInvisibleAnnotations:</span></span><br><span class="line">      <span class="attr">0:</span> <span class="comment">#11()</span></span><br><span class="line"></span><br><span class="line">  <span class="string">public</span> <span class="string">void</span> <span class="string">runtimePolicy();</span></span><br><span class="line">    <span class="attr">flags:</span> <span class="string">ACC_PUBLIC</span></span><br><span class="line">    <span class="attr">Code:</span></span><br><span class="line">      <span class="string">stack=0</span>, <span class="string">locals=1</span>, <span class="string">args_size=1</span></span><br><span class="line">         <span class="attr">0:</span> <span class="string">return</span></span><br><span class="line">      <span class="attr">LineNumberTable:</span></span><br><span class="line">        <span class="attr">line 15:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">RuntimeVisibleAnnotations:</span></span><br><span class="line">      <span class="attr">0:</span> <span class="comment">#14()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 RetentionTest 的字节码内容我们可以得出以下两点结论：</p><ul><li>编译器并没有记录下 sourcePolicy() 方法的注解信息</li><li>编译器使用 RuntimeInvisibleAnnotations 去记录 classPolicy()方法的注解信息</li><li>编译器使用 RuntimeVisibleAnnotations 去记录 runtimePolicy()方法的注解信息</li></ul><h3 id="1-2-3-元注解-Documented"><a href="#1-2-3-元注解-Documented" class="headerlink" title="1.2.3 元注解 - @Documented"></a>1.2.3 元注解 - @Documented</h3><blockquote><p>Documented注解的作用如下：使用 javadoc 工具为类生成帮助文档，并确认是否保留注解信息。</p></blockquote><p>以下代码在使用Javadoc工具可以生成 @DocAnnotation注解信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DocAnnotation &#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;default&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@DocAnnotation(&quot;some method doc&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 测试方法的文档注解</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-4-元注解-Inherited"><a href="#1-2-4-元注解-Inherited" class="headerlink" title="1.2.4 元注解 - @Inherited"></a>1.2.4 元注解 - @Inherited</h3><blockquote><p>Inherited注解的作用：被它修饰的Annotation将具有继承特性。父类使用了被@Inherited修饰的Annotation，则子类将自动具备该注解。</p></blockquote><p>我们来测试下这个注解：</p><ul><li>定义@Inherited注解：</li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Inherited</span></span><br><span class="line"><span class="variable">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="variable">@Target</span>(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span><br><span class="line">public <span class="variable">@interface</span> InheritedAnnotation &#123;</span><br><span class="line">    <span class="selector-tag">String</span> <span class="selector-attr">[]</span> <span class="selector-tag">values</span>();</span><br><span class="line">    <span class="selector-tag">int</span> <span class="selector-tag">number</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用这个注解</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@InheritedAnnotation</span>(values = &#123;<span class="string">&quot;brand&quot;</span>&#125;, number = <span class="number">100</span>)</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> <span class="keyword">extends</span> <span class="title">UserInfo</span> </span>&#123;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">    public void testMethod()&#123;</span><br><span class="line">        <span class="type">Class</span> clazz = <span class="type">Student</span>.<span class="keyword">class</span>;</span><br><span class="line">        <span class="type">Annotation</span>[] annotations = clazz.getAnnotations();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Annotation</span> annotation : annotations) &#123;</span><br><span class="line">            <span class="type">System</span>.out.println(annotation.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>输出</li></ul><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxx.InheritedAnnotation(<span class="keyword">values</span>=[brand], number=<span class="number">100</span>)</span><br></pre></td></tr></table></figure><p>虽然Customer类没有显示地被注解@InheritedAnnotation，但是它的父类UserInfo被注解，而且@InheritedAnnotation被@Inherited注解，因此Customer类自动继承注解</p><h3 id="1-2-4-元注解-Repeatable-Java8"><a href="#1-2-4-元注解-Repeatable-Java8" class="headerlink" title="1.2.4 元注解 - @Repeatable (Java8)"></a>1.2.4 元注解 - @Repeatable (Java8)</h3><blockquote><p>Repeatable是可重复使用的意思，允许在同一声明的类型(类，属性，或方法)中，可以多次使用同一个注解</p></blockquote><p>JDK8之前要想实现注解重复使用，需要组合模式，编写和可读性都不是很好</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">public</span> @<span class="selector-tag">interface</span> <span class="selector-tag">Pet</span> &#123;</span><br><span class="line">     <span class="selector-tag">String</span> <span class="selector-tag">myPet</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">public</span> @<span class="selector-tag">interface</span> <span class="selector-tag">Pets</span> &#123;</span><br><span class="line">    <span class="selector-tag">Pet</span><span class="selector-attr">[]</span> <span class="selector-tag">value</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">class</span> <span class="selector-tag">RepeatAnnotationOV</span> &#123;</span><br><span class="line">    <span class="variable">@Pets</span>(&#123;<span class="variable">@Pet</span>(myPet=<span class="string">&quot;dog&quot;</span>),<span class="variable">@Pet</span>(myPet=<span class="string">&quot;cat&quot;</span>)&#125;)</span><br><span class="line">    public void <span class="built_in">workMethod</span>()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由另一个注解来存储重复注解，在使用时候，用存储注解Authorities来扩展重复注解。Java 8中的做法：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Repeatable</span>(Pets.class)</span><br><span class="line">public <span class="variable">@interface</span> Pet &#123;</span><br><span class="line">     <span class="selector-tag">String</span> <span class="selector-tag">myPet</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">public</span> @<span class="selector-tag">interface</span> <span class="selector-tag">Pets</span> &#123;</span><br><span class="line">    <span class="selector-tag">Pet</span><span class="selector-attr">[]</span> <span class="selector-tag">value</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">class</span> <span class="selector-tag">RepeatAnnotationNV</span> &#123;</span><br><span class="line">    <span class="variable">@Pet</span>(role=<span class="string">&quot;dog&quot;</span>)</span><br><span class="line">    <span class="variable">@Pet</span>(role=<span class="string">&quot;cat&quot;</span>)</span><br><span class="line">    public void <span class="built_in">workMethod</span>()&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同的地方是，创建重复注解Authority时，加上@Repeatable,指向存储注解Authorities，在使用时候，直接可以重复使用Authority注解。从上面例子看出，java 8里面做法更适合常规的思维，可读性强一点</p><h3 id="1-2-5-元注解-Native-Java8"><a href="#1-2-5-元注解-Native-Java8" class="headerlink" title="1.2.5 元注解 - @Native (Java8)"></a>1.2.5 元注解 - @Native (Java8)</h3><p>使用 @Native 注解修饰成员变量，则表示这个变量可以被本地代码引用，常常被代码生成工具使用。对于 @Native 注解不常使用，了解即可</p><h2 id="1-3-注解与反射接口"><a href="#1-3-注解与反射接口" class="headerlink" title="1.3 注解与反射接口"></a>1.3 注解与反射接口</h2><blockquote><p>定义注解后，如何获取注解中的内容呢？反射包java.lang.reflect下的AnnotatedElement接口提供这些方法。这里注意：只有注解被定义为RUNTIME后，该注解才能是运行时可见，当class文件被装载时被保存在class文件中的Annotation才会被虚拟机读取。</p></blockquote><p>AnnotatedElement 接口是所有程序元素（Class、Method和Constructor）的父接口，所以程序通过反射获取了某个类的AnnotatedElement对象之后，程序就可以调用该对象的方法来访问Annotation信息。我们看下具体的先关接口</p><ul><li>boolean isAnnotationPresent(Class&lt;?extends Annotation&gt; annotationClass)<br>判断该程序元素上是否包含指定类型的注解，存在则返回true，否则返回false。注意：此方法会忽略注解对应的注解容器。</li><li>T getAnnotation(Class annotationClass)<br>返回该程序元素上存在的、指定类型的注解，如果该类型注解不存在，则返回null。</li><li>Annotation[] getAnnotations()<br>返回该程序元素上存在的所有注解，若没有注解，返回长度为0的数组。</li><li>T[] getAnnotationsByType(Class annotationClass)<br>返回该程序元素上存在的、指定类型的注解数组。没有注解对应类型的注解时，返回长度为0的数组。该方法的调用者可以随意修改返回的数组，而不会对其他调用者返回的数组产生任何影响。getAnnotationsByType方法与 getAnnotation的区别在于，getAnnotationsByType会检测注解对应的重复注解容器。若程序元素为类，当前类上找不到注解，且该注解为可继承的，则会去父类上检测对应的注解。</li><li>T getDeclaredAnnotation(Class annotationClass)<br>返回直接存在于此元素上的所有注解。与此接口中的其他方法不同，该方法将忽略继承的注释。如果没有注释直接存在于此元素上，则返回null</li><li>T[] getDeclaredAnnotationsByType(Class annotationClass)<br>返回直接存在于此元素上的所有注解。与此接口中的其他方法不同，该方法将忽略继承的注释</li><li>Annotation[] getDeclaredAnnotations()<br>返回直接存在于此元素上的所有注解及注解对应的重复注解容器。与此接口中的其他方法不同，该方法将忽略继承的注解。如果没有注释直接存在于此元素上，则返回长度为零的一个数组。该方法的调用者可以随意修改返回的数组，而不会对其他调用者返回的数组产生任何影响。</li></ul><h2 id="1-4-自定义注解"><a href="#1-4-自定义注解" class="headerlink" title="1.4 自定义注解"></a>1.4 自定义注解</h2><blockquote><p>当我们理解了内置注解, 元注解和获取注解的反射接口后，我们便可以开始自定义注解了。这个例子我把上述的知识点全部融入进来, 代码很简单：</p></blockquote><ul><li><em><strong>定义自己的注解</strong></em></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.helenlyn.common.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Description: 水果供应者注解        &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Copyright: Copyright (c) 2021 &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Company: helenlyn Co., Ltd.             &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Update Time:                      &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Updater:                          &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Update Comments:                  &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FruitProvider &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 供应商编号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">id</span><span class="params">()</span> <span class="keyword">default</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 供应商名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 供应商地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">address</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><em><strong>使用注解</strong></em></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.helenlyn.common.dto;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.helenlyn.common.<span class="keyword">annotation</span>.FruitColor;</span><br><span class="line"><span class="keyword">import</span> com.helenlyn.common.<span class="keyword">annotation</span>.FruitName;</span><br><span class="line"><span class="keyword">import</span> com.helenlyn.common.<span class="keyword">annotation</span>.FruitProvider;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Description:               &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Copyright: Copyright (c) 2021 &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Company: helenlyn Co., Ltd.             &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Update Time:                      &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Updater:                          &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Update Comments:                  &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppleDto</span> &#123;</span><br><span class="line">   <span class="meta">@FruitName(<span class="string">&quot;Apple&quot;</span>)</span></span><br><span class="line">    <span class="keyword">private</span> String appleName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@FruitColor(fruitColor=FruitColor.Color.RED)</span></span><br><span class="line">    <span class="keyword">private</span> String appleColor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@FruitProvider(id=1,name=<span class="string">&quot;helenlyn 贸易公司&quot;</span>,address=<span class="string">&quot;福州xx路xxx大楼&quot;</span>)</span></span><br><span class="line">    <span class="keyword">private</span> String appleProvider;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><em><strong>用反射接口获取注解信息</strong></em><br>在 FruitInfoUtil 中进行测试：</li></ul><figure class="highlight php-template"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml">/**</span></span><br><span class="line"><span class="language-xml"> * <span class="tag">&lt;<span class="name">p</span>&gt;</span>Description: FruitInfoUtil注解实现 <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"> * <span class="tag">&lt;<span class="name">p</span>&gt;</span>Copyright: Copyright (c) 2021 <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"> * <span class="tag">&lt;<span class="name">p</span>&gt;</span>Company: helenlyn Co., Ltd.             <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"> * <span class="tag">&lt;<span class="name">p</span>&gt;</span>Update Time:                      <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"> * <span class="tag">&lt;<span class="name">p</span>&gt;</span>Updater:                          <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"> * <span class="tag">&lt;<span class="name">p</span>&gt;</span>Update Comments:                  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"> */</span></span><br><span class="line"><span class="language-xml">public class FruitInfoUtil &#123;</span></span><br><span class="line"><span class="language-xml">    public static String getFruitInfo(Class</span><span class="language-php"><span class="meta">&lt;?</span>&gt; clazz) &#123;</span></span><br><span class="line"><span class="language-php">        String strFruitName = <span class="string">&quot; 水果名称：&quot;</span>;</span></span><br><span class="line"><span class="language-php">        String strFruitColor = <span class="string">&quot; 水果颜色：&quot;</span>;</span></span><br><span class="line"><span class="language-php">        String strFruitProvicer = <span class="string">&quot;供应商信息：&quot;</span>;</span></span><br><span class="line"><span class="language-php"></span></span><br><span class="line"><span class="language-php">        Field[] fields = clazz.<span class="title function_ invoke__">getDeclaredFields</span>();</span></span><br><span class="line"><span class="language-php"></span></span><br><span class="line"><span class="language-php">        <span class="keyword">for</span> (Field field : fields) &#123;</span></span><br><span class="line"><span class="language-php">            <span class="keyword">if</span> (field.<span class="title function_ invoke__">isAnnotationPresent</span>(FruitName.<span class="keyword">class</span>)) &#123;</span></span><br><span class="line"><span class="language-php">                FruitName fruitName = (FruitName) field.<span class="title function_ invoke__">getAnnotation</span>(FruitName.<span class="keyword">class</span>);</span></span><br><span class="line"><span class="language-php">                strFruitName += fruitName.<span class="title function_ invoke__">value</span>();</span></span><br><span class="line"><span class="language-php">                System.out.<span class="title function_ invoke__">println</span>(strFruitName);</span></span><br><span class="line"><span class="language-php">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (field.<span class="title function_ invoke__">isAnnotationPresent</span>(FruitColor.<span class="keyword">class</span>)) &#123;</span></span><br><span class="line"><span class="language-php">                FruitColor fruitColor = (FruitColor) field.<span class="title function_ invoke__">getAnnotation</span>(FruitColor.<span class="keyword">class</span>);</span></span><br><span class="line"><span class="language-php">                strFruitColor += fruitColor.<span class="title function_ invoke__">fruitColor</span>().<span class="title function_ invoke__">toString</span>();</span></span><br><span class="line"><span class="language-php">                System.out.<span class="title function_ invoke__">println</span>(strFruitColor);</span></span><br><span class="line"><span class="language-php">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (field.<span class="title function_ invoke__">isAnnotationPresent</span>(FruitProvider.<span class="keyword">class</span>)) &#123;</span></span><br><span class="line"><span class="language-php">                FruitProvider fruitProvider = (FruitProvider) field.<span class="title function_ invoke__">getAnnotation</span>(FruitProvider.<span class="keyword">class</span>);</span></span><br><span class="line"><span class="language-php">                strFruitProvicer = <span class="string">&quot; 供应商编号：&quot;</span> + fruitProvider.<span class="title function_ invoke__">id</span>() + <span class="string">&quot; 供应商名称：&quot;</span> + fruitProvider.<span class="title function_ invoke__">name</span>() + <span class="string">&quot; 供应商地址：&quot;</span> + fruitProvider.<span class="title function_ invoke__">address</span>();</span></span><br><span class="line"><span class="language-php">                System.out.<span class="title function_ invoke__">println</span>(strFruitProvicer);</span></span><br><span class="line"><span class="language-php">            &#125;</span></span><br><span class="line"><span class="language-php">        &#125;</span></span><br><span class="line"><span class="language-php">        <span class="keyword">return</span> String.<span class="title function_ invoke__">format</span>(<span class="string">&quot;%s;%s;%s;&quot;</span>, strFruitName, strFruitColor, strFruitProvicer);</span></span><br><span class="line"><span class="language-php">    &#125;</span></span><br><span class="line"><span class="language-php">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><em><strong>测试的输出</strong></em></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2022</span><span class="number">-07</span><span class="number">-09</span> <span class="number">11</span>:<span class="number">33</span>:<span class="number">41.688</span>  INFO <span class="number">5895</span> <span class="comment">--- [TaskExecutor-35] o.s.a.r.c.CachingConnectionFactory       : Attempting to connect to: cl-debug-rabbitmq-erp-service-7w0cpa.docker.sdp:9146</span></span><br><span class="line">Hibernate: <span class="keyword">update</span> UserBasicInfo <span class="keyword">set</span> personName<span class="operator">=</span>? <span class="keyword">where</span> personCode<span class="operator">=</span>?</span><br><span class="line"> 水果名称：Apple</span><br><span class="line"> 水果颜色：RED</span><br><span class="line"> 供应商编号：<span class="number">1</span> 供应商名称：helenlyn 贸易公司 供应商地址：福州xx路xxx大楼</span><br></pre></td></tr></table></figure><h1 id="2-理解注解的原理"><a href="#2-理解注解的原理" class="headerlink" title="2 理解注解的原理"></a>2 理解注解的原理</h1><h1 id="2-1-Java-8-提供了哪些新的注解"><a href="#2-1-Java-8-提供了哪些新的注解" class="headerlink" title="2.1 Java 8 提供了哪些新的注解"></a>2.1 Java 8 提供了哪些新的注解</h1><ul><li>@Repeatable</li><li>ElementType.TYPE_USE</li><li>ElementType.TYPE_PARAMETER</li></ul><p>ElementType.TYPE_USE(此类型包括类型声明和类型参数声明，是为了方便设计者进行类型检查)包含了ElementType.TYPE(类、接口（包括注解类型）和枚举的声明)和ElementType.TYPE_PARAMETER(类型参数声明), 可以看下面这个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义ElementType.TYPE_PARAMETER注解</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE_PARAMETER)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyNotEmpty &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义ElementType.TYPE_USE注解</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE_USE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyNotNull &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TypeParameterAndTypeUseAnnotation</span>&lt;<span class="meta">@MyNotEmpty</span> T&gt;&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//使用TYPE_PARAMETER类型，会编译不通过</span></span><br><span class="line"><span class="comment">//public @MyNotEmpty T test(@MyNotEmpty T a)&#123;</span></span><br><span class="line"><span class="comment">//new ArrayList&lt;@MyNotEmpty String&gt;();</span></span><br><span class="line"><span class="comment">//return a;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//使用TYPE_USE类型，编译通过</span></span><br><span class="line">  <span class="keyword">public</span> <span class="meta">@MyNotNull</span> T <span class="title function_">test2</span><span class="params">(<span class="meta">@MyNotNull</span> T a)</span>&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;<span class="meta">@MyNotNull</span> String&gt;();</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-注解支持继承吗？"><a href="#2-2-注解支持继承吗？" class="headerlink" title="2.2 注解支持继承吗？"></a>2.2 注解支持继承吗？</h2><blockquote><ul><li>注解是不支持继承的</li><li>不能使用关键字extends来继承某个@interface，但注解在编译后，编译器会自动继java.lang.annotation.Annotation接口。虽然反编译后发现注解继承了Annotation接口，请记住，即使Java的接口可以实现多继承，但定义注解时依然无法使用extends关键字继承@interface。 区别于注解的继承，被注解的子类继承父类注解可以用@Inherited： 如果某个类使用了被@Inherited修饰的Annotation，则其子类将自动具有该注解。</li></ul></blockquote><h1 id="3-注解的应用场景"><a href="#3-注解的应用场景" class="headerlink" title="3 注解的应用场景"></a>3 注解的应用场景</h1><h2 id="自定义注解和AOP-通过切面实现解耦"><a href="#自定义注解和AOP-通过切面实现解耦" class="headerlink" title="自定义注解和AOP - 通过切面实现解耦"></a>自定义注解和AOP - 通过切面实现解耦</h2><blockquote><p>笔者曾经在 《<a href="https://www.cnblogs.com/wzh2010/p/15023339.html">基于AOP的动态数据源切换</a>》 这篇文章中有个典型的例子，就是使用AOP切面来对多数据源进行使用场景的切换，下面展示下如何通过注解实现解耦的。</p></blockquote><ul><li><em><strong>自定义Annotation，映射的目标范围为 类型和方法。</strong></em></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 数据源切换注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(&#123; ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DataSource &#123;</span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><em><strong>编写AOP实现,切面代码，以实现对注解的PointCut,切点拦截</strong></em></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceAspect</span> <span class="keyword">implements</span> <span class="title class_">Ordered</span>  &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个切入点，匹配到上面的注解DataSource</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;@annotation(com.helenlyn.dataassist.annotation.DataSource)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dataSourcePointCut</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Around 环绕方式做切面注入</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> point</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Around(&quot;dataSourcePointCut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint point)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">MethodSignature</span> <span class="variable">signature</span> <span class="operator">=</span> (MethodSignature) point.getSignature();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> signature.getMethod();</span><br><span class="line">        <span class="type">DataSource</span> <span class="variable">ds</span> <span class="operator">=</span> method.getAnnotation(DataSource.class);</span><br><span class="line">        <span class="type">String</span> <span class="variable">routeKey</span> <span class="operator">=</span> ds.name();  <span class="comment">// 从头部中取出注解的name（basic 或 cloudoffice 或 attend），用这个name进行数据源查找。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">dataSourceRouteKey</span> <span class="operator">=</span> DynamicDataSourceRouteHolder.getDataSourceRouteKey();</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotEmpty(dataSourceRouteKey)) &#123;</span><br><span class="line">            <span class="comment">// StringBuilder currentRouteKey = new StringBuilder(dataSourceRouteKey);</span></span><br><span class="line">            routeKey = ds.name();</span><br><span class="line">        &#125;</span><br><span class="line">        DynamicDataSourceRouteHolder.setDataSourceRouteKey(routeKey);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> point.proceed();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123; <span class="comment">// 最后做清理，这个步骤很重要，因为我们的配置中有一个默认的数据源，执行完要回到默认的数据源。</span></span><br><span class="line">            DynamicDataSource.clearDataSource();</span><br><span class="line">            DynamicDataSourceRouteHolder.clearDataSourceRouteKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><em><strong>测试，在Control中写三个测试方法</strong></em></li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无注解默认情况：数据源指向basic</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="variable">@RequestMapping</span>(value = <span class="string">&quot;/default/&#123;user_code&#125;&quot;</span>, method = RequestMethod.GET)</span><br><span class="line">    public UserInfoDto <span class="built_in">getUserInfo</span>(<span class="variable">@PathVariable</span>(<span class="string">&quot;user_code&quot;</span>) String userCode) &#123;</span><br><span class="line">        <span class="selector-tag">return</span> <span class="selector-tag">userInfoService</span><span class="selector-class">.getUserInfo</span>(userCode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据源指向attend</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    @<span class="selector-tag">DataSource</span>(name= Constant.DATA_SOURCE_ATTEND_NAME)</span><br><span class="line">    @<span class="selector-tag">RequestMapping</span>(value = <span class="string">&quot;/attend/&#123;user_code&#125;&quot;</span>, method = RequestMethod.GET)</span><br><span class="line">    <span class="selector-tag">public</span> <span class="selector-tag">UserInfoDto</span> <span class="selector-tag">getUserInfoAttend</span>(<span class="variable">@PathVariable</span>(<span class="string">&quot;user_code&quot;</span>) String userCode) &#123;</span><br><span class="line">        <span class="selector-tag">return</span> <span class="selector-tag">userInfoService</span><span class="selector-class">.getUserInfo</span>(userCode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据源指向cloud</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    @<span class="selector-tag">DataSource</span>(name= Constant.DATA_SOURCE_CLOUD_NAME)</span><br><span class="line">    @<span class="selector-tag">RequestMapping</span>(value = <span class="string">&quot;/cloud/&#123;user_code&#125;&quot;</span>, method = RequestMethod.GET)</span><br><span class="line">    <span class="selector-tag">public</span> <span class="selector-tag">UserInfoDto</span> <span class="selector-tag">getUserInfoCloud</span>(<span class="variable">@PathVariable</span>(<span class="string">&quot;user_code&quot;</span>) String userCode) &#123;</span><br><span class="line">        <span class="selector-tag">return</span> <span class="selector-tag">userInfoService</span><span class="selector-class">.getUserInfo</span>(userCode);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>执行效果<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAO1aUaYPT2B-r5FFaxTa9UDaphH5YUAAkILaxvRfjhWgBzNBUcmMgMBAAMCAAN4AAM2BA.png"><br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAO0aUaYFr4FzOH-jB1_7TJCFHPIFWUAAj8LaxvRfjhWOUWtLCQxXOsBAAMCAAN4AAM2BA.png"><br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAO2aUaYR6kvTdhTCncm9BrkqmudIV8AAkQLaxvRfjhWusSK9H2hlQgBAAMCAAN4AAM2BA.png"></li></ul><blockquote><p>除此之外，我们可以看到很多日志管理、权限管理，也都是也是通过类似的注解机制来实现的，通过注解+AOP来最终实现模块之间的解耦，以及业务与系统层面的解耦 。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java核心系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java核心 </tag>
            
            <tag> Java基础 </tag>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java核心系列3：异常机制详解</title>
      <link href="/2025/02/18/Java%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/Java%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%863-%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6/"/>
      <url>/2025/02/18/Java%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/Java%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%863-%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="1-什么是异常"><a href="#1-什么是异常" class="headerlink" title="1 什么是异常"></a>1 什么是异常</h1><p>异常是指程序在运行过程中发生的，由于外部问题导致的运行异常事件，如：文件找不到、网络连接失败、空指针、非法参数等。异常是一个事件，它发生在程序运行期间，且中断程序的运行。Java 是一种面向对象的编程语言，它的异常都是对象，是Throwable子类的实例，当程序中存在错误条件时，且条件生成时，错误就会引发异常。</p><h1 id="2-异常的分类"><a href="#2-异常的分类" class="headerlink" title="2 异常的分类"></a>2 异常的分类</h1><p>要了解异常的分类，我们先看看Java异常类的继承结构图：<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAO4aUaaC7RpB2BfX5nQpndSuAtRZxYAAlMLaxvRfjhWbxOERJ73DLwBAAMCAAN4AAM2BA.png"></p><h2 id="2-1-Throwable"><a href="#2-1-Throwable" class="headerlink" title="2.1 Throwable"></a>2.1 Throwable</h2><p>Throwable 是 Java 语言中所有错误与异常的顶层父类，其他类都继承于该类。 Throwable 包含两个子类：Error（错误）和Exception（异常），它们通常用于指示发生了异常情况。 Throwable 包含了其线程创建时线程执行堆栈的快照，它提供printStackTrace() 等接口用于获取堆栈跟踪数据等信息。</p><h2 id="2-2-Error（错误）"><a href="#2-2-Error（错误）" class="headerlink" title="2.2 Error（错误）"></a>2.2 Error（错误）</h2><p>Error 类及其子类：程序中无法处理的错误，表示运行应用程序中出现了严重的错误。通常情况为下应用程序 <strong>“不应该试图捕获的严重问题”</strong> 。此类错误一般表示代码运行时 JVM 出现问题。通常有 Virtual MachineError（虚拟机运行错误）、NoClassDefFoundError（类定义错误）等。比如 OutOfMemoryError：内存不足错误；StackOverflowError：栈溢出错误。这些错误是不可查的，因为它们在应用程序的控制和处理能力之 外，而且绝大多数是程序运行时不允许出现的状况。在 Java中，错误通过Error的子类描述。</p><h2 id="2-3-Exception（异常）"><a href="#2-3-Exception（异常）" class="headerlink" title="2.3 Exception（异常）"></a>2.3 Exception（异常）</h2><p>Exception以及它的子类，代表程序运行时发送的各种不期望发生的事件。可以被Java异常处理机制使用，是异常处理的核心。Exception 这种异常又分为两类：运行时异常和编译时异常。</p><h3 id="2-3-1-运行时异常"><a href="#2-3-1-运行时异常" class="headerlink" title="2.3.1 运行时异常"></a>2.3.1 运行时异常</h3><p>都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。 运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。</p><h3 id="2-3-2-非运行时异常-（编译异常）"><a href="#2-3-2-非运行时异常-（编译异常）" class="headerlink" title="2.3.2 非运行时异常 （编译异常）"></a>2.3.2 非运行时异常 （编译异常）</h3><p>是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。</p><h3 id="2-3-3-检查性异常（checked-exception）"><a href="#2-3-3-检查性异常（checked-exception）" class="headerlink" title="2.3.3 检查性异常（checked exception）"></a>2.3.3 检查性异常（checked exception）</h3><p>正确的程序在运行中，很容易出现的、情理可容的异常状况。可查异常虽然是异常状况，但在一定程度上它的发生是可以预计的，而且一旦发生这种异常状况，就必须采取某种方式进行处理。除了Error 和 RuntimeException的其它异常。Java语言强制要求程序员为这样的异常做预备处理工作（使用try…catch…finally或者throws）。在方法中要么用try-catch语句捕获它并处理，要么用throws子句声明抛出它，否则编译不会通过。类似如SQLException，IOException，ClassNotFoundException 等。<br>常见的检查性异常如下：</p><table><thead><tr><th>异常</th><th>描述</th></tr></thead><tbody><tr><td>Classnotfoundexception</td><td>当应用程序试图加数一个,通过名字查找时超发现没有该的定义时,抛出该异常</td></tr><tr><td>Clonenotsupportedexcept</td><td>当去克一个对象时,发现该对象没有实现Cloneable接口时,抛出该异常</td></tr><tr><td>lllegalaccessexception</td><td>当应用程序芸试通过反射的方式来访间类、成员变量或调用方法时,却无法访问这些类、成员变量或方法的定义时,抛出该异常</td></tr><tr><td>Instantiationexception</td><td>当试图使用 Class:类中的 newinstance方法創建一个类的实例,而制定的类对象因为是一个接口或是一个抽象类而无法实例化时,抛出该异常</td></tr><tr><td>Interruptedexception</td><td>个线程被另一个线程中断时,抛出该异常</td></tr><tr><td>NosuchFieldexception</td><td>当拢不到指定的变量字段时,抛出该异常</td></tr><tr><td>NosuchMethodexception</td><td>当我不到指定的类方法时,抛出该异常</td></tr></tbody></table><h3 id="2-3-4-非检查性异常-checked-exception"><a href="#2-3-4-非检查性异常-checked-exception" class="headerlink" title="2.3.4 非检查性异常(checked exception)"></a>2.3.4 非检查性异常(checked exception)</h3><p>包括运行时异常（RuntimeException与其子类）和错误（Error）及其子类。Java语言在编译时，不会提示和发现这样的异常，不要求在程序中处理这些异常。所以我们可以在程序中编写代码来处理（使用try…catch…finally）这样的异常，也可以不做任何处理。但是这种错误或异常，一般来说是程序逻辑错误导致的异常，所以我们应该修正代码，而不是通过异常处理器处理。<br>常见的非检查性异常如下：</p><table><thead><tr><th>异常</th><th>描述</th></tr></thead><tbody><tr><td>Arithmeticexception</td><td>当出现异常的运算条件时,抛出异常。例如,一个整数“除以零”时,抛出此美的一个实例</td></tr><tr><td>Arrayindexoutofboundsexcep</td><td>用非法索引访问数组时跑出的异常。如果索引为负或大于等于数组大小,则该索引为非法索引异常描述</td></tr><tr><td>Arraystoreexception</td><td>试图将错误类型的对象存储到一个对象数组时,抛出的异常</td></tr><tr><td>Classcastexception</td><td>试图将对象强制转换为不是同一个类型或其子类的实例时,抛出的异常</td></tr><tr><td>Illegalargumentexception</td><td>当向一个方法传递非法或不正确的参数时,抛出该异常</td></tr><tr><td>IllegalmonitorstateException</td><td>当某一线程已经试图等待对象的监视器,或者通知其他正在等待该对象监视器的线程,而该线程本身没有获得指定监视器时抛出该异常</td></tr><tr><td>Illegalstateexception</td><td>在非法或不适当的时间调用方法时产生的信号。或者说Java环境或应用程序没有处于请求操作所要求的适当状态下</td></tr><tr><td>IllegalthreadstateException</td><td>线程没有处于请求操作所要求的适当状态时,抛出该异常。</td></tr><tr><td>Indexoutofboundsexception</td><td>当某种排序的索引超出范围时抛出的异常,例如,一个数组,字符串或一个向量的排序等</td></tr><tr><td>Negativearraysizeexception</td><td>如果应用程序试图创建大小为负的数组时,抛出该异常</td></tr><tr><td>Nullpointerexception</td><td>当应用程序在需要操作对象的时候而获得的对象实例是nu时抛出该异常</td></tr><tr><td>Numberformatexception</td><td>当应用程序试图将字符串转换成一种数值类型,但该字符串不能转换为适当格式时,抛出该异常。</td></tr><tr><td>SecurityException</td><td>由安全管理器抛出的异常,指示存在安全侵犯。</td></tr><tr><td>StringindexoutofboundsExcept</td><td>此异常由 String方法抛出,说明索引为负或者超出了字符串的大小</td></tr></tbody></table><h1 id="3-异常基础详解"><a href="#3-异常基础详解" class="headerlink" title="3 异常基础详解"></a>3 异常基础详解</h1><h2 id="3-1-异常关键字"><a href="#3-1-异常关键字" class="headerlink" title="3.1 异常关键字"></a>3.1 异常关键字</h2><ol><li>try – 用于监听。<br>将要被监听的代码(可能抛出异常的代码)放在try语句块之内，当try语句块内发生异常时，异常就被抛出。</li><li>catch – 用于捕获异常。<br>catch用来捕获try语句块中发生的异常。</li><li>finally – finally语句块总是会被执行。<br>它主要用于回收在try块里打开的物力资源(如数据库连接、网络连接和磁盘文件)。只有finally块，执行完成之后，才会回来执行try或者catch块中的return或者throw语句，如果finally中使用了return或者throw等终止方法的语句，则就不会跳回执行，直接停止。</li><li>throw – 用于抛出异常。</li><li>throws – 用在方法签名中，用于声明该方法可能抛出的异常。</li></ol><h2 id="3-2-throws-异常的显示声明"><a href="#3-2-throws-异常的显示声明" class="headerlink" title="3.2 throws-异常的显示声明"></a>3.2 throws-异常的显示声明</h2><p>在Java中，当前执行的语句必属于某个方法，Java解释器调用main方法执行开始执行程序。若方法中存在检查异常，如果不对其捕获，那必须在方法头中显式声明该异常，以便于告知方法调用者此方法有异常，需要进行处理。 在方法中声明一个异常，方法头中使用关键字throws，后面接上要声明的异常。若声明多个异常，则使用逗号分割。如下所示：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">yourMethod</span>() throws Exception</span>&#123;</span><br><span class="line">    <span class="comment">//todo  业务逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：若是父类的方法没有声明异常，则子类继承方法后，也不能声明异常。</p></blockquote><p>通常，应该捕获那些知道如何处理的异常，将不知道如何处理的异常继续传递下去。传递异常可以在方法签名处使用 throws 关键字声明可能会抛出的异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">(String filePath)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filePath);</span><br><span class="line">    String result;</span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(file));</span><br><span class="line">    <span class="keyword">while</span>((result = reader.readLine())!=<span class="literal">null</span>) &#123;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">    reader.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Throws抛出异常的规则：</p><ul><li>如果是不可查异常（unchecked exception），即Error、RuntimeException或它们的子类，那么可以不使用throws关键字来声明要抛出的异常，编译仍能顺利通过，但在运行时会被系统抛出。</li><li>必须声明方法可抛出的任何可查异常（checked exception）。即如果一个方法可能出现受可查异常，要么用try-catch语句捕获，要么用throws子句声明将它抛出，否则会导致编译错误</li><li>仅当抛出了异常，该方法的调用者才必须处理或者重新抛出该异常。当方法的调用者无力处理该异常的时候，应该继续抛出，而不是囫囵吞枣。</li><li>调用方法必须遵循任何可查异常的处理和声明规则。若覆盖一个方法，则不能声明与覆盖方法不同的异常。声明的任何异常必须是被覆盖方法所声明异常的同类或子类。</li></ul><h2 id="3-3-throw-抛出异常"><a href="#3-3-throw-抛出异常" class="headerlink" title="3.3 throw-抛出异常"></a>3.3 throw-抛出异常</h2><p>如果代码可能会引发某种错误，可以创建一个合适的异常类实例并抛出它，这就是抛出异常。如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">double</span> <span class="title">yourMethod</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(value &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">ArithmeticException</span>(<span class="string">&quot;参数不能为0&quot;</span>); <span class="comment">//抛出一个运行时异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">6.0</span> / value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大部分情况下都不需要手动抛出异常，因为Java的大部分方法要么已经处理异常，要么已声明异常。所以一般都是捕获异常或者再往上抛。有时我们会从 catch 中抛出一个异常，目的是为了改变异常的类型。多用于在多系统集成时，当某个子系统故障，异常类型可能有多种，可以用统一的异常类型向外暴露，不需暴露太多内部异常细节。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">(String filePath)</span> <span class="keyword">throws</span> MyException &#123;    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// code</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="type">MyException</span> <span class="variable">ex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(<span class="string">&quot;read file failed.&quot;</span>);</span><br><span class="line">        ex.initCause(e);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4-异常的自定义"><a href="#3-4-异常的自定义" class="headerlink" title="3.4 异常的自定义"></a>3.4 异常的自定义</h2><p>习惯上，定义一个异常类应包含两个构造函数，一个无参构造函数和一个带有详细描述信息的构造函数（Throwable 的 toString 方法会打印这些详细信息，调试时很有用）, 比如上面用到的自定义MyException：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    public <span class="type">MyException</span>()&#123; &#125;</span><br><span class="line">    public <span class="type">MyException</span>(<span class="type">String</span> msg)&#123;</span><br><span class="line">        <span class="keyword">super</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-5-异常的捕获"><a href="#3-5-异常的捕获" class="headerlink" title="3.5 异常的捕获"></a>3.5 异常的捕获</h2><p>异常捕获处理的方法通常有：</p><ul><li>try-catch</li><li>try-catch-finally</li><li>try-finally</li><li>try-with-resource</li></ul><h3 id="3-5-1-try-catch"><a href="#3-5-1-try-catch" class="headerlink" title="3.5.1 try-catch"></a>3.5.1 try-catch</h3><p>在一个 try-catch 语句块中可以捕获多个异常类型，并对不同类型的异常做出不同的处理</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">readFile</span>(<span class="params"><span class="title class_">String</span> filePath</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// code</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="title class_">FileNotFoundException</span> e) &#123;</span><br><span class="line">        <span class="comment">// handle FileNotFoundException</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="title class_">IOException</span> e)&#123;</span><br><span class="line">        <span class="comment">// handle IOException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同一个 catch 也可以捕获多种类型异常，用 | 隔开</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">readFile</span>(<span class="params"><span class="title class_">String</span> filePath</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// code</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="title class_">FileNotFoundException</span> | <span class="title class_">UnknownHostException</span> e) &#123;</span><br><span class="line">        <span class="comment">// handle FileNotFoundException or UnknownHostException</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="title class_">IOException</span> e)&#123;</span><br><span class="line">        <span class="comment">// handle IOException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-2-try-catch-finally"><a href="#3-5-2-try-catch-finally" class="headerlink" title="3.5.2 try-catch-finally"></a>3.5.2 try-catch-finally</h3><ul><li>常规语法</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;                        </span><br><span class="line">    <span class="comment">//执行程序代码，可能会出现异常                 </span></span><br><span class="line">&#125; <span class="keyword">catch</span>(<span class="built_in">Exception</span> e) &#123;   </span><br><span class="line">    <span class="comment">//捕获异常并处理   </span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//必执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>执行的顺序<ul><li>当try没有捕获到异常时：try语句块中的语句逐一被执行，程序将跳过catch语句块，执行finally语句块和其后的语句；</li><li>当try捕获到异常，catch语句块里没有处理此异常的情况：当try语句块里的某条语句出现异常时，而没有处理此异常的catch语句块时，此异常将会抛给JVM处理，finally语句块里的语句还是会被执行，但finally语句块后的语句不会被执行；</li><li>当try捕获到异常，catch语句块里有处理此异常的情况：在try语句块中是按照顺序来执行的，当执行到某一条语句出现异常时，程序将跳到catch语句块，并与catch语句块逐一匹配，找到与之对应的处理程序，其他的catch语句块将不会被执行，而try语句块中，出现异常之后的语句也不会被执行，catch语句块执行完后，执行finally语句块里的语句，最后执行finally语句块后的语句；</li></ul></li><li>无异常情况 ，catch 模块被忽略，先执行业务逻辑，再执行finally。<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAO5aUaaUxryh8ibOFf1dh3ra5ZswfEAAlULaxvRfjhWm3vR_WWHDfIBAAMCAAN4AAM2BA.png"></li><li>异常情况，假设执行到业务逻辑2的时候，出现故障异常，则业务逻辑3没有执行，直接执行catch，最后再执行finally。<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAO6aUaaY7SdxqnLvUOXVJZUOeatOsoAAlYLaxvRfjhWavP1YELob6cBAAMCAAN4AAM2BA.png"></li><li>一个完整的例子</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">(String filePath)</span> <span class="keyword">throws</span> MyException &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filePath);</span><br><span class="line">    String result;</span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        reader = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(file));</span><br><span class="line">        <span class="keyword">while</span>((result = reader.readLine())!=<span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;readFile method catch block.&quot;</span>);</span><br><span class="line">        <span class="type">MyException</span> <span class="variable">ex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(<span class="string">&quot;read file failed.&quot;</span>);</span><br><span class="line">        ex.initCause(e);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;readFile method finally block.&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != reader) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                reader.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-3-try-finally"><a href="#3-5-3-try-finally" class="headerlink" title="3.5.3 try-finally"></a>3.5.3 try-finally</h3><p>也可以直接用try-finally吗。try块中引起异常，异常代码之后的语句不再执行，直接执行finally语句。try块没有引发异常，则执行完try块就执行finally语句。 try-finally可用在不需要捕获异常的代码，可以保证资源在使用后被关闭。例如IO流中执行完相应操作后，关闭相应资源；使用Lock对象保证线程同步，通过finally可以保证锁会被释放；数据库连接代码时，关闭连接操作等等。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以Lock加锁为例，演示try-finally</span></span><br><span class="line">ReentrantLock <span class="keyword">lock</span> = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//需要加锁的代码</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">lock</span>.unlock(); <span class="comment">//保证锁一定被释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>finally遇见如下情况不会执行</p><ul><li>在前面的代码中用了System.exit()退出程序。</li><li>finally语句块中发生了异常。</li><li>程序所在的线程死亡。</li><li>关闭CPU。</li></ul><h3 id="3-5-4-try-with-resource"><a href="#3-5-4-try-with-resource" class="headerlink" title="3.5.4 try-with-resource"></a>3.5.4 try-with-resource</h3><p>上面例子中，finally 中的 close 方法也可能抛出 IOException, 从而覆盖了原始异常。JAVA 7 提供了更优雅的方式来实现资源的自动释放，自动释放的资源需要是实现了 AutoCloseable 接口的类。</p><ul><li>代码实现</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tryWithResourceTest</span>()</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (Scanner scanner = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;c:/abc&quot;</span>),<span class="string">&quot;UTF-8&quot;</span>))&#123;</span><br><span class="line">        <span class="comment">// code</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        <span class="comment">// handle exception</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>看下Scanner</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Scanner</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;String&gt;, Closeable &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Closeable</span> <span class="keyword">extends</span> <span class="title class_">AutoCloseable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>try 代码块退出时，会自动调用 scanner.close 方法，和把 scanner.close 方法放在 finally 代码块中不同的是，若 scanner.close 抛出异常，则会被抑制，抛出的仍然为原始异常。被抑制的异常会由 addSusppressed 方法添加到原来的异常，如果想要获取被抑制的异常列表，可以调用 getSuppressed 方法来获取。</p><h2 id="3-6-异常总结"><a href="#3-6-异常总结" class="headerlink" title="3.6 异常总结"></a>3.6 异常总结</h2><ul><li>try、catch和finally都不能单独使用，只能是try-catch、try-finally或者try-catch-finally。</li><li>try语句块监控代码，出现异常就停止执行下面的代码，然后将异常移交给catch语句块来处理。</li><li>finally语句块中的代码一定会被执行，常用于回收资源 。</li><li>throws：声明一个异常，告知方法调用者。</li><li>throw ：抛出一个异常，至于该异常被捕获还是继续抛出都与它无关。<br>Java编程思想一书中，对异常的总结。</li><li>在恰当的级别处理问题。（在知道该如何处理的情况下了捕获异常。）</li><li>解决问题并且重新调用产生异常的方法。</li><li>进行少许修补，然后绕过异常发生的地方继续执行。</li><li>用别的数据进行计算，以代替方法预计会返回的值。</li><li>把当前运行环境下能做的事尽量做完，然后把相同的异常重抛到更高层。</li><li>把当前运行环境下能做的事尽量做完，然后把不同的异常抛到更高层。</li><li>终止程序。</li><li>进行简化（如果你的异常模式使问题变得太复杂，那么用起来会非常痛苦）。</li><li>让类库和程序更安全。</li></ul><h2 id="3-7-常用的异常"><a href="#3-7-常用的异常" class="headerlink" title="3.7 常用的异常"></a>3.7 常用的异常</h2><p>在Java中提供了一些异常用来描述经常发生的错误，对于这些异常，有的需要程序员进行捕获处理或声明抛出，有的是由Java虚拟机自动进行捕获处理。Java中常见的异常类:</p><ul><li>RuntimeException<ul><li>java.lang.ArrayIndexOutOfBoundsException 数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出。</li><li>java.lang.ArithmeticException 算术条件异常。譬如：整数除零等。</li><li>java.lang.NullPointerException 空指针异常。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等</li><li>java.lang.ClassNotFoundException 找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常。</li><li>java.lang.NegativeArraySizeException 数组长度为负异常</li><li>java.lang.ArrayStoreException 数组中包含不兼容的值抛出的异常</li><li>java.lang.SecurityException 安全性异常</li><li>java.lang.IllegalArgumentException 非法参数异常</li></ul></li><li>IOException<ul><li>IOException：操作输入流和输出流时可能出现的异常。</li><li>EOFException 文件已结束异常</li><li>FileNotFoundException 文件未找到异常</li></ul></li><li>其他<ul><li>ClassCastException 类型转换异常类</li><li>ArrayStoreException 数组中包含不兼容的值抛出的异常</li><li>SQLException 操作数据库异常类</li><li>NoSuchFieldException 字段未找到异常</li><li>NoSuchMethodException 方法未找到抛出的异常</li><li>NumberFormatException 字符串转换为数字抛出的异常</li><li>StringIndexOutOfBoundsException 字符串索引超出范围抛出的异常</li><li>IllegalAccessException 不允许访问某类异常</li><li>InstantiationException 当应用程序试图使用Class类中的newInstance()方法创建一个类的实例，而指定的类对象无法被实例化时，抛出该异常</li></ul></li></ul><h1 id="4-异常实践"><a href="#4-异常实践" class="headerlink" title="4 异常实践"></a>4 异常实践</h1><p>当你抛出或捕获异常的时候，有很多不同的情况需要考虑，而且大部分事情都是为了改善代码的可读性或者 API 的可用性。异常不仅仅是一个错误控制机制，也是一个通信媒介。因此，为了和同事更好的合作，一个团队必须要制定出一个最佳实践和规则，只有这样，团队成员才能理解这些通用概念，同时在工作中使用它。这里给出几个被很多团队使用的异常处理最佳实践。</p><h2 id="4-1-只针对不正常的情况才使用异常"><a href="#4-1-只针对不正常的情况才使用异常" class="headerlink" title="4.1 只针对不正常的情况才使用异常"></a>4.1 只针对不正常的情况才使用异常</h2><blockquote><p>异常只应该被用于不正常的条件，它们永远不应该被用于正常的控制流。《阿里手册》中：【强制】Java 类库中定义的可以通过预检查方式规避的RuntimeException异常不应该通过catch 的方式来处理，比如：NullPointerException，IndexOutOfBoundsException等等。</p></blockquote><p>比如，在解析字符串形式的数字时，可能存在数字格式错误，不得通过catch Exception来实现</p><ul><li>代码1</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj != <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>代码2</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">  obj.method(); </span><br><span class="line">&#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要原因有三点：</p><ul><li>异常机制的设计初衷是用于不正常的情况，所以很少会会JVM实现试图对它们的性能进行优化。所以，创建、抛出和捕获异常的开销是很昂贵的。</li><li>把代码放在try-catch中返回阻止了JVM实现本来可能要执行的某些特定的优化。</li><li>对数组进行遍历的标准模式并不会导致冗余的检查，有些现代的JVM实现会将它们优化掉。</li></ul><h2 id="4-2-在-finally-块中清理资源或者使用-try-with-resource-语句"><a href="#4-2-在-finally-块中清理资源或者使用-try-with-resource-语句" class="headerlink" title="4.2 在 finally 块中清理资源或者使用 try-with-resource 语句"></a>4.2 在 finally 块中清理资源或者使用 try-with-resource 语句</h2><p>当使用类似InputStream这种需要使用后关闭的资源时，一个常见的错误就是在try块的最后关闭资源。</p><ul><li>错误示例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doNotCloseResourceInTry</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;./tmp.txt&quot;</span>);</span><br><span class="line">        inputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">        <span class="comment">// use the inputStream to read a file</span></span><br><span class="line">        <span class="comment">// do NOT do this</span></span><br><span class="line">        inputStream.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题就是，只有没有异常抛出的时候，这段代码才可以正常工作。try 代码块内代码会正常执行，并且资源可以正常关闭。但是，使用 try 代码块是有原因的，一般调用一个或多个可能抛出异常的方法，而且，你自己也可能会抛出一个异常，这意味着代码可能不会执行到 try 代码块的最后部分。结果就是，你并没有关闭资源。所以，你应该把清理工作的代码放到 finally 里去，或者使用 try-with-resource 特性。</p><ul><li>方法一：<strong>使用 finally 代码块</strong><br>与前面几行 try 代码块不同，finally 代码块总是会被执行。不管 try 代码块成功执行之后还是你在 catch 代码块中处理完异常后都会执行。因此，你可以确保你清理了所有打开的资源。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">closeResourceInFinally</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;./tmp.txt&quot;</span>);</span><br><span class="line">        inputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">        <span class="comment">// use the inputStream to read a file</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (inputStream != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                log.error(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方法二：<strong>Java 7 的 try-with-resource 语法</strong><br>如果你的资源实现了 AutoCloseable 接口，你可以使用这个语法。大多数的 Java 标准资源都继承了这个接口。当你在 try 子句中打开资源，资源会在 try 代码块执行后或异常处理后自动关闭。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">automaticallyCloseResource</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;./tmp.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);) &#123;</span><br><span class="line">        <span class="comment">// use the inputStream to read a file</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-尽量使用标准的异常"><a href="#4-3-尽量使用标准的异常" class="headerlink" title="4.3 尽量使用标准的异常"></a>4.3 尽量使用标准的异常</h2><p>重用现有的异常有几个好处：</p><ul><li>它使得你的API更加易于学习和使用，因为它与程序员原来已经熟悉的习惯用法是一致的。</li><li>对于用到这些API的程序而言，它们的可读性更好，因为它们不会充斥着程序员不熟悉的异常。</li><li>异常类越少，意味着内存占用越小，并且转载这些类的时间开销也越小。<br>Java标准异常中有几个是经常被使用的异常。如下表格：</li></ul><table><thead><tr><th>异常</th><th>使用场合</th></tr></thead><tbody><tr><td>IllegalArgumentException</td><td>参数的值不合适</td></tr><tr><td>IllegalStateException</td><td>参数的状态不合适</td></tr><tr><td>NullPointerException</td><td>在null被禁止的情况下参数值为null</td></tr><tr><td>IndexOutOfBoundsException</td><td>下标越界</td></tr><tr><td>ConcurrentModificationException</td><td>在禁止并发修改的情况下，对象检测到并发修改</td></tr><tr><td>UnsupportedOperationException</td><td>对象不支持客户请求的方法</td></tr></tbody></table><p>虽然它们是Java平台库迄今为止最常被重用的异常，但是，在许可的条件下，其它的异常也可以被重用。例如，如果你要实现诸如复数或者矩阵之类的算术对象，那么重用ArithmeticException和NumberFormatException将是非常合适的。</p><p>如果一个异常满足你的需要，则不要犹豫，使用就可以，不过你一定要确保抛出异常的条件与该异常的文档中描述的条件一致。这种重用必须建立在语义的基础上，而不是名字的基础上。</p><p>最后，一定要清楚，选择重用哪一种异常并没有必须遵循的规则。例如，考虑纸牌对象的情形，假设有一个用于发牌操作的方法，它的参数(handSize)是发一手牌的纸牌张数。假设调用者在这个参数中传递的值大于整副牌的剩余张数。那么这种情形既可以被解释为IllegalArgumentException(handSize的值太大)，也可以被解释为IllegalStateException(相对客户的请求而言，纸牌对象的纸牌太少)。</p><h2 id="4-4-对异常进行文档说明"><a href="#4-4-对异常进行文档说明" class="headerlink" title="4.4 对异常进行文档说明"></a>4.4 对异常进行文档说明</h2><blockquote><p>当在方法上声明抛出异常时，也需要进行文档说明。目的是为了给调用者提供尽可能多的信息，从而可以更好地避免或处理异常。<br>在 Javadoc 添加 @throws 声明，并且描述抛出异常的场景。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Method description</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> MyBusinessException - businuess exception description</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">(String input)</span> <span class="keyword">throws</span> MyBusinessException &#123;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，在抛出MyBusinessException 异常时，需要尽可能精确地描述问题和相关信息，这样无论是打印到日志中还是在监控工具中，都能够更容易被人阅读，从而可以更好地定位具体错误信息、错误的严重程度等。</p><h2 id="4-5-优先捕获最具体的异常"><a href="#4-5-优先捕获最具体的异常" class="headerlink" title="4.5 优先捕获最具体的异常"></a>4.5 优先捕获最具体的异常</h2><blockquote><p>大多数 IDE 都可以帮助你实现这个最佳实践。当你尝试首先捕获较不具体的异常时，它们会报告无法访问的代码块。</p></blockquote><p>但问题在于，只有匹配异常的第一个 catch 块会被执行。 因此，如果首先捕获 IllegalArgumentException ，则永远不会到达应该处理更具体的 NumberFormatException 的 catch 块，因为它是 IllegalArgumentException 的子类。</p><p>总是优先捕获最具体的异常类，并将不太具体的 catch 块添加到列表的末尾。</p><p>你可以在下面的代码片断中看到这样一个 try-catch 语句的例子。 第一个 catch 块处理所有 NumberFormatException 异常，第二个处理所有非 NumberFormatException 异常的IllegalArgumentException 异常。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">catchMostSpecificExceptionFirst</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        doSomething(<span class="string">&quot;A message&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">        log.error(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-6-不要捕获-Throwable-类"><a href="#4-6-不要捕获-Throwable-类" class="headerlink" title="4.6 不要捕获 Throwable 类"></a>4.6 不要捕获 Throwable 类</h2><blockquote><p>Throwable 是所有异常和错误的超类。你可以在 catch 子句中使用它，但是你永远不应该这样做！</p></blockquote><p>如果在 catch 子句中使用 Throwable ，它不仅会捕获所有异常，也将捕获所有的错误。JVM 抛出错误，指出不应该由应用程序处理的严重问题。 典型的例子是 OutOfMemoryError 或者 StackOverflowError 。两者都是由应用程序控制之外的情况引起的，无法处理。<br>所以，最好不要捕获 Throwable ，除非你确定自己处于一种特殊的情况下能够处理错误。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doNotCatchThrowable</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">// don&#x27;t do this!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-7-不要忽略异常"><a href="#4-7-不要忽略异常" class="headerlink" title="4.7 不要忽略异常"></a>4.7 不要忽略异常</h2><blockquote><p>很多时候，开发者很有自信不会抛出异常，因此写了一个catch块，但是没有做任何处理或者记录日志。</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doNotIgnoreExceptions</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        <span class="comment">// this will never happen</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但现实是经常会出现无法预料的异常，或者无法确定这里的代码未来是不是会改动(删除了阻止异常抛出的代码)，而此时由于异常被捕获，使得无法拿到足够的错误信息来定位问题。<br>合理的做法是至少要记录异常的信息。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logAnException</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;This should never happen: &quot;</span> + e); <span class="comment">// see this line</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-8不要记录并抛出异常"><a href="#4-8不要记录并抛出异常" class="headerlink" title="4.8不要记录并抛出异常"></a>4.8不要记录并抛出异常</h2><p>这可能是本文中最常被忽略的最佳实践。 可以发现很多代码甚至类库中都会有捕获异常、记录日志并再次抛出的逻辑。如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> Long(<span class="string">&quot;xyz&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">    log.error(e);</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个处理逻辑看着是合理的。但这经常会给同一个异常输出多条日志。如下：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">17</span>:<span class="number">44</span>:<span class="number">28</span>,<span class="number">945</span> ERROR TestExceptionHandling:<span class="number">65</span> - <span class="keyword">java.lang.NumberFormatException: </span>For input string: <span class="string">&quot;xyz&quot;</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> <span class="keyword">java.lang.NumberFormatException: </span>For input string: <span class="string">&quot;xyz&quot;</span></span><br><span class="line"><span class="built_in">at</span> <span class="keyword">java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)</span></span><br><span class="line"><span class="keyword"></span><span class="built_in">at</span> <span class="keyword">java.lang.Long.parseLong(Long.java:589)</span></span><br><span class="line"><span class="keyword"></span><span class="built_in">at</span> <span class="keyword">java.lang.Long.(Long.java:965)</span></span><br><span class="line"><span class="keyword"></span><span class="built_in">at</span> com.stackify.example.TestExceptionHandling.logAndThrowException(TestExceptionHandling.<span class="keyword">java:63)</span></span><br><span class="line"><span class="keyword"></span><span class="built_in">at</span> com.stackify.example.TestExceptionHandling.main(TestExceptionHandling.<span class="keyword">java:58)</span></span><br></pre></td></tr></table></figure><p>如上所示，后面的日志也没有附加更有用的信息。如果想要提供更加有用的信息，那么可以将异常包装为自定义异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">wrapException</span><span class="params">(String input)</span> <span class="keyword">throws</span> MyBusinessException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyBusinessException</span>(<span class="string">&quot;A message that describes the error.&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，仅仅当想要处理异常时才去捕获，否则只需要在方法签名中声明让调用者去处理。</p><h2 id="4-9-包装异常时不要抛弃原始的异常"><a href="#4-9-包装异常时不要抛弃原始的异常" class="headerlink" title="4.9 包装异常时不要抛弃原始的异常"></a>4.9 包装异常时不要抛弃原始的异常</h2><p>捕获标准异常并包装为自定义异常是一个很常见的做法。这样可以添加更为具体的异常信息并能够做针对的异常处理。<br>在你这样做时，请确保将原始异常设置为原因（注：参考下方代码 NumberFormatException e 中的原始异常 e ）。Exception 类提供了特殊的构造函数方法，它接受一个 Throwable 作为参数。否则，你将会丢失堆栈跟踪和原始异常的消息，这将会使分析导致异常的异常事件变得困难。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">wrapException</span><span class="params">(String input)</span> <span class="keyword">throws</span> MyBusinessException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyBusinessException</span>(<span class="string">&quot;A message that describes the error.&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-10-不要使用异常控制程序的流程"><a href="#4-10-不要使用异常控制程序的流程" class="headerlink" title="4.10 不要使用异常控制程序的流程"></a>4.10 不要使用异常控制程序的流程</h2><p>不应该使用异常控制应用的执行流程，例如，本应该使用if语句进行条件判断的情况下，你却使用异常处理，这是非常不好的习惯，会严重影响应用的性能。</p><h2 id="4-11-不要在finally块中使用return。"><a href="#4-11-不要在finally块中使用return。" class="headerlink" title="4.11 不要在finally块中使用return。"></a>4.11 不要在finally块中使用return。</h2><p>try块中的return语句执行成功后，并不马上返回，而是继续执行finally块中的语句，如果此处存在return语句，则在此直接返回，无情丢弃掉try块中的返回点。<br>如下是一个反例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">checkReturn</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// x等于1，此处不返回</span></span><br><span class="line">        <span class="keyword">return</span> ++x;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 返回的结果是2</span></span><br><span class="line">        <span class="keyword">return</span> ++x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h1><p>这边详细介绍了异常的概念、原理，以及在应用中的一些小结。异常的能力是我们快速定位程序错误的重要手段之一，也是我们不断优化程序，提高程序健壮性的依据，所以熟练掌握异常的使用是非常有必要的。</p>]]></content>
      
      
      <categories>
          
          <category> Java核心系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java核心 </tag>
            
            <tag> Java基础 </tag>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java设计模式-单例模式</title>
      <link href="/2025/02/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2025/02/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>单例模式相信大家都有所听闻，甚至也写过不少了，在面试中也是考得最多的其中一个设计模式，面试官常常会要求写出两种类型的单例模式并且解释其原理，废话不多说，我们开始学习如何很好地回答这一道面试题吧。</p><h2 id="什么是单例模式"><a href="#什么是单例模式" class="headerlink" title="什么是单例模式"></a>什么是单例模式</h2><p>面试官问什么是单例模式时，千万不要答非所问，给出单例模式有两种类型之类的回答，要围绕单例模式的定义去展开。</p><p>单例模式是指在内存中只会创建且仅创建一次对象的设计模式。在程序中多次使用同一个对象且作用相同时，为了防止频繁地创建对象使得内存飙升，单例模式可以让程序仅在内存中创建一个对象，让所有需要调用的地方都共享这一单例对象。</p><h2 id="单例模式的类型"><a href="#单例模式的类型" class="headerlink" title="单例模式的类型"></a>单例模式的类型</h2><p>单例模式有两种类型：</p><ul><li><code>懒汉式</code>：在真正需要使用对象时才去创建该单例类对象</li><li><code>饿汉式</code>：在类加载时已经创建好该单例对象，等待被程序使用</li></ul><h3 id="懒汉式创建单例对象"><a href="#懒汉式创建单例对象" class="headerlink" title="懒汉式创建单例对象"></a>懒汉式创建单例对象</h3><p>懒汉式创建对象的方法是在程序使用对象前，先判断该对象是否已经实例化（判空），若已实例化直接返回该类对象。否则则先执行实例化操作。</p><p>根据上面的流程，就可以写出下面的这段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没错，这里我们已经写出了一个很不错的单例模式，不过它不是完美的，但是这并不影响我们使用这个“单例对象”。</p><p>以上就是懒汉式创建单例对象的方法，我会在后面解释这段代码在哪里可以优化，存在什么问题。</p><h3 id="饿汉式创建单例对象"><a href="#饿汉式创建单例对象" class="headerlink" title="饿汉式创建单例对象"></a>饿汉式创建单例对象</h3><p>饿汉式在<code>类加载</code>时已经创建好该对象，在程序调用时直接返回该单例对象即可，即我们在编码时就已经指明了要马上创建这个对象，不需要等到被调用时再去创建。</p><p>关于类加载，涉及到JVM的内容，我们目前可以简单认为在程序启动时，这个单例对象就已经创建好了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">singleton</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意上面的代码在第3行已经实例化好了一个Singleton对象在内存中，不会有多个Singleton对象实例存在</p><p>类在加载时会在堆内存中创建一个Singleton对象，当类被卸载时，Singleton对象也随之消亡了。</p><h2 id="懒汉式如何保证只创建一个对象"><a href="#懒汉式如何保证只创建一个对象" class="headerlink" title="懒汉式如何保证只创建一个对象"></a>懒汉式如何保证只创建一个对象</h2><p>我们再来回顾懒汉式的核心方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">        singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singleton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法其实是存在问题的，试想一下，如果两个线程同时判断 singleton 为空，那么它们都会去实例化一个Singleton 对象，这就变成多例了。所以，我们要解决的是<code>线程安全</code>问题。</p><p>最容易想到的解决方法就是在方法上加锁，或者是对类对象加锁，程序就会变成下面这个样子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">        singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singleton;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(Singleton.class) &#123;   </span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singleton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就规避了两个线程同时创建Singleton对象的风险，但是引来另外一个问题：<strong>每次去获取对象都需要先获取锁，并发性能非常地差，极端情况下，可能会出现卡顿现象。</strong></p><p>接下来要做的就是<code>优化性能</code>：目标是如果没有实例化对象则加锁创建，如果已经实例化了，则不需要加锁，直接获取实例</p><p>所以直接在方法上加锁的方式就被废掉了，因为这种方式无论如何都需要先获取锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;  <span class="comment">// 线程A和线程B同时看到singleton = null，如果不为null，则直接返回singleton</span></span><br><span class="line">        <span class="keyword">synchronized</span>(Singleton.class) &#123; <span class="comment">// 线程A或线程B获得该锁进行初始化</span></span><br><span class="line">            <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123; <span class="comment">// 其中一个线程进入该分支，另外一个线程则不会进入该分支</span></span><br><span class="line">                singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singleton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码已经完美地解决了<strong>并发安全 + 性能低效</strong>问题：</p><ul><li>第 2 行代码，如果 singleton 不为空，则直接返回对象，不需要获取锁；而如果多个线程发现 singleton 为空，则进入分支；</li><li>第 3 行代码，多个线程尝试争抢同一个锁，只有一个线程争抢成功，第一个获取到锁的线程会再次判断singleton 是否为空，因为 singleton 有可能已经被之前的线程实例化</li><li>其它之后获取到锁的线程在执行到第 4 行校验代码，发现 singleton 已经不为空了，则不会再 new 一个对象，直接返回对象即可</li><li>之后所有进入该方法的线程都不会去获取锁，在第一次判断 singleton 对象时已经不为空了</li></ul><p>因为需要两次判空，且对类对象加锁，该懒汉式写法也被称为：<strong>Double Check（双重校验） + Lock（加锁）</strong></p><p>完整的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;  <span class="comment">// 线程A和线程B同时看到singleton = null，如果不为null，则直接返回singleton</span></span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123; <span class="comment">// 线程A或线程B获得该锁进行初始化</span></span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123; <span class="comment">// 其中一个线程进入该分支，另外一个线程则不会进入该分支</span></span><br><span class="line">                    singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码已经近似完美了，但是还存在最后一个问题：指令重排</p><h2 id="使用volatile防止指令重排"><a href="#使用volatile防止指令重排" class="headerlink" title="使用volatile防止指令重排"></a>使用volatile防止指令重排</h2><p>创建一个对象，在 JVM 中会经过三步：</p><p>（1）为singleton分配内存空间</p><p>（2）初始化 singleton 对象</p><p>（3）将singleton指向分配好的内存空间</p><p>指令重排序是指：<strong>JVM在保证最终结果正确的情况下，可以不按照程序编码的顺序执行语句，尽可能提高程序的性能</strong></p><p>在这三步中，第 2、3 步有可能会发生指令重排现象，创建对象的顺序变为 1-3-2，会导致多个线程获取对象时，有可能线程 A 创建对象的过程中，执行了 1、3 步骤，线程 B 判断 singleton 已经不为空，获取到未初始化的singleton 对象，就会报 NPE 异常。文字较为晦涩，可以看流程图：</p><p>使用 volatile 关键字可以**防止指令重排序，**其原理较为复杂，这篇文章不打算展开，可以这样理解：<strong>使用 volatile 关键字修饰的变量，可以保证其指令执行的顺序与程序指明的顺序一致，不会发生顺序变换</strong>，这样在多线程环境下就不会发生 NPE 异常了。</p><blockquote><p>volatile 还有第二个作用：使用 volatile 关键字修饰的变量，可以保证其内存可见性，即每一时刻线程读取到该变量的值都是内存中最新的那个值，线程每次操作该变量都需要先读取该变量。</p></blockquote><p>最终的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;  <span class="comment">// 线程A和线程B同时看到singleton = null，如果不为null，则直接返回singleton</span></span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123; <span class="comment">// 线程A或线程B获得该锁进行初始化</span></span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123; <span class="comment">// 其中一个线程进入该分支，另外一个线程则不会进入该分支</span></span><br><span class="line">                    singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="破坏懒汉式单例与饿汉式单例"><a href="#破坏懒汉式单例与饿汉式单例" class="headerlink" title="破坏懒汉式单例与饿汉式单例"></a>破坏懒汉式单例与饿汉式单例</h2><p>无论是完美的懒汉式还是饿汉式，终究敌不过<strong>反射和序列化</strong>，它们俩都可以把单例对象破坏掉（产生多个对象）。</p><h3 id="利用反射破坏单例模式"><a href="#利用反射破坏单例模式" class="headerlink" title="利用反射破坏单例模式"></a>利用<strong>反射</strong>破坏单例模式</h3><p>下面是一段使用反射破坏单例模式的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取类的显式构造器</span></span><br><span class="line">    Constructor&lt;Singleton&gt; construct = Singleton.class.getDeclaredConstructor();</span><br><span class="line">    <span class="comment">// 可访问私有构造器</span></span><br><span class="line">    construct.setAccessible(<span class="literal">true</span>); </span><br><span class="line">    <span class="comment">// 利用反射构造新对象</span></span><br><span class="line">    <span class="type">Singleton</span> <span class="variable">obj1</span> <span class="operator">=</span> construct.newInstance(); </span><br><span class="line">    <span class="comment">// 通过正常方式获取单例对象</span></span><br><span class="line">    <span class="type">Singleton</span> <span class="variable">obj2</span> <span class="operator">=</span> Singleton.getInstance(); </span><br><span class="line">    System.out.println(obj1 == obj2); <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的代码一针见血了：利用反射，强制访问类的私有构造器，去创建另一个对象</p><h3 id="利用序列化与反序列化破坏单例模式"><a href="#利用序列化与反序列化破坏单例模式" class="headerlink" title="利用序列化与反序列化破坏单例模式"></a>利用<strong>序列化与反序列化</strong>破坏单例模式</h3><p>下面是一种使用序列化和反序列化破坏单例模式的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建输出流</span></span><br><span class="line">    <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;Singleton.file&quot;</span>));</span><br><span class="line">    <span class="comment">// 将单例对象写到文件中</span></span><br><span class="line">    oos.writeObject(Singleton.getInstance());</span><br><span class="line">    <span class="comment">// 从文件中读取单例对象</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Singleton.file&quot;</span>);</span><br><span class="line">    <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file));</span><br><span class="line">    <span class="type">Singleton</span> <span class="variable">newInstance</span> <span class="operator">=</span> (Singleton) ois.readObject();</span><br><span class="line">    <span class="comment">// 判断是否是同一个对象</span></span><br><span class="line">    System.out.println(newInstance == Singleton.getInstance()); <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个对象地址不相等的原因是：readObject() 方法读入对象时它必定会返回一个新的对象实例，必然指向新的内存地址。</p><h2 id="让面试官鼓掌的枚举实现"><a href="#让面试官鼓掌的枚举实现" class="headerlink" title="让面试官鼓掌的枚举实现"></a>让面试官鼓掌的枚举实现</h2><p>我们已经掌握了懒汉式与饿汉式的常见写法了，通常情况下到这里已经足够了。但是，追求极致的我们，怎么能够止步于此，在《Effective Java》书中，给出了终极解决方法，话不多说，学完下面，真的不虚面试官考你了。</p><p>在 JDK 1.5 后，使用 Java 语言实现单例模式的方式又多了一种：<code>枚举</code></p><p>枚举实现单例模式完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是枚举类型的单例模式！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用枚举实现单例模式较其它两种实现方式的优势有 3 点，让我们来细品。</p><h3 id="优势1-：一目了然的代码"><a href="#优势1-：一目了然的代码" class="headerlink" title="优势1 ：一目了然的代码"></a>优势1 ：一目了然的代码</h3><p>代码对比饿汉式与懒汉式来说，更加地简洁。最少只需要3行代码，就可以完成一个单例模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们从最直观的地方入手，第一眼看到这3行代码，就会感觉到<code>少</code>，没错，就是少，虽然这优势有些牵强，但写的代码越少，越不容易出错。</p><h3 id="优势2：天然的线程安全与单一实例"><a href="#优势2：天然的线程安全与单一实例" class="headerlink" title="优势2：天然的线程安全与单一实例"></a>优势2：天然的线程安全与单一实例</h3><p>它不需要做任何额外的操作，就可以保证对象单一性与线程安全性。</p><p>我写了一段测试代码放在下面，这一段代码可以证明程序启动时仅会创建一个 Singleton 对象，且是线程安全的。</p><blockquote><p>我们可以简单地理解枚举创建实例的过程：在程序启动时，会调用 Singleton 的空参构造器，实例化好一个Singleton 对象赋给 INSTANCE，之后再也不会实例化</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    Singleton() &#123; System.out.println(<span class="string">&quot;枚举创建对象了&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; <span class="comment">/* test(); */</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">t1</span> <span class="operator">=</span> Singleton.INSTANCE;</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">t2</span> <span class="operator">=</span> Singleton.INSTANCE;</span><br><span class="line">        System.out.print(<span class="string">&quot;t1和t2的地址是否相同：&quot;</span> + t1 == t2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 枚举创建对象了</span></span><br><span class="line"><span class="comment">// t1和t2的地址是否相同：true</span></span><br></pre></td></tr></table></figure><p>除了优势1和优势2，还有最后一个优势是 <code>保护单例模式</code>，它使得枚举在当前的单例模式领域已经是 <code>无懈可击</code> 了</p><h3 id="优势-3：枚举保护单例模式不被破坏"><a href="#优势-3：枚举保护单例模式不被破坏" class="headerlink" title="优势 3：枚举保护单例模式不被破坏"></a>优势 3：枚举保护单例模式不被破坏</h3><p>使用枚举可以防止调用者使用<strong>反射、序列化与反序列化</strong>机制强制生成多个单例对象，破坏单例模式。</p><p><strong>防反射</strong></p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAOgaUYQjOwdPzUlS35SfRipHk32A1YAAlsLaxvRfjBWEo_Nh4YW0_QBAAMCAAN4AAM2BA.png"></p><p>枚举类默认继承了 Enum 类，在利用反射调用 newInstance() 时，会判断该类是否是一个枚举类，如果是，则抛出异常。</p><p><strong>防止反序列化创建多个枚举对象</strong></p><p>在读入 Singleton 对象时，每个枚举类型和枚举名字都是唯一的，所以在序列化时，仅仅只是对枚举的类型和变量名输出到文件中，在读入文件反序列化成对象时，使用 Enum 类的 valueOf(String name) 方法根据变量的名字查找对应的枚举对象。</p><p>所以，在序列化和反序列化的过程中，只是写出和读入了枚举类型和名字，没有任何关于对象的操作。</p><p>小结：</p><p>（1）Enum 类内部使用<strong>Enum 类型判定</strong>防止通过反射创建多个对象</p><p>（2）Enum 类通过写出（读入）对象类型和枚举名字将对象序列化（反序列化），<strong>通过 valueOf() 方法匹配枚举名</strong>找到内存中的唯一的对象实例，防止通过反序列化构造多个对象</p><p>（3）枚举类不需要关注线程安全、破坏单例和性能问题，因为其创建对象的时机与<strong>饿汉式单例有异曲同工之妙</strong>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>（1）单例模式常见的写法有两种：懒汉式、饿汉式</p><p>（2）懒汉式：在需要用到对象时才实例化对象，正确的实现方式是：Double Check + Lock，解决了并发安全和性能低下问题</p><p>（3）饿汉式：在类加载时已经创建好该单例对象，在获取单例对象时直接返回对象即可，不会存在并发安全和性能问题。</p><p>（4）在开发中如果对内存要求非常高，那么使用懒汉式写法，可以在特定时候才创建该对象；</p><p>（5）如果对内存要求不高使用饿汉式写法，因为简单不易出错，且没有任何并发安全和性能问题</p><p>（6）为了防止多线程环境下，因为指令重排序导致变量报NPE，需要在单例对象上添加 volatile 关键字防止指令重排序</p><p>（7）最优雅的实现方式是使用枚举，其代码精简，没有线程安全问题，且 Enum 类内部防止反射和反序列化时破坏单例。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单例模式 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring框架核心知识</title>
      <link href="/2025/02/18/Spring%E6%A1%86%E6%9E%B6/Java%E5%9B%9E%E9%A1%BE-%E6%A1%86%E6%9E%B6%E7%AF%87/"/>
      <url>/2025/02/18/Spring%E6%A1%86%E6%9E%B6/Java%E5%9B%9E%E9%A1%BE-%E6%A1%86%E6%9E%B6%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="框架篇"><a href="#框架篇" class="headerlink" title="框架篇"></a>框架篇</h1><h2 id="1-Spring-refresh-流程"><a href="#1-Spring-refresh-流程" class="headerlink" title="1. Spring refresh 流程"></a>1. Spring refresh 流程</h2><p><strong>要求</strong></p><ul><li>掌握 refresh 的 12 个步骤</li></ul><p><strong>Spring refresh 概述</strong></p><p>refresh 是 AbstractApplicationContext 中的一个方法，负责初始化 ApplicationContext 容器，容器必须调用 refresh 才能正常工作。它的内部主要会调用 12 个方法，我们把它们称为 refresh 的 12 个步骤：</p><ol><li>prepareRefresh</li><li>obtainFreshBeanFactory</li><li>prepareBeanFactory</li><li>postProcessBeanFactory</li><li>invokeBeanFactoryPostProcessors</li><li>registerBeanPostProcessors</li><li>initMessageSource</li><li>initApplicationEventMulticaster</li><li>onRefresh</li><li>registerListeners</li><li>finishBeanFactoryInitialization</li><li>finishRefresh</li></ol><blockquote><p><em><strong>功能分类</strong></em></p><ul><li><p>1 为准备环境</p></li><li><p>2 3 4 5 6 为准备 BeanFactory</p></li><li><p>7 8 9 10 12 为准备 ApplicationContext</p></li><li><p>11 为初始化 BeanFactory 中非延迟单例 bean</p></li></ul></blockquote><p><strong>1. prepareRefresh</strong></p><ul><li><p>这一步创建和准备了 Environment 对象，它作为 ApplicationContext 的一个成员变量</p></li><li><p>Environment 对象的作用之一是为后续 @Value，值注入时提供键值</p></li><li><p>Environment 分成三个主要部分</p><ul><li>systemProperties - 保存 java 环境键值</li><li>systemEnvironment - 保存系统环境键值</li><li>自定义 PropertySource - 保存自定义键值，例如来自于 *.properties 文件的键值</li></ul></li></ul><p><strong>2. obtainFreshBeanFactory</strong></p><ul><li>这一步获取（或创建） BeanFactory，它也是作为 ApplicationContext 的一个成员变量</li><li>BeanFactory 的作用是负责 bean 的创建、依赖注入和初始化，bean 的各项特征由 BeanDefinition 定义<ul><li>BeanDefinition 作为 bean 的设计蓝图，规定了 bean 的特征，如单例多例、依赖关系、初始销毁方法等</li><li>BeanDefinition 的来源有多种多样，可以是通过 xml 获得、配置类获得、组件扫描获得，也可以是编程添加</li></ul></li><li>所有的 BeanDefinition 会存入 BeanFactory 中的 beanDefinitionMap 集合</li></ul><p>![](.&#x2F;Java%E5%9B%9E%E9%A1%BE-%E6%A1%86%E6%9E%B6%E7%AF%87&#x2F;AgACAgUAAxkDAAMqZ7SS9ZPpRGk_NZNn7ypO3Jpfl8gAApnBMRtiZKBVLulZj_H_mKMBAAMCAAN4AAM2BA.png</p><p><strong>3. prepareBeanFactory</strong></p><ul><li>这一步会进一步完善 BeanFactory，为它的各项成员变量赋值</li><li>beanExpressionResolver 用来解析 SpEL，常见实现为 StandardBeanExpressionResolver</li><li>propertyEditorRegistrars 会注册类型转换器<ul><li>它在这里使用了 ResourceEditorRegistrar 实现类</li><li>并应用 ApplicationContext 提供的 Environment 完成 ${ } 解析</li></ul></li><li>registerResolvableDependency 来注册 beanFactory 以及 ApplicationContext，让它们也能用于依赖注入</li><li>beanPostProcessors 是 bean 后处理器集合，会工作在 bean 的生命周期各个阶段，此处会添加两个：<ul><li>ApplicationContextAwareProcessor 用来解析 Aware 接口</li><li>ApplicationListenerDetector 用来识别容器中 ApplicationListener 类型的 bean</li></ul></li></ul><p><strong>4. postProcessBeanFactory</strong></p><ul><li>这一步是空实现，留给子类扩展。<ul><li>一般 Web 环境的 ApplicationContext 都要利用它注册新的 Scope，完善 Web 下的 BeanFactory</li></ul></li><li>这里体现的是模板方法设计模式</li></ul><p><strong>5. invokeBeanFactoryPostProcessors</strong></p><ul><li>这一步会调用 beanFactory 后处理器</li><li>beanFactory 后处理器，充当 beanFactory 的扩展点，可以用来补充或修改 BeanDefinition</li><li>常见的 beanFactory 后处理器有<ul><li>ConfigurationClassPostProcessor – 解析 @Configuration、@Bean、@Import、@PropertySource 等</li><li>PropertySourcesPlaceHolderConfigurer – 替换 BeanDefinition 中的 ${ }</li><li>MapperScannerConfigurer – 补充 Mapper 接口对应的 BeanDefinition</li></ul></li></ul><p><strong>6. registerBeanPostProcessors</strong></p><ul><li>这一步是继续从 beanFactory 中找出 bean 后处理器，添加至 beanPostProcessors 集合中</li><li>bean 后处理器，充当 bean 的扩展点，可以工作在 bean 的实例化、依赖注入、初始化阶段，常见的有：<ul><li>AutowiredAnnotationBeanPostProcessor 功能有：解析 @Autowired，@Value 注解</li><li>CommonAnnotationBeanPostProcessor 功能有：解析 @Resource，@PostConstruct，@PreDestroy</li><li>AnnotationAwareAspectJAutoProxyCreator 功能有：为符合切点的目标 bean 自动创建代理</li></ul></li></ul><p><strong>7. initMessageSource</strong></p><ul><li>这一步是为 ApplicationContext 添加 messageSource 成员，实现国际化功能</li><li>去 beanFactory 内找名为 messageSource 的 bean，如果没有，则提供空的 MessageSource 实现</li></ul><p><strong>8. initApplicationContextEventMulticaster</strong></p><ul><li>这一步为 ApplicationContext 添加事件广播器成员，即 applicationContextEventMulticaster</li><li>它的作用是发布事件给监听器</li><li>去 beanFactory 找名为 applicationEventMulticaster 的 bean 作为事件广播器，若没有，会创建默认的事件广播器</li><li>之后就可以调用 ApplicationContext.publishEvent(事件对象) 来发布事件</li></ul><p><strong>9. onRefresh</strong></p><ul><li>这一步是空实现，留给子类扩展<ul><li>SpringBoot 中的子类在这里准备了 WebServer，即内嵌 web 容器</li></ul></li><li>体现的是模板方法设计模式</li></ul><p><strong>10. registerListeners</strong></p><ul><li>这一步会从多种途径找到事件监听器，并添加至 applicationEventMulticaster</li><li>事件监听器顾名思义，用来接收事件广播器发布的事件，有如下来源<ul><li>事先编程添加的</li><li>来自容器中的 bean</li><li>来自于 @EventListener 的解析</li></ul></li><li>要实现事件监听器，只需要实现 ApplicationListener 接口，重写其中 onApplicationEvent(E e) 方法即可</li></ul><p><strong>11. finishBeanFactoryInitialization</strong></p><ul><li>这一步会将 beanFactory 的成员补充完毕，并初始化所有非延迟单例 bean</li><li>conversionService 也是一套转换机制，作为对 PropertyEditor 的补充</li><li>embeddedValueResolvers 即内嵌值解析器，用来解析 @Value 中的 ${ }，借用的是 Environment 的功能</li><li>singletonObjects 即单例池，缓存所有单例对象<ul><li>对象的创建都分三个阶段，每一阶段都有不同的 bean 后处理器参与进来，扩展功能</li></ul></li></ul><p><strong>12. finishRefresh</strong></p><ul><li>这一步会为 ApplicationContext 添加 lifecycleProcessor 成员，用来控制容器内需要生命周期管理的 bean</li><li>如果容器中有名称为 lifecycleProcessor 的 bean 就用它，否则创建默认的生命周期管理器</li><li>准备好生命周期管理器，就可以实现<ul><li>调用 context 的 start，即可触发所有实现 LifeCycle 接口 bean 的 start</li><li>调用 context 的 stop，即可触发所有实现 LifeCycle 接口 bean 的 stop</li></ul></li><li>发布 ContextRefreshed 事件，整个 refresh 执行完成</li></ul><h2 id="2-Spring-bean-生命周期"><a href="#2-Spring-bean-生命周期" class="headerlink" title="2. Spring bean 生命周期"></a>2. Spring bean 生命周期</h2><p><strong>要求</strong></p><ul><li>掌握 Spring bean 的生命周期</li></ul><p><strong>bean 生命周期 概述</strong></p><p>bean 的生命周期从调用 beanFactory 的 getBean 开始，到这个 bean 被销毁，可以总结为以下七个阶段：</p><ol><li>处理名称，检查缓存</li><li>处理父子容器</li><li>处理 dependsOn</li><li>选择 scope 策略</li><li>创建 bean</li><li>类型转换处理</li><li>销毁 bean</li></ol><blockquote><p><em><strong>注意</strong></em></p><ul><li>划分的阶段和名称并不重要，重要的是理解整个过程中做了哪些事情</li></ul></blockquote><p><strong>1. 处理名称，检查缓存</strong></p><ul><li>这一步会处理别名，将别名解析为实际名称</li><li>对 FactoryBean 也会特殊处理，如果以 &amp; 开头表示要获取 FactoryBean 本身，否则表示要获取其产品</li><li>这里针对单例对象会检查一级、二级、三级缓存<ul><li>singletonFactories 三级缓存，存放单例工厂对象</li><li>earlySingletonObjects 二级缓存，存放单例工厂的产品对象<ul><li>如果发生循环依赖，产品是代理；无循环依赖，产品是原始对象</li></ul></li><li>singletonObjects 一级缓存，存放单例成品对象</li></ul></li></ul><p><strong>2. 处理父子容器</strong></p><ul><li>如果当前容器根据名字找不到这个 bean，此时若父容器存在，则执行父容器的 getBean 流程</li><li>父子容器的 bean 名称可以重复</li></ul><p><strong>3. 处理 dependsOn</strong></p><ul><li>如果当前 bean 有通过 dependsOn 指定了非显式依赖的 bean，这一步会提前创建这些 dependsOn 的 bean </li><li>所谓非显式依赖，就是指两个 bean 之间不存在直接依赖关系，但需要控制它们的创建先后顺序</li></ul><p><strong>4. 选择 scope 策略</strong></p><ul><li>对于 singleton scope，首先到单例池去获取 bean，如果有则直接返回，没有再进入创建流程</li><li>对于 prototype scope，每次都会进入创建流程</li><li>对于自定义 scope，例如 request，首先到 request 域获取 bean，如果有则直接返回，没有再进入创建流程</li></ul><p><strong>5.1 创建 bean - 创建 bean 实例</strong></p><table><thead><tr><th><strong>要点</strong></th><th><strong>总结</strong></th></tr></thead><tbody><tr><td>有自定义 TargetSource 的情况</td><td>由 AnnotationAwareAspectJAutoProxyCreator 创建代理返回</td></tr><tr><td>Supplier 方式创建 bean 实例</td><td>为 Spring 5.0 新增功能，方便编程方式创建  bean  实例</td></tr><tr><td>FactoryMethod 方式  创建 bean  实例</td><td>① 分成静态工厂与实例工厂；② 工厂方法若有参数，需要对工厂方法参数进行解析，利用  resolveDependency；③ 如果有多个工厂方法候选者，还要进一步按权重筛选</td></tr><tr><td>AutowiredAnnotationBeanPostProcessor</td><td>① 优先选择带  @Autowired  注解的构造；② 若有唯一的带参构造，也会入选</td></tr><tr><td>mbd.getPreferredConstructors</td><td>选择所有公共构造，这些构造之间按权重筛选</td></tr><tr><td>采用默认构造</td><td>如果上面的后处理器和 BeanDefiniation 都没找到构造，采用默认构造，即使是私有的</td></tr></tbody></table><p><strong>5.2 创建 bean - 依赖注入</strong></p><table><thead><tr><th><strong>要点</strong></th><th><strong>总结</strong></th></tr></thead><tbody><tr><td>AutowiredAnnotationBeanPostProcessor</td><td>识别   @Autowired  及 @Value  标注的成员，封装为  InjectionMetadata 进行依赖注入</td></tr><tr><td>CommonAnnotationBeanPostProcessor</td><td>识别   @Resource  标注的成员，封装为  InjectionMetadata 进行依赖注入</td></tr><tr><td>resolveDependency</td><td>用来查找要装配的值，可以识别：① Optional；② ObjectFactory 及 ObjectProvider；③ @Lazy  注解；④ @Value  注解（${  }, #{ }, 类型转换）；⑤ 集合类型（Collection，Map，数组等）；⑥ 泛型和  @Qualifier（用来区分类型歧义）；⑦ primary  及名字匹配（用来区分类型歧义）</td></tr><tr><td>AUTOWIRE_BY_NAME</td><td>根据成员名字找 bean 对象，修改 mbd 的 propertyValues，不会考虑简单类型的成员</td></tr><tr><td>AUTOWIRE_BY_TYPE</td><td>根据成员类型执行 resolveDependency 找到依赖注入的值，修改  mbd 的 propertyValues</td></tr><tr><td>applyPropertyValues</td><td>根据 mbd 的 propertyValues 进行依赖注入（即xml中 &#96;&lt;property name ref</td></tr></tbody></table><p><strong>5.3 创建 bean - 初始化</strong></p><table><thead><tr><th><strong>要点</strong></th><th><strong>总结</strong></th></tr></thead><tbody><tr><td>内置 Aware 接口的装配</td><td>包括 BeanNameAware，BeanFactoryAware 等</td></tr><tr><td>扩展 Aware 接口的装配</td><td>由 ApplicationContextAwareProcessor 解析，执行时机在  postProcessBeforeInitialization</td></tr><tr><td>@PostConstruct</td><td>由 CommonAnnotationBeanPostProcessor 解析，执行时机在  postProcessBeforeInitialization</td></tr><tr><td>InitializingBean</td><td>通过接口回调执行初始化</td></tr><tr><td>initMethod</td><td>根据 BeanDefinition 得到的初始化方法执行初始化，即 <code>&lt;bean init-method&gt;</code> 或 @Bean(initMethod)</td></tr><tr><td>创建 aop 代理</td><td>由 AnnotationAwareAspectJAutoProxyCreator 创建，执行时机在  postProcessAfterInitialization</td></tr></tbody></table><p><strong>5.4 创建 bean - 注册可销毁 bean</strong></p><p>在这一步判断并登记可销毁 bean</p><ul><li>判断依据<ul><li>如果实现了 DisposableBean 或 AutoCloseable 接口，则为可销毁 bean</li><li>如果自定义了 destroyMethod，则为可销毁 bean</li><li>如果采用 @Bean 没有指定 destroyMethod，则采用自动推断方式获取销毁方法名（close，shutdown）</li><li>如果有 @PreDestroy 标注的方法</li></ul></li><li>存储位置<ul><li>singleton scope 的可销毁 bean 会存储于 beanFactory 的成员当中</li><li>自定义 scope 的可销毁 bean 会存储于对应的域对象当中</li><li>prototype scope 不会存储，需要自己找到此对象销毁</li></ul></li><li>存储时都会封装为 DisposableBeanAdapter 类型对销毁方法的调用进行适配</li></ul><p><strong>6. 类型转换处理</strong></p><ul><li>如果 getBean 的 requiredType 参数与实际得到的对象类型不同，会尝试进行类型转换</li></ul><p><strong>7. 销毁 bean</strong></p><ul><li>销毁时机<ul><li>singleton bean 的销毁在 ApplicationContext.close 时，此时会找到所有 DisposableBean 的名字，逐一销毁</li><li>自定义 scope bean 的销毁在作用域对象生命周期结束时</li><li>prototype bean 的销毁可以通过自己手动调用 AutowireCapableBeanFactory.destroyBean 方法执行销毁</li></ul></li><li>同一 bean 中不同形式销毁方法的调用次序<ul><li>优先后处理器销毁，即 @PreDestroy</li><li>其次 DisposableBean 接口销毁</li><li>最后 destroyMethod 销毁（包括自定义名称，推断名称，AutoCloseable 接口 多选一）</li></ul></li></ul><h2 id="3-Spring-bean-循环依赖"><a href="#3-Spring-bean-循环依赖" class="headerlink" title="3. Spring bean 循环依赖"></a>3. Spring bean 循环依赖</h2><p><strong>要求</strong></p><ul><li>掌握单例 set 方式循环依赖的原理</li><li>掌握其它循环依赖的解决方法</li></ul><p><strong>循环依赖的产生</strong></p><ul><li><p>首先要明白，bean 的创建要遵循一定的步骤，必须是创建、注入、初始化三步，这些顺序不能乱</p></li><li><p>set 方法（包括成员变量）的循环依赖如图所示</p><ul><li><p>可以在【a 创建】和【a set 注入 b】之间加入 b 的整个流程来解决</p></li><li><p>【b set 注入 a】 时可以成功，因为之前 a 的实例已经创建完毕</p></li><li><p>a 的顺序，及 b 的顺序都能得到保障</p></li></ul></li><li><p>构造方法的循环依赖如图所示，显然无法用前面的方法解决</p></li></ul><p><strong>构造循环依赖的解决</strong></p><ul><li><p>思路1</p><ul><li>a 注入 b 的代理对象，这样能够保证 a 的流程走通</li><li>后续需要用到 b 的真实对象时，可以通过代理间接访问</li></ul></li><li><p>思路2</p><ul><li>a 注入 b 的工厂对象，让 b 的实例创建被推迟，这样能够保证 a 的流程先走通</li><li>后续需要用到 b 的真实对象时，再通过 ObjectFactory 工厂间接访问</li></ul></li><li><p>示例1：用 @Lazy 为构造方法参数生成代理</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App60_1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        <span class="keyword">private</span> B b;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(<span class="meta">@Lazy</span> B b)</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;A(B b) &#123;&#125;&quot;</span>, b.getClass());</span><br><span class="line">            <span class="built_in">this</span>.b = b;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@PostConstruct</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;init()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        <span class="keyword">private</span> A a;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">B</span><span class="params">(A a)</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;B(&#123;&#125;)&quot;</span>, a);</span><br><span class="line">            <span class="built_in">this</span>.a = a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@PostConstruct</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;init()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">        context.registerBean(<span class="string">&quot;a&quot;</span>, A.class);</span><br><span class="line">        context.registerBean(<span class="string">&quot;b&quot;</span>, B.class);</span><br><span class="line">        AnnotationConfigUtils.registerAnnotationConfigProcessors(context.getDefaultListableBeanFactory());</span><br><span class="line">        context.refresh();</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>示例2：用 ObjectProvider 延迟依赖对象的创建</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App60_2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        <span class="keyword">private</span> ObjectProvider&lt;B&gt; b;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(ObjectProvider&lt;B&gt; b)</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;A(&#123;&#125;)&quot;</span>, b);</span><br><span class="line">            <span class="built_in">this</span>.b = b;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@PostConstruct</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;init()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        <span class="keyword">private</span> A a;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">B</span><span class="params">(A a)</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;B(&#123;&#125;)&quot;</span>, a);</span><br><span class="line">            <span class="built_in">this</span>.a = a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@PostConstruct</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;init()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">        context.registerBean(<span class="string">&quot;a&quot;</span>, A.class);</span><br><span class="line">        context.registerBean(<span class="string">&quot;b&quot;</span>, B.class);</span><br><span class="line">        AnnotationConfigUtils.registerAnnotationConfigProcessors(context.getDefaultListableBeanFactory());</span><br><span class="line">        context.refresh();</span><br><span class="line"></span><br><span class="line">        System.out.println(context.getBean(A.class).b.getObject());</span><br><span class="line">        System.out.println(context.getBean(B.class));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>示例3：用 @Scope 产生代理</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App60_3</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">        <span class="type">ClassPathBeanDefinitionScanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathBeanDefinitionScanner</span>(context.getDefaultListableBeanFactory());</span><br><span class="line">        scanner.scan(<span class="string">&quot;com.itheima.app60.sub&quot;</span>);</span><br><span class="line">        context.refresh();</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(B b)</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;A(B b) &#123;&#125;&quot;</span>, b.getClass());</span><br><span class="line">        <span class="built_in">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;init()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope(proxyMode = ScopedProxyMode.TARGET_CLASS)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">(A a)</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;B(&#123;&#125;)&quot;</span>, a);</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;init()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>示例4：用 Provider 接口解决，原理上与 ObjectProvider 一样，Provider 接口是独立的 jar 包，需要加入依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.inject<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.inject<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App60_4</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        <span class="keyword">private</span> Provider&lt;B&gt; b;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(Provider&lt;B&gt; b)</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;A(&#123;&#125;&#125;)&quot;</span>, b);</span><br><span class="line">            <span class="built_in">this</span>.b = b;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@PostConstruct</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;init()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        <span class="keyword">private</span> A a;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">B</span><span class="params">(A a)</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;B(&#123;&#125;&#125;)&quot;</span>, a);</span><br><span class="line">            <span class="built_in">this</span>.a = a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@PostConstruct</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;init()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">        context.registerBean(<span class="string">&quot;a&quot;</span>, A.class);</span><br><span class="line">        context.registerBean(<span class="string">&quot;b&quot;</span>, B.class);</span><br><span class="line">        AnnotationConfigUtils.registerAnnotationConfigProcessors(context.getDefaultListableBeanFactory());</span><br><span class="line">        context.refresh();</span><br><span class="line"></span><br><span class="line">        System.out.println(context.getBean(A.class).b.get());</span><br><span class="line">        System.out.println(context.getBean(B.class));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解决-set-循环依赖的原理"><a href="#解决-set-循环依赖的原理" class="headerlink" title="解决 set 循环依赖的原理"></a>解决 set 循环依赖的原理</h3><p><strong>一级缓存</strong></p><p>作用是保证单例对象仅被创建一次</p><ul><li>第一次走 <code>getBean(&quot;a&quot;)</code> 流程后，最后会将成品 a 放入 singletonObjects 一级缓存</li><li>后续再走 <code>getBean(&quot;a&quot;)</code> 流程时，先从一级缓存中找，这时已经有成品 a，就无需再次创建</li></ul><p><strong>一级缓存与循环依赖</strong></p><p>一级缓存无法解决循环依赖问题，分析如下</p><ul><li>无论是获取 bean a 还是获取 bean b，走的方法都是同一个 getBean 方法，假设先走 <code>getBean(&quot;a&quot;)</code></li><li>当 a 的实例对象创建，接下来执行 <code>a.setB()</code> 时，需要走 <code>getBean(&quot;b&quot;)</code> 流程，红色箭头 1</li><li>当 b 的实例对象创建，接下来执行 <code>b.setA()</code> 时，又回到了 <code>getBean(&quot;a&quot;)</code> 的流程，红色箭头 2</li><li>但此时 singletonObjects 一级缓存内没有成品的 a，陷入了死循环</li></ul><p><strong>二级缓存</strong></p><p>解决思路如下：</p><ul><li>再增加一个 singletonFactories 缓存</li><li>在依赖注入前，即 <code>a.setB()</code> 以及 <code>b.setA()</code> 将 a 及 b 的半成品对象（未完成依赖注入和初始化）放入此缓存</li><li>执行依赖注入时，先看看 singletonFactories 缓存中是否有半成品的对象，如果有拿来注入，顺利走完流程</li></ul><p>对于上面的图</p><ul><li><code>a = new A()</code> 执行之后就会把这个半成品的 a 放入 singletonFactories 缓存，即 <code>factories.put(a)</code></li><li>接下来执行 <code>a.setB()</code>，走入 <code>getBean(&quot;b&quot;)</code> 流程，红色箭头 3</li><li>这回再执行到 <code>b.setA()</code> 时，需要一个 a 对象，有没有呢？有！</li><li><code>factories.get()</code> 在 singletonFactories  缓存中就可以找到，红色箭头 4 和 5</li><li>b 的流程能够顺利走完，将 b 成品放入 singletonObject 一级缓存，返回到 a 的依赖注入流程，红色箭头 6</li></ul><p><strong>二级缓存与创建代理</strong></p><p>二级缓存无法正确处理循环依赖并且包含有代理创建的场景，分析如下</p><ul><li>spring 默认要求，在 <code>a.init</code> 完成之后才能创建代理 <code>pa = proxy(a)</code></li><li>由于 a 的代理创建时机靠后，在执行 <code>factories.put(a)</code> 向 singletonFactories 中放入的还是原始对象</li><li>接下来箭头 3、4、5 这几步 b 对象拿到和注入的都是原始对象</li></ul><p><strong>三级缓存</strong></p><p>简单分析的话，只需要将代理的创建时机放在依赖注入之前即可，但 spring 仍然希望代理的创建时机在 init 之后，只有出现循环依赖时，才会将代理的创建时机提前。所以解决思路稍显复杂：</p><ul><li>图中 <code>factories.put(fa)</code> 放入的既不是原始对象，也不是代理对象而是工厂对象 fa</li><li>当检查出发生循环依赖时，fa 的产品就是代理 pa，没有发生循环依赖，fa 的产品是原始对象 a</li><li>假设出现了循环依赖，拿到了 singletonFactories 中的工厂对象，通过在依赖注入前获得了 pa，红色箭头 5</li><li>这回 <code>b.setA()</code> 注入的就是代理对象，保证了正确性，红色箭头 7</li><li>还需要把 pa 存入新加的 earlySingletonObjects 缓存，红色箭头 6</li><li><code>a.init</code> 完成后，无需二次创建代理，从哪儿找到 pa 呢？earlySingletonObjects 已经缓存，蓝色箭头 9</li></ul><p>当成品对象产生，放入 singletonObject 后，singletonFactories 和 earlySingletonObjects 就中的对象就没有用处，清除即可</p><h2 id="4-Spring-事务失效"><a href="#4-Spring-事务失效" class="headerlink" title="4. Spring 事务失效"></a>4. Spring 事务失效</h2><p><strong>要求</strong></p><ul><li>掌握事务失效的八种场景</li></ul><p><strong>1. 抛出检查异常导致事务不能正确回滚</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountMapper accountMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> amount)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fromBalance</span> <span class="operator">=</span> accountMapper.findBalanceBy(from);</span><br><span class="line">        <span class="keyword">if</span> (fromBalance - amount &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            accountMapper.update(from, -<span class="number">1</span> * amount);</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">            accountMapper.update(to, amount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>原因：Spring 默认只会回滚非检查异常</p></li><li><p>解法：配置 rollbackFor 属性</p><ul><li><code>@Transactional(rollbackFor = Exception.class)</code></li></ul></li></ul><p><strong>2. 业务方法内自己 try-catch 异常导致事务不能正确回滚</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountMapper accountMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> amount)</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">fromBalance</span> <span class="operator">=</span> accountMapper.findBalanceBy(from);</span><br><span class="line">            <span class="keyword">if</span> (fromBalance - amount &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                accountMapper.update(from, -<span class="number">1</span> * amount);</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">                accountMapper.update(to, amount);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>原因：事务通知只有捉到了目标抛出的异常，才能进行后续的回滚处理，如果目标自己处理掉异常，事务通知无法知悉</p></li><li><p>解法1：异常原样抛出</p><ul><li>在 catch 块添加 <code>throw new RuntimeException(e);</code></li></ul></li><li><p>解法2：手动设置 TransactionStatus.setRollbackOnly()</p><ul><li>在 catch 块添加 <code>TransactionInterceptor.currentTransactionStatus().setRollbackOnly();</code></li></ul></li></ul><p><strong>3. aop 切面顺序导致导致事务不能正确回滚</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service3</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountMapper accountMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> amount)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fromBalance</span> <span class="operator">=</span> accountMapper.findBalanceBy(from);</span><br><span class="line">        <span class="keyword">if</span> (fromBalance - amount &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            accountMapper.update(from, -<span class="number">1</span> * amount);</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">            accountMapper.update(to, amount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line">    <span class="meta">@Around(&quot;execution(* transfer(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        LoggerUtils.get().debug(<span class="string">&quot;log:&#123;&#125;&quot;</span>, pjp.getTarget());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> pjp.proceed();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>原因：事务切面优先级最低，但如果自定义的切面优先级和他一样，则还是自定义切面在内层，这时若自定义切面没有正确抛出异常…</p></li><li><p>解法1、2：同情况2 中的解法:1、2</p></li><li><p>解法3：调整切面顺序，在 MyAspect 上添加 <code>@Order(Ordered.LOWEST_PRECEDENCE - 1)</code> （不推荐）</p></li></ul><p><strong>4. 非 public 方法导致的事务失效</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service4</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountMapper accountMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> amount)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fromBalance</span> <span class="operator">=</span> accountMapper.findBalanceBy(from);</span><br><span class="line">        <span class="keyword">if</span> (fromBalance - amount &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            accountMapper.update(from, -<span class="number">1</span> * amount);</span><br><span class="line">            accountMapper.update(to, amount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>原因：Spring 为方法创建代理、添加事务通知、前提条件都是该方法是 public 的</p></li><li><p>解法1：改为 public 方法</p></li><li><p>解法2：添加 bean 配置如下（不推荐）</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> TransactionAttributeSource <span class="title function_">transactionAttributeSource</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AnnotationTransactionAttributeSource</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5. 父子容器导致的事务失效</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> day04.tx.app.service;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service5</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountMapper accountMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> amount)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fromBalance</span> <span class="operator">=</span> accountMapper.findBalanceBy(from);</span><br><span class="line">        <span class="keyword">if</span> (fromBalance - amount &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            accountMapper.update(from, -<span class="number">1</span> * amount);</span><br><span class="line">            accountMapper.update(to, amount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制器类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> day04.tx.app.controller;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> Service5 service;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> amount)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        service.transfer(from, to, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>App 配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;day04.tx.app.service&quot;)</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="comment">// ... 有事务相关配置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Web 配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;day04.tx.app&quot;)</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> &#123;</span><br><span class="line">    <span class="comment">// ... 无事务配置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在配置了父子容器，WebConfig 对应子容器，AppConfig 对应父容器，发现事务依然失效</p><ul><li><p>原因：子容器扫描范围过大，把未加事务配置的 service 扫描进来</p></li><li><p>解法1：各扫描各的，不要图简便</p></li><li><p>解法2：不要用父子容器，所有 bean 放在同一容器</p></li></ul><p><strong>6. 调用本类方法导致传播行为失效</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service6</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED, rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        LoggerUtils.get().debug(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">        bar();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW, rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        LoggerUtils.get().debug(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>原因：本类方法调用不经过代理，因此无法增强</p></li><li><p>解法1：依赖注入自己（代理）来调用</p></li><li><p>解法2：通过 AopContext 拿到代理对象，来调用</p></li><li><p>解法3：通过 CTW，LTW 实现功能增强</p></li></ul><p>解法1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service6</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Service6 proxy; <span class="comment">// 本质上是一种循环依赖</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED, rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        LoggerUtils.get().debug(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">System.out.println(proxy.getClass());</span><br><span class="line">proxy.bar();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW, rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        LoggerUtils.get().debug(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解法2，还需要在 AppConfig 上添加 <code>@EnableAspectJAutoProxy(exposeProxy = true)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service6</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED, rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        LoggerUtils.get().debug(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">        ((Service6) AopContext.currentProxy()).bar();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW, rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        LoggerUtils.get().debug(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>7. @Transactional 没有保证原子行为</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service7</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(Service7.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountMapper accountMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fromBalance</span> <span class="operator">=</span> accountMapper.findBalanceBy(from);</span><br><span class="line">        logger.debug(<span class="string">&quot;更新前查询余额为: &#123;&#125;&quot;</span>, fromBalance);</span><br><span class="line">        <span class="keyword">if</span> (fromBalance - amount &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            accountMapper.update(from, -<span class="number">1</span> * amount);</span><br><span class="line">            accountMapper.update(to, amount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findBalance</span><span class="params">(<span class="type">int</span> accountNo)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> accountMapper.findBalanceBy(accountNo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码实际上是有 bug 的，假设 from 余额为 1000，两个线程都来转账 1000，可能会出现扣减为负数的情况</p><ul><li><p>原因：事务的原子性仅涵盖 insert、update、delete、select … for update 语句，select 方法并不阻塞</p></li><li><p>如上图所示，红色线程和蓝色线程的查询都发生在扣减之前，都以为自己有足够的余额做扣减</p></li></ul><p><strong>8. @Transactional 方法导致的 synchronized 失效</strong></p><p>针对上面的问题，能否在方法上加 synchronized 锁来解决呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service7</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(Service7.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountMapper accountMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fromBalance</span> <span class="operator">=</span> accountMapper.findBalanceBy(from);</span><br><span class="line">        logger.debug(<span class="string">&quot;更新前查询余额为: &#123;&#125;&quot;</span>, fromBalance);</span><br><span class="line">        <span class="keyword">if</span> (fromBalance - amount &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            accountMapper.update(from, -<span class="number">1</span> * amount);</span><br><span class="line">            accountMapper.update(to, amount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findBalance</span><span class="params">(<span class="type">int</span> accountNo)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> accountMapper.findBalanceBy(accountNo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案是不行，原因如下：</p><ul><li><p>synchronized 保证的仅是目标方法的原子性，环绕目标方法的还有 commit 等操作，它们并未处于 sync 块内</p></li><li><p>可以参考下图发现，蓝色线程的查询只要在红色线程提交之前执行，那么依然会查询到有 1000 足够余额来转账</p></li><li><p>解法1：synchronized 范围应扩大至代理方法调用</p></li><li><p>解法2：使用 select … for update 替换 select</p></li></ul><h2 id="5-Spring-MVC-执行流程"><a href="#5-Spring-MVC-执行流程" class="headerlink" title="5. Spring MVC 执行流程"></a>5. Spring MVC 执行流程</h2><p><strong>要求</strong></p><ul><li>掌握 Spring MVC 的执行流程</li><li>了解 Spring MVC 的重要组件的作用</li></ul><p><strong>概要</strong></p><p>我把整个流程分成三个阶段</p><ul><li>准备阶段</li><li>匹配阶段</li><li>执行阶段</li></ul><p><strong>准备阶段</strong></p><ol><li><p>在 Web 容器第一次用到 DispatcherServlet 的时候，会创建其对象并执行 init 方法</p></li><li><p>init 方法内会创建 Spring Web 容器，并调用容器 refresh 方法</p></li><li><p>refresh 过程中会创建并初始化 SpringMVC 中的重要组件， 例如 MultipartResolver，HandlerMapping，HandlerAdapter，HandlerExceptionResolver、ViewResolver 等</p></li><li><p>容器初始化后，会将上一步初始化好的重要组件，赋值给 DispatcherServlet 的成员变量，留待后用</p></li></ol><p><strong>匹配阶段</strong></p><ol><li><p>用户发送的请求统一到达前端控制器 DispatcherServlet</p></li><li><p>DispatcherServlet 遍历所有 HandlerMapping ，找到与路径匹配的处理器</p><p>① HandlerMapping 有多个，每个 HandlerMapping 会返回不同的处理器对象，谁先匹配，返回谁的处理器。其中能识别 @RequestMapping 的优先级最高</p><p>② 对应 @RequestMapping 的处理器是 HandlerMethod，它包含了控制器对象和控制器方法信息</p><p>③ 其中路径与处理器的映射关系在 HandlerMapping 初始化时就会建立好</p></li><li><p>将 HandlerMethod 连同匹配到的拦截器，生成调用链对象 HandlerExecutionChain 返回</p></li><li><p>遍历HandlerAdapter 处理器适配器，找到能处理 HandlerMethod 的适配器对象，开始调用</p></li></ol><p><strong>调用阶段</strong></p><ol><li><p>执行拦截器 preHandle</p></li><li><p>由 HandlerAdapter 调用 HandlerMethod</p><p>① 调用前处理不同类型的参数</p><p>② 调用后处理不同类型的返回值</p></li><li><p>第 2 步没有异常</p><p>① 返回 ModelAndView</p><p>② 执行拦截器 postHandle 方法</p><p>③ 解析视图，得到 View 对象，进行视图渲染</p></li><li><p>第 2 步有异常，进入 HandlerExceptionResolver 异常处理流程</p></li><li><p>最后都会执行拦截器的 afterCompletion 方法</p></li><li><p>如果控制器方法标注了 @ResponseBody 注解，则在第 2 步，就会生成 json 结果，并标记 ModelAndView 已处理，这样就不会执行第 3 步的视图渲染</p></li></ol><h2 id="6-Spring-注解"><a href="#6-Spring-注解" class="headerlink" title="6. Spring 注解"></a>6. Spring 注解</h2><p><strong>要求</strong></p><ul><li>掌握 Spring 常见注解</li></ul><blockquote><p><em><strong>提示</strong></em></p><ul><li>注解的详细列表请参考：面试题-spring-注解.xmind</li><li>下面列出了视频中重点提及的注解，考虑到大部分注解同学们已经比较熟悉了，仅对个别的作简要说明</li></ul></blockquote><p><strong>事务注解</strong></p><ul><li>@EnableTransactionManagement，会额外加载 4 个 bean<ul><li>BeanFactoryTransactionAttributeSourceAdvisor 事务切面类</li><li>TransactionAttributeSource 用来解析事务属性</li><li>TransactionInterceptor 事务拦截器</li><li>TransactionalEventListenerFactory 事务监听器工厂</li></ul></li><li>@Transactional</li></ul><p><strong>核心</strong></p><ul><li>@Order</li></ul><p><strong>切面</strong></p><ul><li>@EnableAspectJAutoProxy<ul><li>会加载 AnnotationAwareAspectJAutoProxyCreator，它是一个 bean 后处理器，用来创建代理</li><li>如果没有配置 @EnableAspectJAutoProxy，又需要用到代理（如事务）则会使用 InfrastructureAdvisorAutoProxyCreator 这个 bean 后处理器</li></ul></li></ul><p><strong>组件扫描与配置类</strong></p><ul><li><p>@Component</p></li><li><p>@Controller</p></li><li><p>@Service</p></li><li><p>@Repository</p></li><li><p>@ComponentScan</p></li><li><p>@Conditional </p></li><li><p>@Configuration</p><ul><li>配置类其实相当于一个工厂, 标注 @Bean 注解的方法相当于工厂方法</li><li>@Bean 不支持方法重载, 如果有多个重载方法, 仅有一个能入选为工厂方法</li><li>@Configuration 默认会为标注的类生成代理, 其目的是保证 @Bean 方法相互调用时, 仍然能保证其单例特性</li><li>@Configuration 中如果含有 BeanFactory 后处理器, 则实例工厂方法会导致 MyConfig 提前创建, 造成其依赖注入失败，解决方法是改用静态工厂方法或直接为 @Bean 的方法参数依赖注入, 针对 Mapper 扫描可以改用注解方式</li></ul></li><li><p>@Bean</p></li><li><p>@Import </p><ul><li><p>四种用法</p><p>① 引入单个 bean</p><p>② 引入一个配置类</p><p>③ 通过 Selector 引入多个类</p><p>④ 通过 beanDefinition 注册器</p></li><li><p>解析规则</p><ul><li>同一配置类中, @Import 先解析  @Bean 后解析</li><li>同名定义, 默认后面解析的会覆盖前面解析的</li><li>不允许覆盖的情况下, 如何能够让 MyConfig(主配置类) 的配置优先? (虽然覆盖方式能解决)</li><li>采用 DeferredImportSelector，因为它最后工作, 可以简单认为先解析 @Bean, 再 Import</li></ul></li></ul></li><li><p>@Lazy</p><ul><li>加在类上，表示此类延迟实例化、初始化</li><li>加在方法参数上，此参数会以代理方式注入</li></ul></li><li><p>@PropertySource</p></li></ul><p><strong>依赖注入</strong></p><ul><li>@Autowired</li><li>@Qualifier</li><li>@Value</li></ul><p><strong>mvc mapping</strong></p><ul><li>@RequestMapping，可以派生多个注解如 @GetMapping 等</li></ul><p><strong>mvc rest</strong></p><ul><li>@RequestBody</li><li>@ResponseBody，组合 @Controller &#x3D;&gt;  @RestController</li><li>@ResponseStatus</li></ul><p><strong>mvc 统一处理</strong></p><ul><li>@ControllerAdvice，组合 @ResponseBody &#x3D;&gt; @RestControllerAdvice</li><li>@ExceptionHandler</li></ul><p><strong>mvc 参数</strong></p><ul><li>@PathVariable</li></ul><p><strong>mvc ajax</strong></p><ul><li>@CrossOrigin</li></ul><p><strong>boot auto</strong></p><ul><li>@SpringBootApplication</li><li>@EnableAutoConfiguration</li><li>@SpringBootConfiguration</li></ul><p><strong>boot condition</strong></p><ul><li>@ConditionalOnClass，classpath 下存在某个 class 时，条件才成立</li><li>@ConditionalOnMissingBean，beanFactory 内不存在某个 bean 时，条件才成立</li><li>@ConditionalOnProperty，配置文件中存在某个 property（键、值）时，条件才成立</li></ul><p><strong>boot properties</strong></p><ul><li>@ConfigurationProperties，会将当前 bean 的属性与配置文件中的键值进行绑定</li><li>@EnableConfigurationProperties，会添加两个较为重要的 bean<ul><li>ConfigurationPropertiesBindingPostProcessor，bean 后处理器，在 bean 初始化前调用下面的 binder</li><li>ConfigurationPropertiesBinder，真正执行绑定操作</li></ul></li></ul><h2 id="7-SpringBoot-自动配置原理"><a href="#7-SpringBoot-自动配置原理" class="headerlink" title="7. SpringBoot 自动配置原理"></a>7. SpringBoot 自动配置原理</h2><p><strong>要求</strong></p><ul><li>掌握 SpringBoot 自动配置原理</li></ul><p><strong>自动配置原理</strong></p><p>@SpringBootConfiguration 是一个组合注解，由 @ComponentScan、@EnableAutoConfiguration 和 @SpringBootConfiguration 组成</p><ol><li><p>@SpringBootConfiguration 与普通 @Configuration 相比，唯一区别是前者要求整个 app 中只出现一次</p></li><li><p>@ComponentScan</p><ul><li>excludeFilters - 用来在组件扫描时进行排除，也会排除自动配置类</li></ul></li><li><p>@EnableAutoConfiguration 也是一个组合注解，由下面注解组成</p><ul><li>@AutoConfigurationPackage – 用来记住扫描的起始包</li><li>@Import(AutoConfigurationImportSelector.class) 用来加载 <code>META-INF/spring.factories</code> 中的自动配置类</li></ul></li></ol><p><strong>为什么不使用 @Import 直接引入自动配置类</strong></p><p>有两个原因：</p><ol><li>让主配置类和自动配置类变成了强耦合，主配置类不应该知道有哪些从属配置</li><li>直接用 <code>@Import(自动配置类.class)</code>，引入的配置解析优先级较高，自动配置类的解析应该在主配置没提供时作为默认配置</li></ol><p>因此，采用了 <code>@Import(AutoConfigurationImportSelector.class)</code></p><ul><li>由 <code>AutoConfigurationImportSelector.class</code> 去读取 <code>META-INF/spring.factories</code> 中的自动配置类，实现了弱耦合。</li><li>另外 <code>AutoConfigurationImportSelector.class</code> 实现了 DeferredImportSelector 接口，让自动配置的解析晚于主配置的解析</li></ul><h2 id="8-Spring-中的设计模式"><a href="#8-Spring-中的设计模式" class="headerlink" title="8. Spring 中的设计模式"></a>8. Spring 中的设计模式</h2><p><strong>要求</strong></p><ul><li>掌握 Spring 中常见的设计模式</li></ul><p><strong>1. Spring 中的 Singleton</strong></p><p>请大家区分 singleton pattern 与 Spring 中的 singleton bean</p><ul><li>根据单例模式的目的 <em>Ensure a class only has one instance, and provide a global point of access to it</em> </li><li>显然 Spring 中的 singleton bean 并非实现了单例模式，singleton bean 只能保证每个容器内，相同 id 的 bean 单实例</li><li>当然 Spring 中也用到了单例模式，例如<ul><li>org.springframework.transaction.TransactionDefinition#withDefaults</li><li>org.springframework.aop.TruePointcut#INSTANCE</li><li>org.springframework.aop.interceptor.ExposeInvocationInterceptor#ADVISOR</li><li>org.springframework.core.annotation.AnnotationAwareOrderComparator#INSTANCE</li><li>org.springframework.core.OrderComparator#INSTANCE</li></ul></li></ul><p><strong>2. Spring 中的 Builder</strong></p><p>定义 <em>Separate the construction of a complex object from its representation so that the same construction process can create different representations</em> </p><p>它的主要亮点有三处：</p><ol><li><p>较为灵活的构建产品对象</p></li><li><p>在不执行最后 build 方法前，产品对象都不可用</p></li><li><p>构建过程采用链式调用，看起来比较爽</p></li></ol><p>Spring 中体现 Builder 模式的地方：</p><ul><li><p>org.springframework.beans.factory.support.BeanDefinitionBuilder</p></li><li><p>org.springframework.web.util.UriComponentsBuilder</p></li><li><p>org.springframework.http.ResponseEntity.HeadersBuilder</p></li><li><p>org.springframework.http.ResponseEntity.BodyBuilder</p></li></ul><p><strong>3. Spring 中的 Factory Method</strong></p><p>定义 <em>Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses</em> </p><p>根据上面的定义，Spring 中的 ApplicationContext 与 BeanFactory 中的 getBean 都可以视为工厂方法，它隐藏了 bean （产品）的创建过程和具体实现</p><p>Spring 中其它工厂：</p><ul><li><p>org.springframework.beans.factory.FactoryBean</p></li><li><p>@Bean 标注的静态方法及实例方法</p></li><li><p>ObjectFactory 及 ObjectProvider</p></li></ul><p>前两种工厂主要封装第三方的 bean 的创建过程，后两种工厂可以推迟 bean 创建，解决循环依赖及单例注入多例等问题</p><p><strong>4. Spring 中的 Adapter</strong></p><p>定义 <em>Convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldn’t otherwise because of incompatible interfaces</em> </p><p>典型的实现有两处：</p><ul><li>org.springframework.web.servlet.HandlerAdapter – 因为控制器实现有各种各样，比如有<ul><li>大家熟悉的 @RequestMapping 标注的控制器实现</li><li>传统的基于 Controller 接口（不是 @Controller注解啊）的实现</li><li>较新的基于 RouterFunction 接口的实现</li><li>它们的处理方法都不一样，为了统一调用，必须适配为 HandlerAdapter 接口</li></ul></li><li>org.springframework.beans.factory.support.DisposableBeanAdapter – 因为销毁方法多种多样，因此都要适配为 DisposableBean 来统一调用销毁方法</li></ul><p><strong>5. Spring 中的 Composite</strong></p><p>定义 <em>Compose objects into tree structures to represent part-whole hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly</em> </p><p>典型实现有：</p><ul><li>org.springframework.web.method.support.HandlerMethodArgumentResolverComposite</li><li>org.springframework.web.method.support.HandlerMethodReturnValueHandlerComposite</li><li>org.springframework.web.servlet.handler.HandlerExceptionResolverComposite</li><li>org.springframework.web.servlet.view.ViewResolverComposite</li></ul><p>composite 对象的作用是，将分散的调用集中起来，统一调用入口，它的特征是，与具体干活的实现实现同一个接口，当调用 composite 对象的接口方法时，其实是委托具体干活的实现来完成</p><p><strong>6. Spring 中的 Decorator</strong></p><p>定义 <em>Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality</em> </p><p>典型实现：</p><ul><li>org.springframework.web.util.ContentCachingRequestWrapper</li></ul><p><strong>7. Spring 中的 Proxy</strong></p><p>定义 <em>Provide a surrogate or placeholder for another object to control access to it</em> </p><p>装饰器模式注重的是功能增强，避免子类继承方式进行功能扩展，而代理模式更注重控制目标的访问</p><p>典型实现：</p><ul><li>org.springframework.aop.framework.JdkDynamicAopProxy</li><li>org.springframework.aop.framework.ObjenesisCglibAopProxy</li></ul><p><strong>8. Spring 中的 Chain of Responsibility</strong></p><p>定义 <em>Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request. Chain the receiving objects and pass the request along the chain until an object handles it</em> </p><p>典型实现：</p><ul><li>org.springframework.web.servlet.HandlerInterceptor</li></ul><p><strong>9. Spring 中的 Observer</strong></p><p>定义 <em>Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically</em> </p><p>典型实现：</p><ul><li>org.springframework.context.ApplicationListener</li><li>org.springframework.context.event.ApplicationEventMulticaster</li><li>org.springframework.context.ApplicationEvent</li></ul><p><strong>10. Spring 中的 Strategy</strong></p><p>定义 <em>Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it</em> </p><p>典型实现：</p><ul><li>org.springframework.beans.factory.support.InstantiationStrategy</li><li>org.springframework.core.annotation.MergedAnnotations.SearchStrategy</li><li>org.springframework.boot.autoconfigure.condition.SearchStrategy</li></ul><p><strong>11. Spring 中的 Template Method</strong></p><p>定义 <em>Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm’s structure</em> </p><p>典型实现：</p><ul><li>大部分以 Template 命名的类，如 JdbcTemplate，TransactionTemplate</li><li>很多以 Abstract 命名的类，如 AbstractApplicationContext</li></ul>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SSM </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
