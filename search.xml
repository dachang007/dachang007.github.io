<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java核心系列10：线程管理</title>
      <link href="/2025/04/02/Java%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%8610-%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
      <url>/2025/04/02/Java%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%8610-%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="1-线程的基本概念"><a href="#1-线程的基本概念" class="headerlink" title="1 线程的基本概念"></a>1 线程的基本概念</h2><p>线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。每个线程都有一个独立的执行路径，但共享进程的资源，如内存和文件句柄。在Java中，线程可以通过继承<code>Thread</code>类或实现<code>Runnable</code>接口来创建。</p><p>此外，<code>Java 5</code>开始，引入了<code>java.util.concurrent</code>包，提供了更多的并发工具，如Callable接口与Future接口，它们主要用于任务执行。</p><h2 id="2-线程的创建与启动"><a href="#2-线程的创建与启动" class="headerlink" title="2 线程的创建与启动"></a>2 线程的创建与启动</h2><h3 id="2-1-继承Thread类"><a href="#2-1-继承Thread类" class="headerlink" title="2.1 继承Thread类"></a>2.1 继承Thread类</h3><ul><li>创建一个类继承自<code>Thread</code>类。</li><li>重写<code>run()</code>方法，该方法包含了线程要执行的任务。</li><li>创建该类的对象，并调用<code>start()</code>方法启动线程。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">run</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;线程运行中&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="title class_">String</span>[] args</span>) &#123;</span><br><span class="line">        <span class="title class_">MyThread</span> t = <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        t.<span class="title function_">start</span>(); <span class="comment">// 调用start()方法来启动线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-实现Runnable接口"><a href="#2-2-实现Runnable接口" class="headerlink" title="2.2 实现Runnable接口"></a>2.2 实现Runnable接口</h3><ul><li>创建一个类实现<code>Runnable</code>接口。</li><li>实现<code>run()</code>方法，该方法同样包含了线程要执行的任务。</li><li>将该类的对象作为参数传递给<code>Thread</code>类的构造函数，创建<code>Thread</code>对象。</li><li>调用<code>Thread</code>对象的<code>start()</code>方法启动线程。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">run</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;线程运行中&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="title class_">String</span>[] args</span>) &#123;</span><br><span class="line">        <span class="title class_">Thread</span> t = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        t.<span class="title function_">start</span>(); <span class="comment">// 调用start()方法来启动线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-线程的同步与通信"><a href="#3-线程的同步与通信" class="headerlink" title="3 线程的同步与通信"></a>3 线程的同步与通信</h2><p>由于多个线程可能会同时访问共享资源，因此需要使用同步机制来确保数据的正确性和一致性。Java提供了多种同步机制，如<code>synchronized</code>关键字、<code>wait()</code>和<code>notify()</code>方法、以及<code>ReentrantLock</code>等。</p><h3 id="3-1-synchronized关键字"><a href="#3-1-synchronized关键字" class="headerlink" title="3.1 synchronized关键字"></a>3.1 synchronized关键字</h3><ol><li>可以用于方法或代码块上，以确保同一时刻只有一个线程能够执行该方法或代码块。</li><li>当一个线程持有某个对象的锁时，其他线程将无法访问该对象的同步方法或代码块，直到锁被释放。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">SynchronizedExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedExample</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建多个线程来测试同步</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                example.increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                example.increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待线程执行完毕</span></span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出最终结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Final count: &quot;</span> + example.getCount()); <span class="comment">// 最终输出2000</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-wait-和notify-方法"><a href="#3-2-wait-和notify-方法" class="headerlink" title="3.2 wait()和notify()方法"></a>3.2 wait()和notify()方法</h3><p>这两个方法用于在线程之间进行通信。</p><ol><li><code>wait()</code>方法使当前线程等待，直到其他线程调用<code>notify()</code>或<code>notifyAll()</code>方法唤醒它。</li><li><code>notify()</code>方法唤醒一个等待该对象的线程（如果有多个线程在等待，则选择其中一个），而<code>notifyAll()</code>方法唤醒所有等待该对象的线程。</li></ol><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAPRaUeueyavezm8d1RgrPrVUbZrLcAAAvcLaxunpzhWCiLKGOtGlPUBAAMCAAN5AAM2BA.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"># 先写后读</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitNotifyExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">ready</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writer</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="comment">// 模拟写操作</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>); <span class="comment">// 假设写操作需要1秒</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Data is ready&quot;</span>);</span><br><span class="line">            ready = <span class="literal">true</span>;</span><br><span class="line">            lock.notify(); <span class="comment">// 唤醒等待的线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reader</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!ready) &#123;</span><br><span class="line">                lock.wait(); <span class="comment">// 等待数据准备好</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 读取数据</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Data has been read&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">WaitNotifyExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WaitNotifyExample</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">writerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(example::writer);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">readerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(example::reader);</span><br><span class="line"></span><br><span class="line">        writerThread.start();</span><br><span class="line">        readerThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-ReentrantLock"><a href="#3-3-ReentrantLock" class="headerlink" title="3.3 ReentrantLock"></a>3.3 ReentrantLock</h3><ol><li>提供了比<code>synchronized</code>更灵活的锁机制。</li><li>可以显式地加锁和解锁，还支持公平锁和非公平锁等特性。</li></ol><h3 id="3-4-线程的生命周期与状态"><a href="#3-4-线程的生命周期与状态" class="headerlink" title="3.4 线程的生命周期与状态"></a>3.4 线程的生命周期与状态</h3><p>Java线程在其生命周期中会经历多种状态，包括新建（New）、就绪（Runnable）、运行（Running）、阻塞（Blocked）、等待（Waiting）、超时等待（Timed Waiting）和终止（Terminated）。</p><ul><li><strong>新建（New）</strong>：线程被创建但尚未启动。</li><li><strong>就绪（Runnable）</strong>：线程已启动且正在等待CPU分配时间片。</li><li><strong>运行（Running）</strong>：线程正在执行其任务。</li><li><strong>阻塞（Blocked）</strong>：线程因等待某个条件而暂时停止执行。</li><li><strong>等待（Waiting）</strong>：线程因调用<code>wait()</code>方法而等待其他线程唤醒。</li><li><strong>超时等待（Timed Waiting）</strong>：线程在等待某个条件的同时还设置了一个超时时间。</li><li><strong>终止（Terminated）</strong>：线程已完成任务并退出。</li></ul><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAPOaUer6dvmjBFagfhkaXqEfpl3ui4AAu0LaxunpzhWc0KL_3hfiHIBAAMCAAN5AAM2BA.png"></p><h2 id="5-线程池"><a href="#5-线程池" class="headerlink" title="5 线程池"></a>5 线程池</h2><p>为了更有效地管理线程，Java提供了线程池机制。线程池是一种用于管理和复用线程的框架，它允许开发者以较小的开销来创建和管理大量的线程。Java中的<code>ExecutorService</code>接口及其实现类（如<code>ThreadPoolExecutor</code>）提供了强大的线程池功能。<br>Java中提供了几种常见的线程池类型，包括：</p><ol><li>FixedThreadPool（固定大小线程池）：包含固定数量的线程，适用于需要限制并发线程数量的场景。</li><li>CachedThreadPool（缓存线程池）：不固定线程数量，可以根据需要自动创建新线程，适用于短期异步任务。</li><li>SingleThreadPool（单线程池）：只包含一个工作线程，保证所有任务按顺序执行，适用于需要保持任务顺序执行的场景。</li><li>ScheduledThreadPool（定时线程池）：可以执行定时任务和周期性任务。</li><li>WorkStealingPool（工作窃取线程池）：Java 8中引入的一种新类型的线程池，主要用于处理耗时任务，适用于需要大量并行任务、任务之间没有依赖关的情况。</li></ol><p>在后续的章节里面，我们会专门来详细介绍下线程池的使用</p><h2 id="6-最佳实践"><a href="#6-最佳实践" class="headerlink" title="6 最佳实践"></a>6 最佳实践</h2><ul><li><strong>避免创建过多的线程</strong>：过多的线程会导致上下文切换频繁，从而降低系统性能。</li><li><strong>合理设置线程优先级</strong>：根据任务的紧急程度和重要性来设置线程的优先级。</li><li><strong>使用线程安全的集合</strong>：在多线程环境下使用线程安全的集合来避免数据不一致的问题。</li><li><strong>避免死锁</strong>：在设计多线程程序时要特别注意避免死锁的发生。</li></ul><p>综上所述，Java线程管理是一个复杂而重要的领域。通过合理地创建、调度、同步和销毁线程，可以显著提高程序的性能、响应性和稳定性。同时，开发者还需要遵循一些最佳实践来避免常见的问题和陷阱。</p>]]></content>
      
      
      <categories>
          
          <category> Java核心系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java核心 </tag>
            
            <tag> Java基础 </tag>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java核心系列4：AOP原理和切面应用</title>
      <link href="/2025/04/02/Java%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%864-AOP%E5%8E%9F%E7%90%86%E5%92%8C%E5%88%87%E9%9D%A2%E5%BA%94%E7%94%A8/"/>
      <url>/2025/04/02/Java%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%864-AOP%E5%8E%9F%E7%90%86%E5%92%8C%E5%88%87%E9%9D%A2%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><p>我们所说的Aop（即面向切面编程），即面向接口，也面向方法，在基于IOC的基础上实现。</p><p>Aop最大的特点是对指定的方法进行拦截并增强，这种增强的方式不需要业务代码进行调整，无需侵入到业务代码中，使业务与非业务处理逻辑分离。</p><p>以Spring举例，通过事务的注解配置，Spring会自动在业务方法中开启、提交业务，并且在业务处理失败时，执行相应的回滚策略。</p><p>aop的实现主要包括了两个部分：</p><ul><li>匹配符合条件的方法(Pointcut)</li><li>对匹配的方法增强(<strong>JDK代理、cglib代理</strong>)<br>spring针对xml配置和配置自动代理的Advisor有很大的处理差别，在IOC中主要是基于XML配置分析的，在AOP的源码解读中，则主要从自动代理的方式解析，分析完注解的方式，再分析基于xml的方式。</li></ul><h1 id="2-案例分析"><a href="#2-案例分析" class="headerlink" title="2 案例分析"></a>2 案例分析</h1><p>下面是spring aop的用法，也是用于源码分析的案例切面类：TracesRecordAdvisor</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TracesRecordAdvisor</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* spring.action.expend.aop.services.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">expression</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;expression()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beforePrint</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进入服务，在服务执行之前,记录日志....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning(&quot;expression()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPrint</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;退出服务，在服务执行结束之后,记录日志.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>xml配置: aop的注解启用只需要在xml中配置这段代码即可，这个是作为入口</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>服务类：PayServiceImpl 使用jdk代理 所以要有一个接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PayServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">PayService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">payMoneyMenthod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在执行付款...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">springAopTestService</span><span class="params">()</span> &#123;</span><br><span class="line">    ClassPathXmlApplicationContext applicationContext=<span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;spring-aop.xml&quot;</span>);</span><br><span class="line">    PayService payService= (PayService) applicationContext.getBean(<span class="string">&quot;payServiceImpl&quot;</span>);</span><br><span class="line">    payService.payMoneyMenthod();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">进入服务，在服务执行之前,记录日志....</span><br><span class="line">正在执行付款...</span><br><span class="line">退出服务，在服务执行结束之后,记录日志.....</span><br></pre></td></tr></table></figure><p>从上面的执行结果看，payMoneyMenthod 方法的确是被增强了。</p><h1 id="3-BeanFactoryPostProcessor"><a href="#3-BeanFactoryPostProcessor" class="headerlink" title="3 BeanFactoryPostProcessor"></a>3 BeanFactoryPostProcessor</h1><p>读spring源码的时候，可以首先看下BeanFactoryPostProcessor和BeanPostProcess,这两个接口都是在spring通过配置文件或者xml获取bean声明，生成BeanDefinition后，允许我们再对生成的BeanDefinition，进行入口包装和增强。</p><p>我们看看BeanFactoryPostProcessor的定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanFactoryPostProcessor</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法postProcessBeanFactory的参数为ConfigurableListableBeanFactory，我们之前讨论过beanFactory用来获取bean的，而ConfigurableListableBeanFactory继承接口SingletonBeanRegistry和BeanFactroy，所以可以访问到已经生成过的BeanDefinitions集合，如果某个类实现该接口，spring会注册这个类，然后执行这个类的postProcessBeanFactory方法，以便我们对BeanDefinition进行扩展。</p><p>接下来的代码表示Spring是如何注册BeanFactoryPostProcessor并执行postProcessBeanFactory的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        prepareRefresh();</span><br><span class="line">        <span class="comment">//核心方法1</span></span><br><span class="line">        <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> obtainFreshBeanFactory();</span><br><span class="line">        prepareBeanFactory(beanFactory);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            postProcessBeanFactory(beanFactory);</span><br><span class="line">            <span class="comment">//核心方法2 执行BeanFactoryPostProcessor</span></span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">            <span class="comment">//核心方法 3 注册BeanPostProcessor</span></span><br><span class="line">            registerBeanPostProcessors(beanFactory);</span><br><span class="line">            <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">            initMessageSource();</span><br><span class="line">            <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">            initApplicationEventMulticaster();</span><br><span class="line">            <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">            onRefresh();</span><br><span class="line">            <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">            registerListeners();</span><br><span class="line">            <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">            finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">            <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">            finishRefresh();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">             ............</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">             ............</span><br><span class="line">            resetCommonCaches();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心方法1obtainFreshBeanFactory就是前两篇所说的生成BeanDefinition的入口，invokeBeanFactoryPostProcessors核心方法2就是执行BeanFactoryPostProcessor接口的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">   PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过方法getBeanFactoryPostProcessors获取注册BeanFactoryPostProcessor，然后来看看如何添加一个处理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addBeanFactoryPostProcessor</span><span class="params">(BeanFactoryPostProcessor beanFactoryPostProcessor)</span> &#123;</span><br><span class="line">   <span class="built_in">this</span>.beanFactoryPostProcessors.add(beanFactoryPostProcessor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于方法invokeBeanFactoryPostProcessors不再往下看了，里面的方法大致先对BeanFactoryPostProcessor进行排序，排序的标准是是否实现了PriorityOrdered，然后根据设置的order大小指定执行顺序，生成一个排序集合和一个普通的集合，最后执行invokeBeanFactoryPostProcessors</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invokeBeanFactoryPostProcessors</span><span class="params">(</span></span><br><span class="line"><span class="params">      Collection&lt;? extends BeanFactoryPostProcessor&gt; postProcessors, ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (BeanFactoryPostProcessor postProcessor : postProcessors) &#123;</span><br><span class="line">              <span class="comment">//执行到自定义的BeanFactoryPostProcessor</span></span><br><span class="line">             postProcessor.postProcessBeanFactory(beanFactory);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法就会循环先前注册的BeanFactoryPostProcessor集合，然后执行postProcessBeanFactory。</p><h1 id="4-BeanPostProcess-解读"><a href="#4-BeanPostProcess-解读" class="headerlink" title="4 BeanPostProcess 解读"></a>4 BeanPostProcess 解读</h1><p>与BeanFactoryPostProcessor相比，BeanPostProcess就重要得多了，因为Spring的注解、AOP等都是通过这个接口的方法拦截执行的，它贯穿了Bean创建过程的整个生命周期，在IOC阶段，Spring只注册BeanPostProcess，执行则放到了Bean的实例化创建阶段。</p><p>首先看下BeanPostProcessor的接口定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line">        <span class="comment">//在bean创建 属性赋值之后  Aware接口执行之后执行</span></span><br><span class="line">        Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">        <span class="comment">//在init-method afterPropertiesSet 执行之后执行</span></span><br><span class="line">        Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在bean的声明周期中，下面的序列是bean创建后要执行的接口和方法顺序：</p><ul><li>实例化（autowireConstructor或者instantiateBean)</li><li>属性初始化(populateBean)</li><li>Aware接口（如果你的 bean 有进行实现)</li><li>BeanPostProcess.postProcessBeforeInitialization</li><li>PostConstructInitializingBean.afterPropertiesSet</li><li>BeanPostProcess.postProcessAfterInitialization</li></ul><p>其中通过注解引入依赖的方式就是在AutowiredAnnotationBeanPostProcessor这个类中实现的，而接下来要分析的Spring Aop也是从这里开始的，这个类叫AnnotationAwareAspectJAutoProxyCreator,</p><h1 id="5-NameSpaceHanlder-解读"><a href="#5-NameSpaceHanlder-解读" class="headerlink" title="5 NameSpaceHanlder 解读"></a>5 NameSpaceHanlder 解读</h1><p>在Spring中，任何的技术都是在IOC的基础上进行的，Aop也不例外，程序会首先读取xml配置文件，然后对读取到的标签先查找命名空间，然后找对应的NameSpaceHandler，最终调用parse方法解析标签。</p><p>aop标签的解析，使用纯注解的方式aop:aspectj-autoproxy和使用aop:config的配置解析不太一样，具体表现在生成PointCut和生成Before、After、Around等切面类时，使用aop:config的方式会为这些注解生成一个BeanDefinition，而这个BeanDefinition的构造函数是由3个BeanDefinition组成，表明这个类是合成类，即synthetic这个属性为true。然后跟解析普通的bean一样，生成这些实例对象，后面的过程就跟是用纯注解的方式相同了，接下来的分析是基于纯注解分析的，也就是解析从解析aop:aspectj-autoproxy这个标签开始。</p><p>前面的xml文件的标签解析是通过parseDefaultElement方法解析默认的标签的，而我们在配置文件里面配置了启动自动代理的方式<code>&lt;aop:aspectj-autoproxy/&gt;</code>，当Spring读取到这个标签，则会走parseCustomElement(root)这个方法了，这个方法的源码不再解析，主要完成的功能如下:</p><ul><li>获取element的nameSpaceUri,根据nameSpaceUri找到NameSpaceHanlder</li><li>调用NameSpaceHanlder的parse方法解析element</li></ul><p>下面是NameSpaceHanlder接口的定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">NamespaceHandler</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>;</span><br><span class="line">        BeanDefinition <span class="title function_">parse</span><span class="params">(Element element, ParserContext parserContext)</span>;</span><br><span class="line">        BeanDefinitionHolder <span class="title function_">decorate</span><span class="params">(Node source, BeanDefinitionHolder definition, ParserContext parserContext)</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里面的init方法是我们初始化操作的，这里可以完成对指定的标签设置解析器，然后再parse方法里面找到指定标签的解析器，然后调用该解析器的parse方法解析标签，后面会重点看这两个方法。</p><p>再来看下Spring如何加载NameSpaceHanlder的，Spring首先会取查找项目空间下目录META-INF&#x2F;的所有spring.handlers文件，这个文件是在Spring依赖的jar下面，在核心jar包都会由这个文件，aop的jar包路径下文件内容为：spring.handlers</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.springframework.org/schema/aop=org.springframework.aop.config.AopNamespaceHandler</span><br></pre></td></tr></table></figure><p>发现这里面存储的是一个key，value,key是aop的nameSpaceUri，value是AopNamespaceHandler，从这个类名上就能发现该类实现了NamespaceHandler，肯定也就实现了init和parse方法，所以解析<code>&lt;aop:aspectj-autoproxy/&gt;</code>的任务就由AopNamespaceHandler的parse完成。</p><p>查看AopNamespaceHandler的init方法</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">init</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// In 2.0 XSD as well as in 2.1 XSD.</span></span><br><span class="line">    <span class="title function_">registerBeanDefinitionParser</span>(<span class="string">&quot;config&quot;</span>, <span class="keyword">new</span> <span class="title class_">ConfigBeanDefinitionParser</span>());</span><br><span class="line">    <span class="title function_">registerBeanDefinitionParser</span>(<span class="string">&quot;aspectj-autoproxy&quot;</span>, <span class="keyword">new</span>                       <span class="title class_">AspectJAutoProxyBeanDefinitionParser</span>());</span><br><span class="line">    <span class="title function_">registerBeanDefinitionDecorator</span>(<span class="string">&quot;scoped-proxy&quot;</span>, <span class="keyword">new</span> <span class="title class_">ScopedProxyBeanDefinitionDecorator</span>());</span><br><span class="line">    <span class="comment">// Only in 2.0 XSD: moved to context namespace as of 2.1</span></span><br><span class="line">    <span class="title function_">registerBeanDefinitionParser</span>(<span class="string">&quot;spring-configured&quot;</span>, <span class="keyword">new</span> <span class="title class_">SpringConfiguredBeanDefinitionParser</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码就很清晰了，<code>&lt;aop:config&gt;</code> 标签由ConfigBeanDefinitionParser处理，<code>&lt;aop:aspectj-autoproxy/&gt;</code> 则由AspectJAutoProxyBeanDefinitionParser这个类处理，这两种处理其实对应了自动代理和通过xml配置的处理方式，然后会调用AspectJAutoProxyBeanDefinitionParser的parse方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BeanDefinition <span class="title function_">parse</span><span class="params">(Element element, ParserContext parserContext)</span> &#123;</span><br><span class="line">        AopNamespaceUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(parserContext, element);</span><br><span class="line">        extendBeanDefinition(element, parserContext);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个方法其实就是为了注册一个AnnotationAwareAspectJAutoProxyCreator类，然后AOP的所有处理逻辑都会交给这个类处理,由于这个类的实现了BeanPostProcessor,所以这个类的入口就是BeanPostProcessor接口的两个方法：</p><ul><li>postProcessBeforeInitialization</li><li>postProcessAfterInitialization</li></ul><h1 id="6-Spring-Aop-源码分析"><a href="#6-Spring-Aop-源码分析" class="headerlink" title="6 Spring Aop 源码分析"></a>6 Spring Aop 源码分析</h1><p>我们前面分析了，当spring读取xml文件遇到<code>&lt;aop:aspectj-autoproxy/&gt;</code>会找到AopNamespaceHandler这个处理类，然后这个类又将这个标签委托给了AspectJAutoProxyBeanDefinitionParser类，最终调用这个类得parse方法，parse方法未做分析，其实这个方法的目的很简单，就是注册AnnotationAwareAspectJAutoProxyCreator这个类，这个类实现了BeanPostProcessor和InstantiationAwareBeanPostProcessor接口，最终在实例化bean对象也就是执行BeanFactory.getBean(beanName)的过程中，会调用这两个接口的方法(执行顺序如下)：</p><p>InstantiationAwareBeanPostProcessor先执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">postProcessBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName)</span><br><span class="line">postProcessAfterInstantiation(Object bean, String beanName)</span><br></pre></td></tr></table></figure><p>BeanPostProcessor再执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">postProcessBeforeInitialization(Object bean, String beanName)</span><br><span class="line">Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span></span><br></pre></td></tr></table></figure><p>AOP的实现基本上是在这两个方法中进行的，所以就从这里来看Spring是如何实现AOP的，Spring的AOP代理目前支持方法的增强，看源码目前好像也支持了属性的增强了。</p><p>读取源码前首先来分析一下方法增强的原理，有助于我们读取源码时紧紧抓住主线。首先第一个问题，如果我们想对一个类的方法进行增强，我们应该怎么做呢？</p><p>这种业务需求可以通过代理实现，在方法执行前，拦截这个方法，并且加入要执行增强的逻辑，最后再执行目标方法。下面是Spring用的两种代理方式：</p><blockquote><p><strong>JDK代理</strong>：我们可以通Proxy类获取一个目标类的代理对象，但JDK代理要求被代理的类必须实现接口，所以是基于接口的代理。</p></blockquote><blockquote><p><strong>cglib代理</strong>：如果目标类没有接口，使用cglib代理，是由asm封装的，直接操作类得字节码，效率也很高。</p></blockquote><p>由于在生产业务中，我们不可能对所有的类都执行增强，所以还需要一个选择器，将符合条件的bean进行增强，Spring使用了PointCut接口，通过该接口的getMethodMatcher方法获取一个方法匹配器，然后通过matches方法匹配到目标类对象的目标方法执行增强操作。mathcer匹配规则就是通过Spring 配置的expression表达式了。</p><p>所以在分析源码的时，要围绕这两方面进行：</p><ul><li>匹配切点方法（构建切入点表达式类和切面类）</li><li>创建代理对象</li></ul><p>这两方面在Spring的实现里非常复杂，尤其是第一步匹配切点方法过程，这个过程中，Spring会将@Aspect注解类的@Before，@After，@Around、@Pointcut等注解都封装成待执行的切面方法类，然后通过方法匹配器匹配到的要增强的方法前后执行切面方法类，达到方法增强的目的。</p><p>第二阶段，创建代理对象默认是通过JDK代理实现配置，&lt;aop:aspectj-autoproxy proxy-target-class&#x3D;”true”&gt;这样配置可以指定使用cglib代理。</p><h1 id="7-注解切面代理类分析"><a href="#7-注解切面代理类分析" class="headerlink" title="7 注解切面代理类分析"></a>7 注解切面代理类分析</h1><p>上面分析了真正实现AOP功能的是AnnotationAwareAspectJAutoProxyCreator,由于这个类实现了BeanPostProcessor和InstantiationAwareBeanPostProcessor，所以在创建一个bean的时候，会进入到这两个接口的方法，这两个接口包含了四个方法，方法执行顺序上面已经分析过了，来看看这个类的类图：<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAO8aUea8taWIg069oOemwfAWUdNTAcAArMLaxunpzhWofFefUwj4FEBAAMCAAN3AAM2BA.png" alt="AnnotationAwareAspectJAutoProxyCreator类"><br>类图上比较重要的接口就是右上角实现的两个接口，在bean创建的生命周期过程中，会校验当前容器中是否注册了实现了这两个接口的类，如果有则调用接口的方法，前面的分析中在解析aop:aspectj-autoproxy&#x2F;时，将这个类注册到了容器中，而且上面也罗列了这两个接口中四个方法的调用顺序，在这个类中完成主要功能的2个方法及其执行顺序:</p><ul><li>InstantiationAwareBeanPostProcessor先执行：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">postProcessBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName)</span><br></pre></td></tr></table></figure><ul><li>BeanPostProcessor再执行：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span></span><br></pre></td></tr></table></figure><p>postProcessBeforeInstantiation方法主要是找出注解了Advice的类，并将Advice的类使用了@Before，@After，@Around、@Pointcut,@AfterThrowing等注解的方法封装成一个一个类放入到缓存中供匹配到的类生成代理用</p><p>postProcessAfterInitialization主要是匹配符合条件的目标类对象，然后生成代理的过程,接下来就按顺序分析这两个方法完成的功能。</p><h1 id="8-Aspect注解类分析"><a href="#8-Aspect注解类分析" class="headerlink" title="8 Aspect注解类分析"></a>8 Aspect注解类分析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="comment">//构建一个缓存key</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">cacheKey</span> <span class="operator">=</span> getCacheKey(beanClass, beanName);</span><br><span class="line">    <span class="keyword">if</span> (beanName == <span class="literal">null</span> || !<span class="built_in">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">        <span class="comment">//如果当前beanClass的缓存key 存在于Class为Advise的缓存中，表示当前的beanClass是Adivse类</span></span><br><span class="line">        <span class="comment">//而且不需要生成代理。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.advisedBeans.containsKey(cacheKey)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//核心校验：1 当前类是否是AOP的基础类 2、当前类是否应该跳过不生成代理</span></span><br><span class="line">        <span class="keyword">if</span> (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这部分主要是用于实现了TargetSource接口的bean，然后从getTarget中获取对象 创建代理</span></span><br><span class="line">    <span class="keyword">if</span> (beanName != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">TargetSource</span> <span class="variable">targetSource</span> <span class="operator">=</span> getCustomTargetSource(beanClass, beanName);</span><br><span class="line">        <span class="keyword">if</span> (targetSource != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.targetSourcedBeans.add(beanName);</span><br><span class="line">            Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">proxy</span> <span class="operator">=</span> createProxy(beanClass, beanName, specificInterceptors, targetSource);</span><br><span class="line">            <span class="built_in">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">            <span class="keyword">return</span> proxy;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法主要是先为beanClass生成一个缓存的key，这个beanClass如果是FactoryBean，则按照工厂类的命名规则命名，否则用beanName命名，然后用刚才生成的key判断beanClass是否已经存在于Advice的缓存集合中，如果已经存在则代表该类是切面类而且已经被处理过了，后续处理不会为该类生成代理，如果没有没处理过，则会调用下面的方法校验该类是否是AOP的基础类 ，总之这个方法作用就是将AOP相关操作的切面类和基础类放入到缓存中，当为bean生成代理的时候，忽略advice缓存中的AOP切面类和基础类，下面是具体校验过程：AnnotationAwareAspectJAutoProxyCreator重写了该方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isInfrastructureClass</span><span class="params">(Class&lt;?&gt; beanClass)</span> &#123;</span><br><span class="line"><span class="comment">//调用父类的isInfrastructureClass判断是否是aop基础类</span></span><br><span class="line"><span class="comment">//校验当前类是否使用@Aspect注解</span></span><br><span class="line"><span class="keyword">return</span> (<span class="built_in">super</span>.isInfrastructureClass(beanClass) || <span class="built_in">this</span>.aspectJAdvisorFactory.isAspect(beanClass));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>父类的isInfrastructureClass方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isInfrastructureClass</span><span class="params">(Class&lt;?&gt; beanClass)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">retVal</span> <span class="operator">=</span> Advice.class.isAssignableFrom(beanClass) ||</span><br><span class="line">            Advisor.class.isAssignableFrom(beanClass) ||</span><br><span class="line">            AopInfrastructureBean.class.isAssignableFrom(beanClass);</span><br><span class="line">    <span class="keyword">if</span> (retVal &amp;&amp; logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">&quot;Did not attempt to auto-proxy infrastructure class [&quot;</span> + beanClass.getName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>里面isAssignableFrom表示当前类是否允许被设置为beanClass类对象，可以以此判断beanClass是否是Advice类，所以这个方法的校验目的就是判断当前正在创建目标类是否是AOP的基础类，即该类是否是Advice,Advisor或者实现了AopInfrastructureBean接口。该方法调用父类的isInfrastructureClass判断是否是aop基础类，然后再校验当前类是否使用@Aspect注解，目的只有一个，如果是Advice切面相关的类不做任何处理，直接放入advice缓存即可。然后再来看shouldSkip(beanClass, beanName)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">shouldSkip</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> &#123;</span><br><span class="line">    <span class="comment">//查找当前已经生成的所有Advisor切面类  不展开分析</span></span><br><span class="line">    List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</span><br><span class="line">    <span class="keyword">for</span> (Advisor advisor : candidateAdvisors) &#123;</span><br><span class="line">        <span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> AspectJPointcutAdvisor) &#123;</span><br><span class="line">            <span class="keyword">if</span> (((AbstractAspectJAdvice) advisor.getAdvice()).getAspectName().equals(beanName)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.shouldSkip(beanClass, beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法主要是校验当前正在创建bean的beanName是否属于已经创建好的切面类缓存中，如果是则加入到advices缓存中，不再处理。其中findCandidateAdvisors()会查找当前容器中生成的所有实现了Advisor的类，Spring会将@Before，@After，@Around等生成一个继承了Advisor类对象存储到缓存中供后续使用,这一部分时Spring AOP前半段的核心内容，后续都会围绕着如何将切面类的注解生成Adisor类探索。</p><p>AnnotationAwareAspectJAutoProxyCreator重写了findCandidateAdvisors方法，所以会执行到该方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title function_">findCandidateAdvisors</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">//通过父类的方法查找所有容器中的Advisor类，也就是基于xml配置的&lt;aop:before/&gt;生成的</span></span><br><span class="line">   List&lt;Advisor&gt; advisors = <span class="built_in">super</span>.findCandidateAdvisors();</span><br><span class="line">   <span class="comment">//查找通过注解的方式生成Advisor类</span></span><br><span class="line">   advisors.addAll(<span class="built_in">this</span>.aspectJAdvisorsBuilder.buildAspectJAdvisors());</span><br><span class="line">   <span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法会首先调用父类的findCandidateAdvisors方法用于获取通过xml文件配置生成的Advisor，也就是通过aop:before,aop:after等生成的，然后调用通过注解方式即@Before，@After，@Around、@Pointcut,@AfterThrowing生成的advisor.</p><p>可以说，这两个方法分别处理了基于xml配置文件的方式和基于注解的配置方式，因为所有的分析都是基于AnnotationAwareAspectJAutoProxyCreator这个类进行的，所以在这个地方会先获取配置文件的，再生成基于注解类的Advisor，这样就将基于xml配置的和基于注解的配置都会解析到。看下 this.aspectJAdvisorsBuilder.buildAspectJAdvisors()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Advisor&gt; <span class="title function_">buildAspectJAdvisors</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;String&gt; aspectNames = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        aspectNames = <span class="built_in">this</span>.aspectBeanNames;</span><br><span class="line">        <span class="keyword">if</span> (aspectNames == <span class="literal">null</span>) &#123;</span><br><span class="line">            List&lt;Advisor&gt; advisors = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Advisor&gt;();</span><br><span class="line">            aspectNames = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;String&gt;();</span><br><span class="line">            <span class="comment">//从beanDefinitions中获取所有的beanName</span></span><br><span class="line">            String[] beanNames =</span><br><span class="line">                    BeanFactoryUtils.beanNamesForTypeIncludingAncestors(<span class="built_in">this</span>.beanFactory, Object.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">                <span class="comment">//如果beanName不符合配置的 &lt;aop:include name=&quot;***&quot;/&gt;</span></span><br><span class="line">                <span class="comment">//忽略这个bean上所有的切面方法</span></span><br><span class="line">                <span class="keyword">if</span> (!isEligibleBean(beanName)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                Class&lt;?&gt; beanType = <span class="built_in">this</span>.beanFactory.getType(beanName);</span><br><span class="line">                <span class="keyword">if</span> (beanType == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果当前beanType是一个切面类 则将该切面类相关信息封装起来</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.advisorFactory.isAspect(beanType)) &#123;</span><br><span class="line">                    aspectNames.add(beanName);</span><br><span class="line">                    <span class="type">AspectMetadata</span> <span class="variable">amd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AspectMetadata</span>(beanType, beanName);</span><br><span class="line">                    <span class="keyword">if</span> (amd.getAjType().getPerClause().getKind() == PerClauseKind.SINGLETON) &#123;</span><br><span class="line">                        <span class="comment">// 将切面信息放入到分装到MetadataAwareAspectInstanceFactory 生成一个AspectMetadata</span></span><br><span class="line">                        <span class="type">MetadataAwareAspectInstanceFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanFactoryAspectInstanceFactory</span>(<span class="built_in">this</span>.beanFactory, beanName);</span><br><span class="line">                        <span class="comment">// 获取容器中所有Advisor类 需要进入这个方法详细分析</span></span><br><span class="line">                        List&lt;Advisor&gt; classAdvisors = <span class="built_in">this</span>.advisorFactory.getAdvisors(factory);</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">this</span>.beanFactory.isSingleton(beanName)) &#123;</span><br><span class="line">                            <span class="comment">//单例加入缓存</span></span><br><span class="line">                            <span class="built_in">this</span>.advisorsCache.put(beanName, classAdvisors);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">//非单例  将工厂加入缓存</span></span><br><span class="line">                            <span class="built_in">this</span>.aspectFactoryCache.put(beanName, factory);</span><br><span class="line">                        &#125;</span><br><span class="line">                        advisors.addAll(classAdvisors);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 非单例  将生成Advisor的工厂类加入到缓存</span></span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">this</span>.beanFactory.isSingleton(beanName)) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Bean with name &#x27;&quot;</span> + beanName +</span><br><span class="line">                                    <span class="string">&quot;&#x27; is a singleton, but aspect instantiation model is not singleton&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="type">MetadataAwareAspectInstanceFactory</span> <span class="variable">factory</span> <span class="operator">=</span></span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">PrototypeAspectInstanceFactory</span>(<span class="built_in">this</span>.beanFactory, beanName);</span><br><span class="line">                        <span class="built_in">this</span>.aspectFactoryCache.put(beanName, factory);</span><br><span class="line">                        advisors.addAll(<span class="built_in">this</span>.advisorFactory.getAdvisors(factory));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">this</span>.aspectBeanNames = aspectNames;</span><br><span class="line">            <span class="keyword">return</span> advisors;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ..............</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法主要的任务其实就是获取类得类型为Aspect的切面类，然后获取切面类方法的所有注解并将注解转换成Advisor类返回，主要步骤为：</p><ul><li>获取容器中所有的BeanDefinition的beanName</li><li>根据beanName，或者beanClass，匹配符合规则的Aspect切面类，通过aop:include配置的规则</li><li>获取Aspect切面类的所有切面方法封装成Advisor对象返回。</li><li>将获取到的所有Advisor放入到缓存中。<br>这个方法代码虽然很多，但是核心的是this.advisorFactory.getAdvisors(factory)，即第三个步骤，这个方法将会获取到切面类的所有切面方法，并封装成Advisor，getAdvisors是一个接口，ReflectiveAspectJAdvisorFactory实现了这个接口，下面代码是其实现逻辑：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Advisor&gt; <span class="title function_">getAdvisors</span><span class="params">(MetadataAwareAspectInstanceFactory aspectInstanceFactory)</span> &#123;</span><br><span class="line">        <span class="comment">//获取切面类Class</span></span><br><span class="line">        Class&lt;?&gt; aspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();</span><br><span class="line">        <span class="comment">//获取切面类的beanName</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">aspectName</span> <span class="operator">=</span> aspectInstanceFactory.getAspectMetadata().getAspectName();</span><br><span class="line">        validate(aspectClass);</span><br><span class="line">        <span class="comment">//进一步对AspectMetadata封装 里面包含了切面类的信息</span></span><br><span class="line">        <span class="type">MetadataAwareAspectInstanceFactory</span> <span class="variable">lazySingletonAspectInstanceFactory</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LazySingletonAspectInstanceFactoryDecorator</span>(aspectInstanceFactory);</span><br><span class="line">        List&lt;Advisor&gt; advisors = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Advisor&gt;();</span><br><span class="line">        <span class="comment">//获取切面类中没有使用Pointcut注解的方法</span></span><br><span class="line">        <span class="keyword">for</span> (Method method : getAdvisorMethods(aspectClass)) &#123;</span><br><span class="line">            <span class="comment">//检查该方法是否是切面方法， 如果是成Advisor类返回</span></span><br><span class="line">            <span class="type">Advisor</span> <span class="variable">advisor</span> <span class="operator">=</span> getAdvisor(method, lazySingletonAspectInstanceFactory, advisors.size(), aspectName);</span><br><span class="line">            <span class="keyword">if</span> (advisor != <span class="literal">null</span>) &#123;</span><br><span class="line">                advisors.add(advisor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果没有切面方法 设置一个空的</span></span><br><span class="line">        <span class="keyword">if</span> (!advisors.isEmpty() &amp;&amp; lazySingletonAspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) &#123;</span><br><span class="line">            <span class="type">Advisor</span> <span class="variable">instantiationAdvisor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SyntheticInstantiationAdvisor</span>(lazySingletonAspectInstanceFactory);</span><br><span class="line">            advisors.add(<span class="number">0</span>, instantiationAdvisor);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理属性字段 Spring支持到了属性的增强</span></span><br><span class="line">        <span class="keyword">for</span> (Field field : aspectClass.getDeclaredFields()) &#123;</span><br><span class="line">            <span class="type">Advisor</span> <span class="variable">advisor</span> <span class="operator">=</span> getDeclareParentsAdvisor(field);</span><br><span class="line">            <span class="keyword">if</span> (advisor != <span class="literal">null</span>) &#123;</span><br><span class="line">                advisors.add(advisor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> advisors;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个方法首先已经将切面类信息封装到AspectMetadata的类再次封装到MetadataAwareAspectInstanceFactory，然后获取切面类的所有没有使用Pointcut注解的方法，调用getAdvisor获取这个方法使用的切面注解，生成对应的Advisor类。 至于PointCut的处理则是再后面的getAdvisor中处理的。</p><h1 id="9-获取切面类的Advisor"><a href="#9-获取切面类的Advisor" class="headerlink" title="9 获取切面类的Advisor"></a>9 获取切面类的Advisor</h1><p>获取Advisor类的方法为getAdvisor，首先来看下这个方法的参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//切面类的切面方法  这里可能就是 beforePrint()</span></span><br><span class="line">Method  candidateAdviceMethod </span><br><span class="line"><span class="comment">//获取AspectMetadata的实例工厂(可以获取切面的类所有信息)</span></span><br><span class="line">MetadataAwareAspectInstanceFactory aspectInstanceFactory</span><br><span class="line"><span class="comment">//切面的排序</span></span><br><span class="line"><span class="type">int</span> declarationOrderInAspect</span><br><span class="line"><span class="comment">//切面类的beanName 这里是tracesRecordAdvisor</span></span><br><span class="line"> String aspectName</span><br></pre></td></tr></table></figure><p>上面的参数中可以获取到切面类和切面方法，这样就可以获得一个Advisor对象，然后还需要一个切入点表达式PointCut用来匹配符合条件的方法，拦截到目标方法后，就可以执行Adivsor增强方法了。 来看看创建Advisor的过程，这里假设Method是TracesRecordAdvisor类的beforePrint方法，也就是我们测试案例中创建使用了@Before注解的切面方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Advisor <span class="title function_">getAdvisor</span><span class="params">(Method candidateAdviceMethod, MetadataAwareAspectInstanceFactory aspectInstanceFactory,</span></span><br><span class="line"><span class="params">      <span class="type">int</span> declarationOrderInAspect, String aspectName)</span> &#123;</span><br><span class="line"></span><br><span class="line">   validate(aspectInstanceFactory.getAspectMetadata().getAspectClass());</span><br><span class="line">   <span class="comment">//获取pointCut,这里实际上获得的是 expression()这个方法对应了pointCut的内容</span></span><br><span class="line">   <span class="type">AspectJExpressionPointcut</span> <span class="variable">expressionPointcut</span> <span class="operator">=</span> getPointcut(</span><br><span class="line">         candidateAdviceMethod, aspectInstanceFactory.getAspectMetadata().getAspectClass());</span><br><span class="line">   <span class="keyword">if</span> (expressionPointcut == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">//创建advisor</span></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">InstantiationModelAwarePointcutAdvisorImpl</span>(expressionPointcut, candidateAdviceMethod,</span><br><span class="line">         <span class="built_in">this</span>, aspectInstanceFactory, declarationOrderInAspect, aspectName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看看getPointCut方法如何获取到exression过程需要嵌套很多步骤，这里不展开了，简单看下如何将查找到的值设置到表达式中的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> AspectJExpressionPointcut <span class="title function_">getPointcut</span><span class="params">(Method candidateAdviceMethod, Class&lt;?&gt; candidateAspectClass)</span> &#123;</span><br><span class="line">   <span class="comment">//</span></span><br><span class="line">   AspectJAnnotation&lt;?&gt; aspectJAnnotation =</span><br><span class="line">         AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod);</span><br><span class="line">   <span class="keyword">if</span> (aspectJAnnotation == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="type">AspectJExpressionPointcut</span> <span class="variable">ajexp</span> <span class="operator">=</span></span><br><span class="line">         <span class="keyword">new</span> <span class="title class_">AspectJExpressionPointcut</span>(candidateAspectClass, <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>], <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[<span class="number">0</span>]);</span><br><span class="line">   <span class="comment">//将上面生成的AspectJAnnotation 解析出的expression方法放入到表达式中</span></span><br><span class="line">   <span class="comment">//</span></span><br><span class="line">   ajexp.setExpression(aspectJAnnotation.getPointcutExpression());</span><br><span class="line">   <span class="keyword">return</span> ajexp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要关注下上面的findAspectJAnnotationOnMethod方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> AspectJAnnotation&lt;?&gt; findAspectJAnnotationOnMethod(Method method) &#123;</span><br><span class="line">    <span class="comment">//看到了我们熟悉的切面方法注解，这里的beforePrint使用@Before注解</span></span><br><span class="line">   Class&lt;?&gt;[] classesToLookFor = <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] &#123;</span><br><span class="line">         Before.class, Around.class, After.class, AfterReturning.class, AfterThrowing.class, Pointcut.class&#125;;</span><br><span class="line">   <span class="keyword">for</span> (Class&lt;?&gt; c : classesToLookFor) &#123;</span><br><span class="line">      AspectJAnnotation&lt;?&gt; foundAnnotation = findAnnotation(method, (Class&lt;Annotation&gt;) c);</span><br><span class="line">      <span class="keyword">if</span> (foundAnnotation != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> foundAnnotation;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法就是查找切面方法是否使用了Before, Around, After，AfterReturning, AfterThrowing,Pointcut注解，如果使用了，则返回一个AspectJAnnotation对象，里面有一个annotation的泛型对象，这个泛型对象就是被设置为这些注解的值，而且还会获得这些注解里面配置的pointcut表达式内容，如果是引用的表达式方法，则将方法参数设置到pointcutExpression这个属性中。<br>解析完切面方法的注解后现在再回过头来看看如何创建一个advisor实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">InstantiationModelAwarePointcutAdvisorImpl</span><span class="params">(AspectJExpressionPointcut declaredPointcut,</span></span><br><span class="line"><span class="params">      Method aspectJAdviceMethod, AspectJAdvisorFactory aspectJAdvisorFactory,</span></span><br><span class="line"><span class="params">      MetadataAwareAspectInstanceFactory aspectInstanceFactory, <span class="type">int</span> declarationOrder, String aspectName)</span> &#123;</span><br><span class="line">           <span class="built_in">this</span>.declaredPointcut = declaredPointcut;</span><br><span class="line">           <span class="built_in">this</span>.aspectJAdviceMethod = aspectJAdviceMethod;</span><br><span class="line">           <span class="built_in">this</span>.aspectJAdvisorFactory = aspectJAdvisorFactory;</span><br><span class="line">           <span class="built_in">this</span>.aspectInstanceFactory = aspectInstanceFactory;</span><br><span class="line">           <span class="built_in">this</span>.declarationOrder = declarationOrder;</span><br><span class="line">           <span class="built_in">this</span>.aspectName = aspectName;</span><br><span class="line">            <span class="comment">//切面类是否是懒加载</span></span><br><span class="line">            <span class="keyword">if</span> (aspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) &#123;</span><br><span class="line">                <span class="comment">// Static part of the pointcut is a lazy type.</span></span><br><span class="line">                <span class="type">Pointcut</span> <span class="variable">preInstantiationPointcut</span> <span class="operator">=</span> Pointcuts.union(</span><br><span class="line">                    aspectInstanceFactory.getAspectMetadata().getPerClausePointcut(), <span class="built_in">this</span>.declaredPointcut);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Make it dynamic: must mutate from pre-instantiation to post-instantiation state.</span></span><br><span class="line">                <span class="comment">// If it&#x27;s not a dynamic pointcut, it may be optimized out</span></span><br><span class="line">                <span class="comment">// by the Spring AOP infrastructure after the first evaluation.</span></span><br><span class="line">                <span class="built_in">this</span>.pointcut = <span class="keyword">new</span> <span class="title class_">PerTargetInstantiationModelPointcut</span>(</span><br><span class="line">                    <span class="built_in">this</span>.declaredPointcut, preInstantiationPointcut, aspectInstanceFactory);</span><br><span class="line">                <span class="built_in">this</span>.lazy = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.pointcut = <span class="built_in">this</span>.declaredPointcut;</span><br><span class="line">                <span class="built_in">this</span>.lazy = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">//最终会执行到这里获取一个advice</span></span><br><span class="line">                <span class="built_in">this</span>.instantiatedAdvice = instantiateAdvice(<span class="built_in">this</span>.declaredPointcut);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h1 id="10-为切面方法创建Advice"><a href="#10-为切面方法创建Advice" class="headerlink" title="10 为切面方法创建Advice"></a>10 为切面方法创建Advice</h1><p>上面方法的最后一句instantiateAdvice(this.declaredPointcut)会创建一个advice，具体是调用getAdvice方法获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Advice <span class="title function_">getAdvice</span><span class="params">(Method candidateAdviceMethod, AspectJExpressionPointcut expressionPointcut,</span></span><br><span class="line"><span class="params">                        MetadataAwareAspectInstanceFactory aspectInstanceFactory, <span class="type">int</span> declarationOrder, String aspectName)</span> &#123;</span><br><span class="line">        <span class="comment">//获取切面类对象，这里是TracesRecordAdvisor</span></span><br><span class="line">        Class&lt;?&gt; candidateAspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();</span><br><span class="line">        validate(candidateAspectClass);</span><br><span class="line">        <span class="comment">//核心点1：获取切面注解，这里得方法是 beforePrint 使用了@Before注解</span></span><br><span class="line">        AspectJAnnotation&lt;?&gt; aspectJAnnotation =</span><br><span class="line">                AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod);</span><br><span class="line">        <span class="keyword">if</span> (aspectJAnnotation == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            ....................</span><br><span class="line">        AbstractAspectJAdvice springAdvice;</span><br><span class="line">        <span class="comment">//核心点2：根据注解转换后的 将注解生成不同的Advice类。</span></span><br><span class="line">        <span class="keyword">switch</span> (aspectJAnnotation.getAnnotationType()) &#123;</span><br><span class="line">            <span class="keyword">case</span> AtBefore:</span><br><span class="line">                springAdvice = <span class="keyword">new</span> <span class="title class_">AspectJMethodBeforeAdvice</span>(</span><br><span class="line">                        candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AtAfter:</span><br><span class="line">                springAdvice = <span class="keyword">new</span> <span class="title class_">AspectJAfterAdvice</span>(</span><br><span class="line">                        candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AtAfterReturning:</span><br><span class="line">                springAdvice = <span class="keyword">new</span> <span class="title class_">AspectJAfterReturningAdvice</span>(</span><br><span class="line">                        candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);</span><br><span class="line">                <span class="type">AfterReturning</span> <span class="variable">afterReturningAnnotation</span> <span class="operator">=</span> (AfterReturning) aspectJAnnotation.getAnnotation();</span><br><span class="line">                <span class="keyword">if</span> (StringUtils.hasText(afterReturningAnnotation.returning())) &#123;</span><br><span class="line">                    springAdvice.setReturningName(afterReturningAnnotation.returning());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AtAfterThrowing:</span><br><span class="line">                springAdvice = <span class="keyword">new</span> <span class="title class_">AspectJAfterThrowingAdvice</span>(</span><br><span class="line">                        candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);</span><br><span class="line">                <span class="type">AfterThrowing</span> <span class="variable">afterThrowingAnnotation</span> <span class="operator">=</span> (AfterThrowing) aspectJAnnotation.getAnnotation();</span><br><span class="line">                <span class="keyword">if</span> (StringUtils.hasText(afterThrowingAnnotation.throwing())) &#123;</span><br><span class="line">                    springAdvice.setThrowingName(afterThrowingAnnotation.throwing());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AtAround:</span><br><span class="line">                springAdvice = <span class="keyword">new</span> <span class="title class_">AspectJAroundAdvice</span>(</span><br><span class="line">                        candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AtPointcut:</span><br><span class="line">                <span class="comment">//这里对PointCut不做处理</span></span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">&quot;Processing pointcut &#x27;&quot;</span> + candidateAdviceMethod.getName() + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(</span><br><span class="line">                        <span class="string">&quot;Unsupported advice type on method: &quot;</span> + candidateAdviceMethod);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将切面类信息配置到SpringAdvice中</span></span><br><span class="line">        springAdvice.setAspectName(aspectName);</span><br><span class="line">        springAdvice.setDeclarationOrder(declarationOrder);</span><br><span class="line">        String[] argNames = <span class="built_in">this</span>.parameterNameDiscoverer.getParameterNames(candidateAdviceMethod);</span><br><span class="line">        <span class="keyword">if</span> (argNames != <span class="literal">null</span>) &#123;</span><br><span class="line">            springAdvice.setArgumentNamesFromStringArray(argNames);</span><br><span class="line">        &#125;</span><br><span class="line">        springAdvice.calculateArgumentBindings();</span><br><span class="line">        <span class="keyword">return</span> springAdvice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先来看看核心点1，上面其实已经看过了， 但是上面的方法作用仅仅是为了获取注解上的exression表达式的，这里再调用一遍就是为注解生成Advice类的，目的就是获取切面注解与AspectJAnnotation的映射类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> AspectJAnnotation&lt;?&gt; findAspectJAnnotationOnMethod(Method method) &#123;</span><br><span class="line">    <span class="comment">//看到了我们熟悉的切面方法注解，这里的beforePrint使用@Before注解</span></span><br><span class="line">   Class&lt;?&gt;[] classesToLookFor = <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] &#123;</span><br><span class="line">         Before.class, Around.class, After.class, AfterReturning.class, AfterThrowing.class, Pointcut.class&#125;;</span><br><span class="line">   <span class="keyword">for</span> (Class&lt;?&gt; c : classesToLookFor) &#123;</span><br><span class="line">      AspectJAnnotation&lt;?&gt; foundAnnotation = findAnnotation(method, (Class&lt;Annotation&gt;) c);</span><br><span class="line">      <span class="keyword">if</span> (foundAnnotation != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> foundAnnotation;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法就是查找切面方法是否实现了Before, Around, After，AfterReturning, AfterThrowing,Pointcut注解，如果实现了，则返回一个AspectJAnnotation对象，里面有一个annotation的泛型对象，这个泛型对象就是被设置为这些注解的值。最终这些对象会被转换成下面的对象存入AspectJAnnotation中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">       <span class="comment">//会将注解转换成后面的AspectJAnnotationType枚举的类。 </span></span><br><span class="line">       annotationTypes.put(Pointcut.class,AspectJAnnotationType.AtPointcut);</span><br><span class="line">       annotationTypes.put(After.class,AspectJAnnotationType.AtAfter);</span><br><span class="line">       annotationTypes.put(AfterReturning.class,AspectJAnnotationType.AtAfterReturning);</span><br><span class="line">       annotationTypes.put(AfterThrowing.class,AspectJAnnotationType.AtAfterThrowing);</span><br><span class="line">       annotationTypes.put(Around.class,AspectJAnnotationType.AtAround);</span><br><span class="line">       annotationTypes.put(Before.class,AspectJAnnotationType.AtBefore);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过核心点1，Spring已经将注解@Before对应转换为AtBefore，@After转换成AtAfter，以此类推，都会一一映射到了核心点2的switch的条件类了，在核心点2中，会为对应的切面注解类生成Advice类。 所有的注解切面类具体实现都是由AbstractAspectJAdvice这个抽象类实现的，这个类的构造函数有三个参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//切面方法 这里可能是beforePrint</span></span><br><span class="line">Method aspectJAroundAdviceMethod</span><br><span class="line"><span class="comment">//切入点表达式匹配器 这里指封装了exression的匹配器</span></span><br><span class="line">AspectJExpressionPointcut pointcut</span><br><span class="line"><span class="comment">//切面类  这里指TracesRecordAdvisor</span></span><br><span class="line">AspectInstanceFactory aif</span><br></pre></td></tr></table></figure><p>下面是Spring为对应注解生成对应的Advice类<br>|–|–|<br>|注解类|Advice 顾问方法|<br>|AtBefore|AspectJMethodBeforeAdvice|<br>|AtAfter|AspectJAfterAdvice|<br>|AtAfterReturning|AspectJAfterReturningAdvice|<br>|AtAfterThrowing|AspectJAfterThrowingAdvice|<br>|AtAround|AspectJAroundAdvice|</p><p>各个注解会在不同的实际执行自身增强方法，这个部分只是生成Advice类，然会放入到缓存中，等真正生成代理时就会调用这些方法。这个在创建代理的时候需要具体拆开说，至此，Spring将使用了@Aspect注解的切面类的切面方法，都转换成了对应的Adivsor类，这个类包含了切面方法，封装后的切点匹配器PointCut以及生成切面类的实例对象，通过这个类就可以匹配到符合条件的目标类的目标方法，然后执行增强操作了。</p><p>由切面注解生成的Advice类，最终会放入到一个缓存中，当生成目标bean的时候，会将所有所以能够匹配到目标bean的advice放入到集合中，由一个实现了MethodInvocation的类统一管理调用过程，这个类后面会详细说到，这里简单分析下AspectJAfterAdvice的invoke方法，看看它的调用过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//调用是实现了MethodInvocation方法的类 这个其实是个链式调用</span></span><br><span class="line"><span class="keyword">return</span> mi.proceed();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">//最终执行后置增强方法</span></span><br><span class="line">invokeAdviceMethod(getJoinPointMatch(), <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的invoke方法需要一个MethodInvocation的参数，上面的Advice类除了AspectJMethodBeforeAdvice之外，都实现了这个接口，所以可以实现链式调用，这个逻辑会在创建代理的具体讲解，这里只是简单分析下，这些advice的invoke方法规定了切面方法于要增强方法的执行时机。</p><h1 id="11-初探AOP代理"><a href="#11-初探AOP代理" class="headerlink" title="11 初探AOP代理"></a>11 初探AOP代理</h1><p>上面一部分操作主要是处理使用了@Aspect注解的切面类，然后将切面类的所有切面方法根据使用的注解生成对应的Advisor的过程，这个Advisor包含了切面方法，切入点匹配器和切面类，也就是准好了要增强的逻辑，接下来就是要将这些逻辑注入到合适的位置进行增强，这部分的操作就是由老生常谈的代理实现的了。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="title class_">Object</span> <span class="title function_">postProcessAfterInitialization</span>(<span class="title class_">Object</span> bean, <span class="title class_">String</span> beanName) throws <span class="title class_">BeansException</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="title class_">Object</span> cacheKey = <span class="title function_">getCacheKey</span>(bean.<span class="title function_">getClass</span>(), beanName);</span><br><span class="line">       <span class="comment">//如果要创建的类不是提前暴露的代理 则进入下面的方法</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">earlyProxyReferences</span>.<span class="title function_">contains</span>(cacheKey)) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="title function_">wrapIfNecessary</span>(bean, beanName, cacheKey);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建代理前，需要先校验bean是否需要创建代理</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) &#123;</span><br><span class="line">    <span class="comment">//如果bean是通过TargetSource接口获取 则直接返回</span></span><br><span class="line">   <span class="keyword">if</span> (beanName != <span class="literal">null</span> &amp;&amp; <span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">      <span class="keyword">return</span> bean;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">//如果bean是切面类 直接返回</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">Boolean</span>.FALSE.equals(<span class="keyword">this</span>.advisedBeans.<span class="keyword">get</span>(cacheKey))) &#123;</span><br><span class="line">      <span class="keyword">return</span> bean;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">//如果bean是Aspect 而且允许跳过创建代理， 加入advise缓存 返回</span></span><br><span class="line">   <span class="keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.advisedBeans.put(cacheKey, <span class="built_in">Boolean</span>.FALSE);</span><br><span class="line">      <span class="keyword">return</span> bean;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//如果前面生成的advisor缓存中存在能够匹配到目标类方法的Advisor 则创建代理</span></span><br><span class="line">   Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="literal">null</span>);</span><br><span class="line">   <span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line">      <span class="keyword">this</span>.advisedBeans.put(cacheKey, <span class="built_in">Boolean</span>.TRUE);</span><br><span class="line">       <span class="comment">//创建代理</span></span><br><span class="line">      Object proxy = createProxy(</span><br><span class="line">            bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));</span><br><span class="line">      <span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">      <span class="keyword">return</span> proxy;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">this</span>.advisedBeans.put(cacheKey, <span class="built_in">Boolean</span>.FALSE);</span><br><span class="line">   <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法很简单，主要的关注点在getAdvicesAndAdvisorsForBean和createProxy上，第一个是获取能够匹配目标类方法的Advisor集合，如果这个集合不为空，则代表该类需要被增强，需要生成代理，如果匹配不到，则表示该类并不需要被增强，无需创建代理。至于createProxy就很明显了，就是创建代理，这个方法里面决定了使用jdk代理还是cglib代理，并且用到了前面生成的Advisor实现增强功能。 这部分内容会放到下一篇文章中专门分析。</p><h1 id="12-总结"><a href="#12-总结" class="headerlink" title="12 总结"></a>12 总结</h1><p>简单总结一下，Spring AOP在初始阶段完成的主要任务：<br><strong>读取配置文件阶段：</strong></p><ul><li>读取xml文件遇到 <code>&lt;aop:aspectj-autoproxy/&gt;</code>标签时，找到命名空间处理器AopNamespaceHandler,然后找到处理该标签的类AspectJAutoProxyBeanDefinitionParser</li><li>通过AspectJAutoProxyBeanDefinitionParser的parse方法，将AspectJAwareAdvisorAutoProxyCreator注册到容器的声明周期中。<br><strong>创建bean阶段：</strong></li><li>执行AspectJAwareAdvisorAutoProxyCreator的postProcessBeforeInstantiation校验目标类是否是Aspect类和AOP基础类以及是否需要跳过不需要执行代理的类</li><li>获取beanDefinitions中所有使用了Aspect注解的类，然后将切面方法根据使用的注解生成Advisor类放入到缓存（关键）</li><li>调用AspectJAwareAdvisorAutoProxyCreator的postProcessAfterInitialization的方法，对需要增强的类创建代理。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java核心系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java核心 </tag>
            
            <tag> Java基础 </tag>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java核心系列5：反射机制详解</title>
      <link href="/2025/04/02/Java%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%865-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
      <url>/2025/04/02/Java%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%865-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h1><p>无论是那种语言体系，反射都是必不可少的一个技术特征。从Java体系来说，很多常用的技术框架或多或少都使用到了反射技术，比如Spring、MyBatis、RocketMQ、FastJson 等等。反射技术强大而必要，在大多数框架中起到举足轻重的作用。所以，反射也是Java必不可少的核心技术之一。</p><p>接下来我们来看看反射的一些技术要点：</p><ol><li>反射的概念（即什么是反射）？</li><li>反射的作用（它帮我们解决了哪些问题）？</li><li>反射的实现原理？</li><li>如何使用反射？<br>下面我就针对以上的疑问，一一来讲解。</li></ol><h2 id="1-1-反射是什么？"><a href="#1-1-反射是什么？" class="headerlink" title="1.1 反射是什么？"></a>1.1 反射是什么？</h2><p>Java反射（Reflection）是Java语言的一个核心特性，它允许运行中的Java代码对自身进行自我检查，甚至修改自身的组件。具体来说，反射机制提供了在运行状态中，对于任意一个类，都能够了解这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。这种动态获取的信息以及动态调用对象的方法在Java中就叫做反射。</p><p>一句话总结：反射就是在运行时才具体知晓要操作的类是什么结构，并在运行时获取类的完整构造，并调用对应的方法、属性等。</p><p>Java的反射主要包括以下三个部分：</p><ul><li>类的加载：Java的类在需要使用时才会被加载到JVM中。这个过程是由类加载器（ClassLoader）完成的。类加载器首先检查这个类是否已经被加载过，如果还没有加载，那么就会从磁盘上加载类的字节码并创建一个Class对象。</li><li>获取类的信息：当一个对象被创建后，我们可以使用反射来获取这个对象的Class对象。通过这个Class对象，我们可以获取到这个类的所有属性和方法。</li><li>方法的调用：通过反射，我们可以动态的调用一个对象的方法。即使这个方法是一个私有的方法，也能够通过反射来调用。</li></ul><h2 id="1-2-为什么要用反射？"><a href="#1-2-为什么要用反射？" class="headerlink" title="1.2 为什么要用反射？"></a>1.2 为什么要用反射？</h2><p>Java Reflection功能非常强大，并且非常有用，比如：</p><ul><li>获取任意类的名称、package信息、所有属性、方法、注解、类型、类加载器等</li><li>获取任意对象的属性，并且能改变对象的属性</li><li>调用任意对象的方法</li><li>判断任意一个对象所属的类</li><li>实例化任意一个类的对象</li><li>通过反射我们可以实现动态装配，降低代码的耦合度，实现动态代理等。</li></ul><p>具体的应用场景：</p><ul><li>框架设计：许多框架，如Spring，Hibernate等，都大量使用了反射来实现对象的自动装配，动态代理等功能。</li><li>单元测试：单元测试框架（如JUnit）会使用反射来调用被注解的方法。</li><li>插件化：为了实现插件化，可以通过反射加载不同的插件。</li><li>对象序列化与反序列化：在对象进行序列化和反序列化的时候，会使用反射获取到对象的所有属性和方法。</li></ul><h1 id="2-反射的使用"><a href="#2-反射的使用" class="headerlink" title="2 反射的使用"></a>2 反射的使用</h1><p>在Java中，Class类与java.lang.reflect类库配合对反射技术进行了完整的支持。在反射的Package中，我们经常使用功能类如下：</p><ul><li>Constructor类表示的是Class 对象所表示的类的构造方法，利用它可以在运行时动态创建对象</li><li>Field类表示Class对象所表示的类的成员变量，通过它可以在运行时动态修改成员变量的属性值(包含private)</li><li>Method类表示Class对象所表示的类的成员方法，通过它可以动态调用对象的方法(包含private)</li></ul><p>下面将对这几个类进行详细介绍。</p><h2 id="2-1-反射创建类对象"><a href="#2-1-反射创建类对象" class="headerlink" title="2.1 反射创建类对象"></a>2.1 反射创建类对象</h2><p>一般情况下我们通过反射创建类对象主要有两种方式：</p><ul><li>通过 Class 对象的 newInstance() 方法</li><li>通过 Constructor 对象的 newInstance() 方法</li><li>通过 Class 对象的 newInstance() 方法实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.ad.reflection.TestRefle&quot;</span>);</span><br><span class="line">TestRefle tr= (TestRefle)clz.newInstance();</span><br></pre></td></tr></table></figure><ul><li>通过 Constructor 对象的 newInstance() 方法实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.ad.reflection.TestRefle&quot;</span>);</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clz.getConstructor();</span><br><span class="line">TestRefle tr= (TestRefle)constructor.newInstance();</span><br></pre></td></tr></table></figure><p>这边需要注意，通过 Constructor 对象创建类对象可以选择特定构造方法，而通过 Class 对象则只能使用默认的无参数构造方法。</p><p>下面的代码演示的是通过 Constructor 调用有参构造方法进行了类对象初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.ad.reflection.TestRefle&quot;</span>);</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clz.getConstructor(String.class);</span><br><span class="line">TestRefle tr= (TestRefle)constructor.newInstance(<span class="string">&quot;提供一个String参数&quot;</span>);</span><br></pre></td></tr></table></figure><p>接下来我们继续，通过具体的API获取详细的类信息：类信息、方法信息、属性信息等。</p><h2 id="2-2-获取Class类对象"><a href="#2-2-获取Class类对象" class="headerlink" title="2.2 获取Class类对象"></a>2.2 获取Class类对象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取Class对象的三种方式</span></span><br><span class="line">根据类名: <span class="type">Class</span> <span class="variable">mailClass</span> <span class="operator">=</span> MailInfo.class;</span><br><span class="line">根据对象: <span class="type">Class</span> <span class="variable">mailClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MailInfo</span>().getClass();</span><br><span class="line">根据全限定类名: <span class="type">Class</span> <span class="variable">mailClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.ad.MailInfo&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据对象获取信息和实例对象</span></span><br><span class="line">获取全限定类名: mailClass.getName();</span><br><span class="line">获取类名: mailClass.getSimpleName();</span><br><span class="line">实例化: userClass.getDeclaredConstructor().newInstance();</span><br></pre></td></tr></table></figure><p>更加详细Class类获取参考如下：</p><table><thead><tr><th>方法</th><th>用途</th></tr></thead><tbody><tr><td>forName()</td><td>(1)获取Class对象的一个引用，但引用的类还没有加载(该类的第一个对象没有生成)就加载了这个类。 (2)为了产生Class引用，forName()立即就进行了初始化。</td></tr><tr><td>Object-getClass()</td><td>获取Class对象的一个引用，返回表示该对象的实际类型的Class引用。</td></tr><tr><td>getName()</td><td>取全限定的类名(包括包名)，即类的完整名字。 getSimpleName() 获取类名(不包括包名)</td></tr><tr><td>getCanonicalName()</td><td>获取全限定的类名(包括包名)</td></tr><tr><td>isInterface()</td><td>判断Class对象是否是表示一个接口</td></tr><tr><td>getInterfaces()</td><td>返回Class对象数组，表示Class对象所引用的类所实现的所有接口。</td></tr><tr><td>getSupercalss()</td><td>返回Class对象，表示Class对象所引用的类所继承的直接基类。应用该方法可在运行时发现一个对象完整的继承结构。</td></tr><tr><td>newInstance()</td><td>返回一个Oject对象，是实现“虚拟构造器”的一种途径。使用该方法创建的类，必须带有无参的构造器。</td></tr></tbody></table><h2 id="2-3-获取类的成员变量的信息"><a href="#2-3-获取类的成员变量的信息" class="headerlink" title="2.3 获取类的成员变量的信息"></a>2.3 获取类的成员变量的信息</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Field[] fields = _class.getDeclaredFields();</span><br></pre></td></tr></table></figure><p>更加详细成员变量获取参考如下：</p><table><thead><tr><th>方法</th><th>用途</th></tr></thead><tbody><tr><td>getField(String name)</td><td>获得某个公有的属性对象</td></tr><tr><td>getFields()</td><td>获取所有的公有的属性对象</td></tr><tr><td>getDeclaredField(String name)</td><td>获得某个属性对象（public和非public）</td></tr><tr><td>getDeclaredFields()</td><td>获得所有属性对象（public和非public）</td></tr></tbody></table><h2 id="2-4-获得类方法"><a href="#2-4-获得类方法" class="headerlink" title="2.4 获得类方法"></a>2.4 获得类方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Method[] methods = _class.getDeclaredMethods();</span><br></pre></td></tr></table></figure><p>更加详细方法获取参考如下：</p><table><thead><tr><th>方法</th><th>用途</th></tr></thead><tbody><tr><td>getMethod(String name, Class…&lt;?&gt; paramerterTypes)</td><td>获得某个公有的方法对象</td></tr><tr><td>getMethods()</td><td>获取所有的公有的方法对象</td></tr><tr><td>getDeclaredMethod(String name, Class…&lt;?&gt; paramerterTypes)</td><td>获得对应类下某个方法（public和非public）</td></tr><tr><td>getDeclaredMethods()</td><td>获得对应类下所有方法（public和非public）</td></tr></tbody></table><h2 id="2-5-获得构造函数"><a href="#2-5-获得构造函数" class="headerlink" title="2.5 获得构造函数"></a>2.5 获得构造函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Constructor[] constructors = _class.getDeclaredConstructors();</span><br></pre></td></tr></table></figure><p>更加详细构造函数获取参考如下：</p><table><thead><tr><th>方法</th><th>用途</th></tr></thead><tbody><tr><td>getConstructor(Class…&lt;?&gt; paramerterTypes)</td><td>获得该类中与参数类型匹配的公有构造方法</td></tr><tr><td>getConstructors()</td><td>获取该类的所有公有构造方法</td></tr><tr><td>getDeclaredConstructor(Class…&lt;?&gt; paramerterTypes)</td><td>获得该类中与参数类型匹配的构造方法</td></tr><tr><td>getDeclaredConstructors()</td><td>获取该类的所有构造方法</td></tr></tbody></table><p>这样通过反射就可以做在运行时获取类的完整构造，并获得类信息了。</p><table><thead><tr><th>类名</th><th>用途</th></tr></thead><tbody><tr><td>Class类</td><td>代表类的实体，在运行的Java应用程序中表示类和接口</td></tr><tr><td>Field类</td><td>代表类的成员变量（即类的属性）</td></tr><tr><td>Method类</td><td>代表类的方法</td></tr><tr><td>Constructor类</td><td>代表类的构造函数</td></tr></tbody></table><p>通过上面的几个示例我们基本了解了反射的使用，但这仅仅是使用，我们还需深入理解反射背后的底层实现原理。</p><h1 id="3-反射原理分析"><a href="#3-反射原理分析" class="headerlink" title="3 反射原理分析"></a>3 反射原理分析</h1><h2 id="3-1-反射的调用流程"><a href="#3-1-反射的调用流程" class="headerlink" title="3.1 反射的调用流程"></a>3.1 反射的调用流程</h2><p>1、编写完Java项目之后，java文件都会被编译成一个.class文件</p><p>2、这些class文件在程序运行时会被ClassLoader加载到JVM中，当一个类被加载以后，JVM就会在内存中自动产生一个Class对象。</p><p>3、通过Class对象获取 Field（属性）、Method（方法）、Construcor（构造函数）</p><p>我们平时通过new的形式创建对象，本质上就是通过Class来创建个新对象<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAPAaUehAAF9R3HKiOn5QC9oh0Sgm434AAK8C2sbp6c4VmhFq0MC4Pb2AQADAgADdwADNgQ.png"><br>通过上面的流程我们可以看出反射的优势：</p><ul><li><strong>动态装配</strong></li></ul><p>我们的程序在运行时，可能不一定会用到所有我们编写和构建的类，这样避免启动时间太长并且浪费大量无用的机器资源。<br>取而代之的是动态的加载一些类，这些类可能之前用不到所以不用加载到jvm，而是在运行时根据需要才加载。</p><ul><li><strong>降低耦合</strong></li></ul><p>如果你在使用new时明确的指定类名，那这就是典型的硬编码实现，而在使用反射的时候，可以只传入类名参数，就可以生成对象，降低了耦合度，使得程序更具灵性。</p><p>完整的调用流程，图片来自网上，比较模糊，后续再补一个<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAO_aUegrA7OJrzaigLEU5oJUlJhjf8AArsLaxunpzhWp76Dja8gOcUBAAMCAAN3AAM2BA.png" alt="反射调用整体流程">ttps:&#x2F;&#x2F;img2022.cnblogs.com&#x2F;blog&#x2F;167509&#x2F;202203&#x2F;167509-20220326110641303-1256637401.png)</p><h2 id="3-2-反射的应用场景"><a href="#3-2-反射的应用场景" class="headerlink" title="3.2 反射的应用场景"></a>3.2 反射的应用场景</h2><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAO-aUeggAq1cBsBeU0CUigwhcOh9VQAAroLaxunpzhWjoQDizWii1oBAAMCAAN4AAM2BA.png" alt="反射的应用场景"></p><ul><li>框架设计：许多框架，如Spring，Hibernate，mybatis，dubbo，rocketmq等，都大量使用了反射来实现对象的自动装配，动态代理等功能。</li><li>单元测试：单元测试框架（如JUnit）会使用反射来调用被注解的方法。</li><li>插件化：为了实现插件化，可以通过反射加载不同的插件。</li><li>对象序列化与反序列化：在对象进行序列化和反序列化的时候，会使用反射获取到对象的所有属性和方法。</li><li>动态配置、动态代理：通过反射去读取配置，以及代理请求</li></ul><h1 id="4-反射经典案例解析"><a href="#4-反射经典案例解析" class="headerlink" title="4 反射经典案例解析"></a>4 反射经典案例解析</h1><p>以下案例来自百度文心一言大模型自动生成，已调试通过。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectionExample</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="comment">// 获取目标类的Class对象  </span></span><br><span class="line">            Class&lt;?&gt; targetClass = Class.forName(<span class="string">&quot;java.util.ArrayList&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 获取目标类的所有公共方法  </span></span><br><span class="line">            Method[] methods = targetClass.getMethods();  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 遍历所有方法并打印方法名  </span></span><br><span class="line">            <span class="keyword">for</span> (Method method : methods) &#123;  </span><br><span class="line">                System.out.println(method.getName());  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 获取特定方法，比如添加元素的add方法  </span></span><br><span class="line">            <span class="type">Method</span> <span class="variable">addMethod</span> <span class="operator">=</span> targetClass.getMethod(<span class="string">&quot;add&quot;</span>, Object.class);  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 创建目标类的实例对象  </span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">targetObject</span> <span class="operator">=</span> targetClass.newInstance();  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 调用add方法添加元素  </span></span><br><span class="line">            addMethod.invoke(targetObject, <span class="string">&quot;Hello, World!&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 获取目标类的所有属性（字段）并打印属性名  </span></span><br><span class="line">            Field[] fields = targetClass.getDeclaredFields();  </span><br><span class="line">            <span class="keyword">for</span> (Field field : fields) &#123;  </span><br><span class="line">                System.out.println(field.getName());  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个案例展示了如何使用反射来获取目标类的Class对象，获取并打印目标类的所有公共方法，获取特定方法，创建目标类的实例对象，调用目标类的方法，以及获取并打印目标类的所有属性（字段）。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>无论是那种语言体系（C#、Java等等），反射都是必不可少的一个技术特征。而从Java体系来说，很多常用的技术框架或多或少都使用到了反射技术，比如Spring、MyBatis、RocketMQ、FastJson 等等。</p><p>学习好Java反射技术能帮助你更好的理解底层调用的原理，也有助于设计更加轻巧、高内聚、低耦合的业务框架。</p>]]></content>
      
      
      <categories>
          
          <category> Java核心系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java核心 </tag>
            
            <tag> Java基础 </tag>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java核心系列6：集合框架详解</title>
      <link href="/2025/04/02/Java%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%866-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
      <url>/2025/04/02/Java%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%866-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="1-集合框架图总览"><a href="#1-集合框架图总览" class="headerlink" title="1 集合框架图总览"></a>1 集合框架图总览</h1><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAPFaUek1AeB4_p1r3pvUbac0epF6w0AAsULaxunpzhWejH-1zwrEC4BAAMCAAN4AAM2BA.png" alt="Java集合框架图"><br>我们来简单解读下上面这个框架图：</p><ul><li>所有集合类都位于java.util包下</li><li>Iterator是遍历集合的工具，我们经常通过Iterator迭代器来遍历集合。我们说Collection依赖于Iterator，是因为Collection的实现类都要实现iterator()函数，返回一个Iterator对象。ListIterator主要作用就是遍历List。</li><li>Java的集合类主要由两个接口派生而出：Collection和Map，作为Java集合框架的根接口，这两个接口包含了一些子接口和实现类。</li><li>集合接口：即图中的 LinkIterator、List、Set、Queue、SortedMap、SortedMap 6个接口（即短虚线框部分），表示不同集合类型，是集合框架的基础。</li><li>抽象类：即图中的 AbstractCollection、AbstractList、AbstractSet、AbstractMap、AbstractSequentialList 5个抽象类（长虚线框部分），抽象类只是对集合接口的部分实现，有需要的话可以继续扩展，完善自定义集合类。</li><li>实现类：即图片中LinkHashMap、TreeMap等8个实现类（实线框部分），主要是对接口的具体实现。</li><li>Collection 接口包含一组允许重复的对象</li><li>Set 接口继承 Collection，但是集合内的元素不重复。Set的实现类有HastSet和TreeSet。HashSet依赖于HashMap，它实际上是通过HashMap实现的；TreeSet依赖于TreeMap，它实际上是通过TreeMap实现的。</li><li>List 接口继承 Collection，集合内元素允许重复，但维护了元素的插入顺序，所以是个有序队列。每一个元素都有它的索引。第一个元素的索引值是0。List的实现类有LinkedList, ArrayList, Vector, Stack。</li><li>Map接口是键－值对象顶层接口，下面还包含了一些子接口和实现类。AbstractMap是个抽象类，它实现了Map接口中的大部分API。而HashMap，TreeMap，WeakHashMap都是继承于AbstractMap。Hashtable虽然继承于Dictionary，但它实现了Map接口。</li><li>Set、List和Map是集合的三大类：<ul><li>List：有序集合，集合中元素可重复，访问元素可以根据元素索引访问。</li><li>Set：无序集合，集合中元素不可以重复，访问集合中的元素只能根据元素自身信息来访问（因此元素不允许重复）。</li><li>Map：Key-value模式的键值对元素，访问时根据元素key来读取对应的value。</li></ul></li><li>Arrays和Collections是操作数组、集合的两个工具类。</li></ul><p>完成对上面框架的整体介绍之后，我们接着对每个类别进行详细的分析。</p><h1 id="2-Collection接口"><a href="#2-Collection接口" class="headerlink" title="2 Collection接口"></a>2 Collection接口</h1><p>Collection接口是处理对象集合的根接口，其中定义了很多对元素进行操作的方法。Collection接口有两个主要的子接口List和Set，注意Map不是Collection的子接口，这个要牢记。<br>Collection接口中的方法如下:<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAPEaUekrkV4riOG17In-S6vi6FMOfwAAsQLaxunpzhWNj0R50W5FRgBAAMCAAN5AAM2BA.png" alt="Collection接口中的方法"><br>其中，有几个比较常用的方法，比如方法add()添加一个元素到集合中，addAll()将指定集合中的所有元素添加到集合中，contains()方法检测集合中是否包含指定的元素，toArray()方法返回一个表示集合的数组。</p><p>另外，Collection中有一个iterator()函数，它的作用是返回一个Iterator接口。通常，我们通过Iterator迭代器来遍历集合。ListIterator是List接口所特有的，在List接口中，通过ListIterator()返回一个ListIterator对象。</p><p>Collection接口有两个常用的子接口，下面会详细介绍。</p><h2 id="2-1-List接口"><a href="#2-1-List接口" class="headerlink" title="2.1 List接口"></a>2.1 List接口</h2><p>List集合代表一个有序集合，集合中每个元素都有其对应的顺序索引。List集合允许使用重复元素，可以通过索引来访问指定位置的集合元素。</p><p>List接口继承于Collection接口，它可以定义一个允许重复的有序集合。因为List中的元素是有序的，所以我们可以通过使用索引（元素在List中的位置，类似于数组下标）来访问List中的元素，这类似于Java的数组。</p><p>List接口为Collection直接接口。List所代表的是有序的Collection，即它用某种特定的插入顺序来维护元素顺序。用户可以对列表中每个元素的插入位置进行精确地控制，同时可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。实现List接口的集合主要有：ArrayList、LinkedList、Vector、Stack。</p><h3 id="2-1-1-ArrayList"><a href="#2-1-1-ArrayList" class="headerlink" title="2.1.1 ArrayList"></a>2.1.1 ArrayList</h3><p>ArrayList是一个动态数组，也是我们最常用的集合。它允许任何符合规则的元素插入甚至包括null。每一个ArrayList都有一个初始容量（10），该容量代表了数组的大小。随着容器中的元素不断增加，容器的大小也会随着增加。在每次向容器中增加元素的同时都会进行容量检查，当快溢出时，就会进行扩容操作。所以如果我们明确所插入元素的多少，最好指定一个初始容量值，避免过多的进行扩容操作而浪费时间、效率。</p><p>size、isEmpty、get、set、iterator 和 listIterator 操作都以固定时间运行。add 操作以分摊的固定时间运行，也就是说，添加 n 个元素需要 O(n) 时间（由于要考虑到扩容，所以这不只是添加元素会带来分摊固定时间开销那样简单）。</p><p>ArrayList擅长于随机访问。同时ArrayList是非同步的。</p><h3 id="2-1-2-LinkedList"><a href="#2-1-2-LinkedList" class="headerlink" title="2.1.2 LinkedList"></a>2.1.2 LinkedList</h3><p>同样实现List接口的LinkedList与ArrayList不同，ArrayList是一个动态数组，而LinkedList是一个双向链表。所以它除了有ArrayList的基本操作方法外还额外提供了get，remove，insert方法在LinkedList的首部或尾部。</p><p>由于实现的方式不同，LinkedList不能随机访问，它所有的操作都是要按照双重链表的需要执行。在列表中索引的操作将从开头或结尾遍历列表（从靠近指定索引的一端）。这样做的好处就是可以通过较低的代价在List中进行插入和删除操作。</p><p>与ArrayList一样，LinkedList也是非同步的。如果多个线程同时访问一个List，则必须自己实现访问同步。一种解决方法是在创建List时构造一个同步的List:</p><p>List list &#x3D; Collections.synchronizedList(new LinkedList(…));</p><h3 id="2-1-3-Vector"><a href="#2-1-3-Vector" class="headerlink" title="2.1.3 Vector"></a>2.1.3 Vector</h3><p>与ArrayList相似，但是Vector是同步的。所以说Vector是线程安全的动态数组。它的操作与ArrayList几乎一样。<br>的</p><h3 id="2-1-4-Stack"><a href="#2-1-4-Stack" class="headerlink" title="2.1.4 Stack"></a>2.1.4 Stack</h3><p>Stack继承自Vector，实现一个后进先出的堆栈。Stack提供5个额外的方法使得Vector得以被当作堆栈使用。基本的push和pop 方法，还有peek方法得到栈顶的元素，empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置。Stack刚创建后是空栈。<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAPDaUekeRSEZ24DUKcqW8MitpUC3zAAAsELaxunpzhWfxhQQkaAvQsBAAMCAAN5AAM2BA.png" alt="List集合"></p><h2 id="2-2-Set接口"><a href="#2-2-Set接口" class="headerlink" title="2.2 Set接口"></a>2.2 Set接口</h2><p>Set是一种不包括重复元素的Collection。它维持它自己的内部排序，所以随机访问没有任何意义。与List一样，它同样允许null的存在但是仅有一个。由于Set接口的特殊性，所有传入Set集合中的元素都必须不同，同时要注意任何可变对象，如果在对集合中元素进行操作时，导致element1.equals(element2)为true，则必定会产生数据冲突的问题。Set接口有三个具体实现类，分别是：</p><ul><li>散列集HashSet</li><li>链式散列集LinkedHashSet</li><li>树形集TreeSet</li></ul><p>Set是一种不包含重复的元素的Collection，无序，即任意的两个元素element1和element2都有element1.equals(element2)为false，Set最多可以有一个null元素。需要注意的是，虽然Set中元素没有顺序性，但是元素在set中的位置是由该元素的HashCode决定的，所以具体的位置其实是固定的。</p><p>此外需要说明一点，在set接口中的不重复是有特殊要求的。</p><p>举一个例子:对象A和对象B，本来是不同的两个对象，正常情况下它们是能够放入到Set里面的，但是如果对象A和B的都重写了hashcode和equals方法，并且重写后的hashcode和equals方法是相同的话。那么A和B是不能同时放入到Set集合中去的，也就是Set集合中的去重和hashcode与equals方法直接相关。</p><p>为了更好地理解，请看下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setWork</span><span class="params">()</span> &#123;</span><br><span class="line">       Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">       set.add(<span class="string">&quot;Brand1&quot;</span>);</span><br><span class="line">       set.add(<span class="string">&quot;Brand2&quot;</span>);</span><br><span class="line">       set.add(<span class="string">&quot;Brand1&quot;</span>);</span><br><span class="line">       System.out.println(<span class="string">&quot;Set Size:&quot;</span> + set.size());</span><br><span class="line">       System.out.println(<span class="string">&quot;Set Elements:&quot;</span> + set.toString());</span><br><span class="line"></span><br><span class="line"><span class="comment">//再次添加一个字符串对象 Brand2，然后通过equals方法比较，发现是相等的，所以添加失败返回false</span></span><br><span class="line">       <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> set.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Brand2&quot;</span>));</span><br><span class="line">       System.out.println(result);</span><br><span class="line">       System.out.println(set);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>执行结果：<br>Set Size:2<br>Set Elements:[Brand1, Brand2]<br>false<br>[Brand1, Brand2]<br>可以看出，因为有hashcode和equals方法，用来比较指向的字符串对象所存储的字符串是否相等，所以第二个Brand1加进去是无效的。</p><p>程序通过new关键字来创建新的字符串对象Brand2，使用&#x3D;&#x3D;运算符判断返回false，使用equals方法比较返回true，所以同样不能添加到Set集合中，最终还是两个元素。</p><h3 id="2-2-1-HashSet"><a href="#2-2-1-HashSet" class="headerlink" title="2.2.1 HashSet"></a>2.2.1 HashSet</h3><p>HashSet 是一个没有重复元素的集合。它是由HashMap实现的，不保证元素的顺序(这里所说的没有顺序是指：元素插入的顺序与输出的顺序不一致)，而且HashSet允许使用null 元素。HashSet是非同步的，如果多个线程同时访问一个哈希set，而其中至少一个线程修改了该set，那么它必须保持外部同步。 HashSet按Hash算法来存储集合的元素，因此具有很好的存取和查找性能。</p><p>HashSet的实现方式大致如下，通过一个HashMap存储元素，元素是存放在HashMap的Key中，而Value统一使用一个Object对象。</p><p>HashSet使用和理解中容易出现的误区:</p><ul><li>HashSet中存放null值<br>HashSet中是允许存入null值的，但是在HashSet中仅仅能够存入一个null值。</li><li>HashSet中存储元素的位置是固定的<br>HashSet中存储的元素的是无序的，这个没什么好说的，但是由于HashSet底层是基于Hash算法实现的，使用了hashcode，所以HashSet中相应的元素的位置是固定的。</li><li>必须小心操作可变对象（Mutable Object）。<br>如果一个Set中的可变元素改变了自身状态导致Object.equals(Object)&#x3D;true将导致一些问题。</li></ul><h3 id="2-2-2-LinkedHashSet"><a href="#2-2-2-LinkedHashSet" class="headerlink" title="2.2.2 LinkedHashSet"></a>2.2.2 LinkedHashSet</h3><p>LinkedHashSet继承自HashSet，其底层是基于LinkedHashMap来实现的，有序，非同步。LinkedHashSet集合同样是根据元素的hashCode值来决定元素的存储位置，但是它同时使用链表维护元素的次序。这样使得元素看起来像是以插入顺序保存的，也就是说，当遍历该集合时候，LinkedHashSet将会以元素的添加顺序访问集合的元素。</p><h3 id="2-2-3-TreeSet"><a href="#2-2-3-TreeSet" class="headerlink" title="2.2.3 TreeSet"></a>2.2.3 TreeSet</h3><p>TreeSet是一个有序集合，其底层是基于TreeMap实现的，非线程安全。TreeSet可以确保集合元素处于排序状态。TreeSet支持两种排序方式，自然排序和定制排序，其中自然排序为默认的排序方式。当我们构造TreeSet时，若使用不带参数的构造函数，则TreeSet的使用自然比较器；若用户需要使用自定义的比较器，则需要使用带比较器的参数。</p><p>注意：TreeSet集合不是通过hashcode和equals函数来比较元素的.它是通过compare或者comparaeTo函数来判断元素是否相等.compare函数通过判断两个对象的id，相同的id判断为重复元素，不会被加入到集合中。</p><h1 id="3-Map接口"><a href="#3-Map接口" class="headerlink" title="3 Map接口"></a>3 Map接口</h1><p>Map与List、Set接口不同，它是由一系列键值对组成的集合，提供了key到Value的映射。同时它也没有继承Collection。在Map中它保证了key与value之间的一一对应关系。也就是说一个key对应一个value，所以它不能存在相同的key值，当然value值可以相同。</p><h2 id="3-1-HashMap"><a href="#3-1-HashMap" class="headerlink" title="3.1 HashMap"></a>3.1 HashMap</h2><p>以哈希表数据结构实现，查找对象时通过哈希函数计算其位置，它是为快速查询而设计的，其内部定义了一个hash表数组（Entry[] table），元素会通过哈希转换函数将元素的哈希地址转换成数组中存放的索引，如果有冲突，则使用散列链表的形式将所有相同哈希地址的元素串起来，可能通过查看HashMap.Entry的源码它是一个单链表结构。</p><h2 id="3-2-LinkedHashMap"><a href="#3-2-LinkedHashMap" class="headerlink" title="3.2 LinkedHashMap"></a>3.2 LinkedHashMap</h2><p>LinkedHashMap是HashMap的一个子类，它保留插入的顺序，如果需要输出的顺序和输入时的相同，那么就选用LinkedHashMap。</p><p>LinkedHashMap是Map接口的哈希表和链接列表实现，具有可预知的迭代顺序。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。<br>LinkedHashMap实现与HashMap的不同之处在于，后者维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，该迭代顺序可以是插入顺序或者是访问顺序。</p><p>根据链表中元素的顺序可以分为：按插入顺序的链表，和按访问顺序(调用get方法)的链表。默认是按插入顺序排序，如果指定按访问顺序排序，那么调用get方法后，会将这次访问的元素移至链表尾部，不断访问可以形成按访问顺序排序的链表。<br>注意，此实现不是同步的。如果多个线程同时访问链接的哈希映射，而其中至少一个线程从结构上修改了该映射，则它必须保持外部同步。</p><p>由于LinkedHashMap需要维护元素的插入顺序，因此性能略低于HashMap的性能，但在迭代访问Map里的全部元素时将有很好的性能，因为它以链表来维护内部顺序。</p><h2 id="3-3-TreeMap"><a href="#3-3-TreeMap" class="headerlink" title="3.3 TreeMap"></a>3.3 TreeMap</h2><p>TreeMap 是一个有序的key-value集合，非同步，基于红黑树（Red-Black tree）实现，每一个key-value节点作为红黑树的一个节点。TreeMap存储时会进行排序的，会根据key来对key-value键值对进行排序，其中排序方式也是分为两种，一种是自然排序，一种是定制排序，具体取决于使用的构造方法。</p><p>自然排序：TreeMap中所有的key必须实现Comparable接口，并且所有的key都应该是同一个类的对象，否则会报ClassCastException异常。</p><p>定制排序：定义TreeMap时，创建一个comparator对象，该对象对所有的treeMap中所有的key值进行排序，采用定制排序的时候不需要TreeMap中所有的key必须实现Comparable接口。</p><p>TreeMap判断两个元素相等的标准：两个key通过compareTo()方法返回0，则认为这两个key相等。</p><p>如果使用自定义的类来作为TreeMap中的key值，且想让TreeMap能够良好的工作，则必须重写自定义类中的equals()方法，TreeMap中判断相等的标准是：两个key通过equals()方法返回为true，并且通过compareTo()方法比较应该返回为0。<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAPCaUejy88_1sBCEpcW5-r6wslnfV4AAsALaxunpzhWzPj4F5SrGPQBAAMCAAN4AAM2BA.png" alt="Map集合"></p><h1 id="4-Iterator-与-ListIterator详解"><a href="#4-Iterator-与-ListIterator详解" class="headerlink" title="4 Iterator 与 ListIterator详解"></a>4 Iterator 与 ListIterator详解</h1><h2 id="4-1-Iterator"><a href="#4-1-Iterator" class="headerlink" title="4.1 Iterator"></a>4.1 Iterator</h2><p>Iterator的定义如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><p>Java的Iterator（迭代器）是一个设计模式，它使你可以遍历一个容器（如列表，集合，队列等）。它提供了一种方法来顺序访问聚合对象的元素，而不需要暴露该对象的内部表示。</p><p>Iterator提供的API接口如下：</p><ul><li>boolean hasNext()：判断集合里是否存在下一个元素。如果有，hasNext()方法返回 true。</li><li>Object next()：返回集合里下一个元素。</li><li>void remove()：删除集合里上一次next方法返回的元素。<br>参考如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;  </span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">         <span class="comment">// 创建一个ArrayList对象</span></span><br><span class="line">            List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            list.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">            list.add(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">            list.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取该ArrayList的迭代器</span></span><br><span class="line">            Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用迭代器遍历列表中的元素</span></span><br><span class="line">            <span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">element</span> <span class="operator">=</span> it.next();</span><br><span class="line">                System.out.println(element);</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;Java&quot;</span>.equals(element)) &#123;</span><br><span class="line">                    it.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 移除之后的ArrayList对象</span></span><br><span class="line">            System.out.println(<span class="string">&quot;after remove element 「java」: &quot;</span> + list);</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Hello</span><br><span class="line">World</span><br><span class="line">Java</span><br><span class="line">remove java element : [Hello, World]</span><br></pre></td></tr></table></figure><p>需要注意的点如下：</p><ul><li>Iterator只能单向移动。</li><li>Iterator.remove()是唯一安全在迭代过程中修改集合；如果在迭代过程中以任何其它的方式修改了基本集合将会产生未知的行为。而且每调用一次next()方法，remove()方法只能被调用一次，如果违反这个规则将抛出一个异常，因为可能导致数据异常。</li></ul><h2 id="4-2-ListIterator"><a href="#4-2-ListIterator" class="headerlink" title="4.2 ListIterator"></a>4.2 ListIterator</h2><p>ListIterator是一个功能更加强大的迭代器, 它继承于Iterator接口,只能用于各种List类型的访问。它提供了在列表中插入和删除元素的方法，以及使用hasPrevious()和previous()方法在迭代过程中向前和向后遍历列表的功能。<br>以下是ListIterator的主要方法：</p><ul><li>boolean hasNext(): 返回true如果迭代器有下一个元素。</li><li>Object next(): 返回迭代器的下一个元素并将指针移到下一个元素。</li><li>boolean hasPrevious(): 返回true如果迭代器有前一个元素。</li><li>Object previous(): 返回迭代器的前一个元素并将指针移到前一个元素。</li><li>int nextIndex(): 返回迭代器下一次要访问的元素的索引。</li><li>int previousIndex(): 返回迭代器上一次访问的元素的索引。</li><li>void remove(): 从列表中删除迭代器最后一次返回的元素。</li><li>void add(Object o): 在迭代器指向的位置插入指定的元素。</li><li>void set(E e): 从列表中替换迭代器最后一次返回的元素。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ListIterator</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>; </span><br><span class="line">    E <span class="title function_">next</span><span class="params">()</span>; </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasPrevious</span><span class="params">()</span>; </span><br><span class="line">    E <span class="title function_">previous</span><span class="params">()</span>; </span><br><span class="line">    <span class="type">int</span> <span class="title function_">nextIndex</span><span class="params">()</span>; </span><br><span class="line">    <span class="type">int</span> <span class="title function_">previousIndex</span><span class="params">()</span>; </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span>; </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(E e)</span>; </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由以上定义我们可以推出ListIterator可以:</p><ul><li>双向移动（向前或者向后遍历）</li><li>产生相对于迭代器在列表中指向的当前位置的前一个和后一个元素的索引</li><li>可以使用set()方法替换它访问过的最后一个元素</li><li>可以使用add()方法在next()方法返回的元素之前或previous()方法返回的元素之后插入一个元素</li></ul><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">listIteratorWork</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个 ArrayList</span></span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">&quot;Element A&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;Element B&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;Element C&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;当前列表 : &quot;</span> + list);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 ListIterator 对象</span></span><br><span class="line">    ListIterator&lt;String&gt; listIterator = list.listIterator();</span><br><span class="line">    <span class="comment">// 使用 hasNext() 和 next() 方法迭代列表</span></span><br><span class="line">    System.out.println(<span class="string">&quot;逐一遍历 : &quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (listIterator.hasNext()) &#123;</span><br><span class="line">        System.out.println(listIterator.next() + <span class="string">&quot;, &quot;</span> + listIterator.previousIndex() + <span class="string">&quot;, &quot;</span> + listIterator.nextIndex());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在迭代过程中使用 add() 方法添加元素</span></span><br><span class="line">    listIterator.add(<span class="string">&quot;Element D&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;添加一个元素之后:&quot;</span> + list);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在迭代过程中使用 set() 方法进行元素修改</span></span><br><span class="line">    listIterator = list.listIterator(<span class="number">1</span>);</span><br><span class="line">    System.out.print(<span class="string">&quot;修改一个元素之后:&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (listIterator.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;Element D&quot;</span>.equals(listIterator.next())) &#123;</span><br><span class="line">            listIterator.set(<span class="string">&quot;Element replace&quot;</span>);</span><br><span class="line">        &#125;           </span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(list);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">当前列表 : [<span class="built_in">Element</span> A, <span class="built_in">Element</span> B, <span class="built_in">Element</span> C]</span><br><span class="line">逐一遍历 : </span><br><span class="line"><span class="built_in">Element</span> A, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="built_in">Element</span> B, <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="built_in">Element</span> C, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line">添加一个元素之后:[<span class="built_in">Element</span> A, <span class="built_in">Element</span> B, <span class="built_in">Element</span> C, <span class="built_in">Element</span> D]</span><br><span class="line">修改一个元素之后:[<span class="built_in">Element</span> A, <span class="built_in">Element</span> B, <span class="built_in">Element</span> C, <span class="built_in">Element</span> replace]</span><br></pre></td></tr></table></figure><h1 id="5-面试考点分析"><a href="#5-面试考点分析" class="headerlink" title="5 面试考点分析"></a>5 面试考点分析</h1><h2 id="5-1-ArrayList和LinkedList对比"><a href="#5-1-ArrayList和LinkedList对比" class="headerlink" title="5.1 ArrayList和LinkedList对比"></a>5.1 ArrayList和LinkedList对比</h2><ul><li>ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。</li><li>两者都是线程不安全，都实现了Collection接口。</li><li>数据结构：ArrayList是基于动态数组的数据结构，LinkedList是基于双向链表的数据结构。</li><li>性能：ArrayList支持随机访问，查询快，增删慢，查询的时间复杂度为O(1)，插入和删除的时间复杂度为O(n)，因为对插入和删除位置后面的元素进行移动位置，以保证内存的连续性，所以<ul><li>对于随机访问get和set，ArrayList绝对优于LinkedList，因为LinkedList要移动指针。</li><li>对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。</li></ul></li><li>内存空间占用： ArrayList的空 间浪费主要体现在在list列表的结尾会预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗 比ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）。</li></ul><h2 id="5-2-HashTable与HashMap对比"><a href="#5-2-HashTable与HashMap对比" class="headerlink" title="5.2 HashTable与HashMap对比"></a>5.2 HashTable与HashMap对比</h2><ul><li>相同点：<ul><li>都实现了Map、Cloneable、java.io.Serializable接口。</li><li>都是存储”键值对(key-value)”的散列表，而且都是采用拉链法实现的。</li></ul></li><li>不同点：<ul><li>是否安全：HashMap是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过 synchronized 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap ）</li><li>同步性：HashTable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的 。</li><li>对null值的处理：HashMap的key、value都可为null，HashTable的key、value都不可为null 。</li><li>基类不同：HashMap继承于AbstractMap，而Hashtable继承于Dictionary。</li><li>支持的遍历种类不同：HashMap只支持Iterator(迭代器)遍历。而Hashtable支持Iterator(迭代器)和Enumeration(枚举器)两种方式遍历。</li><li>操作效率：因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；</li><li>对Null key 和Null value的支持： HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛出 NullPointerException</li><li>初始容量大小和每次扩充容量大小的不同 ：<ul><li>创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。</li><li>创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小。也就是说 HashMap 总是使用2的幂作为哈希表的大小,后面会介绍到为什么是2的幂次方。</li></ul></li><li>底层数据结构： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li></ul></li></ul><h2 id="5-3-LinkedHashMap和TreeMap比较"><a href="#5-3-LinkedHashMap和TreeMap比较" class="headerlink" title="5.3 LinkedHashMap和TreeMap比较"></a>5.3 LinkedHashMap和TreeMap比较</h2><p>LinkedHashMap保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时用带参数，按照应用次数排序。在遍历的时候会比HashMap慢。</p><p>TreeMap实现SortMap接口，内部实现是红黑树。能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap时，得到的记录是排过序的。TreeMap不允许key的值为null。非同步的。</p><h2 id="5-4-HashSet、LinkedHashSet、TreeSet比较"><a href="#5-4-HashSet、LinkedHashSet、TreeSet比较" class="headerlink" title="5.4 HashSet、LinkedHashSet、TreeSet比较"></a>5.4 HashSet、LinkedHashSet、TreeSet比较</h2><h3 id="5-4-1-Set接口"><a href="#5-4-1-Set接口" class="headerlink" title="5.4.1 Set接口"></a>5.4.1 Set接口</h3><p>Set不允许包含相同的元素，如果试图把两个相同元素加入同一个集合中，add方法返回false。</p><p>Set判断两个对象相同不是使用&#x3D;&#x3D;运算符，而是根据equals方法。也就是说，只要两个对象用equals方法比较返回true，Set就不会接受这两个对象。</p><h3 id="5-4-2-HashSet"><a href="#5-4-2-HashSet" class="headerlink" title="5.4.2 HashSet"></a>5.4.2 HashSet</h3><p>HashSet有以下特点：</p><ul><li>不能保证元素的排列顺序，顺序有可能发生变化。</li><li>不是同步的。</li><li>集合元素可以是null，但只能放入一个null。<br>HashSet集合判断两个元素相等的标准是两个对象通过equals方法比较相等，并且两个对象的hashCode()方法返回值也相等。</li></ul><h3 id="5-4-3-LinkedHashSet"><a href="#5-4-3-LinkedHashSet" class="headerlink" title="5.4.3 LinkedHashSet"></a>5.4.3 LinkedHashSet</h3><p>LinkedHashSet集合同样是根据元素的hashCode值来决定元素的存储位置，但是它同时使用链表维护元素的次序。这样使得元素看起来像是以插入顺序保存的，也就是说，当遍历该集合时候，LinkedHashSet将会以元素的添加顺序访问集合的元素。LinkedHashSet在迭代访问Set中的全部元素时，性能比HashSet好，但是插入时性能稍微逊色于HashSet。</p><h3 id="5-4-4-TreeSet类"><a href="#5-4-4-TreeSet类" class="headerlink" title="5.4.4 TreeSet类"></a>5.4.4 TreeSet类</h3><p>TreeSet是SortedSet接口的唯一实现类，TreeSet可以确保集合元素处于排序状态。TreeSet支持两种排序方式，自然排序和定制排序，其中自然排序为默认的排序方式。向TreeSet中加入的应该是同一个类的对象。</p><p>TreeSet判断两个对象不相等的方式是两个对象通过equals方法返回false，或者通过CompareTo方法比较没有返回0。</p><h2 id="5-5-Iterator和ListIterator区别"><a href="#5-5-Iterator和ListIterator区别" class="headerlink" title="5.5 Iterator和ListIterator区别"></a>5.5 Iterator和ListIterator区别</h2><ul><li>ListIterator有add()方法，可以向List中添加对象，而Iterator不能</li><li>ListIterator和Iterator都有hasNext()和next()方法，可以实现顺序向后遍历，但是ListIterator有hasPrevious()和previous()方法，可以实现逆向（顺序向前）遍历。Iterator就不可以。</li><li>ListIterator可以定位当前的索引位置，nextIndex()和previousIndex()可以实现。Iterator没有此功能。</li><li>都可实现删除对象，但是ListIterator可以实现对象的修改，set()方法可以实现。Iierator仅能遍历，不能修改。<br>因为ListIterator的这些功能，可以方便的实现对LinkedList等List数据结构的操作。其实，数组对象也可以用迭代器来实现。</li></ul><h2 id="5-6-Collection-和-Collections区别"><a href="#5-6-Collection-和-Collections区别" class="headerlink" title="5.6 Collection 和 Collections区别"></a>5.6 Collection 和 Collections区别</h2><p>Java中的Collection和Collections都是用于处理集合的类，但它们有一些重要的区别。</p><p><strong>继承关系</strong>：Collection是所有集合类的根接口，它定义了集合的基本操作，比如添加元素、删除元素等。Collections是一个帮助类，它提供了静态方法来操作和操作集合，比如排序、查找等。Collections类通过实现和实例化集合类的各种基本操作，让集合类的操作更加简单。</p><p><strong>用法</strong>：Collection通常用于定义集合类的基本操作，而Collections则提供了各种静态方法来操作和操作集合。Collections类中包含了很多有用的静态方法，比如排序、查找、复制等。</p>]]></content>
      
      
      <categories>
          
          <category> Java核心系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java核心 </tag>
            
            <tag> Java基础 </tag>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java核心系列7：线程安全性讨论</title>
      <link href="/2025/04/02/Java%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%867-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%A8%E8%AE%BA/"/>
      <url>/2025/04/02/Java%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%867-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%A8%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="1-为什么需要多线程"><a href="#1-为什么需要多线程" class="headerlink" title="1 为什么需要多线程"></a>1 为什么需要多线程</h1><p>我们都知道，CPU、内存、I&#x2F;O 设备的速度是有极大差异的，为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系结构、操作系统、编译程序都做出了优化，主要体现为:</p><ul><li>CPU增加了缓存，均衡了与内存之间的速度差异，但会导致可见性问题</li><li>操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I&#x2F;O 设备的速度差异，但会导致原子性问题</li><li>编译程序优化指令执行次序，使得缓存能够得到更加合理地利用，但会导致有序性问题</li></ul><p>从上面可以看到，虽然多线程平衡了CPU、内存、I&#x2F;O 设备之间的效率，但是同样也带来了一些问题。</p><h1 id="2-线程不安全案例分析"><a href="#2-线程不安全案例分析" class="headerlink" title="2 线程不安全案例分析"></a>2 线程不安全案例分析</h1><p>如果有多个线程，对一个共享数据进行操作，但没有采取同步的话，那操作结果可能超出预想，产生不一致。</p><p>下面举个粒子，设置一个计数器count，我们通过1000个线程同时对它进行增量操作，看看操作之后的值，是不是符合预想中的1000。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnsafeThreadTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadNum</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">    <span class="type">UnsafeThreadTest</span> <span class="variable">threadTest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnsafeThreadTest</span>();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(threadSize);</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorSvc</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line"><span class="comment">// 执行并发计数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>; idx &lt; threadNum; idx ++) &#123;</span><br><span class="line">        executorSvc.execute(() -&gt; &#123;</span><br><span class="line">            threadTest.add();</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.await();</span><br><span class="line"><span class="comment">// 关闭线程池</span></span><br><span class="line">    executorSvc.shutdown();</span><br><span class="line">    System.out.println(<span class="string">&quot;最终计数：&quot;</span> + threadTest.get());</span><br><span class="line">&#125;</span><br><span class="line">最终计数：<span class="number">994</span>  <span class="comment">// 结果跟预期的 1000 不一样</span></span><br></pre></td></tr></table></figure><h1 id="3-并发出现问题的原因"><a href="#3-并发出现问题的原因" class="headerlink" title="3 并发出现问题的原因"></a>3 并发出现问题的原因</h1><blockquote><p>可以看到，上述代码输出的结果跟预期的 1000 不一样，我们需要理清楚发生了什么问题?</p><p><strong>★ 并发三要素：可见性、原子性、有序性</strong></p></blockquote><h2 id="3-1-可见性：由CPU缓存引起"><a href="#3-1-可见性：由CPU缓存引起" class="headerlink" title="3.1 可见性：由CPU缓存引起"></a>3.1 可见性：由CPU缓存引起</h2><p>CPU缓存是一种高速缓存，用于存储CPU最近使用的数据。由于CPU缓存比主存储器更快，因此CPU会尽可能地使用缓存，以提高程序的性能。但是，这也会导致可见性问题。</p><p>可见性问题是指当一个线程修改了一个共享变量的值时，另一个线程可能无法立即看到这个修改。</p><p>我们举个简单的例子，看下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主存中 index 的值默认为 10</span></span><br><span class="line">System.out.println(<span class="string">&quot;主存中的值：&quot;</span> + index);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread1 执行赋值</span></span><br><span class="line">index = <span class="number">100</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Thread2 执行的</span></span><br><span class="line">threadA = index;</span><br></pre></td></tr></table></figure><p>因为Thread1修改后的值可能仍然存储在CPU缓存中，而没有被写回主存储器。这种情况下，Thread2无法读取到修改后的值，所以导致错误信息。</p><p>具体来说，当多个线程同时运行在同一个处理器上时，它们共享该处理器的缓存。如果一个线程修改了某个共享变量的值，该值可能被存储在处理器缓存中，并且未被立即写回到主存储器中。</p><p>因此，当另一个线程试图读取该变量的值时，它可能会从主存储器中读取旧的值 10，而不是从处理器缓存中读取已更新的值 100。</p><h2 id="3-2-原子性-由分时复用引起"><a href="#3-2-原子性-由分时复用引起" class="headerlink" title="3.2 原子性: 由分时复用引起"></a>3.2 原子性: 由分时复用引起</h2><p>原子性：原子性是指一个操作在执行过程中不可分割，即该操作要么完全执行，要么完全不执行。</p><p>我们举个简单的例子，看下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主存中 index 的值默认为 10</span></span><br><span class="line">System.out.println(<span class="string">&quot;主存中的值：&quot;</span> + index);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread1 执行增值</span></span><br><span class="line">index += <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Thread2 执行增值</span></span><br><span class="line">index += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>以上的信息可以看出：</p><ul><li>主存的值为10</li><li>i +&#x3D; 1 这个操作实际执行三条 CPU 指令<ul><li>变量 i 从内存读取到 CPU寄存器；</li><li>在CPU寄存器中执行 i + 1 操作；</li><li>将最后的结果i写入内存，因为有缓存机制，所以最终可能写入的是 CPU 缓存而不是内存。</li></ul></li><li>由于CPU分时复用（线程切换）的存在，Thread1执行了第一条指令后，就切换到Thread2执行，Thread2全部执行完成之后，再切换会Thread1执行后续两条指令，将造成最后写到内存中的index值是11而不是12。</li></ul><h2 id="3-3-有序性-重排序引起"><a href="#3-3-有序性-重排序引起" class="headerlink" title="3.3 有序性: 重排序引起"></a>3.3 有序性: 重排序引起</h2><p>有序性：即程序执行的顺序按照代码的先后顺序执行。</p><p>重排序（Reordering）是指在计算机系统中，由于处理器优化或编译器优化等原因，导致指令执行的顺序与程序代码中的顺序不一致。重排序可能会引起有序性错误，即在并发或多线程环境中，程序执行的顺序与代码的先后顺序不一致，导致程序结果不正确或出现意外的结果。</p><p>我们举个简单的例子，看下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isCheck</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">idx += <span class="number">1</span>;                <span class="comment">// 执行语句1  </span></span><br><span class="line">isCheck = <span class="literal">false</span>;          <span class="comment">// 执行语句2</span></span><br></pre></td></tr></table></figure><p>上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行操作。</p><p>从代码顺序上看，执行语句1是在执行语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗? 不一定，为什么呢? 这里可能会发生指令重排序（Instruction Reorder）。</p><p>重排序（Reordering）是指在计算机系统中，由于处理器优化或编译器优化等原因，导致指令执行的顺序与程序代码中的顺序不一致。重排序可能会引起有序性错误，即在并发或多线程环境中，程序执行的顺序与代码的先后顺序不一致，导致程序结果不正确或出现意外的结果。</p><p>重排序引起的有序性错误主要有以下几种情况：</p><ol><li>指令重排序：处理器为了优化程序的执行，可能会对指令进行重排序。这种重排序不会改变单线程程序的执行结果，但可能会影响多线程程序的行为。例如，一个线程修改了一个共享变量的值，但由于指令重排序，另一个线程在读取该变量时可能读取到过时的值。</li><li>内存访问重排序：处理器为了提高程序的执行效率，可能会对内存访问进行重排序。例如，一个线程先读取一个共享变量的值，然后再写入该值，但由于内存访问重排序，处理器可能会先执行写入操作，再执行读取操作，从而导致其他线程无法正确地读取到修改后的值。</li><li>同步操作重排序：在并发或多线程环境中，同步操作可能会被重排序。例如，一个线程先释放了一个锁，然后再执行另一个操作，但由于同步操作重排序，释放锁的操作可能会先于另一个操作执行，从而导致其他线程无法正确地获取锁。</li></ol><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAPGaUelcLCws8zRT7ERXBCf6R3tCr8AAtMLaxunpzhWk41It71juDIBAAMCAAN4AAM2BA.png" alt=" "></p><p>为了避免重排序引起的有序性错误，可以采用一些同步机制来确保程序的执行顺序，如内存屏障（Memory barrier，intel 称为 memory fence）、指令fence等。这些同步机制可以确保指令的执行顺序与代码中的顺序一致，避免指令重排序和内存访问重排序等问题。同时，也可以使用串行化（Serialization）或事务内存（Transactional memory）等技术来保证并发程序的有序性。</p><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h1><ul><li>CPU、内存、I&#x2F;O 设备的速度是有极大差异的，多线程 的实现是为了合理利用 CPU 的高性能，平衡这三者的速度差异</li><li>多线程情况下，并发产生问题的三要素：可见性、原子性、有序性<ul><li>可见性：由CPU缓存引起</li><li>原子性: 由分时复用引起</li><li>有序性: 重排序引起</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java核心系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java核心 </tag>
            
            <tag> Java基础 </tag>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java核心系列8：Java如何保证线程安全性</title>
      <link href="/2025/04/02/Java%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%868-Java%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7/"/>
      <url>/2025/04/02/Java%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%868-Java%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Java内存模型（JMM）-如何解决并发问题"><a href="#1-Java内存模型（JMM）-如何解决并发问题" class="headerlink" title="1 Java内存模型（JMM） 如何解决并发问题"></a>1 Java内存模型（JMM） 如何解决并发问题</h1><p><strong>维度1：使用关键字、属性进行优化</strong></p><p>JMM本质实际就是：Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法。这些方法包括了：</p><ul><li>volatile、synchronized 和 final 关键字</li><li>Happens-Before 规则</li></ul><p><strong>维度2：从 顺序一致性、可见性、有序性、原子性角度</strong></p><ul><li>顺序一致性</li></ul><p>一个线程中的所有操作按照程序的顺序执行，不受其他线程的影响。</p><ul><li>原子性</li></ul><p>Java程序中，对数据的读和写操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行，否则会产生问题。<br>通过下面的案例可以看出，哪些是原子操作，哪些是非原子操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1个动作，线程直接将值赋给idx，也就是直接写到内存中</span></span><br><span class="line">idx = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3个动作：先定义 jdx，再读取idx的值，最后赋值给jdx</span></span><br><span class="line">jdx := idx</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3个动作：读取jdx的值，进行加1操作，然后新值重新写入新的值</span></span><br><span class="line">jdx ++</span><br></pre></td></tr></table></figure><p>从上面的案例中可以看中，只有第一个例子才是具备原子性的，因为他只有一个存的动作。至于其他的例子，包含读取、操作、赋值等多个动作，有一个动作失败则不成立。</p><p>所以，基本读取和赋值，Java内存模型可以保证原子性操作，如果要实现更大范围、步骤更多的操作的原子性，则需要通过synchronized或者Lock来实现。</p><p>synchronized和Lock的存在是为了够保证任一时刻只有一个线程能够执行该代码块，这样也就解决了原子性。</p><ul><li>可见性</li></ul><p>Java提供了volatile关键字来保证可见性，使用volatile来修饰共享变量，可以保证修改的值立即更新到主存中。这样其他线程读取数据时，始终都会从内存中读取到新值。</p><p>而普通的共享变量不能保证可见性，因为修改之后，不确定什么时候被写入主存，当其他Thread去读取时，内存中很有可能还是原来的旧值，所以无法保证可见性。</p><p>另外，通过synchronized关键字和Lock功能也能够保证可见性，因为能限制同一时刻只有一个线程获取锁然后执行同步代码，且在释放之前会将变量的修改更新到主存中。所以实时可见。</p><ul><li>有序性</li></ul><p>在Java里面，可以通过volatile关键字来保证一定的“有序性”。</p><p>另外，通过synchronized关键字和Lock功能也能够保证可见性，因为能限制同一时刻只有一个线程获取锁然后执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。</p><p>注：JMM是通过Happens-Before 规则来保证Thread操作有序性。</p><h2 id="2-1-关键字-volatile、synchronized-和-final"><a href="#2-1-关键字-volatile、synchronized-和-final" class="headerlink" title="2.1 关键字: volatile、synchronized 和 final"></a>2.1 关键字: volatile、synchronized 和 final</h2><p>在Java中，volatile、synchronized和final是三个非常重要的关键字，它们都与并发编程密切相关。下面是对这三个关键字的详细介绍：</p><h3 id="2-1-1-volatile"><a href="#2-1-1-volatile" class="headerlink" title="2.1.1 volatile"></a>2.1.1 volatile</h3><p>volatile是Java中的一种修饰符，它用于声明一个共享变量，以确保多个线程对该变量的访问是可见的和有序的。volatile关键字的作用是禁止指令重排和强制刷新缓存，以保证操作的顺序性和可见性。</p><p>当一个变量被声明为volatile时，它表示该变量的值可能会被意想不到地改变。编译器和处理器会注意到这个变量的特殊性，并采取相应的措施来保证多个线程对该变量的访问是正确的。具体来说，volatile关键字会禁止编译器对volatile变量进行优化，每次读取该变量时都会直接从它的内存地址中读取，而不是从寄存器或缓存中读取。同时，volatile关键字也会强制处理器在每个操作该变量的指令之后立即刷新缓存，以保证其他线程能够看到最新的值。</p><p>需要注意的是，虽然volatile关键字可以保证可见性和有序性，但它并不能保证原子性。也就是说，如果一个操作包含多个步骤，而这些步骤不能被一个指令替换，那么这个操作就不能被保证为原子性。在这种情况下，需要使用锁或者其他同步机制来保证原子性。</p><h3 id="2-1-2-synchronized"><a href="#2-1-2-synchronized" class="headerlink" title="2.1.2 synchronized"></a>2.1.2 synchronized</h3><p>synchronized是Java中的一种关键字，它用于实现同步代码块和方法。synchronized关键字可以保证同一时刻只有一个线程能够执行被synchronized修饰的代码块或方法。synchronized关键字会创建一个锁对象或锁标识符，当一个线程获取了这个锁对象或锁标识符后，其他线程就不能再获取这个锁对象或锁标识符，直到第一个线程释放了这个锁对象或锁标识符。</p><p>synchronized关键字可以保证多个线程对共享变量的访问是互斥的，也就是说在同一时刻只有一个线程能够访问共享变量。这样可以避免多个线程同时修改共享变量而导致数据不一致的问题。同时，synchronized关键字还可以保证多个线程之间的操作是有序的，即一个线程在执行synchronized代码块或方法之前必须等待其他线程完成之前的操作。</p><p>需要注意的是，synchronized关键字虽然可以保证互斥性和有序性，但它并不能保证原子性。也就是说，如果一个操作包含多个步骤，而这些步骤不能被一个指令替换，那么这个操作就不能被保证为原子性。在这种情况下，需要使用其他同步机制来保证原子性。</p><h3 id="2-1-3-final"><a href="#2-1-3-final" class="headerlink" title="2.1.3 final"></a>2.1.3 final</h3><p>final是Java中的一种修饰符，它用于声明一个最终变量或方法。final关键字表示该变量或方法不能被修改或重写。具体来说，final关键字可以用于声明一个常量，该常量的值不能被修改；也可以用于声明一个方法，该方法不能被重写。</p><p>final关键字在并发编程中也有着重要的作用。final关键字可以保证一个共享变量的值只被一个线程修改，这样可以避免多个线程同时修改共享变量而导致数据不一致的问题。同时，final关键字还可以保证一个方法的执行不会被其他线程中断或干扰，这样可以保证方法的原子性和可见性。</p><p>需要注意的是，final关键字并不能保证多个线程之间的操作是有序的。也就是说，在一个线程中执行final方法时，其他线程可能会同时执行自己的操作，而这些操作之间是没有顺序关系的。在这种情况下，需要使用其他同步机制来保证操作的顺序性。</p><h2 id="2-2-Happens-Before-规则"><a href="#2-2-Happens-Before-规则" class="headerlink" title="2.2 Happens-Before 规则"></a>2.2 Happens-Before 规则</h2><p>上面提到了可以用 volatile 和 synchronized 来保证有序性。除此之外，在JVM 中还有Happens-Before规则，用来确定并发操作之间的顺序关系。</p><p>Happens-Before规则定义了以下几种顺序关系：</p><h3 id="2-2-1-程序顺序规则（Program-Order-Rule）"><a href="#2-2-1-程序顺序规则（Program-Order-Rule）" class="headerlink" title="2.2.1 程序顺序规则（Program Order Rule）"></a>2.2.1 程序顺序规则（Program Order Rule）</h3><p>在一个程序中，按照代码的顺序，先执行的操作Happens-Before后执行的操作。这意味着在程序中，如果一个操作先于另一个操作执行，那么这个操作的结果对后续操作是可见的。</p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAPMaUep0s9i6B7J4M0_5mE3hgMmkgMAAuULaxunpzhWEIJNAd4lSE8BAAMCAAN4AAM2BA.png" alt="程序顺序规则"></p><h3 id="2-2-2-管程锁定规则（Monitor-Lock-Rule）"><a href="#2-2-2-管程锁定规则（Monitor-Lock-Rule）" class="headerlink" title="2.2.2 管程锁定规则（Monitor Lock Rule）"></a>2.2.2 管程锁定规则（Monitor Lock Rule）</h3><p>一个unlock操作先行发生于后面对同一个锁的lock操作。<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAPLaUepsGjsjrpgPnxIYsLvGgLsCdwAAuQLaxunpzhWXx3hv6JOovgBAAMCAAN5AAM2BA.png" alt="管程锁定规则"></p><h3 id="2-2-3-volatile变量规则（Volatile-Variable-Rule）"><a href="#2-2-3-volatile变量规则（Volatile-Variable-Rule）" class="headerlink" title="2.2.3 volatile变量规则（Volatile Variable Rule）"></a>2.2.3 volatile变量规则（Volatile Variable Rule）</h3><p>对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作，先写后读。<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAPKaUepjPks8Y6U1Ty5ZCn-a8R-M3kAAuMLaxunpzhW-spg20adwdgBAAMCAAN5AAM2BA.png" alt="volatile变量规则"></p><h3 id="2-2-4-线程启动规则（Thread-Start-Rule）"><a href="#2-2-4-线程启动规则（Thread-Start-Rule）" class="headerlink" title="2.2.4 线程启动规则（Thread Start Rule）"></a>2.2.4 线程启动规则（Thread Start Rule）</h3><p>Thread 对象的 start() 方法调用先行发生于此线程的每一个动作。<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAPJaUepceFgT1znaYKlNU4R0FNmaIUAAuELaxunpzhWFVMao-WL6a4BAAMCAAN5AAM2BA.png" alt="线程启动规则"></p><h3 id="2-2-5-线程加入规则-（Thread-Join-Rule）"><a href="#2-2-5-线程加入规则-（Thread-Join-Rule）" class="headerlink" title="2.2.5 线程加入规则(（Thread Join Rule）"></a>2.2.5 线程加入规则(（Thread Join Rule）</h3><p>Thread 对象的结束先行发生于 join() 方法返回。<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAPIaUepPEETisPsjID9A7_DlUmKBRsAAuALaxunpzhWNpI2Dr_LHlEBAAMCAAN5AAM2BA.png" alt="线程加入规则"></p><h3 id="2-2-6-线程终止规则（Thread-Termination-Rule）"><a href="#2-2-6-线程终止规则（Thread-Termination-Rule）" class="headerlink" title="2.2.6 线程终止规则（Thread Termination Rule）"></a>2.2.6 线程终止规则（Thread Termination Rule）</h3><p>线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join()方法和Thread.isAlive()的返回值等手段检测线程是否已经终止执行</p><h3 id="2-2-7-线程中断规则（-Thread-Interruption-Rule）"><a href="#2-2-7-线程中断规则（-Thread-Interruption-Rule）" class="headerlink" title="2.2.7 线程中断规则（ Thread Interruption Rule）"></a>2.2.7 线程中断规则（ Thread Interruption Rule）</h3><p>对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。</p><h3 id="2-2-8-对象终结规则（Finalizer-Rule）"><a href="#2-2-8-对象终结规则（Finalizer-Rule）" class="headerlink" title="2.2.8 对象终结规则（Finalizer Rule）"></a>2.2.8 对象终结规则（Finalizer Rule）</h3><p>一个对象的初始化完成(构造函数执行结束)先行发生于它的 finalize() 方法的开始。</p><h3 id="2-2-9-传递性（Transitivity）"><a href="#2-2-9-传递性（Transitivity）" class="headerlink" title="2.2.9 传递性（Transitivity）"></a>2.2.9 传递性（Transitivity）</h3><p>如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。</p><h1 id="3-线程安全性能讨论"><a href="#3-线程安全性能讨论" class="headerlink" title="3 线程安全性能讨论"></a>3 线程安全性能讨论</h1><p>在多线程环境中，一个类或者一个函数不管在何种运行时环境或交替执行方式，都能保证正确的行为，被安全的调用，就说明线程是安全的。</p><p>这个“正确的行为”通常包括原子性、可见性和有序性。</p><p>但是线程安全不是非真即假，共享数据按照安全程度的强弱顺序可以分成以下五类:</p><ul><li>不可变</li><li>绝对线程安全</li><li>相对线程安全</li><li>线程兼容</li><li>线程对立</li></ul><p>按照线程安全性的强弱顺序，不可变 &gt; 绝对线程安全 &gt; 相对线程安全 &gt; 线程兼容 &gt; 线程对立。</p><h2 id="3-1-不可变（Immutable）"><a href="#3-1-不可变（Immutable）" class="headerlink" title="3.1 不可变（Immutable）"></a>3.1 不可变（Immutable）</h2><p>不可变的对象在创建后其状态就不能被修改，因此它们自然是线程安全的。任何线程在任何时候访问这些对象，都会看到相同的数据。</p><p>多线程环境下，应当尽量使对象成为不可变，来满足线程安全。</p><p>不可变的类型包括:</p><ul><li>final 关键字修饰的基本数据类型</li><li>String</li><li>枚举类型</li><li>Number 部分子类，如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等大数据类型。但同为 Number 的原子类 AtomicInteger 和 AtomicLong 则是可变的</li></ul><p>对于集合类型，可以使用 Collections.unmodifiableXXX() 方法来获取一个不可变的集合。</p><blockquote><p>XXX 可以是Map、List、Set</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImmutableClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;String, Integer&gt; testMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Map&lt;String, Integer&gt; testUnmodifiable = Collections.unmodifiableMap(testMap);</span><br><span class="line">        testUnmodifiable.put(<span class="string">&quot;input-a&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行时抛出异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.UnsupportedOperationException</span><br><span class="line">    at java.util.Collections$testUnmodifiable.put(Collections.java:<span class="number">1523</span>)</span><br><span class="line">    at ImmutableExample.main(ImmutableClass.java:<span class="number">9</span>)</span><br></pre></td></tr></table></figure><p>不可变状态还可以这么理解，外部无法对数据状态进行修改，比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImmutableClass</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> value;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ImmutableClass</span><span class="params">(<span class="type">int</span> value)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.value = value;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> value;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，ImmutableClass是不可变的，因为它的构造函数是私有的，外部无法修改其状态。因此，多个线程同时访问和获取ImmutableClass对象的值时，不会出现数据不一致的问题。</p><h2 id="3-2-绝对线程安全（Absolute-Thread-Safety）"><a href="#3-2-绝对线程安全（Absolute-Thread-Safety）" class="headerlink" title="3.2 绝对线程安全（Absolute Thread Safety）"></a>3.2 绝对线程安全（Absolute Thread Safety）</h2><p>绝对线程安全的对象无论运行时环境如何，调用者都不需要任何额外的同步措施。这通常需要付出较大的代价来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadSafeClass</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> value;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(<span class="type">int</span> value)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.value = value;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> value;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，ThreadSafeClass的每个方法都使用了synchronized关键字进行同步。这保证了无论多少个线程同时访问ThreadSafeClass的对象，每个线程的操作都会被串行执行，不会出现数据竞争的问题。</p><h2 id="3-3-相对线程安全（Relative-Thread-Safety）"><a href="#3-3-相对线程安全（Relative-Thread-Safety）" class="headerlink" title="3.3 相对线程安全（Relative Thread Safety）"></a>3.3 相对线程安全（Relative Thread Safety）</h2><p>相对线程安全的对象需要保证单个操作是线程安全的，在调用的时候不需要做额外的保障措施。但在连续调用时可能需要额外的同步措施来保证调用的正确性。</p><p>Java 语言中，大部分的线程安全类都属于这种类型，例如 Vector、HashTable、Collections 的 synchronizedCollection() 方法包装的集合等。</p><p>以Hashtable为例，因为它的每个方法都是同步的。但是，如果多个线程连续调用Hashtable的不同方法（如put和get），仍然可能出现竞态条件。为了避免这种情况，调用者需要在外部进行额外的同步。</p><p>在下面代码中，如果Vector中的一个元素被线程A删除，而线程B试图获取一个已经被删除的元素，那么就会抛出 ArrayIndexOutOfBoundsException。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VectorUnsafeExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Vector&lt;Integer&gt; vector = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                vector.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</span><br><span class="line">                    vector.remove(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</span><br><span class="line">                    vector.get(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            executorService.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Exception in thread <span class="string">&quot;Thread-159738&quot;</span> java.lang.ArrayIndexOutOfBoundsException: Array index out of range: <span class="number">3</span></span><br><span class="line">    at java.util.Vector.remove(Vector.java:<span class="number">831</span>)</span><br><span class="line">    at VectorUnsafeExample.lambda$main$<span class="number">0</span>(VectorUnsafeExample.java:<span class="number">14</span>)</span><br><span class="line">    at VectorUnsafeExample$$Lambda$<span class="number">1</span>/<span class="number">713338599.</span>run(Unknown Source)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br></pre></td></tr></table></figure><p>如果要保证上面的代码能正确执行下去，就需要对删除元素和获取元素的代码进行同步。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 独立线程A执行删除操作</span><br><span class="line">executorService.execute(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (vector) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</span><br><span class="line">            vector.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"># 独立线程B执行读取操作</span><br><span class="line">executorService.execute(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (vector) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</span><br><span class="line">            vector.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="3-4-线程兼容（Thread-Compatibility）"><a href="#3-4-线程兼容（Thread-Compatibility）" class="headerlink" title="3.4 线程兼容（Thread Compatibility）"></a>3.4 线程兼容（Thread Compatibility）</h2><p>线程兼容的对象本身不是线程安全的，但可以通过在调用端添加额外的同步措施来保证在多线程环境下的安全使用。<br>Java API 中大部分的类都是属于线程兼容的，比如ArrayList类就不是线程安全的。如果多个线程同时修改ArrayList，可能会导致数据不一致。但是，如果调用者在修改ArrayList时使用synchronized块或其他同步机制进行同步，就可以保证线程安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadCompatibleClass</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> value;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(<span class="type">int</span> value)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.value = value;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> value;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，ThreadCompatibleClass的方法没有使用synchronized关键字进行同步。因此，如果多个线程同时修改ThreadCompatibleClass的对象，可能会导致数据不一致。</p><h2 id="3-5-线程对立（Thread-Hostility）"><a href="#3-5-线程对立（Thread-Hostility）" class="headerlink" title="3.5 线程对立（Thread Hostility）"></a>3.5 线程对立（Thread Hostility）</h2><p>线程对立的对象无论如何都无法在多线程环境下并发使用，即使采取了同步措施。</p><p>一个典型的例子是Java中的ThreadLocalRandom类。这个类用于生成随机数，并且每个线程都有其自己的随机数生成器实例。由于每个线程使用不同的实例，因此无需担心线程安全问题。但是，如果尝试在没有正确初始化ThreadLocalRandom的情况下跨线程使用它，就可能导致问题。</p><p>这种情况下，即使添加了同步措施也无法保证线程安全。</p><h1 id="4-如何实现线程安全"><a href="#4-如何实现线程安全" class="headerlink" title="4 如何实现线程安全"></a>4 如何实现线程安全</h1><h2 id="4-1-synchronized关键字-ReentrantLock特性"><a href="#4-1-synchronized关键字-ReentrantLock特性" class="headerlink" title="4.1 synchronized关键字&#x2F;ReentrantLock特性"></a>4.1 synchronized关键字&#x2F;ReentrantLock特性</h2><ul><li>synchronized关键字</li></ul><p>在Java中，synchronized关键字是一种内置的同步机制，用于控制多个线程对共享资源的访问。它用于在并发环境中保护代码块，确保同一时刻只有一个线程可以执行该代码块。</p><p>synchronized关键字可以应用于方法或代码块。当它应用于方法时，它将锁住该方法的对象。当它应用于代码块时，它将锁住指定的锁对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedExample</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">incrementCount</span><span class="params">()</span> &#123;  </span><br><span class="line">        count++;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个例子中，incrementCount()方法使用了synchronized关键字。这意味着在任何时刻，只有一个线程可以执行该方法。如果有其他线程试图同时执行该方法，它们将会被阻塞，直到当前线程完成该方法的执行。</p><ul><li>ReentrantLock特性</li></ul><p>ReentrantLock 是 Java 中的一个可重入锁，它是一种比 synchronized 关键字更灵活的线程同步机制。ReentrantLock 允许一个线程多次获取同一个锁，而不会产生死锁。它也支持公平锁和非公平锁，可以根据实际需求进行选择。</p><p>下面是一个使用 ReentrantLock 的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLockExample</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">incrementCount</span><span class="params">()</span> &#123;  </span><br><span class="line">        lock.lock();  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            count++;  </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">            lock.unlock();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> count;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的这个例子中，我们定义了一个 ReentrantLock 和一个计数器 count。</p><p>incrementCount() 方法使用 lock.lock() 获取锁，然后增加计数器的值，最后使用 lock.unlock() 释放锁。</p><p>getCount() 方法直接返回计数器的值，无需获取锁。<br>这种方式比使用 synchronized 关键字更灵活，因为它可以细粒度地控制需要同步的代码块，而不是整个方法。</p><p>★ 后续的章节会详细的介绍 synchronized关键字和ReentrantLock特性，敬请期待</p><h2 id="4-2-非阻塞同步"><a href="#4-2-非阻塞同步" class="headerlink" title="4.2 非阻塞同步"></a>4.2 非阻塞同步</h2><p>在JAVA中，互斥同步最主要的问题就是线程阻塞和唤醒所带来的开销导致的性能问题，这种同步也称为阻塞同步，是一种悲观的并发策略，无论共享数据是否真的会出现竞争，它都要进行加锁，这样 用户态核心态转换、维护锁计数器和阻塞检查、线程唤醒等操作都会产生大量的开销。</p><p>非阻塞同步是指在多线程环境下，不需要使用阻塞等待的方式来实现同步控制，线程可以一直进行计算操作，而不会被阻塞。下面介绍几种手段实现非阻塞同步。</p><ol><li><p>CAS</p><p>​        随着硬件指令集水平的发展，我们经常使用基于冲突检测的乐观并发策略: 先执行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施(始终重试，直至成功)。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。</p><p>​        乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。硬件支持的原子性操作最典型的是: 比较并交换(Compare-and-Swap，CAS)。</p><p>​        CAS操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值（B）。如果内存位置V的值与预期原值A相匹配，则将内存位置的值更新为B，否则不进行任何操作。在并发环境中，CAS操作可以保证数据的一致性和线程安全性。、</p></li><li><p>AtomicInteger</p><p>​        AtomicInteger是Java中的一个原子整数类，它提供了原子操作的更新方法，可以在多线程环境下安全地更新共享的整数变量。</p><p>​        AtomicInteger的更新方法包括incrementAndGet()、getAndIncrement()、decrementAndGet()、getAndDecrement()、compareAndSet()等，它们使用了 Unsafe 类的 CAS 操作，保证对共享变量的操作是原子性的。</p></li></ol><p>以下代码使用了 AtomicInteger 执行了计数操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicIntegerExample</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="comment">// 启动10个线程，每个线程将计数器加10  </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;  </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;  </span><br><span class="line">                    counter.incrementAndGet();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;).start();  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 等待所有线程执行完毕  </span></span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 输出计数器的值  </span></span><br><span class="line">        System.out.println(<span class="string">&quot;Counter: &quot;</span> + counter);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们使用AtomicInteger来维护一个计数器的值，并启动了10个线程，每个线程将计数器加10次。由于AtomicInteger提供了原子操作的更新方法，因此即使多个线程同时更新计数器的值，也不会出现线程安全问题。最后，我们输出计数器的值，可以看到它应该是100（10个线程每个线程执行10次计数器加1操作）。</p><p>3.ABA</p><p>如果某个线程将变量A更改为B后再更改为A，那么另一个等待CAS操作的线程会认为该变量没有发生过改变，仍然是A，然后执行CAS操作。这样就可能导致数据的不一致。</p><p>J.U.C 包提供了一个带有标记的原子引用类 AtomicStampedReference 来解决这个问题，它可以通过控制变量值的版本来保证 CAS 的正确性。大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效。</p><p>另外，Java 8引入了一种新的原子类：LongAdder和LongAccumulator，它们内部采用了分段化的思想来解决高并发下的ABA问题。它们将内部变量分为一个数组，每个线程更新自己的分段，最后再合并结果。这种方式既解决了ABA问题，又提高了并发性能。</p><h2 id="4-3-无同步方案"><a href="#4-3-无同步方案" class="headerlink" title="4.3 无同步方案"></a>4.3 无同步方案</h2><p>换一个思路，如果没有方法的计算不涉及共享数据，不需要进行同步，是不是就不需要任何同步措施去保证正确性，也就没有线程安全的问题。</p><ul><li>栈封闭：多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的。</li><li>线程本地存储(Thread Local Storage)：如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。</li><li>可重入代码(Reentrant Code)：可以在代码执行的任何时刻中断它，转而去执行另外一段代码(包括递归调用它本身)，而在控制权返回后，原来的程序不会出现任何错误。</li></ul><p>这块简单介绍，后续会有专门的章节进行学习</p><h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h1><ul><li>了解了多线程产生的原因，以及线程不安全的原因</li><li>从 可见性，原子性和有序性 来阐述并发状态下线程不安全的原因</li><li>分析了Java是怎么解决并发问题的</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java核心系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java核心 </tag>
            
            <tag> Java基础 </tag>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java核心系列9：并发与多线程-线程基础</title>
      <link href="/2025/04/02/Java%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%869-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2025/04/02/Java%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%869-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="1-先导"><a href="#1-先导" class="headerlink" title="1 先导"></a>1 先导</h1><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAPPaUesL_F-r5So1LRpVkY_N4GVDFEAAu8LaxunpzhWBkV1X6uJ4hYBAAMCAAN5AAM2BA.png" alt="线程安全基础概览图"><br>Java线程基础主要包含如下知识点，相信我们再面试的过程中，经常会遇到类似的提问。</p><ol><li>线程有哪几种状态? 线程之间如何转变？</li><li>线程有哪几种实现方式? 各优缺点？</li><li>线程的基本操作（线程管理机制）有哪些?</li><li>线程如何中断?</li><li>线程有几种互斥同步方式? 如何选择?</li><li>线程之间的协作方式（通信和协调）?</li></ol><p>下面我们 一 一 解读。</p><h1 id="2-线程的状态和流转"><a href="#2-线程的状态和流转" class="headerlink" title="2 线程的状态和流转"></a>2 线程的状态和流转</h1><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAPOaUer6dvmjBFagfhkaXqEfpl3ui4AAu0LaxunpzhWc0KL_3hfiHIBAAMCAAN5AAM2BA.png" alt="线程的几种状态"></p><h2 id="2-1-新建-New"><a href="#2-1-新建-New" class="headerlink" title="2.1 新建(New)"></a>2.1 新建(New)</h2><p>如上图，创建完线程，但尚未启动。</p><h2 id="2-2-可运行-Runnable"><a href="#2-2-可运行-Runnable" class="headerlink" title="2.2 可运行(Runnable)"></a>2.2 可运行(Runnable)</h2><p>如上图，处于可运行阶段，正在运行，或者正在等待 CPU 时间片。包含了 <code>Running</code> 和 <code>Ready</code> 两种线程状态。</p><h2 id="2-3-阻塞-Blocking"><a href="#2-3-阻塞-Blocking" class="headerlink" title="2.3 阻塞(Blocking)"></a>2.3 阻塞(Blocking)</h2><p>如上图，正被Lock住，等待获取一个排它锁，如果其他的线程释放了锁，该状态就会结束。</p><h2 id="2-4-无限期等待-Waiting"><a href="#2-4-无限期等待-Waiting" class="headerlink" title="2.4 无限期等待(Waiting)"></a>2.4 无限期等待(Waiting)</h2><p>如上图，处在无限期等待阶段，等待其它线程显式地唤醒，否则不会被分配 CPU 时间片。<br>主要有两种方式进行释放：</p><ul><li>调用方的线程执行完成</li><li>使用 Object.notify() &#x2F; Object.notifyAll()进行显性唤醒</li></ul><h2 id="2-5-限期等待-Timed-Waiting"><a href="#2-5-限期等待-Timed-Waiting" class="headerlink" title="2.5 限期等待(Timed Waiting)"></a>2.5 限期等待(Timed Waiting)</h2><p>如上图，因为有时间控制，所以无需等待其它线程显式地唤醒，一定时间之后，系统会自动唤醒。<br>所以他有三种方式进行释放：<br>主要有两种方式进行释放：</p><ul><li>调用方的线程执行完成</li><li>使用 Object.notify() &#x2F; Object.notifyAll()进行显性唤醒</li><li>时间到结束<ul><li>Thread.sleep()</li><li>Object.wait() 方法，带Timeout参数</li><li>Thread.join() 方法，带Timeout参数</li></ul></li></ul><h2 id="2-6-死亡-Terminated"><a href="#2-6-死亡-Terminated" class="headerlink" title="2.6 死亡(Terminated)"></a>2.6 死亡(Terminated)</h2><ul><li>线程结束任务之后结束</li><li>产生了异常并结束</li></ul><h1 id="3-线程实现方式"><a href="#3-线程实现方式" class="headerlink" title="3 线程实现方式"></a>3 线程实现方式</h1><p>在Java中，线程的实现方式主要有两种：继承<code>Thread</code>类和实现<code>Runnable</code>接口。此外，Java 5开始，引入了<code>java.util.concurrent</code>包，提供了更多的并发工具，如<code>Callable</code>接口与<code>Future</code>接口，它们主要用于任务执行。</p><h2 id="3-1-继承Thread类"><a href="#3-1-继承Thread类" class="headerlink" title="3.1 继承Thread类"></a>3.1 继承Thread类</h2><p>通过继承<code>Thread</code>类来创建线程是最基本的方式。你需要创建一个扩展自<code>Thread</code>类的子类，并重写其<code>run()</code>方法。然后，可以创建该子类的实例来创建新的线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程运行中&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        t.start(); <span class="comment">// 调用start()方法来启动线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-实现Runnable接口"><a href="#3-2-实现Runnable接口" class="headerlink" title="3.2 实现Runnable接口"></a>3.2 实现Runnable接口</h2><p>另一种方式是让你的类实现<code>Runnable</code>接口，并实现<code>run()</code>方法。然后，你可以创建<code>Thread</code>类的实例，将实现了<code>Runnable</code>接口的类的实例作为构造参数传递给它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程运行中&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        t.start(); <span class="comment">// 调用start()方法来启动线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-使用Callable和Future"><a href="#3-3-使用Callable和Future" class="headerlink" title="3.3 使用Callable和Future"></a>3.3 使用Callable和Future</h2><p>虽然<code>Callable</code>和<code>Future</code>不是直接用于创建线程的，但它们提供了一种更灵活的方式来处理线程执行的结果。<code>Callable</code>类似于<code>Runnable</code>，但它可以返回一个结果，并且可以抛出异常。<code>Future</code>用于获取<code>Callable</code>执行的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;任务完成&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">        Future&lt;String&gt; future = executor.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>());</span><br><span class="line">        System.out.println(future.get()); <span class="comment">// 阻塞等待获取结果</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4-优缺点解读"><a href="#3-4-优缺点解读" class="headerlink" title="3.4 优缺点解读"></a>3.4 优缺点解读</h2><ul><li><strong>继承Thread类</strong>：简单直观，但Java不支持多重继承，如果类已经继承了其他类，则不能再用这种方式。另外继承整个 Thread 类开销过大，太重了。</li><li><strong>实现Runnable接口</strong>：更加灵活，推荐的方式。</li><li><strong>Callable和Future</strong>：提供了更为强大的功能，例如返回执行结果和抛出异常，但通常用于与<code>ExecutorService</code>等高级并发工具一起使用。</li></ul><h1 id="4-线程管理机制"><a href="#4-线程管理机制" class="headerlink" title="4 线程管理机制"></a>4 线程管理机制</h1><p>Java 中的线程管理机制非常强大，涵盖了从简单的线程创建到复杂的线程池管理等多个方面。</p><h2 id="4-1-Executor-框架"><a href="#4-1-Executor-框架" class="headerlink" title="4.1 Executor 框架"></a>4.1 Executor 框架</h2><p><code>Executor</code> 框架是 Java 并发包（<code>java.util.concurrent</code>）中的一个关键组件，它提供了一种更高级别的抽象来管理线程池。通过使用 <code>Executor</code>，你可以更容易地控制线程的创建、执行、调度、生命周期等。它主要有三种类型：</p><ol><li>CachedThreadPool: 一个任务创建一个线程</li><li>FixedThreadPool: 所有任务只能使用固定大小的线程</li><li>SingleThreadExecutor: 单个线程，相当于大小为 1 的 FixedThreadPool。</li></ol><ul><li><p><strong>优点</strong>：提高程序性能和响应速度，通过复用线程来减少线程创建和销毁的开销，简化并发编程。</p></li><li><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WorkerThread</span>(<span class="string">&quot;&quot;</span> + i);</span><br><span class="line">    executor.execute(worker);</span><br><span class="line">&#125;</span><br><span class="line">executor.shutdown();</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-2-守护线程（Daemon-Threads）"><a href="#4-2-守护线程（Daemon-Threads）" class="headerlink" title="4.2 守护线程（Daemon Threads）"></a>4.2 守护线程（Daemon Threads）</h2><p>守护线程是一种特殊的线程，它主要用于程序中“后台”任务的支持。守护线程与普通线程的区别在于，当程序中所有非守护线程结束时，JVM 会自动退出，即使还有守护线程在运行。守护线程常用于垃圾回收、JVM 内部的监控等任务。<br><strong>设置守护线程</strong>：通过调用线程对象的 <code>setDaemon(true)</code> 方法，在启动线程之前将其设置为守护线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">thread.setDaemon(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h2 id="4-3-sleep-方法"><a href="#4-3-sleep-方法" class="headerlink" title="4.3 sleep() 方法"></a>4.3 sleep() 方法</h2><p><code>sleep()</code> 方法是 <code>Thread</code> 类的一个静态方法，用于让当前正在执行的线程暂停执行指定的时间（毫秒），以毫秒为单位。在指定的时间过去后，线程将回到可运行状态，等待CPU的调度。</p><ul><li><strong>用途</strong>：常用于线程间的简单同步。</li><li><strong>注意</strong>：<code>sleep()</code> 方法不会释放锁（如果当前线程持有锁的话）。</li><li><strong>示例</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">       Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="4-4-yield-方法"><a href="#4-4-yield-方法" class="headerlink" title="4.4 yield() 方法"></a>4.4 yield() 方法</h2><p><code>yield()</code> 方法也是 <code>Thread</code> 类的一个静态方法，它告诉调度器当前线程愿意放弃当前处理器的使用，但这并不意味着线程会立即停止执行或进入等待&#x2F;阻塞状态。</p><p>调度器可以忽略这个提示，继续让当前线程运行。</p><ul><li><strong>用途</strong>：提示调度器让出CPU时间，但具体是否让出取决于调度器的实现。</li><li><strong>注意</strong>：<code>yield()</code> 方法不会使线程进入阻塞状态，也不会释放锁（如果持有的话）,类似仅建议。</li><li><strong>示例</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.<span class="keyword">yield</span>();</span><br></pre></td></tr></table></figure><h1 id="5-线程中断方式"><a href="#5-线程中断方式" class="headerlink" title="5 线程中断方式"></a>5 线程中断方式</h1><p>在Java中，线程中断是一种重要的线程间通信机制，用于通知线程应该停止当前正在执行的任务。线程中断的方式主要有以下几种：</p><h2 id="5-1-使用interrupt-方法"><a href="#5-1-使用interrupt-方法" class="headerlink" title="5.1 使用interrupt()方法"></a>5.1 使用<code>interrupt()</code>方法</h2><p><code>interrupt()</code>方法是Java推荐的线程中断方式。它并不会直接停止线程，而是设置线程的中断状态为true。线程需要定期检查这个中断状态（通过<code>isInterrupted()</code>方法），并根据需要自行决定如何响应中断请求，比如退出循环、释放资源等。</p><ul><li><p><strong>优点</strong>：安全、灵活，符合Java的并发编程理念。</p></li><li><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">        <span class="comment">// 执行任务</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 线程中断后的清理工作</span></span><br><span class="line">&#125;);</span><br><span class="line">thread.start();</span><br><span class="line"><span class="comment">// 稍后中断线程</span></span><br><span class="line">thread.interrupt();</span><br></pre></td></tr></table></figure></li></ul><h2 id="5-2-使用Executor的中断操作"><a href="#5-2-使用Executor的中断操作" class="headerlink" title="5.2 使用Executor的中断操作"></a>5.2 使用<code>Executor</code>的中断操作</h2><ol><li>调用 Executor 的 shutdown() 方法，会等待线程都执行完毕之后再关闭</li><li>调用 Executor 的 shutdownNow() 方法，则相当于直接调用具体线程的 interrupt() 方法</li></ol><h1 id="6-线程互斥同步方式"><a href="#6-线程互斥同步方式" class="headerlink" title="6 线程互斥同步方式"></a>6 线程互斥同步方式</h1><p>Java中的线程互斥同步是并发编程中的一个重要概念，用于保证多个线程在访问共享资源时的互斥性，即同一时间只有一个线程能够访问某个资源。Java提供了多种机制来实现线程的互斥同步，主要包括以下几种方式：</p><h2 id="6-1-synchronized关键字"><a href="#6-1-synchronized关键字" class="headerlink" title="6.1 synchronized关键字"></a>6.1 synchronized关键字</h2><p><strong>1. 基本概念</strong>：synchronized是Java中最基本的同步机制，它可以用来修饰方法或代码块。当一个线程访问一个被synchronized修饰的方法或代码块时，其他试图访问该方法或代码块的线程将被阻塞，直到当前线程执行完毕释放锁。<br><strong>2. 使用方法</strong>：</p><ul><li>修饰方法：直接在方法声明上加上synchronized关键字，例如<code>public synchronized void method() &#123;...&#125;</code>。</li><li>修饰代码块：将需要同步的代码放在synchronized(对象) {…}中，这里的对象就是锁对象，例如<code>synchronized(this) &#123;...&#125;</code>或<code>synchronized(某个对象) &#123;...&#125;</code>。</li></ul><p><strong>3. 特性</strong>：</p><ul><li>可见性：synchronized不仅保证了互斥性，还保证了变量的可见性。当一个线程释放锁时，会将锁变量的值刷新到主存储器中，从而使其他线程可以看到最新的变量值。</li><li>可重入性：synchronized支持可重入性，即同一个线程可以多次获取同一个锁，而不会导致死锁。</li></ul><p><strong>4. 示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// synchronized修饰方法  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;  </span><br><span class="line">        count++;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> count;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSynchronized</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;  </span><br><span class="line">        <span class="type">Counter</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Counter</span>();  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;  </span><br><span class="line">                counter.increment();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;  </span><br><span class="line">                counter.increment();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">  </span><br><span class="line">        t1.start();  </span><br><span class="line">        t2.start();  </span><br><span class="line">  </span><br><span class="line">        t1.join();  </span><br><span class="line">        t2.join();  </span><br><span class="line">  </span><br><span class="line">        System.out.println(<span class="string">&quot;Final count: &quot;</span> + counter.getCount());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-2-ReentrantLock类"><a href="#6-2-ReentrantLock类" class="headerlink" title="6.2 ReentrantLock类"></a>6.2 ReentrantLock类</h2><ul><li><p><strong>基本概念</strong>：ReentrantLock是java.util.concurrent.locks包中的一个可重入锁，它提供了比synchronized更灵活的锁定机制。</p></li><li><p>使用方法</p><p>：</p><ul><li>创建锁对象：<code>ReentrantLock lock = new ReentrantLock();</code></li><li>加锁：<code>lock.lock();</code></li><li>释放锁：通常将释放锁的代码放在finally块中，以确保锁一定会被释放，例如<code>try &#123;...&#125; finally &#123; lock.unlock(); &#125;</code>。</li></ul></li><li><p>特性</p><p>：</p><ul><li>支持公平锁和非公平锁：通过构造器参数可以指定使用哪种锁，默认是非公平锁。</li><li>支持尝试获取锁：提供了<code>tryLock()</code>等方法，尝试获取锁，如果获取不到则不会阻塞线程。</li><li>支持中断锁定的线程：与synchronized不同，ReentrantLock的锁可以被中断。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CounterWithLock</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(); <span class="comment">// 创建ReentrantLock对象  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;  </span><br><span class="line">        lock.lock(); <span class="comment">// 加锁  </span></span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            count++;  </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">            lock.unlock(); <span class="comment">// 释放锁，放在finally块中确保一定会被释放  </span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;  </span><br><span class="line">        lock.lock(); <span class="comment">// 加锁  </span></span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="keyword">return</span> count;  </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">            lock.unlock(); <span class="comment">// 释放锁  </span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestReentrantLock</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;  </span><br><span class="line">        <span class="type">CounterWithLock</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CounterWithLock</span>();  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;  </span><br><span class="line">                counter.increment();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;  </span><br><span class="line">                counter.increment();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">  </span><br><span class="line">        t1.start();  </span><br><span class="line">        t2.start();  </span><br><span class="line">  </span><br><span class="line">        t1.join();  </span><br><span class="line">        t2.join();  </span><br><span class="line">  </span><br><span class="line">        System.out.println(<span class="string">&quot;Final count: &quot;</span> + counter.getCount());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-3-对比"><a href="#6-3-对比" class="headerlink" title="6.3 对比"></a>6.3 对比</h2><p>对于大多数简单场景，synchronized关键字是最直接、最简单的选择；而对于需要更灵活控制锁的场景，则可以考虑使用ReentrantLock等高级同步机制。</p><h1 id="7-线程协作（通信）方案"><a href="#7-线程协作（通信）方案" class="headerlink" title="7 线程协作（通信）方案"></a>7 线程协作（通信）方案</h1><p>Java中线程之间的协作主要可以通过多种机制实现，其中等待&#x2F;通知机制（<code>wait/notify/notifyAll</code>）和<code>join</code>方法是两种常用的方式。下面我将分别给出这两种方式的简单代码示例。</p><h2 id="7-1-等待-通知机制（wait-notify-notifyAll）"><a href="#7-1-等待-通知机制（wait-notify-notifyAll）" class="headerlink" title="7.1 等待&#x2F;通知机制（wait&#x2F;notify&#x2F;notifyAll）"></a>7.1 等待&#x2F;通知机制（wait&#x2F;notify&#x2F;notifyAll）</h2><p>等待&#x2F;通知机制依赖于Java中的<code>Object</code>类，因为<code>wait()</code>, <code>notify()</code>, 和 <code>notifyAll()</code> 方法都定义在<code>Object</code>类中。这些方法必须在同步块或同步方法中被调用，因为它们是用来控制对某个对象的访问的。</p><p><strong>示例代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitNotifyExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">ready</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doWait</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!ready) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.wait(); <span class="comment">// 当前线程等待</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt(); <span class="comment">// 保持中断状态</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当ready为true时，继续执行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doNotify</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            ready = <span class="literal">true</span>;</span><br><span class="line">            lock.notify(); <span class="comment">// 唤醒在此对象监视器上等待的单个线程</span></span><br><span class="line">            <span class="comment">// 或者使用 lock.notifyAll(); 唤醒所有等待的线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">WaitNotifyExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WaitNotifyExample</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread 1 is waiting&quot;</span>);</span><br><span class="line">            example.doWait();</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread 1 is proceeding&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>); <span class="comment">// 假设t2需要一些时间来完成准备工作</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread 2 is notifying&quot;</span>);</span><br><span class="line">            example.doNotify();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>t1</code>线程在<code>doWait()</code>方法中等待，直到<code>t2</code>线程调用<code>doNotify()</code>方法并设置<code>ready</code>为<code>true</code>。<code>t2</code>线程模拟了一些准备工作，并在之后唤醒<code>t1</code>。</p><h2 id="7-2-Join-方法"><a href="#7-2-Join-方法" class="headerlink" title="7.2 Join 方法"></a>7.2 Join 方法</h2><p><code>join</code>方法是<code>Thread</code>类的一个方法，用于让当前线程等待另一个线程完成其执行。</p><p><strong>示例代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JoinExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>); <span class="comment">// 假设t1执行需要一些时间</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread 1 completed&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t1.join(); <span class="comment">// 当前线程（main线程）等待t1完成</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Thread 1 has joined, continuing main thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>main</code>线程启动了一个新线程<code>t1</code>，并通过调用<code>t1.join()</code>等待<code>t1</code>完成。<code>t1</code>线程在完成后会打印一条消息，而<code>main</code>线程会在<code>t1</code>完成后继续执行并打印另一条消息。</p><h1 id="8-总结"><a href="#8-总结" class="headerlink" title="8 总结"></a>8 总结</h1><p>总结一下，我们讲了让如下内容</p><ol><li>线程流转状态</li><li>线程实现方式</li><li>线程基本操作</li><li>线程中断方案</li><li>线程互斥同步方法</li><li>线程协作（通信）方案</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java核心系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java核心 </tag>
            
            <tag> Java基础 </tag>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MQ系列1：消息中间件执行原理</title>
      <link href="/2025/03/22/MQ%E7%B3%BB%E5%88%971-%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/"/>
      <url>/2025/03/22/MQ%E7%B3%BB%E5%88%971-%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="1-关于消息中间件"><a href="#1-关于消息中间件" class="headerlink" title="1 关于消息中间件"></a>1 关于消息中间件</h1><h2 id="1-1-什么是消息中间件？"><a href="#1-1-什么是消息中间件？" class="headerlink" title="1.1 什么是消息中间件？"></a>1.1 什么是消息中间件？</h2><p>消息中间件是指在分布式系统中完成消息的发送和接收的基础软件。消息中间件也可以称消息队列（Message Queue &#x2F; MQ），用高效可靠的消息传递机制进行与平台无关的数据交流，并基于数据通信来进行分布式系统的集成。通过提供消息传递和消息队列模型，可以在分布式环境下扩展进程的通信。简而言之，互联网场景中经常使用消息中间件进行消息路由、订阅发布、异步处理等操作，来缓解系统的压力。</p><h2 id="1-2-它解决了我们哪些痛点？"><a href="#1-2-它解决了我们哪些痛点？" class="headerlink" title="1.2 它解决了我们哪些痛点？"></a>1.2 它解决了我们哪些痛点？</h2><p>1、<strong>解耦：</strong> 比如说系统A会交给系统B去处理一些事情，但是A不想直接跟B有关联，避免耦合太强，就可以通过在A，B中间加入消息队列，A将要任务的事情交给消息队列 ,B订阅消息队列来执行任务。</p><blockquote><p>这种场景很常见，比如A是订单系统，B是库存系统，可以通过消息队列把削减库存的工作交予B系统去处理。如果A系统同时想让B、C、D…多个系统处理问题的时候，这种优势就更加明显了。</p></blockquote><p>2、<strong>有序性：</strong> 先进先出原理，先来先处理，比如一个系统处理某件事需要很长一段时间，但是在处理这件事情时候，有其他人也发出了请求，可以把请求放在消息队里，一个一个来处理。</p><blockquote><p>对数据的顺序性和一致性有强需求的业务，比如同一张银行卡同时被多个入口使用，需要保证入账出账的顺序性，避免出现数据不一致。</p></blockquote><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAObaUYFJLQ7pjsv_wjaQZJkTuTV9YYAAkcLaxvRfjBWuagVQAkXvcABAAMCAAN4AAM2BA.png" alt="image"></p><p>3、<strong>消息路由：</strong> 按照不同的规则，将队列中消息发送到不同的其他队列中</p><blockquote><p>通过消息队列将不同染色的请求发送到不同的服务去操作。这样达成了流量按照业务拆分的目的。</p></blockquote><p>4、<strong>异步处理：</strong> 处理一项任务的时候，有3个步骤A、B、C，需要先完成A操作, 然后做B、C 操作。任务执行成功与否强依赖A的结果，但不依赖B、C 的结果。如果我们使用串行的执行方式，那处理任务的周期就会变长，系统的整体吞吐能力也会降低（在同一个系统中做异步其实也是比较大的开销），所以使用消息队列是比较好的办法。</p><blockquote><p>登录操作就是典型的场景：A：执行登录并得到结果、B：记录登录日志、C：将用户信息和Token写入缓存。 执行完A就可以从登录页跳到首页了，B、C让服务慢慢去消化，不阻塞当前操作。</p></blockquote><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAOcaUYF3hhpBJCSvYLoNydEDNNgk7gAAkgLaxvRfjBWcos2dsS1RTsBAAMCAAN4AAM2BA.png" alt="image"></p><p>5、<strong>削峰：</strong> 将峰值期间的操作削减，比如A同学的整个操作流程包含12个步骤，后续的11个步骤是不需要强关注结果的数据，可以放在消息队列中。</p><h1 id="2-消息中间件的执行原理"><a href="#2-消息中间件的执行原理" class="headerlink" title="2 消息中间件的执行原理"></a>2 消息中间件的执行原理</h1><h2 id="2-1-消息中间件的组成"><a href="#2-1-消息中间件的组成" class="headerlink" title="2.1 消息中间件的组成"></a>2.1 消息中间件的组成</h2><ul><li><strong>Broker：</strong> 消息服务器，作为Server提供消息核心服务</li><li><strong>Producer：</strong> 消息生产者，业务的发起方，负责生产消息传输给broker，</li><li><strong>Consumer：</strong> 消息消费者，业务的处理方，负责从broker获取消息并进行业务逻辑处理</li><li><strong>Topic：</strong> 主题，发布&#x2F;订阅模式下的消息统一汇集地，不同生产者向topic发送消息，由MQ服务器分发到不同的订阅者，实现消息的广播</li><li><strong>Queue：</strong> 队列，PTP模式下，特定生产者向特定queue发送消息，消费者订阅特定的queue完成指定消息的接收</li><li><strong>Message：</strong> 消息体，根据不同通信协议定义的固定格式进行编码的数据包，来封装业务数据，实现消息的传输</li></ul><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAOdaUYGc99pOnZuhSaO9erCk8pIDeMAAkkLaxvRfjBW10jlP04Fyd0BAAMCAAN4AAM2BA.png" alt="image"><br>这边以kafka为例子，这是典型的集群模式，Kafka通过Zookeeper管理集群配置，选举leader，以及在Consumer Group发生变化时进行rebalance。Producer使用push模式将消息发布到broker，Consumer使用pull模式从broker订阅并消费消息。</p><ul><li><strong>producer</strong> 负责生产消息</li><li><strong>consumer</strong> 负责消费消息</li><li><strong>broker</strong> 消息服务器，提供消息核心的处理工作</li><li><strong>zookeeper</strong> 用于生产者和消费者的注册与发现</li></ul><h2 id="2-2-消息中间件的模式分类"><a href="#2-2-消息中间件的模式分类" class="headerlink" title="2.2 消息中间件的模式分类"></a>2.2 消息中间件的模式分类</h2><h3 id="2-2-1-PTP点对点"><a href="#2-2-1-PTP点对点" class="headerlink" title="2.2.1 PTP点对点"></a>2.2.1 PTP点对点</h3><p>使用queue作为通信载体，消息生产者生产消息发送到queue中，然后消息消费者从queue中取出并且消费消息。消息被消费以后，queue中不再存储，所以消息消费者不可能消费到已经被消费的消息。 Queue支持存在多个消费者，但是对一个消息而言，只会有一个消费者可以消费。<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAOeaUYGhAWXlrbyHRPNw_QEDewk5mUAAkoLaxvRfjBWUaEvDZIELJMBAAMCAAN4AAM2BA.png" alt="image"><br><strong>点对点模式包含三个角色：</strong></p><ul><li>消息队列（Queue）</li><li>发送者(Sender)</li><li>接收者(Receiver)</li></ul><p>每个消息都被发送到一个特定的队列，接收者从队列中获取消息。队列保留着消息，可以放在内存 中也可以持久化，直到他们被消费或超时。</p><p><strong>特点：</strong></p><ul><li>每个消息只有一个消费者（Consumer）(即一旦被消费，消息就不再在消息队列中)</li><li>发送者和接收者之间在时间上没有依赖性</li><li>接收者在成功接收消息之后需向队列应答成功</li><li>利用FIFO先进先出的特性，可以保证消息的顺序性。</li></ul><h3 id="2-2-2-Pub-Sub发布订阅（广播）"><a href="#2-2-2-Pub-Sub发布订阅（广播）" class="headerlink" title="2.2.2 Pub&#x2F;Sub发布订阅（广播）"></a>2.2.2 Pub&#x2F;Sub发布订阅（广播）</h3><p>使用topic作为通信载体，消息生产者（发布）将消息发布到topic中，同时有多个消息消费者（订阅）消费该消息。和点对点方式不同，发布到topic的消息会被所有订阅者消费。queue实现了负载均衡，将producer生产的消息发送到消息队列中，由多个消费者消费。但一个消息只能被一个消费者接受，当没有消费者可用时，这个消息会被保存直到有一个可用的消费者。<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAOfaUYGl4tpXVUOCO8GCYZtIPP5nYMAAksLaxvRfjBWwtPeSF0tmvwBAAMCAAN4AAM2BA.png" alt="image"><br><strong>发布订阅模型包含三个角色：</strong></p><ul><li>主题（Topic）</li><li>发布者（Publisher）</li><li>订阅者（Subscriber）</li></ul><p>多个发布者将消息发送到Topic，系统将这些消息传递给多个订阅者。</p><p><strong>特点：</strong></p><ul><li>每个消息可以有多个消费者：和点对点方式不同，发布消息可以被所有订阅者消费</li><li>发布者和订阅者之间有时间上的依赖性。</li><li>针对某个主题（Topic）的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息。</li><li>为了消费消息，订阅者必须保持运行的状态。</li></ul><h2 id="2-3-消息中间件的优势"><a href="#2-3-消息中间件的优势" class="headerlink" title="2.3 消息中间件的优势"></a>2.3 消息中间件的优势</h2><p>系统解耦：交互系统之间没有直接的调用关系，只是通过消息传输，故系统侵入性不强，耦合度低。提高系统响应时间：例如原来的一套逻辑，可将紧急重要（需要立刻响应）的业务放到该调用方法中，响应要求不高的使用消息队列，放到MQ队列中，供消费者处理。为大数据处理架构提供服务：通过消息作为整合，大数据的背景下，消息队列还与实时处理架构整合，为数据处理提供性能支持。</p><h2 id="2-4-消息中间件常用协议"><a href="#2-4-消息中间件常用协议" class="headerlink" title="2.4 消息中间件常用协议"></a>2.4 消息中间件常用协议</h2><p>AMQP协议、MQTT协议、STOMP协议、XMPP协议、其他基于TCP&#x2F;IP自定义的协议消息中间件的组成</p><h3 id="2-4-1-AMQP"><a href="#2-4-1-AMQP" class="headerlink" title="2.4.1 AMQP"></a>2.4.1 AMQP</h3><p>AMQP即Advanced Message Queuing Protocol，是应用层协议的一个开放标准，为面向消息的中间件设计。消息中间件主要用于组件之间的解耦，消息的发送者无需知道消息使用者的存在，反之亦然。</p><p>AMQP 的主要特征是面向消息、队列、路由（包括点对点和发布&#x2F;订阅）、可靠性、安全。优点：可靠、通用。</p><h3 id="2-4-2-MQTT"><a href="#2-4-2-MQTT" class="headerlink" title="2.4.2 MQTT"></a>2.4.2 MQTT</h3><p>MQTT（Message Queuing Telemetry Transport，消息队列遥测传输）是IBM开发的一个即时通讯协议，有可能成为物联网的重要组成部分。该协议支持所有平台，几乎可以把所有联网物品和外部连接起来，被用来当做传感器和致动器（比如通过Twitter让房屋联网）的通信协议。优点：格式简洁、占用带宽小、移动端通信、PUSH、嵌入式系统。</p><h3 id="2-4-3-STOMP"><a href="#2-4-3-STOMP" class="headerlink" title="2.4.3 STOMP"></a>2.4.3 STOMP</h3><p>STOMP（Streaming Text Orientated Message Protocol）是流文本定向消息协议，是一种为MOM(Message Oriented Middleware，面向消息的中间件)设计的简单文本协议。STOMP提供一个可互操作的连接格式，允许客户端与任意STOMP消息代理（Broker）进行交互。优点：命令模式（非topic\queue模式）。</p><h3 id="2-4-4-XMPP"><a href="#2-4-4-XMPP" class="headerlink" title="2.4.4 XMPP"></a>2.4.4 XMPP</h3><p>XMPP（可扩展消息处理现场协议，Extensible Messaging and Presence Protocol）是基于可扩展标记语言（XML）的协议，多用于即时消息（IM）以及在线现场探测。适用于服务器之间的准即时操作。核心是基于XML流传输，这个协议可能最终允许因特网用户向因特网上的其他任何人发送即时消息，即使其操作系统和浏览器不同。优点：通用公开、兼容性强、可扩展、安全性高，但XML编码格式占用带宽大。</p><h2 id="2-5-主流的消息中间件"><a href="#2-5-主流的消息中间件" class="headerlink" title="2.5 主流的消息中间件"></a>2.5 主流的消息中间件</h2><p>常见的消息中间件包括：RabbitMQ、RocketMQ、kafka 等，后面我们会有一篇专门对这几种中间件的能力和技术参数做一项完整的对比，并给出不同业务场景下的技术选型建议。</p>]]></content>
      
      
      <categories>
          
          <category> MQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
            <tag> RabbitMQ </tag>
            
            <tag> RocketMQ </tag>
            
            <tag> kafka </tag>
            
            <tag> 消息中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MQ系列2：消息中间件的技术选型</title>
      <link href="/2025/03/22/MQ%E7%B3%BB%E5%88%972-%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/"/>
      <url>/2025/03/22/MQ%E7%B3%BB%E5%88%972-%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 背景</h1><p>在高并发、高消息吞吐的互联网场景中，我们经常会使用消息队列（Message Queue）作为基础设施，在服务端架构中担当消息中转、消息削峰、事务异步处理 等职能。</p><p>对于那些不需要实时响应的的业务，我们都可以放在消息队列中进行传输。下面是用户在进行系统注册的时候场景，充分体现MQ的作用</p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAOkaUYXIKdHP4S4Rn-G0tyLfxGu8tsAAmgLaxvRfjBWoOG_jBZSoEABAAMCAAN4AAM2BA.png"></p><p>可以看到用户注册的过程步骤1+步骤2，从请求到响应总共耗时 55 ms。消息消费+短信发送的时间比较长，从上面看花了5s多，一般让消息队列服务去处理，用户静静等待短信送达即可。</p><p>消息队列中间件（简称消息中间件）是指利用高效可靠的消息传递机制进行与平台无关的数据交流，并基于数据通信来进行分布式系统的集成。通过提供消息传递和消息排队模型，它可以在分布式环境下提供应用解耦、</p><p>弹性伸缩、冗余存储、流量削峰、异步通信、数据同步等等功能，其作为分布式系统架构中的一个重要组件，有着举足轻重的地位。</p><h1 id="2-消息中间件的组成"><a href="#2-消息中间件的组成" class="headerlink" title="2 消息中间件的组成"></a>2 消息中间件的组成</h1><ul><li><strong>Broker</strong>：消息服务器，以服务的形式运行在server端，给各个业务系统提供核心消息数据的中转服务。</li><li><strong>Producer</strong>：消息生产者，业务的发起方，负责生产消息传输给broker。</li><li><strong>Consumer</strong>：消息消费者，业务的处理方，负责从broker获取消息并进行业务逻辑处理</li><li><strong>Topic</strong>：主题模块，发布&#x2F;订阅模式下的消息统一汇集地，不同生产者向topic发送消息，由MQ服务器分发到不同的订阅者，实现消息的广播</li><li><strong>Queue</strong>：队列，PTP模式下，特定生产者向特定queue发送消息，消费者订阅特定的queue完成指定消息的接收。</li><li><strong>Message</strong>：消息体，根据不同通信协议定义的固定格式进行编码的数据包，来封装业务数据，实现消息的传输。</li></ul><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAOlaUYXKjClRSGkqaaP9RxK7q8ZhygAAmkLaxvRfjBWR4AgghyTq_EBAAMCAAN4AAM2BA.png" alt="消息中间件的组成部分"></p><p> 这边以kafka为例子，这是典型的集群模式，Kafka通过Zookeeper管理集群配置，选举leader，以及在Consumer Group发生变化时进行rebalance。Producer使用push模式将消息发布到broker，Consumer使用pull模式从broker订阅并消费消息。</p><ul><li><strong>producer</strong> 负责生产消息</li><li><strong>consumer</strong> 负责消费消息</li><li><strong>broker</strong> 消息服务器，提供消息核心的处理工作</li><li><strong>zookeeper</strong> 用于生产者和消费者的注册与发现</li></ul><h1 id="3-消息中间件的模式分类"><a href="#3-消息中间件的模式分类" class="headerlink" title="3 消息中间件的模式分类"></a>3 消息中间件的模式分类</h1><p>PTP点对点：使用queue作为通信载体 </p><p>消息生产者生产消息发送到queue中，然后消息消费者从queue中取出并且消费消息。 </p><p>不可重复消费，消息被消费以后，queue中不再存储，所以消息消费者不可能消费到已经被消费的消息。 Queue支持存在多个消费者，但是对一个消息而言，只会有一个消费者可以消费。</p><p>Pub&#x2F;Sub发布订阅（广播）：使用topic作为通信载体 </p><p>消息生产者（发布）将消息发布到topic中，同时有多个消息消费者（订阅）消费该消息。和点对点方式不同，发布到topic的消息会被所有订阅者消费，所以从1到N个订阅者都能得到这个消息的拷贝。</p><h1 id="4-消息中间件的优势"><a href="#4-消息中间件的优势" class="headerlink" title="4 消息中间件的优势"></a>4 消息中间件的优势</h1><p>系统解耦：交互系统之间没有直接的调用关系，只是通过消息传输，故系统侵入性不强，耦合度低。</p><p>削峰、提高系统响应时间：例如原来的一套逻辑，可将紧急重要（需要立刻响应）的业务放到该调用方法中，响应要求不高的使用消息队列，放到MQ队列中，供消费者处理。</p><p>业务的有序性处理：先来先处理，比如一个系统处理某件事需要很长一段时间，但是在处理这件事情时候，有其他人也发出了请求，可以把请求放在消息队里，一个一个来处理</p><p>为大数据处理架构提供服务：通过消息作为整合，大数据的背景下，消息队列还与实时处理架构整合，为数据处理提供性能支持。 </p><h1 id="5-消息中间件常用协议"><a href="#5-消息中间件常用协议" class="headerlink" title="5 消息中间件常用协议"></a>5 消息中间件常用协议</h1><p>AMQP协议、MQTT协议、STOMP协议、XMPP协议、其他基于TCP&#x2F;IP自定义的协议。</p><h1 id="6-丰富强大的消息中间件生态"><a href="#6-丰富强大的消息中间件生态" class="headerlink" title="6 丰富强大的消息中间件生态"></a>6 丰富强大的消息中间件生态</h1><p>目前开源的消息中间还是很丰富的，大家用的比较多的比如 ActiveMQ、RabbitMQ、Kafka、RocketMQ、ZeroMQ 等。</p><p>但是每个人的业务场景不一样，受限于系统的规模，业务的取舍（如延迟容忍度，死信、重试的需求，可持久化需求），并不是每一款消息中间件都能满足你的需求。</p><p>除了个别大厂会进行自研（如 阿里的Rocket MQ、滴滴的DD MQ）之外，大部分同学还是要对选型有一些思考的。各自都有各自的侧重点，选择合适自己、扬长避短无疑是最好的方式。</p><h2 id="6-1-主流MQ介绍"><a href="#6-1-主流MQ介绍" class="headerlink" title="6.1 主流MQ介绍"></a>6.1 主流MQ介绍</h2><p>下面基于受众程度，对三款主流的MQ做介绍，通过各项指标上的对比，给出我们在实际应用场景中的建议。</p><p><strong>RabbitMQ：</strong></p><p>采用 Erlang 语言实现的 AMQP 协议的消息中间件，起源于金融系统，广泛应用在分布式系统中，承担消息转发的职责。RabbitMQ 发展历史比较久远，影响范围比较大，被很多开发者认可，在可靠性、可用性、可扩展性、功能性方面有着非凡表现。</p><p><strong>RocketMQ：</strong></p><p>阿里开源的消息中间件，目前已经捐献给 Apache 基金会，它是由 Java 语言开发的，具备高吞吐量、高可用性、适合大规模分布式系统应用等特点。并且在阿里的双11、618等重要活动中经受住了考验。</p><p><strong>Kafka：</strong></p><p>起初是由 LinkedIn 公司采用 Scala 语言开发的一个分布式、多分区、多副本且基于 zookeeper 协调的分布式消息系统，现已捐献给 Apache 基金会。它是一种高吞吐量的分布式发布订阅消息系统，以可水平扩展和高吞吐率而被广泛使用。</p><p>目前越来越多的开源分布式处理系统如 Cloudera、Apache Storm、Spark、Flink 等都支持与 Kafka 集成。</p><h2 id="6-2-主流MQ对比"><a href="#6-2-主流MQ对比" class="headerlink" title="6.2 主流MQ对比"></a>6.2 主流MQ对比</h2><table><thead><tr><th><strong>特性</strong></th><th><strong>RabbitMQ</strong></th><th><strong>RocketMQ</strong></th><th><strong>kafka</strong></th></tr></thead><tbody><tr><td><strong>开发语言</strong></td><td>erlang</td><td>java</td><td>scala</td></tr><tr><td><strong>支持协议</strong></td><td>AMQP</td><td>自定义</td><td>基于TCP 自定义</td></tr><tr><td><strong>消息存储能力</strong></td><td>内存、磁盘。支持少量堆积。</td><td>磁盘。支持大量堆积。</td><td>内存、磁盘、数据库。支持大量堆积。</td></tr><tr><td><strong>消息事务性</strong></td><td>支持（信道设置事务模式，性能有影响）</td><td>支持</td><td>支持</td></tr><tr><td><strong>单机吞吐量</strong></td><td>万级</td><td>10万级+</td><td>10万级+</td></tr><tr><td><strong>时效性</strong></td><td>us级</td><td>ms级</td><td>ms级以内</td></tr><tr><td><strong>消息重复</strong></td><td>支持at least once、at most once</td><td>支持at least once</td><td>支持at least once、at most once</td></tr><tr><td><strong>消息回溯</strong></td><td>不支持</td><td>支持指定时间点的回溯</td><td>支持指定分区offset位置的回溯</td></tr><tr><td><strong>消息重试</strong></td><td>不支持，但可以设置autoACK&#x3D;false,未收到确认的会重入队列</td><td>支持</td><td>不支持，但可以通过消息回溯的方式来实现</td></tr><tr><td><strong>可用性</strong></td><td>高(主从架构)</td><td>非常高(分布式架构)</td><td>非常高(分布式架构)</td></tr><tr><td><strong>功能特性说明</strong></td><td>基于erlang开发，所以并发能力很强，性能极其好，延时很低;管理界面较丰富</td><td>MQ功能比较完备，扩展性佳</td><td>只支持主要的MQ功能，像一些消息查询，消息回溯等功能支持的不是很强，在大数据领域应用广。</td></tr></tbody></table><h2 id="6-3-选型建议"><a href="#6-3-选型建议" class="headerlink" title="6.3 选型建议"></a>6.3 选型建议</h2><h3 id="6-3-1-系统建设规模角度"><a href="#6-3-1-系统建设规模角度" class="headerlink" title="6.3.1 系统建设规模角度"></a>6.3.1 系统建设规模角度</h3><p>中小型系统建议选用RabbitMQ，数据量相对较小，选型应首选功能比较完备的，所以kafka排除。RocketMQ是阿里出品，如果阿里放弃维护，中小型公司一般很难投入人力进行RocketMQ的定制化开发，因此不推荐。</p><h3 id="6-3-2-业务规模角度"><a href="#6-3-2-业务规模角度" class="headerlink" title="6.3.2 业务规模角度"></a>6.3.2 业务规模角度</h3><p>根据具体使用规模在RocketMQ和kafka之间二选一。</p><p>大型业务系统：有实际的业务体量需求，比如足够大规模的分布式环境，以及足够大的数据量。这时候 RocketMQ 和 kafka 都是10w+的吞吐量，都可以在考虑范围内。</p><p>如果你有业务定制需求，可以优先选用RocketMQ，毕竟是开源的，大的业务系统也愿意花精力去优化JAVA源码的。至于kafka，根据业务方向选择，类似日志采集功能，首选kafka，因为他在日志上报、监控数据采集方面有着大规模的实践经验，这也是他们主打的应用场景。</p><p>具体该选哪个，看使用场景。引入MQ之后，也会有一定的弊端，必然一定程度上降低系统可用性，增加复杂性。</p><h3 id="6-3-3-功能性层面选型"><a href="#6-3-3-功能性层面选型" class="headerlink" title="6.3.3 功能性层面选型"></a>6.3.3 功能性层面选型</h3><table><thead><tr><th><strong>功能项</strong></th><th><strong>Kafka（1.1.0+）</strong></th><th><strong>RabbitMQ（3.6.10+）</strong></th></tr></thead><tbody><tr><td><strong>优先级队列</strong></td><td>不支持</td><td>支持：具有优先被消费的特权，建议优先级大小设置在10以内，否则价值不大</td></tr><tr><td><strong>延迟队列</strong></td><td>不支持</td><td>支持</td></tr><tr><td><strong>死信队列</strong></td><td>不支持</td><td>支持：保存无法被正确投递的消息，避免消息被无端丢弃。</td></tr><tr><td><strong>重试模式</strong></td><td>不支持</td><td>不支持：RabbitMQ中可以参考延迟队列实现一个重试队列，需要再封装一下，也不是太难。如果要在kafka中实现重试队列，首先要实现延迟队列的功能，相对比较复杂。</td></tr><tr><td><strong>消费模式</strong></td><td>拉 模式</td><td>推+拉 模式</td></tr><tr><td><strong>广播消费（pub&#x2F;sub）</strong></td><td>支持：kafka对广播消费的支持比较强大</td><td>支持：能力相比较kafka 弱一些</td></tr><tr><td><strong>消息回溯</strong></td><td>支持：kafka可以按照 offset（偏移量）和 timestamp（时间戳） 两种维度进行消息回溯。</td><td>不支持：RabbitMQ消息一旦被确认消费便丢弃</td></tr><tr><td><strong>消息堆积</strong></td><td>支持</td><td>支持：内存堆积过大会影响性能，如果仅考虑吞吐量因素，kafka的堆积效率比RabbitMQ总体高很多。</td></tr><tr><td><strong>持久化</strong></td><td>支持</td><td>支持</td></tr><tr><td><strong>消息追踪</strong></td><td>不支持：消息追踪可以通过外部系统来支持，但是支持粒度肯定没有内置的细腻</td><td>支持：RabbitMQ中可以采用Firehose 或者 rabbitmq_tracing插件实现。开启rabbitmq_tracing插件会大幅度影响性能，不建议在生产环境启用。使用 Firehose 与 外部 trace 系统结合的模式来提供更稳健的消息追踪能力。</td></tr><tr><td><strong>消息过滤</strong></td><td>客户端级别的支持</td><td>不支持，可以定制化封装</td></tr><tr><td><strong>多租户</strong></td><td>不支持</td><td>支持</td></tr><tr><td><strong>多协议支持</strong></td><td>只支持自定义协议，目前几个主流版本中存在兼容性问题。</td><td>RabbitMQ本身就是AMQP协议的实现，同时支持MQTT、STOMP等协议</td></tr><tr><td><strong>跨语言支持</strong></td><td>采用Scala和Java编写，支持多种语言的客户端</td><td>采用Erlang编写，支持多种语言的客户端</td></tr><tr><td><strong>流量控制</strong></td><td>支持client和user级别，可将流控配置在生产者和消费者层面</td><td>RabbitMQ的流控基于 Credit-Based 算法，是内部被动触发的保护机制，仅用于生产者层面。</td></tr><tr><td><strong>消息顺序性</strong></td><td>支持单分区（partition）级别的顺序性，在各自的分区中排序</td><td>顺序性消费的条件比较苛刻，需要单线程发送、单线程消费，这样吞吐量就下来了。而且无法使用延迟队列、优先队列等一些高级功能，所以一般不使用。</td></tr><tr><td><strong>安全机制</strong></td><td>（TLS&#x2F;SSL、SASL）身份认证和（读&#x2F;写）权限控制</td><td>与kafka相似</td></tr><tr><td><strong>幂等性</strong></td><td>单个生产者+单partition + 单会话 场景下，支持幂等性</td><td>不支持</td></tr><tr><td><strong>事务性消息</strong></td><td>支持</td><td>支持</td></tr></tbody></table><ul><li><p>**优先级队列：**可配置优先级，优先级高的消息具备优先被消费的特权，这样可以为下游服务提供不同消息级别的保证。这种模式只是在生产效率高于消费效率的时候才有效果。如果消费者的消费速度大于生产者的速度，消息中间件服务器（Broker）中没有消息堆积，就不存在对待消费数据进行优先级排序的需求了。</p></li><li><p><strong>延迟队列：</strong></p><p>延迟队列会存储对应的延迟消息，延迟消息是指消息被生产后，并不马上消费，而是等待一定时间后，消费者才拿到消息进行消费。延迟队列的模式分为两种，基于消息的延迟和基于队列的延迟。</p><ul><li>基于消息的延迟是指为每条消息设置不同的延迟时间，那么每当队列中有新消息进入的时候就会重新根据延迟时间排序，但是这会对性能造成很大的影响。</li><li>基于队列的延迟，设置不同延迟级别的队列，如 15s、30s、1m、10m 等，每个队列中消息的延迟时间都是相同的，这样不需要消耗大量性能去做延迟时间排序，每个消息都有固定的投递时间。</li></ul></li><li><p>**死信队列：**由于某些原因消息无法被正确的投递，为了确保消息不会被无故的丢弃，一般会存储到一个特殊的队列中，我们称之为死信队列。与此对应的还有一个“回退队列”的概念，试想如果消费者在消费时发生了异常，那么就不会对这一次消费进行确认（Ack）, 进而发生回滚消息的操作之后消息始终会放在队列的顶部，然后不断被处理和回滚，导致队列陷入死循环。为了解决这个问题，可以为每个队列设置一个回退队列，它和死信队列都是为异常的处理提供的一种机制保障。实际情况下，回退队列的角色可以由死信队列和重试队列来扮演。 </p></li><li><p>**重试队列：**重试队列其实可以看成是一种回退队列，具体指消费端消费消息失败时，为防止消息无故丢失而重新将消息回滚到 Broker 中。与回退队列不同的是重试队列一般分成多个重试等级，每个重试等级一般也会设置重新投递延时，重试次数越多投递延时就越大。比如第一次重试延迟时间为5s，再次消费失败后延迟重试时间为10s，以此类推，重试越多次重新投递的时间就越久。为了避免延迟时间被无限放大，需要有个重试次数限制，超过就写入死信队列。这边需要注意：延迟队列动作由内部触发，重试队列动作由外部消费端触发。 </p></li><li><p>**消费模式：**消费模式分为推（push）模式和拉（pull）模式。推模式是指由 Broker 主动推送消息至消费端，实时性较好，不过需要保证服务端推送的消息不会严重超过消费端消化能力。而拉模式是指消费端定时定量主动向 Broker 端请求拉取消息，虽然实时性较差，但是可以根据自身的消费能力来拉取。</p></li><li><p>**广播消费：**消息一般有两种发送模式：</p><ul><li><strong>点对点</strong>（P2P，Point-to-Point）模式和发布&#x2F;订阅（Pub&#x2F;Sub）模式。对于P2P模式而言，消息被消费以后，队列中不会再存储，即使有多个消费者，一条消息只会被一个消费者消费。</li><li>而发布订阅（Pub&#x2F;Sub）模式定义了如何向一个内容节点发布和订阅消息，这个内容节点称为主题（topic），主题可以认为是消息传递的中介，消息发布者将消息发布到某个主题，而消息订阅者则从主题中订阅消息。主题使得消息的订阅者与消息的发布者互相保持独立，不需要进行接触即可保证消息的传递，发布 &#x2F; 订阅模式在消息的一对多广播时采用。RabbitMQ 是一种典型的点对点模式，而 Kafka 是一种典型的发布订阅模式。</li></ul></li><li><p>**消息回溯：**一般消息在消费完成之后就被处理了，之后再也不能消费到该条消息。消息回溯正好相反，是指消息在消费完成之后，还能追溯到之前被消费掉的消息。</p></li><li><p>**消息堆积 + 持久化：**进行流量的削峰填谷是消息中间件的一个核心功能，实现的能力主要体现在消息堆积能力上。消息堆积分内存式堆积和磁盘式堆积。RabbitMQ 是典型的内存式堆积，可以通过一些方式持久化到磁盘中，但是会降低一些性能。Kafka 是典型的磁盘式堆积，所有的消息都存储在磁盘中，存储容量是有了很大的提升，但是磁盘性能会比内存差很多。</p></li><li><p>**消息追踪：**在消息中间件中，消息的链路追踪非常重要，它可以对生产和消费过的消息进行trace追踪。这样，在出现故障的时候，就可以快速的定位问题。</p></li><li><p>**消息过滤：**消息过滤是指按照既定的过滤规则为下游用户提供指定类别的消息。就以 kafka 而言，完全可以将不同类别的消息发送至不同的 topic 中，由此可以实现某种意义的消息过滤，或者 Kafka 还可以根据分区对同一个 topic 中的消息进行分类。不过更加严格意义上的消息过滤应该是对既定的消息采取一定的方式按照一定的过滤规则进行过滤。同样以 Kafka 为例，可以通过客户端提供的 ConsumerInterceptor 接口或者 Kafka Stream 的 filter 功能进行消息过滤。</p></li><li><p>**流量控制：**flow control，当生产者和消费者 处理速度不均衡问题，通过对生产者和消费者的限流，来保障两者的均衡。通常的流控方法有 Stop-and-wait、滑动窗口以及令牌桶等。</p></li><li><p>**消息顺序性：**顺序性是指保证消息有序，特别是分布式场景下，有序的执行，是保证一致性 (Consistency)的前提。</p></li><li><p>**消息幂等性：**对于确保消息在生产者和消费者之间进行传输而言一般有三种传输保障（delivery guarantee）：At most once，至多一次，消息可能丢失，但绝不会重复传输；At least once，至少一次，消息绝不会丢，但是可能会重复；Exactly once，精确一次，每条消息肯定会被传输一次且仅一次。对于大多数消息中间件而言，一般只提供 At most once 和 At least once 两种传输保障，对于第三种一般很难做到，由此消息幂等性也很难保证。</p></li><li><p>**事务性消息：**原子性事务中的操作为一个整体，要么都做，要么都不做。即一旦出错，就回滚事务，事务是由事务开始（Begin Transaction）和事务结束（End Transaction）之间执行的全体操作组成。Kafka 和 RabbitMQ 都支持，不过仅仅指的是生产者发送消息是一个事务性操作，要么发送成功，要么发送失败。</p></li></ul><h3 id="6-3-4-性能层面"><a href="#6-3-4-性能层面" class="headerlink" title="6.3.4 性能层面"></a>6.3.4 性能层面</h3><p>功能维度是消息中间件选型中的一个重要的参考维度，但性能也是考虑的一个重要环节。</p><p>吞吐量角度：Kafka 在开启幂等、事务功能的时候会使其性能降低，RabbitMQ 在开启 rabbitmq_tracing 插件的时候也会极大的影响其性能。消息中间件的性能一般是指其吞吐量，虽然从功能维度上来说，RabbitMQ 的优势要大于 Kafka，但是 Kafka 的吞吐量要比 RabbitMQ 高出 1 至 2 个数量级，一般 RabbitMQ 的单机 QPS 在万级别之内，而 Kafka 的单机 QPS 可以维持在十万级别，甚至可以达到百万级。</p><p>时延角度：另外一个是时延，作为性能维度的一个重要指标，却往往在消息中间件领域所被忽视，因为一般使用消息中间件的场景对时效性的要求并不是很高，如果要求时效性完全可以采用 RPC 的方式实现。消息中间件具备消息堆积的能力。Kafka是ms以内，RabbitMQ是us级别的。 </p><h3 id="6-3-5-高可用角度"><a href="#6-3-5-高可用角度" class="headerlink" title="6.3.5 高可用角度"></a>6.3.5 高可用角度</h3><p>高可用角度是指系统的出错概率和无故障运行时长。</p><p>如消息丢失，是使用消息中间件时所不得不面对的一个同点，其背后消息可靠性也是衡量消息中间件好坏的一个关键因素。尤其是在金融支付领域，消息可靠性尤为重要。然而说到可靠性必然要说到可用性，注意这两者之间的区别，消息中间件的可靠性是指对消息不丢失的保障程度；</p><p>而消息中间件的可用性是指无故障运行的时间百分比，通常用几个 9 来衡量，如 99.99% 就是一个不错的指标。</p><p>对应的 RabbitMQ 是通过镜像环形队列实现多副本及强一致性语义的。多副本可以保证在 master 节点宕机异常之后可以提升 slave 作为新的 master 而继续提供服务来保障可用性。</p><h3 id="6-3-6-运维管理层面"><a href="#6-3-6-运维管理层面" class="headerlink" title="6.3.6 运维管理层面"></a>6.3.6 运维管理层面</h3><p>消息中间件一个很重要的考虑层面是运维管理，比如：申请、审核、监控、告警、管理、容灾、部署等。</p><p>对消息中间件的使用 从使用、接入规范、全方位的监控、流量统计和分析等方面，提供有效的基准数据，也可以在检测到异常的情况配合告警，以便运维、开发人员的迅速介入。除了一般的监控项（比如硬件、GC 等）之外，对于消息中间件还需要关注端到端时延、消息审计、消息堆积等方面。</p><p>对于 RabbitMQ 而言，最正统的监控管理工具莫过于 rabbitmq_management 插件了，另外还有 AppDynamics, Collectd, DataDog, Ganglia 等多种优秀的产品。</p><p>Kafka 丰富的管理工具，比如：Kafka Manager, Kafka Monitor, Kafka Offset Monitor 等产品，其中 Cruise 还可以提供自动化运维的功能。</p><h3 id="6-3-7-社区力度及生态发展"><a href="#6-3-7-社区力度及生态发展" class="headerlink" title="6.3.7 社区力度及生态发展"></a>6.3.7 社区力度及生态发展</h3><p>Kafka 和 RabbitMQ 都有一系列开源的监控管理产品，社区活跃，产品生态都很不错。</p>]]></content>
      
      
      <categories>
          
          <category> MQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
            <tag> RabbitMQ </tag>
            
            <tag> RocketMQ </tag>
            
            <tag> kafka </tag>
            
            <tag> 消息中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis系列：聊聊布隆过滤器</title>
      <link href="/2025/03/20/Redis%E7%B3%BB%E5%88%97-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
      <url>/2025/03/20/Redis%E7%B3%BB%E5%88%97-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h1><p>布隆过滤器（Bloom Filter）是 Redis 4.0 版本之后提供的新功能，我们一般将它当做插件加载到 Redis Service服务器中，给 Redis 提供强大的滤重功能。</p><p>它是一种概率性数据结构，可用于判断一个元素是否存在于一个集合中。相比较之 Set 集合的去重功能，布隆过滤器空间上能节省90% +，不足之处是去重率大约在 99% 左右，那就是有 1% 左右的误判率，这种误差是由布隆过滤器的自身结构决定的。它有如下优缺点：</p><ul><li>优点：空间效率和查询时间都比一般的算法要好的多</li><li>缺点：有一定的误识别率和删除困难</li></ul><p>详细的原理可以参考笔者的这一篇 《<a href="https://yeoh.de5.net/2025/03/20/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%8E%9F%E7%90%86/">聊聊布隆过滤器（原理） | 数根朽木，</a>》。</p><h1 id="2-应用场景说明"><a href="#2-应用场景说明" class="headerlink" title="2 应用场景说明"></a>2 应用场景说明</h1><p>我们在遇到数据量大的时候，为了去重并避免大批量的重复计算，可以考虑使用 Bloom Filter 进行过滤。<br>具体常用的经典场景如下：</p><ul><li>解决大流量下缓存穿透的问题，参考笔者这篇 《<a href="https://yeoh.de5.net/2025/03/20/%E7%94%9F%E4%BA%A7%E4%BA%8B%E6%95%85%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E9%9B%AA%E5%B4%A9%E7%9A%84%E7%81%BE%E9%9A%BE%E5%A4%8D%E7%9B%98/">生产事故记录-一次雪崩的灾难复盘-转载 | 数根朽木，</a>》。</li><li>过滤被屏蔽、拉黑、减少推荐的信息，一般你在浏览抖音或者百度App的时候，看到不喜欢的会设置减少推荐、屏蔽此类信息等，都可以采用这种原理设计。</li><li>各种名单过滤，使用布隆过滤器实现第一层的白名单或者黑名单过滤，可用于各种AB场景。</li></ul><p>下面以缓存穿透为解决目标进行案例介绍。</p><h1 id="3-案例分析"><a href="#3-案例分析" class="headerlink" title="3 案例分析"></a>3 案例分析</h1><p>布隆过滤器的一个经典应用场景就是解决缓存穿透问题!</p><blockquote><p>缓存穿透是指访问一个不存在的key，缓存不起作用，请求会穿透到DB，流量井喷时会导致DB挂掉。</p></blockquote><p>比如 我们查询用户的信息，程序会根据用户的编号去缓存中检索，如果找不到，再到数据库中搜索。如果你给了一个不存在的编号：XXXXXXXX，那么每次都比对不到，就透过缓存进入数据库。这样风险很大，如果因为某些原因导致大量不存在的编号被查询，甚至被恶意伪造编号进行大规模攻击，那将是灾难。</p><p>解决方案质疑就是在缓存之前在加一层 BloomFilter ：</p><ul><li>把存在的key记录在BloomFilter中，在查询的时候先去 BloomFilter 去查询 key 是否存在，如果不存在则说明数据库和缓存都没有，就直接返回，</li><li>存在再走查缓存 ，投入数据库去查询，这样减轻了数据库的压力。</li></ul><h2 id="3-1-巨量查询场景"><a href="#3-1-巨量查询场景" class="headerlink" title="3.1 巨量查询场景"></a>3.1 巨量查询场景</h2><p>下面以火车票订购和查询为案例进行说明，如果火车票被恶意攻击，模拟了一样结构的火车票订单编号，那很可能通过大量的请求穿透过缓存层把数据库打雪崩了，所以使用布隆过滤器为服务提供一层保障。具体的做法就是，我们在购买火车票成功的时候，把订单号的ID写入（异步或者消息队列的方式）到布隆过滤器中，保障后续的查询都在布隆过滤器中走一遍再进到缓存中去查询。</p><h2 id="3-2-创建Bloom-Filter"><a href="#3-2-创建Bloom-Filter" class="headerlink" title="3.2 创建Bloom Filter"></a>3.2 创建Bloom Filter</h2><p>创建 Bloom Filter 的语法如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># BF<span class="selector-class">.RESERVE</span> &#123;key&#125; &#123;error_rate&#125; &#123;capacity&#125; <span class="selector-attr">[EXPANSION &#123;expansion&#125;]</span> <span class="selector-attr">[NONSCALING]</span></span><br><span class="line">BF<span class="selector-class">.RESERVE</span> ticket_orders <span class="number">0.01</span> <span class="number">1000000</span></span><br></pre></td></tr></table></figure><p>这边的命令是通过BF.RESERVE命令手动创建一个名字为 ticket_orders，错误率为 0.01 ，初始容量为 1000000 的布隆过滤器。<br>这边需要注意的一些点是：</p><ul><li>error_rate 越小，对碰撞的容忍度越小，需要的存储空间就越大。如果允许一定比例的不准确，对精确度要求不高的场景，error_rate 可以设的稍大一点。</li><li>capacity 设置的过大，会浪费存储空间，设置过小，准确度不高。所以评估的时候需要精准一点，既要避免浪费空间也要保证准确比例。</li></ul><p>原理不理解的请参考笔者的这一篇《<a href="https://yeoh.de5.net/2025/03/20/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%8E%9F%E7%90%86/">聊聊布隆过滤器（原理） | 数根朽木，</a>》。</p><h2 id="3-3-创建车票订单"><a href="#3-3-创建车票订单" class="headerlink" title="3.3 创建车票订单"></a>3.3 创建车票订单</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># BF.ADD &#123;key&#125;  &#123;value ... &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加单个订单号</span></span><br><span class="line">BF.ADD ticket_orders 1725681193-350000</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加多个订单号</span></span><br><span class="line">BF.MADD ticket_orders 1725681193-350000 1725681197-270001 1725681350-510007</span><br><span class="line">1) (<span class="built_in">integer</span>) 1</span><br><span class="line">2) (<span class="built_in">integer</span>) 1</span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><p>以上的语句是将已经订好的车票订单号存储到Bloom Filter中，包括一次存储单个和一次存储多个。</p><p>火车票订单同步到 Bloom Filter 的步骤如下：<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAOTaUNrqFO1x3979VDlGdz07_B594kAAoYLaxvvjBhWseNFeIUlOSoBAAMCAAN5AAM2BA.png"></p><h2 id="3-4-判断火车票订单Id是否存在"><a href="#3-4-判断火车票订单Id是否存在" class="headerlink" title="3.4 判断火车票订单Id是否存在"></a>3.4 判断火车票订单Id是否存在</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># BF.EXISTS &#123;key&#125; &#123;value&#125; ，存在的话返回 1，不存在返回 0</span></span><br><span class="line">BF.EXISTS ticket_orders 1725681193-350000</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量判断多个值是否存在于布隆过滤器，语句如下：</span></span><br><span class="line">BF.MEXISTS ticket_orders 1725681193-350000 1725681197-270001 1725681350-510007</span><br><span class="line">1) (<span class="built_in">integer</span>) 0</span><br><span class="line">2) (<span class="built_in">integer</span>) 1</span><br><span class="line">3) (<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><p>BF.EXISTS 判断一个元素是否存在于 Bloom Filter中，返回值 &#x3D; 1 表示存在，返回值 &#x3D; 0 表示不存在。可以一次性判断单个元素，或者一次性判断多个元素。</p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAOUaUNrum1KtVOS4VuDWgqATDOL_skAAocLaxvvjBhWsreKUiM0LsABAAMCAAN5AAM2BA.png"></p><p>综上，我们通过几个指令就能实现布隆过滤器的建设，避免缓存穿透的情况发生。如果你要查询缓存信息，必须先到Bloom Filter中先跑一次，不存在的直接过滤掉，这样就不会因为无效的key把缓存打穿。</p><h1 id="4-程序实现说明"><a href="#4-程序实现说明" class="headerlink" title="4 程序实现说明"></a>4 程序实现说明</h1><p>可以在 Golang 中使用 <code>go-redis/redis</code> 库来封装布隆过滤器功能。你需要先确保你的 Redis 服务器已经安装了 <code>RedisBloom</code> 模块，因为 Redis 本身并不直接支持布隆过滤器。一旦 <code>RedisBloom</code> 安装并配置好，你就可以在 Go 代码中通过 <code>go-redis/redis</code> 库来调用相关的 <code>RedisBloom</code> 命令。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> bloomfilter  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;context&quot;</span>  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span>  </span><br><span class="line">    <span class="string">&quot;github.com/go-redis/redis/v8&quot;</span>  </span><br><span class="line">)  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// BloomFilter 封装了与布隆过滤器相关的操作  </span></span><br><span class="line"><span class="keyword">type</span> BloomFilter <span class="keyword">struct</span> &#123;  </span><br><span class="line">    rdb  *redis.Client  </span><br><span class="line">    name <span class="type">string</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// NewBloomFilter 创建一个新的布隆过滤器实例  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBloomFilter</span><span class="params">(rdb *redis.Client, name <span class="type">string</span>)</span></span> *BloomFilter &#123;  </span><br><span class="line">    <span class="keyword">return</span> &amp;BloomFilter&#123;  </span><br><span class="line">        rdb:  rdb,  </span><br><span class="line">        name: name,  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Add 将元素添加到布隆过滤器中  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bf *BloomFilter)</span></span> Add(ctx context.Context, item <span class="type">string</span>, capacity <span class="type">int64</span>, errorRate <span class="type">float64</span>) <span class="type">error</span> &#123;  </span><br><span class="line">    <span class="comment">// 注意：RedisBloom 的 BF.ADD 命令通常不需要显式设置容量和错误率，  </span></span><br><span class="line">    <span class="comment">// 因为这些是在创建布隆过滤器时设置的。这里我们简化为只添加元素。  </span></span><br><span class="line">    <span class="comment">// 如果需要动态调整这些参数，你可能需要重新创建布隆过滤器。  </span></span><br><span class="line">    <span class="comment">// 但为了示例，我们假设这些参数在创建布隆过滤器时已经设置好了。  </span></span><br><span class="line">    _, err := bf.rdb.Do(ctx, <span class="string">&quot;BF.ADD&quot;</span>, bf.name, item).Result()  </span><br><span class="line">    <span class="keyword">return</span> err  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Exists 检查元素是否可能存在于布隆过滤器中  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bf *BloomFilter)</span></span> Exists(ctx context.Context, item <span class="type">string</span>) (<span class="type">bool</span>, <span class="type">error</span>) &#123;  </span><br><span class="line">    result, err := bf.rdb.Do(ctx, <span class="string">&quot;BF.EXISTS&quot;</span>, bf.name, item).Int()  </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>, err  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// BF.EXISTS 返回 1 表示可能存在，0 表示一定不存在  </span></span><br><span class="line">    <span class="keyword">return</span> result == <span class="number">1</span>, <span class="literal">nil</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 注意：在实际应用中，你可能还需要封装更多操作，比如删除布隆过滤器（虽然布隆过滤器通常不支持删除单个元素）  </span></span><br><span class="line"><span class="comment">// 或者调整布隆过滤器的容量和错误率（这通常意味着需要重新创建布隆过滤器）。  </span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    rdb := redis.NewClient(&amp;redis.Options&#123;  </span><br><span class="line">        Addr:     <span class="string">&quot;localhost:6379&quot;</span>, <span class="comment">// Redis 地址  </span></span><br><span class="line">        Password: <span class="string">&quot;&quot;</span>,              <span class="comment">// 密码（如果有的话）  </span></span><br><span class="line">        DB:       <span class="number">0</span>,               <span class="comment">// 使用的数据库  </span></span><br><span class="line">    &#125;)  </span><br><span class="line">  </span><br><span class="line">    bf := NewBloomFilter(rdb, <span class="string">&quot;myBloomFilter&quot;</span>)  </span><br><span class="line">  </span><br><span class="line">    ctx := context.Background()  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 添加元素  </span></span><br><span class="line">    err := bf.Add(ctx, <span class="string">&quot;item1&quot;</span>, <span class="number">100000</span>, <span class="number">0.01</span>) <span class="comment">// 注意：BF.ADD 命令通常不需要 capacity 和 errorRate  </span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">        <span class="built_in">panic</span>(err)  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 检查元素是否存在  </span></span><br><span class="line">    exists, err := bf.Exists(ctx, <span class="string">&quot;item1&quot;</span>)  </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">        <span class="built_in">panic</span>(err)  </span><br><span class="line">    &#125;  </span><br><span class="line">    fmt.Println(<span class="string">&quot;Exists:&quot;</span>, exists)  </span><br><span class="line">  </span><br><span class="line">    exists, err = bf.Exists(ctx, <span class="string">&quot;item2&quot;</span>)  </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">        <span class="built_in">panic</span>(err)  </span><br><span class="line">    &#125;  </span><br><span class="line">    fmt.Println(<span class="string">&quot;Exists:&quot;</span>, exists)  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 注意：上面的 Add 方法中的 capacity 和 errorRate 参数在 BF.ADD 命令中并不直接使用，  </span></span><br><span class="line"><span class="comment">// 因为 RedisBloom 的 BF.ADD 命令主要用于添加元素到已存在的布隆过滤器中。  </span></span><br><span class="line"><span class="comment">// 容量和错误率通常在创建布隆过滤器时通过 BF.RESERVE 命令设置。</span></span><br><span class="line">GO 折叠 复制 全屏</span><br></pre></td></tr></table></figure><p><strong>重要提示</strong>：</p><ul><li>在上面的代码中，<code>Add</code> 方法的 <code>capacity</code> 和 <code>errorRate</code> 参数并未直接用于 <code>BF.ADD</code> 命令，因为 <code>BF.ADD</code> 只是用于向已存在的布隆过滤器中添加元素。如果你需要设置布隆过滤器的容量和错误率，你应该在创建布隆过滤器时使用 <code>BF.RESERVE</code> 命令。</li><li>布隆过滤器不支持传统意义上的“删除”操作，因为一旦一个位被设置为 1，它就不能再被设置为 0（除非重新创建布隆过滤器）。</li><li>在实际部署之前，请确保你的 Redis 服务器已经安装了 RedisBloom 模块，并且 <code>go-redis/redis</code> 库与你的 Redis 服务器版本兼容。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 布隆过滤器 </tag>
            
            <tag> Boolean filter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>聊聊布隆过滤器（原理）</title>
      <link href="/2025/03/20/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%8E%9F%E7%90%86/"/>
      <url>/2025/03/20/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Bloom-Filter-介绍"><a href="#1-Bloom-Filter-介绍" class="headerlink" title="1 Bloom Filter 介绍"></a>1 Bloom Filter 介绍</h1><p>布隆过滤器（Bloom Filter）是 Redis 4.0 版本提供的新功能，我们一般将它当做插件加载到 Redis 服务器中，给 Redis 提供强大的去重功能。<br>它是一种概率性数据结构，可用于判断一个元素是否存在于一个集合中。相比较之 Set 集合的去重功能，布隆过滤器空间上能节省 90% +，不足之处是去重率大约在 99% 左右，那就是有 1% 左右的误判率，这种误差是由布隆过滤器的自身结构决定的。</p><ul><li>优点：空间效率和查询时间都比一般的算法要好的多</li><li>缺点：有一定的误识别率和删除困难</li></ul><h1 id="2-原理分析"><a href="#2-原理分析" class="headerlink" title="2 原理分析"></a>2 原理分析</h1><p>布隆过滤器（Bloom Filter）是一个高空间利用率的概率性数据结构，由二进制向量（即位数组）和一系列随机映射函数（即哈希函数）两部分组成。<br>通过使用exists()来判断某个元素是否存在于自身结构中。当布隆过滤器判定某个值存在时，其实这个值只是有可能存在；当它说某个值不存在时，那这个值肯定不存在，这个误判概率大约在 1% 左右。<br>原理拆解如下：</p><ul><li>在一个很长的二进制向量和一系列随机映射函数的基础上，将元素哈希成不同的位置，每个位置对应二进制向量中的一个比特位。</li><li>当加入一个元素时，采用 n 个相互独立的 Hash 函数计算key，然后将元素 Hash 映射的 n 个位置全部设置为 1。</li><li>检测 key 是否存在，仍然用 Hash 函数计算出这 n 个位置，如果元素key 存在于集合中，则对应的位置为1，否则为0。</li><li>如果n个位置均为1的话，可以确定元素key可能存在于集合中；如果有一个为0，那么元素的key一定不存在于集合中，下面会详细分析这句话。</li><li>这种判断机制会存在误判的可能，但它以较小的空间代价和极简的时间复杂度来近似解决集合交、并、差等操作。</li></ul><h2 id="2-1-添加元素步骤"><a href="#2-1-添加元素步骤" class="headerlink" title="2.1 添加元素步骤"></a>2.1 添加元素步骤</h2><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAOKaUNkuNITT55NuHtBB_hHjsqWRmAAAnULaxvvjBhWPEGSVEcrxqwBAAMCAAN4AAM2BA.png"><br>当使用布隆过滤器添加 key 时，会使用不同的 hash 函数对 key 存储的元素值进行哈希计算，从而会得到多个哈希值。根据哈希值计算出一个整数索引值，将该索引值与位数组长度做取余运算，最终得到一个位数组位置，并将该位置的值变为 1。每个 hash 函数都会计算出一个不同的位置，然后把数组中与之对应的位置变为 1。这边可能出现元素碰撞的情况，比如位置3，a元素和b元素的hash计算位置一致，所以出现了碰撞。</p><h2 id="2-2-判定元素是否存在步骤"><a href="#2-2-判定元素是否存在步骤" class="headerlink" title="2.2 判定元素是否存在步骤"></a>2.2 判定元素是否存在步骤</h2><p>如果我们要判定一个元素是否存在，需要如下步骤：</p><ul><li>首先对给定元素key执行哈希计算，这样可以得到元素增加时的bit位数组位置</li><li>判断这些位置是否都为 1，如果其中有一个为 0，那么说明元素不存在</li><li>若全部位置都为 1，则说明元素有可能存在。</li></ul><p>为啥说是可能存在呢，因为上面说过了，哈希函数出的结果会出现碰撞，所以布隆过滤器会存在误判。<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAOJaUNkqUSOem2FWjXrb5BATTLzKSYAAnQLaxvvjBhWbkntPOpsnD0BAAMCAAN3AAM2BA.png"><br>如上图c，他的位置被其他元素的位置完全覆盖，即使c没有存储，对应位置上也被a和b的Hash函数设置为1，这时候就可能误判为c是有存储的。<br>有概率存在这样的 key，它们内容不同，但多次 Hash 后的 Hash 值都相同。</p><h2 id="2-3-元素删除步骤"><a href="#2-3-元素删除步骤" class="headerlink" title="2.3 元素删除步骤"></a>2.3 元素删除步骤</h2><p>一般不会删除元素，我们上面说了，因为可能存在碰撞情况，所以也有可能存在误删除情况。<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAOIaUNkmx3bJvYuDMhX_IP1XLiWrB0AAnMLaxvvjBhWJf1kEcE_z_ABAAMCAAN4AAM2BA.png"><br>删除意味着需要将对应的 n 个 bits 位置设置为 0，其中有可能是其他元素对应的位。<br>比如图中的b删除之后，位置3的值也被设置为0，这样a也可能会被判定为不存在。</p><h1 id="3-使用场景介绍"><a href="#3-使用场景介绍" class="headerlink" title="3 使用场景介绍"></a>3 使用场景介绍</h1><p>我们在遇到数据量大的时候，为了去重并避免大批量的重复计算，可以考虑使用 Bloom Filter 进行过滤。<br>具体常用的经典场景如下：</p><ul><li>解决大流量下缓存穿透的问题，参考笔者这篇《<a href="https://yeoh.de5.net/2025/03/20/%E7%94%9F%E4%BA%A7%E4%BA%8B%E6%95%85%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E9%9B%AA%E5%B4%A9%E7%9A%84%E7%81%BE%E9%9A%BE%E5%A4%8D%E7%9B%98/">生产事故记录-一次雪崩的灾难复盘-转载 | 数根朽木，</a>》。</li><li>过滤被屏蔽、拉黑、减少推荐的信息，一般你在浏览抖音或者百度App的时候，看到不喜欢的会设置减少推荐、屏蔽此类信息等，都可以采用这种原理设计。</li><li>各种名单过滤，使用布隆过滤器实现第一层的白名单或者黑名单过滤，可用于各种AB场景。</li></ul><h1 id="4-安装集成"><a href="#4-安装集成" class="headerlink" title="4 安装集成"></a>4 安装集成</h1><p>如果是自己编译安装，可以从 github 下载，目前的latest 的 release 版本是 v2.8.17，下载地址如下：<br><a href="https://github.com/RedisBloom/RedisBloom/releases">Releases · RedisBloom&#x2F;RedisBloom</a><br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAOHaUNkXoVEDrksPnJjc9DMY8Awp18AAnILaxvvjBhWl6pyugEha7UBAAMCAAN3AAM2BA.png"></p><p>直接按照编译的方式进行安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解压文件：</span></span><br><span class="line">tar -zxvf tar -zxvf RedisBloom-2.4.5.tar.gz</span><br><span class="line"><span class="comment"># 进入目录：</span></span><br><span class="line"><span class="built_in">cd</span> RedisBloom-2.4.5</span><br><span class="line"><span class="comment"># 执行编译命令，生成redisbloom.so 文件：</span></span><br><span class="line">make</span><br><span class="line"><span class="comment"># 拷贝至指定目录：</span></span><br><span class="line"><span class="built_in">cp</span> redisbloom.so /usr/local/redis/RedisBloom-2.4.5/redisbloom.so</span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要修改 redis.conf 文件，新增 loadmodule配置，并重启 Redis。</span></span><br><span class="line"><span class="comment"># 在redis配置文件里加入以下配置：</span></span><br><span class="line">loadmodule /usr/local/redis/RedisBloom-2.4.5/redisbloom.so</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置完成后重启redis服务：</span></span><br><span class="line">redis-server /usr/local/redis/RedisBloom-2.4.5/redis.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试是否安装成功</span></span><br><span class="line">127.0.0.1:6379&gt; bf.add user brand</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; bf.exists user brand</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Redis系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 布隆过滤器 </tag>
            
            <tag> Boolean filter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生产事故记录-一次雪崩的灾难复盘-转载</title>
      <link href="/2025/03/20/%E7%94%9F%E4%BA%A7%E4%BA%8B%E6%95%85%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E9%9B%AA%E5%B4%A9%E7%9A%84%E7%81%BE%E9%9A%BE%E5%A4%8D%E7%9B%98/"/>
      <url>/2025/03/20/%E7%94%9F%E4%BA%A7%E4%BA%8B%E6%95%85%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E9%9B%AA%E5%B4%A9%E7%9A%84%E7%81%BE%E9%9A%BE%E5%A4%8D%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<h3 id="1-真实案例"><a href="#1-真实案例" class="headerlink" title="1 真实案例"></a>1 真实案例</h3><p>云办公系统用户实时信息查询功能优化发布之后，系统发生宕机事件（系统挂起，页面无法加载）。</p><h4 id="1-1-背景"><a href="#1-1-背景" class="headerlink" title="1.1 背景"></a>1.1 背景</h4><p>我们IM原有的一个功能，当鼠标移动到用户头像的时候，会显示出用户的基本信息。信息比较简单，只包含简单的用户名、昵称、性别、邮箱、电话等基本数据，</p><p>这是一个典型的数据查询，大概过程如下左侧，访问用户基本信息的时候会先去Redis中查一下，如果不存在，就把大约2W左右的用户数据一次性取出来，保存在Redis中，因为用户基本信息在同一张表上，用户信息表的数据量也很少，所以一直也没什么问题。</p><p>过程如下图左侧所示。</p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAOSaUNrStEM8GAZEw1aXHsLidz7AAEdAAKFC2sb74wYVpM-hgZIuF_XAQADAgADeQADNgQ.png" alt="点击查看大图"> </p><p>后续对功能做了优化，原有采集的信息除了用户的基本信息之外，还采集了教育经历、工作经历、所获勋章等。</p><p>这些信息存储在不同的表里面，所以采集过程是一个复杂的联表查询，特别是有些基础表数据量比较大，执行效率也是比较慢的。</p><p>如果把所有用户全部取出来并存储在一个Redis节点中，明显已经不适用，一个是批量查询导致数据库执行效率慢，一个是Redis单节点数据太大。</p><p>所以开发同学做了下优化，每次只取单个用户的综合信息存在Redis中，一个用户建一个缓存，如上图右侧所示。 </p><h4 id="1-2-问题处理"><a href="#1-2-问题处理" class="headerlink" title="1.2 问题处理"></a>1.2 问题处理</h4><p>这种做法看着没啥问题，当晚发布后，在第二天的上午10点~11点就发生了系统瓶颈卡顿，最后挂起的情况，数据库的内存、CPU全部飙上去了。</p><p>第一时间的处理方法是降级，程序回滚到之前只提供基本信息的阶段，其他的前端默认显示空信息。接着就是对问题进行分析了，后确认原因是产生了 缓存雪崩了。</p><p>新发布的系统，缓存池是空的，在早上10点高峰期的时候，大量的人员到IM上进行访问，系统开始初次建立每个人的缓存信息，大量的请求查询不到缓存，直接透过缓存池投向数据库，造成瞬时DB请求量井喷。这是典型的缓存雪崩了。 </p><p>同时因为，失效时间相近（8小时失效），所以也有潜在的缓存雪崩。</p><p>应急处理方案：适当处理缓存的机制，采用布隆过滤器、空初始值、随机缓存失效时间方式来预防缓存击穿和缓存雪崩的产生。</p><p>最终解决方案：改回原来缓存全公司员工信息的方式，根据执行计划和SlowLog，优化获取员工信息的SQL脚本，去掉不需要的字段和无意义的连接。  </p><h3 id="2-缓存雪崩"><a href="#2-缓存雪崩" class="headerlink" title="2 缓存雪崩"></a>2 缓存雪崩</h3><h4 id="2-1-概念"><a href="#2-1-概念" class="headerlink" title="2.1 概念"></a>2.1 概念</h4><p>缓存雪崩是指大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。</p><p>上面的哪个问题，初次访问的数据都是未建立缓存的，跟同时失效的情况一样，当峰值期到来的时候，会大量的请求查询不到缓存，直接透过缓存池投向数据库，造成瞬时DB请求量井喷。</p><h4 id="2-2-解决方案分析"><a href="#2-2-解决方案分析" class="headerlink" title="2.2 解决方案分析"></a>2.2 解决方案分析</h4><h5 id="2-2-1-缓存集群-数据库集群"><a href="#2-2-1-缓存集群-数据库集群" class="headerlink" title="2.2.1 缓存集群+数据库集群"></a>2.2.1 缓存集群+数据库集群</h5><p>在系统容量设计的时候，应该能够预见后期会有大量的请求，所以在发生雪崩前对缓存集群实现高可用，如果是使用 Redis，可以使用 主从+哨兵 ，Redis Cluster 来避免 Redis 全盘崩溃的情况。</p><p>同样的，也需要对数据库进行高可用保障，因为透过缓存之后，真正考验的是数据库的抗压能力。所以 1主N从 甚至 数据库集群 是我们需要重点去考虑的。</p><h5 id="2-2-2-适当的限流、降级"><a href="#2-2-2-适当的限流、降级" class="headerlink" title="2.2.2 适当的限流、降级"></a>2.2.2 适当的限流、降级</h5><p>可以使用 Hystrix进行限流 + 降级 ，比如像上面那种情况，一下子来了1W个请求，不是当前系统的吞吐能力能够承受的，假设单秒TPS的能力只能是 5000个，那么剩余的 5000 请求就可以走限流逻辑。</p><p>可以设置一些默认值，然后调用我们自己降级逻辑去FallBack，保护最后的 MySQL 不会被大量的请求挂起。 除了Hystrix之外，阿里的Sentinel 和 Google的RateLimiter 都是不错的选择。</p><p>Sentinel 漏桶算法</p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAORaUNo2vGaEIssuWq0s3YTfWIgg7IAAoELaxvvjBhWeZNiSpfK6CMBAAMCAAN4AAM2BA.png" alt="漏桶算法示意图"></p><p>RateLimiter 令牌桶算法</p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAOQaUNo0Kyo6SNINz3yCJwE49w_YHQAAoALaxvvjBhWf9cbHvF-SrYBAAMCAAN4AAM2BA.png" alt="令牌桶算法"> </p><p>另外可以考虑使用用本地缓存来进行缓冲，在 Redis Cluster 不可用的时候，不至于全线崩溃。</p><h5 id="2-2-3-随机过期时间"><a href="#2-2-3-随机过期时间" class="headerlink" title="2.2.3 随机过期时间"></a>2.2.3 随机过期时间</h5><p>可以给缓存设置过期时间时加上一个随机值时间，使得每个key的过期时间分布开来，不会集中在同一时刻失效。</p><p>随机值我们团队的做法是：n * 3&#x2F;4 + n * random() 。所以，比如你原本计划对一个缓存建立的过期时间为8小时，那就是6小时 + 0~2小时的随机值。</p><p>这样保证了均匀分布在 6~8小时之间。如图： </p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAOPaUNosuZTM5re2ZEgCalk6Tr-h2kAAn8LaxvvjBhWkQxl3WUd_04BAAMCAAN5AAM2BA.png"> </p><h5 id="2-2-4-缓存预热"><a href="#2-2-4-缓存预热" class="headerlink" title="2.2.4 缓存预热"></a>2.2.4 缓存预热</h5><p>类似上面的那个案例，并不是还没过期，而是新功能发布，压根还没建设过缓存，所以可以在峰值期之前先做好部分缓存，避免瞬时压力太大。</p><p>所以如果10点是峰值期，那么可以预先在8~10点期间，可以逐渐的把大部分缓存建立起来。如图：</p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAOOaUNoMFfGNqeYWe_ajj1hCecCLvEAAn4LaxvvjBhWV8TGUBYzJQABAQADAgADeQADNgQ.png" alt="缓存预热"></p><h3 id="3-缓存穿透"><a href="#3-缓存穿透" class="headerlink" title="3 缓存穿透"></a>3 缓存穿透</h3><h4 id="3-1-概念"><a href="#3-1-概念" class="headerlink" title="3.1 概念"></a>3.1 概念</h4><p>缓存穿透是指访问一个不存在的key，缓存不起作用，请求会穿透到DB，流量井喷时会导致DB挂掉。</p><p>比如 我们查询用户的信息，程序会根据用户的编号去缓存中检索，如果找不到，再到数据库中搜索。如果你给了一个不存在的编号：XXXXXXXX，那么每次都比对不到，就透过缓存进入数据库。</p><p>这样风险很大，如果因为某些原因导致大量不存在的编号被查询，甚至被恶意伪造编号进行攻击，那将是灾难。</p><h4 id="3-2-解决方案分析"><a href="#3-2-解决方案分析" class="headerlink" title="3.2 解决方案分析"></a>3.2 解决方案分析</h4><h5 id="3-2-1-缓存空值"><a href="#3-2-1-缓存空值" class="headerlink" title="3.2.1 缓存空值"></a>3.2.1 缓存空值</h5><p>发生穿透的原因是缓存中没有存储这些空数据的key，或者压根这个数据的key是不会存在的，从而导致每次查询都进入数据库中。</p><p>我们就可以将这些key的值设置为null，并写到缓存池中。后面再出现查询这个key 的请求的时候，直接返回null，这样就在缓存池中就被判断返回了，压力在缓存层中，不会转移到数据库上。</p><h5 id="3-2-2-BloomFilter"><a href="#3-2-2-BloomFilter" class="headerlink" title="3.2.2 BloomFilter"></a>3.2.2 BloomFilter</h5><p>我们称作布隆过滤器，BloomFilter 类似于一个hbase set 用来判断某个元素（key）是否存在于某个集合中。</p><p>这种方式在大数据场景应用比较多，比如 Hbase 中使用它去判断数据是否在磁盘上。还有在爬虫场景判断url 是否已经被爬取过。</p><p>这种方案可以加在第一种方案中，在缓存之前在加一层 BloomFilter ，把存在的key记录在BloomFilter中，在查询的时候先去 BloomFilter 去查询 key 是否存在，如果不存在就直接返回，存在再走查缓存 ，投入数据库去查询，这样减轻了数据库的压力。</p><p>流程图如下：</p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAONaUNn-RoiZBilZC2JiE4w-2KQuVAAAn0LaxvvjBhW7zzsEn3GhWIBAAMCAAN5AAM2BA.png" alt="布隆过滤器"></p><h5 id="3-2-3-两种方案的选择判断"><a href="#3-2-3-两种方案的选择判断" class="headerlink" title="3.2.3 两种方案的选择判断"></a>3.2.3 两种方案的选择判断</h5><p>前面说过，可能会存在一些恶意攻击，伪造出大量不存在的key ，这种情况下如果我们如果采用缓存空值的办法，就会产生大量不存在key的null数据。显然是不合适的，这时我们完全可以使用第二种方案进行过滤掉这些key。</p><p>所以，判断的依据是：</p><ul><li>针对key非常多、请求重复率比较低的数据，我们就没有必要进行缓存，使用 BloomFilter 直接过滤掉。</li><li>而对于空数据的key有限的，重复率比较高的，我们则可以采用 缓存空值的办法 进行处理。</li></ul><h3 id="4-缓存击穿"><a href="#4-缓存击穿" class="headerlink" title="4 缓存击穿"></a>4 缓存击穿</h3><h4 id="4-1-概念"><a href="#4-1-概念" class="headerlink" title="4.1 概念"></a>4.1 概念</h4><p>一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到DB，造成瞬时DB请求量大、压力骤增。（注意跟上面两种的区别）</p><h4 id="4-2-解决方案"><a href="#4-2-解决方案" class="headerlink" title="4.2 解决方案"></a>4.2 解决方案</h4><h5 id="4-2-1-锁的方式"><a href="#4-2-1-锁的方式" class="headerlink" title="4.2.1 锁的方式"></a>4.2.1 锁的方式</h5><p>分布式锁场景，在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。</p><p>这种现象是多个线程同时去查询数据库的这条数据，那么我们可以在第一个查询数据的请求上使用一个 互斥锁来锁住它。</p><p>其他的线程走到这一步拿不到锁就等着，等第一个线程查询到了数据，然后做缓存。后面的线程进来发现已经有缓存了，就直接走缓存。</p><p>锁不好的地方就是在其他线程在拿不到锁的时候就等待，这个会造成系统整体吞吐量降低，用户体验度也不好。</p><h5 id="4-2-2-空初始值"><a href="#4-2-2-空初始值" class="headerlink" title="4.2.2 空初始值"></a>4.2.2 空初始值</h5><p>这是一种短暂降级的方式：</p><p>如果一个缓存失效的时候，有无数个请求狂奔而来，而第一个请求从进入缓存池，判空，再到数据库检索，再查询出结果并返回设置缓存的这个过程里，缓存是不存在的。</p><p>这个就很危险，超高并发下这个短暂的过程足已让千千万万请求投向数据库。更别提这可能是个慢查询，整个过程可能长达2s以上，那对数据库是一种非常大的伤害。</p><p>业内有一种做法叫<strong>做空初始值</strong>，短暂的局部降级来保证整个数据库系统不被击穿。大概流程如下：</p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAOMaUNnx-aLS7RqNCWuzgeYFQ5SINEAAnwLaxvvjBhWYxUFS6a-V9MBAAMCAAN3AAM2BA.png" alt="空初始值"> </p><p>可以看出，整个过程中我们牺牲了A、B、C、D的请求，他们拿回了一个空值或者默认值，但是这局部的降级却保证整个数据库系统不被拥堵的请求击穿。</p>]]></content>
      
      
      <categories>
          
          <category> 排忧解难 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维调优 </tag>
            
            <tag> Redis缓存 </tag>
            
            <tag> 缓存雪崩 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>是什么，为什么，怎么做? —— 谈谈 DNS 泄漏、CDN 访问优化与 Fake IP</title>
      <link href="/2025/03/17/DNS%20%E6%B3%84%E6%BC%8F%E3%80%81CDN%20%E8%AE%BF%E9%97%AE%E4%BC%98%E5%8C%96%E4%B8%8E%20Fake%20IP/"/>
      <url>/2025/03/17/DNS%20%E6%B3%84%E6%BC%8F%E3%80%81CDN%20%E8%AE%BF%E9%97%AE%E4%BC%98%E5%8C%96%E4%B8%8E%20Fake%20IP/</url>
      
        <content type="html"><![CDATA[<h1 id="深度解析Fake-IP与Real-IP：网络分流的最佳实践"><a href="#深度解析Fake-IP与Real-IP：网络分流的最佳实践" class="headerlink" title="深度解析Fake IP与Real IP：网络分流的最佳实践"></a>深度解析Fake IP与Real IP：网络分流的最佳实践</h1><p>2001 年 4 月 IETF 通过的 <strong>RFC 3089</strong>中描述的 <strong>Fake IP</strong>，是四层代理分流场景下性能相对最佳、体验相对最好、实现相对最简单的「最佳实践」。相比之下，Real IP模式为了接近其性能，需要付出大量的额外配置代价。</p><hr><h2 id="1-拆解「DNS-泄漏」的迷思"><a href="#1-拆解「DNS-泄漏」的迷思" class="headerlink" title="1. 拆解「DNS 泄漏」的迷思"></a>1. 拆解「DNS 泄漏」的迷思</h2><p>在许多三层 VPN 提供商（如 ExpressVPN, NordVPN）及 KOL 的宣传下，「DNS 泄漏」被渲染成洪水猛兽。但要理解它，首先要理解 DNS 解析的参与者：</p><ol><li><p><strong>发起查询的用户</strong></p></li><li><p><strong>递归 DNS（Local DNS）</strong>：如运营商 DNS、公共 DNS（1.1.1.1 等）。</p></li><li><p><strong>权威 DNS（Authoritative DNS）</strong>：最终决定域名指向的服务器。</p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAOEaUJ9ZPQAAXIvLGMNuzB-BOBU5nWeAAL8C2sb74wQVr6Qb72hSPmkAQADAgADdwADNgQ.png"></p></li></ol><h3 id="DNS-泄漏的原理"><a href="#DNS-泄漏的原理" class="headerlink" title="DNS 泄漏的原理"></a>DNS 泄漏的原理</h3><p>「DNS 泄漏」本质上查询的是 <strong>递归 DNS 请求权威 DNS 时所使用的出口 IP</strong>。</p><p>查询工具通过让用户请求完全随机的域名（绕开缓存），迫使递归 DNS 请求权威 DNS，从而记录下递归 DNS 的出口 IP。</p><h3 id="为什么-DNS-泄漏不值得恐慌？"><a href="#为什么-DNS-泄漏不值得恐慌？" class="headerlink" title="为什么 DNS 泄漏不值得恐慌？"></a>为什么 DNS 泄漏不值得恐慌？</h3><ol><li><strong>地理位置难以关联</strong>：Cloudflare 等公共 DNS 在全球有数百个 PoP 点，其出口 IP 无法精准对应用户实际位置。</li><li><strong>无法作为风控因子</strong>：DNS 递归流程长、失败率相对高，且无法代表用户真实 IP，主流网站不会仅凭此标记「可疑用户」。</li></ol><p>**真正值得关注的是：**域名的 DNS 查询，一定要通过实际使用的网络出口发送。</p><hr><h2 id="2-CDN-调度与-GeoDNS"><a href="#2-CDN-调度与-GeoDNS" class="headerlink" title="2. CDN 调度与 GeoDNS"></a>2. CDN 调度与 GeoDNS</h2><p>CDN（内容传输网络）通过全球部署的节点将网站带到用户附近。其分配策略主要依赖 <strong>GeoDNS</strong>：权威 DNS 根据递归 DNS 的出口 IP，返回距离用户最近的节点。</p><ul><li><strong>痛点</strong>：如果你用新加坡节点访问 Netflix，却分配了美国的 CDN 节点，体验将大幅下降。</li><li><strong>核心需求</strong>：为了保证 CDN 调度准确，不论 Fake IP 还是 Real IP 模式，都必须确保 DNS 查询走实际的网络出口。</li></ul><hr><h2 id="3-Fake-IP-vs-Real-IP：实现原理对比"><a href="#3-Fake-IP-vs-Real-IP：实现原理对比" class="headerlink" title="3. Fake IP vs Real IP：实现原理对比"></a>3. Fake IP vs Real IP：实现原理对比</h2><h3 id="Fake-IP-模式"><a href="#Fake-IP-模式" class="headerlink" title="Fake IP 模式"></a>Fake IP 模式</h3><ul><li><strong>逻辑</strong>：DNS 解析责任从客户端转移到了代理服务器。</li><li><strong>流程</strong>：<ol><li>客户端拦截 DNS 请求，直接返回一个伪造的 IP（Fake IP）。</li><li>浏览器与 Fake IP 建立连接。</li><li>代理客户端反推出域名，将域名发往代理服务器。</li><li><strong>代理服务器</strong>进行真正的 DNS 解析。</li></ol></li><li><strong>优势</strong>：天然无视本地 DNS 污染，且 CDN 调度由远程服务器完成，自动优化。</li></ul><h3 id="Real-IP-模式"><a href="#Real-IP-模式" class="headerlink" title="Real IP 模式"></a>Real IP 模式</h3><ul><li><strong>逻辑</strong>：所有 DNS 解析发生在本地。</li><li><strong>局限性</strong>：<ol><li>为了分流，客户端必须解析出 Real IP。</li><li>需要复杂的嗅探手段（HTTP Host &#x2F; TLS SNI）来识别域名，且无法处理 ECH 加密。</li><li>需要手动配置大量的 DNS 转发规则，以确保不同地区的域名由对应的出口解析。</li></ol></li></ul><hr><h2 id="4-关于-EDNS-Client-Subnet-ECS"><a href="#4-关于-EDNS-Client-Subnet-ECS" class="headerlink" title="4. 关于 EDNS Client Subnet (ECS)"></a>4. 关于 EDNS Client Subnet (ECS)</h2><p>RFC 7871 定义了 ECS，允许递归 DNS 携带客户端子网信息，帮助权威 DNS 优化调度。</p><p><strong>现状与挑战：</strong></p><ul><li><strong>兼容性极差</strong>：Cloudflare 等出于隐私拒绝支持；部分 CDN（如移动、某些国外节点）虽然兼容但不读取。</li><li><strong>安全风险</strong>：增加了 DoS 攻击和缓存投毒的风险（如 CVE-2025-5994）。</li><li><strong>配置繁琐</strong>：在 Real IP 模式下，你需要为每个网络出口手动分配对应的美国&#x2F;英国等子网段。</li></ul><hr><h2 id="5-性能优势：Fake-IP-「快」在哪里？"><a href="#5-性能优势：Fake-IP-「快」在哪里？" class="headerlink" title="5. 性能优势：Fake IP 「快」在哪里？"></a>5. 性能优势：Fake IP 「快」在哪里？</h2><h3 id="减少-DNS-RTT"><a href="#减少-DNS-RTT" class="headerlink" title="减少 DNS RTT"></a>减少 DNS RTT</h3><p>在理想的网络环境下（如上海到美西专线）：</p><ul><li><strong>Fake IP</strong>：客户端立刻返回结果，总准备耗时约 <strong>58ms</strong>。</li><li><strong>Real IP</strong>：需要等待一个完整的远程 DNS 查询往返，总耗时约 <strong>170ms</strong>。</li></ul><p>[Image comparing Fake IP and Real IP latency workflow]</p><h3 id="TCP-并发握手（Happy-Eyeballs）"><a href="#TCP-并发握手（Happy-Eyeballs）" class="headerlink" title="TCP 并发握手（Happy Eyeballs）"></a>TCP 并发握手（Happy Eyeballs）</h3><p>当 DNS 返回多个 IP 时，Fake IP 模式下的代理客户端可以同时向所有 IP 发送 <strong>TCP SYN</strong>。谁先响应就用谁，这能有效规避单个节点连接超时（可能长达 20-180s）导致的卡顿。这是 Real IP 模式难以透明实现的优化。</p><hr><h2 id="6-配置建议与结论"><a href="#6-配置建议与结论" class="headerlink" title="6. 配置建议与结论"></a>6. 配置建议与结论</h2><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><blockquote><p><strong>Fake IP 模式是目前的最佳实践。</strong></p></blockquote><h3 id="配置清单"><a href="#配置清单" class="headerlink" title="配置清单"></a>配置清单</h3><table><thead><tr><th><strong>场景</strong></th><th><strong>Fake IP 模式</strong></th><th><strong>Real IP 模式</strong></th></tr></thead><tbody><tr><td><strong>DNS 服务器</strong></td><td>仅需配置国内 DNS</td><td>需同时配置国内和海外 DNS</td></tr><tr><td><strong>解析行为</strong></td><td>仅解析直连网站&#x2F;代理服务器域名</td><td>解析所有网站</td></tr><tr><td><strong>分流复杂度</strong></td><td>简单，自动处理</td><td>极高，需配置 DNS 转发与分流</td></tr><tr><td><strong>CDN 优化</strong></td><td>服务器端自动优化</td><td>需手动配置 ECS 或多出口 DNS</td></tr></tbody></table><p><strong>简单来说：</strong></p><ul><li><strong>Fake IP 用户</strong>：只需配置国内 DNS 即可享受最佳体验。</li><li><strong>Real IP 用户</strong>：需手动管理复杂的 DNS 转发规则，否则会面临 DNS 污染或 CDN 调度劣化。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络优化 </tag>
            
            <tag> DNS泄露 </tag>
            
            <tag> Fake IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis系列1：深刻理解高性能Redis的本质</title>
      <link href="/2025/03/11/Redis%E7%B3%BB%E5%88%971-%E6%B7%B1%E5%88%BB%E7%90%86%E8%A7%A3%E9%AB%98%E6%80%A7%E8%83%BDRedis%E7%9A%84%E6%9C%AC%E8%B4%A8/"/>
      <url>/2025/03/11/Redis%E7%B3%BB%E5%88%971-%E6%B7%B1%E5%88%BB%E7%90%86%E8%A7%A3%E9%AB%98%E6%80%A7%E8%83%BDRedis%E7%9A%84%E6%9C%AC%E8%B4%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 背景</h1><p>分布式系统绕不开的核心之一的就是数据缓存，有了缓存的支撑，系统的整体吞吐量会有很大的提升。通过使用缓存，我们把频繁查询的数据由磁盘调度到缓存中，保证数据的高效率读写。当然，除了在内存内运行还远远不够，我们今天就以具有代表性的缓存中间件Redis为例子，分析下，它是如何达到飞起的效率。</p><h1 id="2-Redis高效性能分析"><a href="#2-Redis高效性能分析" class="headerlink" title="2 Redis高效性能分析"></a>2 Redis高效性能分析</h1><p>Redis之所以能够提供超高的执行效率，主要从以下几个维度来实现的：<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAANsaUJahYhmpT20C3buqSiwwIky_9gAAp8LaxvvjBBWtjzhzL6BcHEBAAMCAAN3AAM2BA.png"></p><ul><li>存储模式：基于内存实现，而非磁盘</li><li>数据结构：基于不同业务场景的高效数据结构<ul><li>动态字符串(REDIS_STRING)：整数(REDIS_ENCODING_INT)、字符串(REDIS_ENCODING_RAW)</li><li>双端列表(REDIS_ENCODING_LINKEDLIST)</li><li>压缩列表(REDIS_ENCODING_ZIPLIST)</li><li>跳跃表(REDIS_ENCODING_SKIPLIST)</li><li>哈希表(REDIS_HASH)</li><li>整数集合(REDIS_ENCODING_INTSET)</li></ul></li><li>线程模型： Redis 的网络 IO 以及键值对指令读写是由单个线程来执行的，避免了不必要的contextswitch和竞选</li><li>I&#x2F;O 模型： 基于I&#x2F;O多路复用模型，非阻塞的I&#x2F;O模型</li><li>恰单的数据编码： 根据实际数据类型，选择合理的数据编码</li></ul><h2 id="2-1-官网的性能报告"><a href="#2-1-官网的性能报告" class="headerlink" title="2.1 官网的性能报告"></a>2.1 官网的性能报告</h2><p>Redis官方站点中，有对Redis性能做了比较详细的压测，可以参考官方这一篇 <a href="https://redis.io/topics/benchmarks">How fast is Redis?</a>，在较高的配置基准下（比如 8C 16G +），在连接数为0~10000的时候，最高QPS可达到120000。Redis以超过60000个连接为基准，仍然能够在这些条件下维持50000个q&#x2F;s，体现了超高的性能。下图中横轴是连接数，纵轴是QPS。<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAANuaUJb7Bn3HC0puG7nJ2BTm9ozbmoAAqILaxvvjBBWUInBLUSpaxABAAMCAAN4AAM2BA.png"><br>下面这张图为data size 与整体吞吐量之间的趋向关系：<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAANvaUJcBElaWK_iQhxNzRukOozjSfQAAqMLaxvvjBBWJf_W3gABf_3QAQADAgADeAADNgQ.png"></p><p>这个大概可以得出一个容量预估，比如你的服务用户量是多少，预估峰值QPS是多少，集群需要配置多少个实例（虽然实例的多少不能线性计算），可以大致推算出去。</p><h2 id="2-2-基于内存实现"><a href="#2-2-基于内存实现" class="headerlink" title="2.2 基于内存实现"></a>2.2 基于内存实现</h2><p>Redis的读写操作都是在内存中实现了，相对其他的持久化存储（如MySQL、File等，数据持久化在磁盘上），性能会高很多。因为在们在操作数据的时候，需要通过 IO 操作先将数据读取到内存里，增加工作成本。</p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAANwaUJcOIFjj2RpeyYEPEnUuhbS8iwAAqQLaxvvjBBWXIlT7ND9TucBAAMCAAN5AAM2BA.png"></p><p>上面那张图来源于网络，可以看看他的金字塔模型，越往上执行效率越高，价格也就越贵。下面给出每一层的执行耗时对比：</p><ul><li>寄存器：0.3 ns</li><li>L1高速缓存：0.9 ns</li><li>L2高速缓存：2.8 ns</li><li>L3高速缓存：12.9 ns</li><li>主存：120 ns</li><li>本地二级存储（SSD）：50~150 us</li><li>远程二级存储：30 ms<br>这样可能不直观，我们举个L1和SSD的对比，如果L1耗时1s的话，SSD中差不多要15~45小时。<br>因为 CPU 内部集成了内存控制器，所以CPU直接控制了内存，给予通信上的最优带宽。上面的部分数据引用自《<a href="http://product.dangdang.com/23762087.html">性能之巅：洞悉系统、企业与云计算</a>》。</li></ul><h2 id="2-3-适配多元场景的高效数据结构"><a href="#2-3-适配多元场景的高效数据结构" class="headerlink" title="2.3 适配多元场景的高效数据结构"></a>2.3 适配多元场景的高效数据结构</h2><p>在 Redis 缓存中，常用的主要数据类型有五种，如下：</p><ul><li>字符串&#x2F;REDIS_STRING：适用于 缓存、计数、共享Session、IP统计、分布式锁等。</li><li>列表&#x2F;REDIS_LIST： 链表、消息队列、栈、有序的对象列表（如朋友圈的点赞顺序列表、评论顺序列表）。</li><li>哈希表&#x2F;REDIS_HASH： 购物车信息、用户信息、Hash类型的(key, field, value)存储对象等。</li><li>集合&#x2F;REDIS_SET：无序的唯一的键值结构： 好友、关注、粉丝、感兴趣的人集合等。</li><li>有序集合&#x2F;REDIS_ZSET：访问排行榜、点赞排行、粉丝数排行等。</li></ul><p>上面这5种Redis 支持的数据类型，能够满足不同业务场景下的数据结构需求。而对于这几类数据类型的区分和支持，目的无非也是为了效率，具体的业务中使用恰当的数据结构才能保证得到应有的效率。</p><p>这5种数据类型都有一种或者多种数据结构来支撑，底层数据结构有 7 种。关系如下：<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAOhaUYTlCGnYtTmCbYAAR_OQK4XZAotAAJgC2sb0X4wVgvpselcoIZgAQADAgADdwADNgQ.png"><br>下面我们对这些数据结构一个个的分析。</p><h3 id="2-3-1-SDS-简单动态字符串"><a href="#2-3-1-SDS-简单动态字符串" class="headerlink" title="2.3.1 SDS 简单动态字符串"></a>2.3.1 SDS 简单动态字符串</h3><p>Redis使用简单动态字符串（simple dynamic string，SDS）来表示字符串，Redis中字符串类型包含的数据结构有：整数（R_INT） 、 字符串（R_RAW）。我们以字符串为例子，常规的字符串，如 “Brand”，如果要获取他的长度，需要从头开始遍历，直至遇到 \0 空字符代表结尾,如 C字符串。</p><p>C 字符串结构与 SDS 字符串结构 对比图 参照如下：<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAOiaUYTo38cOQ2RuhvRXvu5l0ZoXEsAAmELaxvRfjBW7KzW_lIkKqkBAAMCAAN5AAM2BA.png"></p><ul><li>free属性的值为0，表示这个SDS没有分配任何未使用空间。</li><li>len属性的值为5，表示这个SDS保存了一个5字节长度的字符串。</li><li>buf是一个char类型的数组，存储真实的字符串，数组的前五个字节分别保存了’B’、’r’、’a’、’n’、’d’五个字符，而最后一个字节则保存了空字符’\0’，代表结尾。<br>注意：SDS遵循C字符串的惯例以空字符结尾，保存空字符的1字节不计算在SDS的len属性中。</li></ul><p>比起C字符串，SDS具有以下优点：</p><ol><li><p>度获取字符串长度时间复杂度为O(1) 。C字符串不记录自身长度，获取C字符串长度时必须遍历整个字符串计数得到，复杂度是O(N)SDS字符串自身记录维护len长度属性，获得SDS字符串长度的复杂度是O(1)</p></li><li><p>杜绝缓冲区溢出。C字符串不记录长度，由于两个C字符串在内存存储上紧邻，在执行字符串拼接strcat时，如果不提前分配足够空间，很可能发生修改s1的数据溢出到s2所在的空间中（缓冲区溢出）。SDS杜绝了缓冲区溢出问题，它记录了长度，当修改SDS字符串之前，API都会检查SDS的空间是否满足修改的要求，不满足API会自动进行空间扩展。</p></li><li><p>空间预分配，减少修改时的内存重分配次数SDS 被修改后，程序不仅会为 SDS 分配所需要的空间，还会分配额外的未使用空间。这样，Redis可以减少连续执行字符串增长操作所需的内存重分配次数。具体分配未使用空间如下2种方式：</p><ul><li><p>如修改后长度len小于1MB，就分配和len属性相同大小的未使用空间：free&#x3D;len。</p></li><li><p>如修改后长度len大于等于1MB，就分配1M的未使用空间：free&#x3D;1MB。</p></li></ul></li><li><p>惰性空间释放，缩短操作时：SDS避免了缩短字符串时所需的内存重分配操作，并为将来可能有的增长操作提供了优化。当SDS做缩短操作，不会立刻使用内存重分配来收回缩短后多出来的字节，而是保持在free属性里。将来如果需要 append 操作，则直接使用 free 中未使用的空间，减少了内存的分配步骤。另外，SDS也提供了API手动进行释放SDS未使用空间，避免惰性释放策略会造成内存浪费。</p></li><li><p>二进制安全，C字符串的字符必须符合某种编码，除结尾空字符以外，字符串内部不允许有空字符串，存储有局限性。而在 Redis 中，不仅可以存储 String 类型的数据，也可能存储一些二进制数据。二进制数据并不是规则的字符串格式，其中会包含一些特殊的字符如 ‘\0’。在 C 中遇到 ‘\0’ 则表示字符串的结束，但SDS不是，它是以len长度标识结尾。</p></li><li><p>兼容部分C字符串函数。SDS虽然是二进制安全的，但还是秉承C字符串以空字符结尾的特性，很多函数与C字符串一致不需要重写。</p></li></ol><h3 id="2-3-2-zipList-压缩列表"><a href="#2-3-2-zipList-压缩列表" class="headerlink" title="2.3.2 zipList 压缩列表"></a>2.3.2 zipList 压缩列表</h3><p>通过上面的数据结构关系图，可以看出，压缩列表是 List 、Hash、 Set 三种数据类型底层实现之一。当我们的list列表数据量比较少的时候，且存储的数据轻量的（如小整数值、短字符串）时候， Redis 就会通过压缩列表来进行底层实现。ziplist 是由一系列特殊编码的连续内存块组成的顺序型的数据结构，在列表头有三个字段 zlbytes、zltail 和 zllen，列表中有多个entry，表尾还有一个 zlend，我们来具体拆解下：</p><ul><li>zlbytes：表示列表占用字节数</li><li>zltail：列表尾的偏移量</li><li>zllen：列表尾的偏移量：列表中的 entry 个数</li><li>entry：存储区，可以包含多个节点，每个节点可以存放整数或者字符串。</li><li>zlend：表示列表结束。</li></ul><p>参考代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ziplist</span>&lt;</span>T&gt; &#123;</span><br><span class="line">    <span class="comment">// 列表占用字节数</span></span><br><span class="line">    int32 zlbytes;</span><br><span class="line"><span class="comment">// 列表尾的偏移量，用于快速定位到最后一个节点</span></span><br><span class="line">    int32 zltail_offset; </span><br><span class="line"><span class="comment">// 列表entry元素个数</span></span><br><span class="line">    int16 zllength; </span><br><span class="line"><span class="comment">// 元素内容列表</span></span><br><span class="line">    T[] entries; </span><br><span class="line"><span class="comment">// 标志压缩列表的结束，值恒为 0xFF</span></span><br><span class="line">    int8 zlend; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAANxaUJdHsQpTQHDHm_jOJ3EBl3NbCsAAqULaxvvjBBWqf_yqAMxBjgBAAMCAAN4AAM2BA.png"><br>如果查找定位首个元素或最后1个元素，可以通过表头zlbytes、zltail_offset元素快速获取，复杂度是 O(1)。但是查找其他元素时，就没有这么高效了，只能逐个查找下去，比如 entry n 的复杂度就是 O(N)。</p><h3 id="2-3-3-linklist-双端列表"><a href="#2-3-3-linklist-双端列表" class="headerlink" title="2.3.3 linklist 双端列表"></a>2.3.3 linklist 双端列表</h3><p>Redis List 数据类型经常使用在链表、消息队列、栈、有序的对象列表（如朋友圈的点赞顺序列表、评论顺序列表、关注时间线）等场景，无论是队列（先进先出），还是栈（先进后出），双端列表都能很好的支持。<br>参考代码如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> list &#123;</span><br><span class="line"><span class="comment">// 表头</span></span><br><span class="line">listnode * head;</span><br><span class="line"><span class="comment">// 表尾</span></span><br><span class="line">listnode * tail;</span><br><span class="line"><span class="comment">// 链表所包含的节点数量</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> len;</span><br><span class="line"><span class="comment">// 函数：复制节点值</span></span><br><span class="line"><span class="type">void</span> *(*dup)(<span class="type">void</span> *ptr);</span><br><span class="line"><span class="comment">// 函数：释放节点值</span></span><br><span class="line"><span class="type">void</span> (*free)(<span class="type">void</span> *ptr);</span><br><span class="line"><span class="comment">// 函数：对比节点值</span></span><br><span class="line"><span class="type">int</span> (*match)(<span class="type">void</span> *ptr, <span class="type">void</span> *key);</span><br><span class="line">&#125; list;</span><br></pre></td></tr></table></figure><p>Redis 的链表实现的特性可以总结如下：</p><ul><li>双端：链表节点带有 prev 和 next 指针，获取某个节点的前一节点和后一节点的复杂度都是 O(1)。</li><li>无环：表头节点的 prev 指针和表尾节点的 next 指针都指向 NULL，对链表的访问以 NULL 为终点。</li><li>表头指针&#x2F;表尾指针：通过 list 结构的 head 指针和 tail 指针，获取链表的表头节点和表尾节点的复杂度为 O(1)。</li><li>链表长度计数器：通过 list 结构的 len 属性来对 list 的链表节点进行计数，获取节点数量的复杂度为O(1)。</li><li>多态：链表节点使用 void* 指针来保存节点值，并通过 list 结构的 dup、free、match 三个属性为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值。使用链表的附加空间相对太高，因为64bit系统中指针是8个字节，所以prev和next指针需要占据16个字节，且链表节点在内存中单独分配，会加剧内存的碎片化，影响内存管理效率。考虑到链表的以上缺点，Redis后续版本对列表数据结构进行改造，使用quicklist代替了ziplist和linkedlist。 作为ziplist 和 linkedlist 的混合体，它将 linkedlist 按段切分，每一段使用 ziplist 来紧凑存储，多个 ziplist 之间使用双向指针串接起来。<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAANyaUJdORu2Z5dHjG1QnGd8DVTNJGsAAqYLaxvvjBBWOCIIpvFHep0BAAMCAAN5AAM2BA.png"><br>这样，性能就的得到了更大的提升。</li></ul><h3 id="2-3-4-Hhash-字典"><a href="#2-3-4-Hhash-字典" class="headerlink" title="2.3.4 Hhash 字典"></a>2.3.4 Hhash 字典</h3><p>无论何种类型（string、list、hash、set、zset），Redis都是以一个Hash结构的形式来保存键值对的。整体是一个数组，数组中的每个元素都是一个独立的对象，被称为哈系桶，比如图中1 ~ n, 对应的entry保存着实际具体值的指针。<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAN0aUJdhO9sSstRoX1-wSq4wEzi4mIAAqcLaxvvjBBWOphPTIesHloBAAMCAAN3AAM2BA.png"><br>上图中的全局哈希表，它的时间复杂度是 O(1)，只需要计算每个键的哈希值，便知道对应的哈希桶位置，定位桶中的 entry ，并找到对应数据。这个执行效率就很高了。为了解决可能存在的冲突，采用了链式哈希的做法，也就是同一个桶里面的元素使用链表保存。</p><h3 id="2-3-5-intset-整数集合"><a href="#2-3-5-intset-整数集合" class="headerlink" title="2.3.5 intset 整数集合"></a>2.3.5 intset 整数集合</h3><p>如果你的集合只有整数值元素，并且数量是轻量的，这时候Redis会使用使用整数集合作为Redis集合的底层数据结构。参考如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">intset</span>&#123;</span><br><span class="line">     <span class="comment">// 编码格式</span></span><br><span class="line">     <span class="type">uint32_t</span> encoding;</span><br><span class="line">     <span class="comment">// 集合中的元素个数</span></span><br><span class="line">     <span class="type">uint32_t</span> length;</span><br><span class="line">     <span class="comment">// 保存元素数据</span></span><br><span class="line">     <span class="type">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure><p>我们拆解下：</p><ul><li><p><strong>encoding：</strong> 编码方式</p></li><li><p><strong>length：</strong> 数组中元素个数，也就是数组的整体长度</p></li><li><p><strong>contents</strong>[]：</p><p>整数集合，集合的每个元素都是数组的一个数组项（item）。具有以下特点：</p><ul><li>按值的大小增序排列</li><li>不包含任何重复项</li></ul></li></ul><h3 id="2-3-6-skipList跳跃表"><a href="#2-3-6-skipList跳跃表" class="headerlink" title="2.3.6 skipList跳跃表"></a>2.3.6 skipList跳跃表</h3><p>skiplist（即跳跃表）是一种有序数据结构，所以它也是ZSet数据类型中的一种，通过在每个节点中维持多个指向其他节点的指针，达到快速定位的目标。</p><p>跳跃表的平均的节点搜索，平均时间复杂度是 O(logN)、最差时间复杂度是 O(N)，还可以通过顺序性操作来批量处理节点。 跳跃表是基于链表的改良，在它基础上，增加了多层级索引，通过索引不断跳转，最终定好位到真实的数据项。这个方式是不是让大家想到b+tree，理念上有点接近，如下图所示：<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAN1aUJdtoyIZpPiLTEfnthBwv0PpH8AAqgLaxvvjBBW7NxZ_1Lb91UBAAMCAAN5AAM2BA.png"><br>可以看出，需要获取 68 这个元素需要经历3次查找，需要获取 97则需要经历4次查找。</p><h2 id="2-4-单线程模型"><a href="#2-4-单线程模型" class="headerlink" title="2.4 单线程模型"></a>2.4 单线程模型</h2><p><strong>Redis 的单线程主要是指Redis的网络IO和键值对读写是由一个线程来完成的，Redis在处理客户端的请求时包括获取 (socket 读)、解析、执行、内容返回 (socket 写) 等都由一个顺序串行的主线程处理，这就是所谓的“单线程”。这也是Redis对外提供键值存储服务的主要流程。</strong></p><p>但Redis的其他功能， 比如持久化、异步删除、集群数据同步等等，其实是由额外的线程执行的。 可以这么说，Redis工作线程是单线程的。但是，整个Redis来说，是多线程的。</p><h3 id="2-4-1-为何是单线程？"><a href="#2-4-1-为何是单线程？" class="headerlink" title="2.4.1 为何是单线程？"></a>2.4.1 为何是单线程？</h3><p>那在主流程中使用单线程，主要是出于什么原因呢？</p><ul><li><strong>整体吞吐量降低</strong><br>适当的扩增线程，是为了有效的利用cpu的性能，让它跟内存达到一个利用的最优值。但频繁的Redis读写，如果没有对线程进行有效管理，不但对系统的吞吐量没有提升，反而可能导致下降。<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAN2aUJd2pA6an-IpSvAE_RXCSA7IpsAAqwLaxvvjBBWfYIom8xRJ6IBAAMCAAN4AAM2BA.png"></li><li><strong>CPU上下文切换</strong><br>在运行任务的时候，CPU需要把任务加载到CPU寄存器中进行计算，当切换到其他thread时，需要将当前上下文存储在系统内核中，以便后续重新执行计算时再次加载。就像你做专心做一件事时，频繁切换，频繁被打断，这个代价是非常高的。<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAN3aUJd5ZJEBMoeY0Ewzn3p5w3WoxQAAq0LaxvvjBBWviQxgPH9LdIBAAMCAAN4AAM2BA.png"><br>如图中，切换上下文时，我们需要完成一系列工作，save context、switch、restore context等，这种操作越频繁越是耗费资源。</li><li><strong>共享资源的并发控制问题</strong><br>引入了程序执行顺序的不确定性，带来了并发读写的一系列问题，增加了系统复杂度。同时可能存在线程切换、甚至加锁解锁、死锁造成的性能损耗。</li><li><strong>内存才是核心关注点</strong><br>对于 Redis 框架来说， 主要的性能瓶颈是内存或者网络带宽，而非 CPU。</li></ul><h3 id="2-4-2-单线程的好处"><a href="#2-4-2-单线程的好处" class="headerlink" title="2.4.2 单线程的好处"></a>2.4.2 单线程的好处</h3><ol><li>避免线程创建过多导致的性能消耗，反而降低整体吞吐能力。</li><li>避免上下文切换引起的 CPU 额外的开销。</li><li>避免了线程之间的竞争问题，如加锁、解锁、死锁等，都会造成性能损耗。</li><li>无需额外考虑多线程带来的程序复杂度，代码更清晰，处理逻辑简单。</li></ol><h3 id="2-4-3-单线程是否有效利用CPU"><a href="#2-4-3-单线程是否有效利用CPU" class="headerlink" title="2.4.3 单线程是否有效利用CPU"></a>2.4.3 单线程是否有效利用CPU</h3><p>官方这么说</p><blockquote><p>It’s not very frequent that CPU becomes your bottleneck with Redis, as usually Redis is either memory or network bound. For instance, using pipelining Redis running on an average Linux system can deliver even 1 million requests per second, so if your application mainly uses O(N) or O(log(N)) commands, it is hardly going to use too much CPU.</p></blockquote><p>大概意思是，Redis是完全的纯内存操作，执行速度是非常快的，CPU通常不会是瓶颈，因为大多数请求不会是CPU密集型的。<a href="https://redis.io/docs/getting-started/faq/">参考</a>，Redis真正的性能瓶颈在网络IO，也就是客户端和服务端之间的网络传输延迟，因此Redis选择了单线程的IO多路复用来实现它的核心网络模型。</p><h2 id="2-5-I-O-多路复用模型"><a href="#2-5-I-O-多路复用模型" class="headerlink" title="2.5 I&#x2F;O 多路复用模型"></a>2.5 I&#x2F;O 多路复用模型</h2><p>服务端网络编程常见的 I&#x2F;O 模型有四种：同步阻塞IO（Blocking IO）、同步非阻塞IO（Non-blocking IO）、IO多路复用（IO Multiplexing）、异步IO（Asynchronous IO）。</p><p>Redis 采用的是 I&#x2F;O 多路复用技术，并发的去处理连接，它的多路复用程序函数有 select、poll、epoll、kqueue。以 epoll （目前最新的也是最好的多路复用技术）函数为例，当客服端执行 read、write、accept、close 等操作命令时，它会将命令封装成一个个事件，然后利用 epoll 多路复用的特性来避免 I&#x2F;O 阻塞。</p><p>下面我们看看普通 I&#x2F;O 模型 和 Redis的 I&#x2F;O 多路复模型的的区别，来分析Redis高频请求下如何保持高效执行。</p><h3 id="2-5-1-普通-I-O-模型"><a href="#2-5-1-普通-I-O-模型" class="headerlink" title="2.5.1 普通 I&#x2F;O 模型"></a>2.5.1 普通 I&#x2F;O 模型</h3><p>先来看一下传统的阻塞 I&#x2F;O 模型到底是如何工作的：当使用 read 或者 write 对某一个文件描述符（File Descriptor：FD)进行读写时，如果当前 FD 不可读或不可写，整个 Redis 服务就不会对其它的操作作出响应，导致整个服务不可用。</p><p>这也就是传统意义上的，也就是我们在编程中使用最多的阻塞模型：<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAN4aUJeEhrgpcra_YyBw2UE9X7lgOEAAq4LaxvvjBBWXAQx6qsoQQUBAAMCAAN5AAM2BA.png"><br>阻塞模型虽然开发中非常常见也非常易于理解，但是由于它会影响其他 FD 对应的服务，所以在需要处理多个客户端任务的时候，往往都不会使用阻塞模型。</p><h3 id="2-5-2-I-O-多路复用"><a href="#2-5-2-I-O-多路复用" class="headerlink" title="2.5.2 I&#x2F;O 多路复用"></a>2.5.2 I&#x2F;O 多路复用</h3><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAN5aUJeNM-4Qy4_DSMvUuDND5uRxyUAArALaxvvjBBW0dgCHSXOrvABAAMCAAN5AAM2BA.png"><br><strong>多路复用</strong>指的是：多个socket连接复用一个线程。这种模式下，内核不会去监视应用程序的连接，而是监视文件描述符.</p><p>当客户端发起请求的时候，会生成不同事件类型的套接字。而在服务端，因为使用了 I&#x2F;O 多路复用技术，所以不是阻塞式的同步执行，而是将消息放入 socket 队列（参考下图的 I&#x2F;O Multiplexing module），然后通过 File event Dispatcher 将其转发到不同的事件处理器上，如accept、read、send。<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAN6aUJebmReDkkjB5bvH9VPt3SFL7YAArELaxvvjBBWoqukEF6bwEwBAAMCAAN4AAM2BA.png"><br>综上，我们得出如下特性：</p><ul><li>单线程模式，内核持续监听 socket 上的连接及数据请求，一监听就交予Redis线程处理，达到单个线程处理多个I&#x2F;O 流的效果。</li><li>epoll 提供了基于事件的回调机制。不同事件调用对应的事件处理器。Redis可以持续性的高效处理事件，性能同步提升。</li><li>Redis 不阻塞任一客户端发起的请求，所以可以同时和多个客户端连接并处理请求，聚币并发执行的能力。</li></ul><h1 id="3-高性能Redis总结"><a href="#3-高性能Redis总结" class="headerlink" title="3 高性能Redis总结"></a>3 高性能Redis总结</h1><ul><li>基于内存实现，而非磁盘，大都是简单的存取操作，资源主要消耗在 IO 上，所以读取速度快。</li><li>数据结构：基于不同业务场景的高效数据结构<ul><li>动态字符串(REDIS_STRING)：整数(REDIS_ENCODING_INT)、字符串(REDIS_ENCODING_RAW)</li><li>双端列表(REDIS_ENCODING_LINKEDLIST)</li><li>压缩列表(REDIS_ENCODING_ZIPLIST)</li><li>跳跃表(REDIS_ENCODING_SKIPLIST)</li><li>哈希表(REDIS_HASH)</li><li>整数集合(REDIS_ENCODING_INTSET)</li></ul></li><li>线程模型：Redis 的网络 IO 以及键值对指令读写是由单个线程来执行的，避免了不必要的contextswitch和竞选</li><li>I&#x2F;O 模型：基于I&#x2F;O多路复用模型，非阻塞的I&#x2F;O模型</li><li>恰单的数据编码：根据实际数据类型，选择合理的数据编码</li><li>Redis 本身是一个全局 哈希表，他的时间复杂度是 O(1)，另外为了防止哈希冲突导致链表过长，执行 rehash 操作进行扩充，减少哈希冲突。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> Redis原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis系列11：内存淘汰策略</title>
      <link href="/2025/03/11/Redis%E7%B3%BB%E5%88%9711-%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/"/>
      <url>/2025/03/11/Redis%E7%B3%BB%E5%88%9711-%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>通过前面的一些文章我们知道，Redis的各项能力是基于内存实现的，相对其他的持久化存储（如MySQL、File等，数据持久化在磁盘上），性能会高很多，这也是高速缓存的一个优势。</p><p>但是问题来了，每一台机器内存终归是有限的，即使是集群模式，总的内存空间也是有限的，不能无限制的消耗。而在Redis的使用过程中，很有可能出现使用消耗超过内存实际大小的情况。比如以下几种情况：</p><ul><li>未设置过期时间，Redis的Key将一直存在，直至我们明确将它删除。</li><li>过度跟不合理的持久化（无论是RDB快照 或是 AOF日志），都会在内存和磁盘中反复操作，需要一定的内存空间进行处理。</li><li>不及时清理过期缓存：清理过期缓存的方式主要有以下两种，并不是实时或者准实时，所以存在部分过期缓存依旧存在的问题。<ul><li>主动定期删除： Redis 默认每 1 秒运行 10 次（平均每 100 ms 执行一次），每次随机抽取部分设置过期时间的 key，检查是否过期，若是过期就直接删除，直至过期的 key 比率低于 1&#x2F;4。</li><li>被动惰性删除：缓存过期并不马上清理，当客户端的请求查询该 key 的时候，检查下 key 是否过期，如果过期，则删除该 key，重新获取。如果长时间未请求，就会有过期缓存滞留。</li></ul></li><li>不合理不规范的使用缓存，导致内存耗尽，比如：<ul><li>过度使用缓存，既缓存冷数据也能缓存热数据，导致内存占用过多，性能也没有得到有效提高</li><li>缓存数量过多或者单个缓存的Value体积过大</li><li>缓存过期时间设置过长或者根本不设置</li></ul></li></ul><h1 id="2-Redis内存淘汰策略"><a href="#2-Redis内存淘汰策略" class="headerlink" title="2 Redis内存淘汰策略"></a>2 Redis内存淘汰策略</h1><p>所以，如果放任上面的那几种情况，内存终归会满的，Redis自身有一套比较完善的内存淘汰策略来专门应对这个问题，在Redis Memory占用超过我们配置的阈值的时候触发策略执行。</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># redis.conf 配置最大内存空间占用为2gb，超过则执行内存淘汰策略</span></span><br><span class="line">redis &gt; CONFIG <span class="keyword">SET</span> maxmemory <span class="number">2</span>gb</span><br></pre></td></tr></table></figure><p>内存淘汰策略一共有8中，除了一种不执行淘汰策略之外，其他7种都是按照各自不一的算法对内存中现有的数据进行处理。<br>我们下面详细来看一下这些淘汰策略，把他们分成三大类，8小类来逐一讲解：</p><h2 id="2-1-不淘汰策略"><a href="#2-1-不淘汰策略" class="headerlink" title="2.1 不淘汰策略"></a>2.1 不淘汰策略</h2><h3 id="2-1-1-noeviction-不淘汰策略"><a href="#2-1-1-noeviction-不淘汰策略" class="headerlink" title="2.1.1 noeviction 不淘汰策略"></a>2.1.1 noeviction 不淘汰策略</h3><p>noeviction指的是即使资源超过 maxmemory 限制的值也不会执行淘汰，只是不允许创建新的缓存了。</p><p>当Redis内存占用达到我们上面的配置的阈值（比如 5gb）之后，就不允许新增缓存key了，当有新的缓存要创建的时候，Redis 直接返回error。</p><h2 id="2-2-仅淘汰配置过期时间key"><a href="#2-2-仅淘汰配置过期时间key" class="headerlink" title="2.2 仅淘汰配置过期时间key"></a>2.2 仅淘汰配置过期时间key</h2><p>这边仅针对配置了过期时间的数据进行淘汰</p><h3 id="2-3-1-volatile-lru-：删除最近最少使用的key"><a href="#2-3-1-volatile-lru-：删除最近最少使用的key" class="headerlink" title="2.3.1 volatile-lru ：删除最近最少使用的key"></a>2.3.1 volatile-lru ：删除最近最少使用的key</h3><p>LRU（Least Recently Used）是按照最近最少使用原则来筛选数据，即最不常用的数据会被筛选出来。</p><p>如果我们的服务中有冷热数据隔离需求，这无疑是一个比较好的办法。可以将缓存的一些不经常使用的冷数据，而且数据size比较大的，筛选出来清理掉。而近期频繁被使用的key就被保留下来了。<br>常见的场景如下：</p><ul><li>电商平台的冷热数据：比如冬季，保暖冬装、电暖设备的浏览次数就会升高，而相应的冷饮、制冷设备（冰箱、空调）的浏览次数就会降低，那么LRU策略下优先删除的就是最近一段时间未访问的缓存信息。</li><li>外卖平台：每天的1113点，1719点，一定是美食外卖品种的高频率访问时间段，而日用品、果蔬生鲜 大都会避开这个高峰期，这时如果内存不够用了，那么就会成为被优先删除的缓存类型。</li></ul><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAN7aUJgQS-lr-yWU93H9tsgXooREYcAArkLaxvvjBBWblIGAhfSvX8BAAMCAAN3AAM2BA.png"></p><h3 id="2-3-2-volatile-lfu：删除访问次数最少的key（4-0-之后新增的策略）"><a href="#2-3-2-volatile-lfu：删除访问次数最少的key（4-0-之后新增的策略）" class="headerlink" title="2.3.2 volatile-lfu：删除访问次数最少的key（4.0 之后新增的策略）"></a>2.3.2 volatile-lfu：删除访问次数最少的key（4.0 之后新增的策略）</h3><p>LRU算法的不足之处在于，一个本身很少被访问的key，只是刚刚被访问了1次，就被认为是最近有使用的热点数据，导致短时间内不会被淘汰。</p><p>而LFU弥补了这个不足，LFU（Least Frequently Used）淘汰策略会根据key的最近访问频率进行淘汰，解决上面说的这个不足。</p><ul><li>LFU在LRU的基础上，为每个数据增加了一个计数器，用于统计该数据的访问次数。</li><li>当使用LFU策略淘汰数据时，会根据数据的访问次数进行筛选，把访问次数最低的数据淘汰出内存。</li><li>如果两个缓存数据的访问次数相同，LFU再比较这两个key最近一次的访问时间，把访问时间更早的缓存key淘汰出内存。</li></ul><p>常见的应用场景：</p><ul><li>对于电商平台中的冷门的商品，电子书App中热度较低、阅读量较低的书籍。这种类型的缓存会优先被淘汰掉。</li></ul><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAN8aUJgXugz0AsS23qOscWqD7a931UAAroLaxvvjBBW4uzhtwMwXPcBAAMCAAN3AAM2BA.png"></p><h3 id="2-3-3-volatile-random：随机删除过期key"><a href="#2-3-3-volatile-random：随机删除过期key" class="headerlink" title="2.3.3 volatile-random：随机删除过期key"></a>2.3.3 volatile-random：随机删除过期key</h3><p>针对有配置过期时间，但没有明显的冷热访问频率区别，所有的查询分布比较均衡的数据。这时候就使用 allkeys-random 策略吧，让它随机选择需要淘汰数据，也相对公平。<br>常见的使用场景有：</p><ul><li>电商平台：常规时段的商品浏览。</li><li>钉钉之类工具：老师无差别抽查学生的作业。</li></ul><h3 id="2-3-4-volatile-ttl：删除过期时间内剩余时间最短的key"><a href="#2-3-4-volatile-ttl：删除过期时间内剩余时间最短的key" class="headerlink" title="2.3.4 volatile-ttl：删除过期时间内剩余时间最短的key"></a>2.3.4 volatile-ttl：删除过期时间内剩余时间最短的key</h3><p>这个特性仅限于配置过期时间的场景，它是根据当前时间 跟 过期时间的差额进行由短到长的排序，较短的优先淘汰。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">asc_sort</span>(validate_time - current_time)</span><br></pre></td></tr></table></figure><p>这种算法相对来说也不考虑缓存的访问频率和重要程度，仅按照创建的先后进行清理，越早的缓存越早清理。所以不具备明显特征的业务场景都适用。</p><h3 id="2-3-5-补充说明"><a href="#2-3-5-补充说明" class="headerlink" title="2.3.5 补充说明"></a>2.3.5 补充说明</h3><p>业务场景有一些数据始终不需要删除，比如置顶新闻、视频，还有我们自己置顶的weibo。为了保障它们不被清理掉，就给这些数据不设置过期时间，这样的话 volatile类型的淘汰策略就不会影响了。但如果是 allkeys 开头的策略依旧会影响到。</p><h2 id="2-3-淘汰所有缓存类型的key"><a href="#2-3-淘汰所有缓存类型的key" class="headerlink" title="2.3 淘汰所有缓存类型的key"></a>2.3 淘汰所有缓存类型的key</h2><p>无论是否配置了过期时间的数据均可进行淘汰。<br>从微服务拆分的角度说，不同的服务类型个方向的服务进行院子隔离会比较一点。这一点设计思维在缓存上依旧适用。<br>我们可以将不需要过期时间的缓存信息 和 需强制配置过期时间的缓存key分开。针对业务场景分别使用 volatile-xx策略 和 allkyes-xxx策略。</p><h3 id="2-3-1-allkeys-lru：删除最近最少使用的key"><a href="#2-3-1-allkeys-lru：删除最近最少使用的key" class="headerlink" title="2.3.1 allkeys-lru：删除最近最少使用的key"></a>2.3.1 allkeys-lru：删除最近最少使用的key</h3><p>保留最近有使用的key，类似volatile-lru</p><h3 id="2-3-2-allkeys-lfu：删除访问次数最少的key"><a href="#2-3-2-allkeys-lfu：删除访问次数最少的key" class="headerlink" title="2.3.2 allkeys-lfu：删除访问次数最少的key"></a>2.3.2 allkeys-lfu：删除访问次数最少的key</h3><p>最不经常使用的，类似volatile-lfu</p><h3 id="2-3-3-allkeys-random：随机删除过期key"><a href="#2-3-3-allkeys-random：随机删除过期key" class="headerlink" title="2.3.3 allkeys-random：随机删除过期key"></a>2.3.3 allkeys-random：随机删除过期key</h3><p>无差别随机删除，volatile-random，为添加新数据腾出空间</p><h2 id="2-4-策略命令的使用"><a href="#2-4-策略命令的使用" class="headerlink" title="2.4 策略命令的使用"></a>2.4 策略命令的使用</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 获取当前内存淘汰策略</span></span><br><span class="line">redis &gt; config <span class="keyword">get</span> maxmemory-policy</span><br><span class="line"></span><br><span class="line"><span class="meta"># 获取Redis能使用的最大内存大小：如果不设置最大内存大小或者设置最大内存大小为0，在64位操作系统下不限制内存大小，在32位操作系统下最多使用3GB内存。</span></span><br><span class="line">redis &gt; config <span class="keyword">get</span> maxmemory</span><br><span class="line"></span><br><span class="line"><span class="meta">#  通过命令配置淘汰策略</span></span><br><span class="line">redis &gt; config <span class="keyword">set</span> maxmemory-policy <span class="keyword">volatile</span>-lru</span><br><span class="line"></span><br><span class="line"><span class="meta"># 设置Redis最大占用内存大小，这边最大占用内存大小配置为2000M</span></span><br><span class="line">redis &gt; config <span class="keyword">set</span> maxmemory <span class="number">2000</span>mb</span><br></pre></td></tr></table></figure><h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h1><p>一张图总结<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAN9aUJglhgZft8f7NZz1DU7m_U8qCQAAr0LaxvvjBBWxeYChBm5c9UBAAMCAAN3AAM2BA.png"></p>]]></content>
      
      
      <categories>
          
          <category> Redis系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> Redis内存淘汰策略 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis系列14：使用List实现消息队列</title>
      <link href="/2025/03/11/Redis%E7%B3%BB%E5%88%9714-%E4%BD%BF%E7%94%A8List%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
      <url>/2025/03/11/Redis%E7%B3%BB%E5%88%9714-%E4%BD%BF%E7%94%A8List%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h1><p>在分布式系统中，很重要的一个能力就是消息中间件。我们通过消息队列实现 功能解耦、消息有序性、消息路由、异步处理、流量削峰 等能力。目前主流的Mq主要有 RabbitMQ 、RocketMQ、kafka，可以参考这篇《<a href="https://yeoh.qzz.io/2025/03/22/MQ%E7%B3%BB%E5%88%972-%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/">MQ系列2：消息中间件的技术选型 | 数根朽木，</a>》。除了这些主流MQ之外，Redis也具备实现消息队列的能力。这一篇记录一下消息队列主要实现哪些能力，原理是什么，以及如何在 Redission 中应用。</p><h1 id="2-关于消息队列"><a href="#2-关于消息队列" class="headerlink" title="2 关于消息队列"></a>2 关于消息队列</h1><h2 id="2-1-什么是消息队列"><a href="#2-1-什么是消息队列" class="headerlink" title="2.1 什么是消息队列"></a>2.1 什么是消息队列</h2><p>消息中间件是指在分布式系统中完成消息的发送和接收的基础软件。消息中间件也可以称消息队列（Message Queue &#x2F; MQ），用高效可靠的消息传递机制进行与平台无关的数据交流，并基于数据通信来进行分布式系统的集成。通过提供消息传递和消息队列模型，可以在分布式环境下扩展进程的通信。简而言之，互联网场景中经常使用消息中间件进行消息路由、订阅发布、异步处理等操作，来缓解系统的压力。</p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAANmaUI1LlcaNdvMQXz_qvLpyuVCb8kAAmoLaxvvjBBWK8VN3mP0XQYBAAMCAAN4AAM2BA.png" alt="image"></p><ul><li>Broker： 消息服务器，作为Server提供消息核心服务，一般会包含多个Q。</li><li>Producer： 消息生产者，业务的发起方，负责生产消息传输给broker，</li><li>Consumer： 消息消费者，业务的处理方，负责从broker获取消息并进行业务逻辑处理</li></ul><h2 id="2-2-它解决了我们哪些问题"><a href="#2-2-它解决了我们哪些问题" class="headerlink" title="2.2 它解决了我们哪些问题"></a>2.2 它解决了我们哪些问题</h2><p>1、<strong>解耦：</strong> 比如说系统A会交给系统B去处理一些事情，但是A不想直接跟B有关联，避免耦合太强，就可以通过在A，B中间加入消息队列，A将要任务的事情交给消息队列 ,B订阅消息队列来执行任务。</p><blockquote><p>这种场景很常见，比如A是订单系统，B是库存系统，可以通过消息队列把削减库存的工作交予B系统去处理。如果A系统同时想让B、C、D…多个系统处理问题的时候，这种优势就更加明显了。</p></blockquote><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAANnaUJPcxv-YkSK_PCwY5VtvX9hxsIAAowLaxvvjBBW1z6ajNZJsawBAAMCAAN4AAM2BA.png" alt="image"></p><p>2、<strong>有序性：</strong> 先进先出原理，先来先处理，比如一个系统处理某件事需要很长一段时间，但是在处理这件事情时候，有其他人也发出了请求，可以把请求放在消息队里，一个一个来处理。</p><blockquote><p>对数据的顺序性和一致性有强需求的业务，比如同一张银行卡同时被多个入口使用，需要保证入账出账的顺序性，避免出现数据不一致。</p></blockquote><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAANoaUJPor3AC8QQ7zhiwg6zhj6T5iQAAo0LaxvvjBBWDKdd0Fr6eMcBAAMCAAN4AAM2BA.png" alt="image"></p><p>3、<strong>消息路由：</strong> 按照不同的规则，将队列中消息发送到不同的其他队列中</p><blockquote><p>通过消息队列将不同染色的请求发送到不同的服务去操作。这样达成了流量按照业务拆分的目的。</p></blockquote><p>4、<strong>异步处理：</strong> 处理一项任务的时候，有3个步骤A、B、C，需要先完成A操作, 然后做B、C 操作。任务执行成功与否强依赖A的结果，但不依赖B、C 的结果。<br>如果我们使用串行的执行方式，那处理任务的周期就会变长，系统的整体吞吐能力也会降低（在同一个系统中做异步其实也是比较大的开销），所以使用消息队列是比较好的办法。</p><blockquote><p>登录操作就是典型的场景：A：执行登录并得到结果、B：记录登录日志、C：将用户信息和Token写入缓存。 执行完A就可以从登录页跳到首页了，B、C让服务慢慢去消化，不阻塞当前操作。</p></blockquote><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAANpaUJP2buiGENSgOom9LmVqifDoVcAAo4LaxvvjBBWn9KIi-qZ7BwBAAMCAAN4AAM2BA.png"></p><p>5、<strong>削峰：</strong> 将峰值期间的操作削减，比如A同学的整个操作流程包含12个步骤，后续的11个步骤是不需要强关注结果的数据，可以放在消息队列中。</p><p>详细可参考笔者这篇《<a href="https://yeoh.qzz.io/2025/03/22/MQ%E7%B3%BB%E5%88%971-%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/">MQ系列1：消息中间件执行原理 | 数根朽木，</a>》。</p><h2 id="2-3-消息队列满足的业务特性"><a href="#2-3-消息队列满足的业务特性" class="headerlink" title="2.3 消息队列满足的业务特性"></a>2.3 消息队列满足的业务特性</h2><h3 id="2-3-1-消息有序性"><a href="#2-3-1-消息有序性" class="headerlink" title="2.3.1 消息有序性"></a>2.3.1 消息有序性</h3><p>正如上面提到的有序性一样，他能够保证消息按照生产的顺序进行处理和消费，避免消息被无序处理的情况发生。</p><h3 id="2-3-2-消息去重"><a href="#2-3-2-消息去重" class="headerlink" title="2.3.2 消息去重"></a>2.3.2 消息去重</h3><p>同样的，生产和消费的消息需要保证幂等性原理。避免出现重复执行的情况，而消息队列的去重机制，也需要确保避免消息被重复消费的问题。</p><h3 id="2-3-3-消息的可靠性传输"><a href="#2-3-3-消息的可靠性传输" class="headerlink" title="2.3.3 消息的可靠性传输"></a>2.3.3 消息的可靠性传输</h3><p>消息队列的数据可以实现重试、持久化存储、死信队列记录等，以避免消息无法成功传递所产生的不一致现象。当消息服务器或者消费者恢复健康的时候，可以继续读取消息进行处理，防止消息遗漏。</p><h1 id="3-使用Redis的List实现消息队列"><a href="#3-使用Redis的List实现消息队列" class="headerlink" title="3 使用Redis的List实现消息队列"></a>3 使用Redis的List实现消息队列</h1><p>稍微学过数据结构都知道。我们经常说Queue（队列），他的存储和使用规则是【先进先出】，栈的存储和使用规则是【先进后出】。<br>所以List本质上是一个线性的有序结构，也就是Queue的存储关系，它能够保证消费的有序性，按照顺序进行处理。</p><h2 id="3-1-入列操作-LPUSH"><a href="#3-1-入列操作-LPUSH" class="headerlink" title="3.1 入列操作 LPUSH"></a>3.1 入列操作 LPUSH</h2><p>即进行消息生产，入列操作语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LPUSH key element<span class="selector-attr">[element...]</span> </span><br></pre></td></tr></table></figure><p>如果key存在，Producer 通过 LPUSH 将消息插入该队列的头部；如果 key 不存在，则是先创建一个空队列，然后在进行数据插入。<br>下面举个例子，往队列中插入几个消息，然后得到的返回值是插入消息的个数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; LPUSH msg_queue msg1 msg2 msg3</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure><p>这边往 key 为 msg_queue 的队列中插入了三个消息 msg1、msg2、msg3。</p><h2 id="3-2-出列操作-RPOP"><a href="#3-2-出列操作-RPOP" class="headerlink" title="3.2 出列操作 RPOP"></a>3.2 出列操作 RPOP</h2><p>即进行消息消费，消费的顺序是先进先出（先生产先消费），出列使用的语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; RPOP msg_queue</span><br><span class="line"><span class="string">&quot;msg1&quot;</span></span><br><span class="line">&gt; RPOP msg_queue</span><br><span class="line"><span class="string">&quot;msg2&quot;</span></span><br><span class="line">&gt; RPOP msg_queue</span><br><span class="line"><span class="string">&quot;msg3&quot;</span></span><br><span class="line">&gt; RPOP msg_queue</span><br><span class="line">(<span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>都消费完成之后，就是nil了。</p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAANqaUJQKdg5p-1dV5s6yMRa2CbGLqwAAo8LaxvvjBBW62hPVyB65lwBAAMCAAN5AAM2BA.png"></p><h2 id="3-3-消费及时性问题"><a href="#3-3-消费及时性问题" class="headerlink" title="3.3 消费及时性问题"></a>3.3 消费及时性问题</h2><p>不同于常规的MQ，具备订阅模式，消费者可以感知到有新的消息生产出来了，再进行消费。List的问题在于，生产者向队列插入数据的时候，List 并不会主动通知消费者，所以消费者做不到及时消费。</p><p>为了保证消费的及时，可能需要做一个心跳包（1秒执行一次），不断地执行 RPOP 指令，当探测到有新消息就会取出消息进行消费，没有消息的时候就返回nil。但是这种也存在明显的短板，就是不断的调用 RPOP 指令，占用 I&#x2F;O 资源和CPU资源。</p><p>比较好的解决办法就是在队列为空队列的时候，暂停读取，等有消息入列的时候，恢复取数和消费的工作，这样也避免了无效的资源浪费。Redis 提供了 BLPOP、BRPOP ，无数据的时候自动阻塞读取的命令，有新消息进入的时候，恢复消息取数，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">BRPOP  key  <span class="built_in">timeout</span></span> </span><br><span class="line">BRPOP  msg_queue  0</span><br></pre></td></tr></table></figure><p>命令最后一个参数 timeout 是超时时间，单位是秒，如果 timeout 大于0，则到达指定的秒数即使没有弹出成功也会返回，如果 timeout 的值为0，则会一直阻塞等待其他连接向列表中插入元素， timeout 参数不允许为负数。</p><h2 id="3-4-消息的重复消费问题"><a href="#3-4-消息的重复消费问题" class="headerlink" title="3.4 消息的重复消费问题"></a>3.4 消息的重复消费问题</h2><p>目前 List 没有纯幂等的鉴别能力，但是可以通过以下两种方法来实现：</p><ul><li>List为每一条消息生成一个 Glocal ID，重复的Glocal ID 不进行重复消费。</li><li>Producer在生产消息的时候在消息中创建一个Glocal ID，当消费的时候把Glocal ID Record一下，后续的消费先判断再消费，避免重复消费同一个消息。<br>这样就保证了对于同一条消息，消费者始终只处理一次，结果始终保持一致。</li></ul><h2 id="3-5-消息的可靠性传输问题"><a href="#3-5-消息的可靠性传输问题" class="headerlink" title="3.5 消息的可靠性传输问题"></a>3.5 消息的可靠性传输问题</h2><p>可靠性传输我们在MQ篇章用了一整节来介绍持久化存储、消息ACK 、二次记录保障。</p><p>这边我们也来看看Redis List中的可靠性传输的保障。Redis中缺少了一个消息确认（ACK）的机制，如果消费数据的时候运行崩溃了，没有确认机制，很可能这条消息就被错过了，无法保证数据的一致性。</p><p>解决方案：Redis 提供了 <code>RPOPLPUSH</code> 指令，当List读取消息的时候，会同步的把该消息复制到另外一个List以作备份。整个操作过程是具备原子性的，避免读取消息了，但是同步备份不成功。</p><p>如果出现处理消息出现故障的情况，在故障回复之后，可以从备份的List中复制消息继续消费。操作如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生产消息 msg1 msg2</span></span><br><span class="line">&gt; LPUSH list_queue msg1 msg2  </span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"><span class="comment"># 消费消息并同步到备份</span></span><br><span class="line">&gt; RPOPLPUSH list_queue list_queue_bak</span><br><span class="line"><span class="string">&quot;msg1&quot;</span></span><br><span class="line"><span class="comment"># 当发生故障的时候去消费备份的数据，可以消费到</span></span><br><span class="line">&gt; RPOP list_queue_bak</span><br><span class="line"><span class="string">&quot;msg1&quot;</span></span><br></pre></td></tr></table></figure><p>如果消费成功则把 list_queue_bak 消息删除即可，如果发生故障，则可以继续从 list_queue_bak 再次读取消息处理。</p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAANraUJQbY2betIEdAdZd_kAAYrXJdM9AAKQC2sb74wQVl4J6ZeZvQduAQADAgADeQADNgQ.png"></p><h1 id="4-使用-Redission-实现队列能力"><a href="#4-使用-Redission-实现队列能力" class="headerlink" title="4 使用 Redission 实现队列能力"></a>4 使用 Redission 实现队列能力</h1><p>这边以Java SpringBoot为例子进行说明，<a href="https://github.com/redisson/redisson/wiki/7.-Distributed-collections">可以点击参考官方文档</a>。</p><h2 id="4-1-添加maven依赖-和-配置基本连接"><a href="#4-1-添加maven依赖-和-配置基本连接" class="headerlink" title="4.1 添加maven依赖 和 配置基本连接"></a>4.1 添加maven依赖 和 配置基本连接</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># maven信息</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.16.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本配置</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">redission_test</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">x.x.x.x</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">ssl:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">xxxx.xxxx</span></span><br></pre></td></tr></table></figure><h2 id="4-2-Java程序实现"><a href="#4-2-Java程序实现" class="headerlink" title="4.2 Java程序实现"></a>4.2 Java程序实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisQueueService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">REDIS_QUEUE</span> <span class="operator">=</span> <span class="string">&quot;listQueue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息生产</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">msgProduce</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        RBlockingDeque&lt;String&gt; blockDeque = redissonClient.getBlockingDeque(REDIS_QUEUE);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            blockDeque.putFirst(msg); <span class="comment">// 消息写入队列头部</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(e.printStackTrace());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息消费：阻塞</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">msgConsume</span><span class="params">()</span> &#123;</span><br><span class="line">        RBlockingDeque&lt;String&gt; blockDeque = redissonClient.getBlockingDeque(REDIS_QUEUE);</span><br><span class="line"><span class="type">Boolen</span> <span class="variable">isCheck</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (isCheck) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> blockDeque.takeLast();  <span class="comment">// 从队列中取出消息</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                log.error(e.printStackTrace());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h1><ul><li>Redis中使用List 数据结构实现消息队列，满足FIFO的处理机制，使用 RPOP 进行消息读取。</li><li>使用 BRPOP 指令处理消费及时性问题</li><li>使用 BRPOPLPUSH 命令进行消息数据备份，解决消息可靠性传输问题。</li><li>相对于专业的MQ，如kafka和RocketMQ，处理能力会差很多。所以在在消息量不大的场景中使用，可以作为一个比较不错的消息队列解决方案。但是过于复杂的场景容易造成消息堆积。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线上事故记录OOM-转载</title>
      <link href="/2025/03/11/%E7%94%9F%E4%BA%A7%E4%BA%8B%E6%95%85%E8%AE%B0%E5%BD%95OOM/"/>
      <url>/2025/03/11/%E7%94%9F%E4%BA%A7%E4%BA%8B%E6%95%85%E8%AE%B0%E5%BD%95OOM/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-案例一"><a href="#0x01-案例一" class="headerlink" title="0x01 案例一"></a>0x01 案例一</h2><p><strong>事故时间</strong>：2018年6月13日</p><p><strong>故障类型</strong>：<code>java.lang.OutOfMemoryError: Java heap space</code></p><p><strong>事故经过</strong>：某考务管理系统，前期收集考生报名信息时允许上传ZIP附件提交相关材料，后台服务会解析压缩包并从中获取相关文件。</p><p>系统运行后不久，考务群就陆续有人反馈报名网站打不开，无法访问等等。让运维重启系统后，又恢复正常，跑了一段时间以后，又有人说无法访问。仔细检查故障时的日志，发现故障时间点都是发生在有人上传ZIP文件的时候。</p><p>从服务器上提取了一部分样本，发现压缩文件里面包含若干个TXT文件，TXT文件中是重复的字符，类似AAA…该TXT文件原始数据巨大且单调重复，导致压缩后的ZIP却非常小，真是个天才！直觉告诉我们这是被恶意攻击了，遂暂时关闭了文件上传接口，改为通过表单录入信息报名。</p><p>事后复盘当时的代码，发现处理ZIP文件时没有释放到磁盘临时文件，都是在内存中直接解压并读取解压后的文本数据，这就给了攻击者可乘之机。但是后来专门去研究了下这方面的安全漏洞，发现这是一种ZIP炸弹（ZIP of Death or ZIP Bomb），即使是释放到磁盘，也有可能造成磁盘资源耗尽。除了构造简单重复内容，还能通过递归嵌套，目录穿越等构造恶意的ZIP并释放巨量数据，有兴趣的朋友可以去自行查阅。</p><p><strong>解决方案</strong>：禁止上传嵌套压缩包，只允许上传单级压缩文件；检查文件大小；检查文件路径。</p><h2 id="0x02-案例二"><a href="#0x02-案例二" class="headerlink" title="0x02 案例二"></a>0x02 案例二</h2><p><strong>事故时间</strong>：2021年6月30日</p><p><strong>故障类型</strong>：<code>java.lang.OutOfMemoryError: Metaspace</code></p><p><strong>事故经过</strong>：某报文处理服务，需要同时处理多种渠道的<code>XML</code>报文，使用了 JAXB (Java Architecture for XML Binding) 和 XSD (XML Schema Definition) 进行报文编&#x2F;解组和格式检查。</p><p>随着业务越来越繁重，某次上线后，生产服务频繁出现<code>java.lang.OutOfMemoryError: Metaspace</code>内存异常。最后经查是因为应用启动时，一次性加载了全量的XSD和<code>Document</code>对象，大量的加载类填满了Metaspace。</p><p>应用JVM参数<code>-XX:MaxMetaspaceSize</code>、<code>-XX:MetaspaceSize</code>均设置为256MB，当时的加载代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SchemaFactory</span> <span class="variable">schemaFactory</span></span><br><span class="line">        <span class="operator">=</span> SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);</span><br><span class="line"><span class="keyword">return</span> schemaFactory.newSchema(schemaSources);</span><br></pre></td></tr></table></figure><p>一次性初始化了所有的XSD源。老规矩，先救命再治病：</p><ul><li><strong>临时解决方案</strong>：评估最大Metaspace并扩容</li><li><strong>最终解决方案</strong>：服务拆分，分块加载</li></ul><h2 id="0x03-案例三"><a href="#0x03-案例三" class="headerlink" title="0x03 案例三"></a>0x03 案例三</h2><p><strong>事故时间</strong>：2022年3月17日</p><p><strong>故障类型</strong>：<code>java.lang.StackOverflowError</code></p><p><strong>事故经过</strong>：某营销管理系统对接第三方接口上送的数据，并进行解析处理，触发对应的业务流程。其中一个业务处理是给编号为0-N的直连机构推送通知，按照接口约定，其中N由第三方接口指定，且最大值不会超过255。</p><p>管理后台采用了类似这样的代码进行处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span> corpNum)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送通知给企业，当前编号: &quot;</span> + corpNum);</span><br><span class="line">        sendSms(corpNum);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;发送通知给企业失败，当前编号: &quot;</span> + corpNum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (corpNum != <span class="number">0</span>) &#123;</span><br><span class="line">        process(corpNum - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上线之后系统一直运行良好，直到有一天，第三方接口上送数据时传了个-1，嚯！系统直接崩了，打电话过去对方说是配置有误，导致参数填写错误。这边喜提<code>java.lang.StackOverflowError</code>。</p><p>其实测试之初应该可以避免的，但是负责该业务的开发过于信任第三方上送的数据，没有考虑到意外的参数范围，狠狠的交了一笔学费。</p><p><strong>解决方案</strong>：增加严格的参数校验，同时修改尾递归写法为循环发送。</p><h2 id="0x04-案例四"><a href="#0x04-案例四" class="headerlink" title="0x04 案例四"></a>0x04 案例四</h2><p><strong>事故时间</strong>：2022年4月15日</p><p><strong>故障类型</strong>：<code>java.lang.OutOfMemoryError: unable to create new native thread</code></p><p><strong>事故经过</strong>：某接口服务配置了无界线程池作为业务线程池。该接口业务非常简单，收集各个上游服务的度量指标 (Metrics) ，简单记录日志并写入数据库，轻量、高频、无长时间阻塞，一切都那么完美。</p><p>然而，某天突然运维报告服务不可用，查询日志发现服务已经凉了有段时间，死因是<code>java.lang.OutOfMemoryError: unable to create new native thread</code>。还好留下了堆栈，一通分析，发现是有段时间应用日志所在磁盘空间写满，导致线程得不到释放，高频调用之下，最终无法创建新线程，导致服务被压垮。</p><p>那么为什么写日志会阻塞线程呢？当时应用使用的是logback日志实现，查看其配置，使用的是<code>AsyncAppender</code>异步记录器：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;file.async&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.AsyncAppender&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 不丢失日志 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">discardingThreshold</span>&gt;</span>0<span class="tag">&lt;/<span class="name">discardingThreshold</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;file.log&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里的配置正是压死骆驼的最后一根稻草。日志首先被写入<code>BlockingQueue</code>内存队列，再由工作线程异步写入磁盘。如果磁盘写满导致下游<code>FileAppender</code>无法正常工作，而<code>AsyncAppender</code>的队列又被填满，就会导致对<code>Logger</code>的调用发生阻塞。</p><p>官方文档里对于<code>discardingThreshold</code>是这样描述的：</p><blockquote><p>In light of the discussion above and in order to reduce blocking, by default, when less than 20% of the queue capacity remains, AsyncAppender will drop events of level TRACE, DEBUG and INFO keeping only events of level WARN and ERROR. This strategy ensures non-blocking handling of logging events (hence excellent performance) at the cost loosing events of level TRACE, DEBUG and INFO when the queue has less than 20% capacity. Event loss can be prevented by setting the discardingThreshold property to 0 (zero).</p></blockquote><p>设置为0，虽然可以防丢，但也让logback没有退路可言。</p><p><strong>解决方案</strong>：为接口配置有界线程池，并调整<code>discardingThreshold</code>为合理数值。</p><h2 id="0x05-案例五"><a href="#0x05-案例五" class="headerlink" title="0x05 案例五"></a>0x05 案例五</h2><p><strong>事故时间</strong>：2022年5月25日</p><p><strong>故障类型</strong>：<code>java.lang.OutOfMemoryError: Java heap space</code></p><p><strong>事故经过</strong>：某后台管理系统，由于存在敏感数据，需要在本地安装安全控件来辅助访问，该系统在首页上提供了多个版本的控件安装包下载。</p><p>上线之初系统运行都挺正常，但是某天突然有用户反馈系统无法访问，浏览器提示502网关错误。查阅发现服务已挂，应用日志提示<code>java.lang.OutOfMemoryError: Java heap space</code>，使用MAT(Memory Analyzer Tool)工具分析dump文件，发现存在大量的<code>byte[]</code>内存占用。</p><p>结合应用日志，发现服务异常之时正在调用某个文件下载方法，该方法使用<code>FileInputStream</code>读取文件到内存中，并使用<code>byte[]</code>数组存储文件内容， subsequent to将该<code>byte[]</code>数组写入到<code>Response</code>的输出流完成下载，关键代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] readFileContent(File file) &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">fileLength</span> <span class="operator">=</span> file.length();</span><br><span class="line">    <span class="type">byte</span>[] fileContent = <span class="keyword">new</span> <span class="title class_">byte</span>[(<span class="type">int</span>) fileLength];</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file)) &#123;</span><br><span class="line">        in.read(fileContent);</span><br><span class="line">        <span class="keyword">return</span> fileContent;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.error(e.getMessage(), e);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>短短几行代码却让人虎躯一震，没有判断文件的大小就直接完整读取，危险！而且没有使用缓冲流的方式进行读写。事实证明问题恰恰就是出在这里，某个版本的控件由于打包时体积偏大（约200多MB），导致多个用户同时下载时，堆区内存一下子就被控件文件数据填满，进而发生OOM异常。</p><p><strong>解决方案</strong>：将控件安装包文件挂载到FTP上并提供外链，不经过应用服务器下载。</p><h2 id="0x06-案例六"><a href="#0x06-案例六" class="headerlink" title="0x06 案例六"></a>0x06 案例六</h2><p><strong>事故时间</strong>：2023年3月10日</p><p><strong>故障类型</strong>：<code>java.lang.OutOfMemoryError: Java heap space</code></p><p><strong>事故经过</strong>：A公司开发人员在开发某开放接口时，需要调用C公司的一个基础数据接口服务。然而，从14时许开始，A公司的接口调用就开始出现异常，返回错误码<code>500</code>，错误信息为<code>java.lang.OutOfMemoryError: Java heap space</code>。</p><p>C公司开发人员向A公司开发人员反映某开放接口从14时许开始无法访问和使用。该系统为某基础数据接口服务，基于HTTP协议进行通信。</p><p>按照惯例，首先排查网络是否异常，经运维人员检查，证明网络连通性没有问题。A公司开发组于14时30分通知运维人员重启应用服务，期间短暂恢复正常。但是，很快，十分钟后，电话再次响起，告知服务又出现异常，无法访问。</p><p>在日志中搜索，找到了若干处内存溢出错误<code>java.lang.OutOfMemoryError: Java heap space</code>，但是令人费解的是每次出现OOM错误的位置居然都不一样。最后发现是应用启动脚本中，<code>-Xmn</code>参数设置成与<code>-Xmx</code>参数一样的大小，导致堆区大小失衡，进而引发内存异常。</p><p>该问题的排查过程在<a href="https://www.cnblogs.com/mylibs/p/production-accident-0002.html">生产事故-记一次特殊的OOM排查</a>一文中有详细的分析过程，这里就不再赘述了。</p><h2 id="0x07-案例七"><a href="#0x07-案例七" class="headerlink" title="0x07 案例七"></a>0x07 案例七</h2><p><strong>事故时间</strong>：2024年4月28日</p><p><strong>故障类型</strong>：<code>java.lang.OutOfMemoryError: Java heap space</code></p><p><strong>事故经过</strong>：某报表分析系统，其业务大体上为导入各种CSV&#x2F;XLS&#x2F;XLSX文件进行解析，校验并计算各项统计数据，对于异常的数据可以在首页上监控告警并提示。</p><p>有天运营的妹子突然找过来说她登录不了系统了，刚开始听到的我认为只是简单的浏览器问题，可以秀一波操作了，结果到了工位上一看，发现登录页面验证码出不来了。做过前后端分离项目的朋友都知道，这种情况下，后端服务非死即伤。强装镇定，安抚一下妹子，说我得去查查日志看看咋回事。</p><p>远程到服务器，发现后端应用确实已经灰飞烟灭，查看GC日志，发现有若干<code>java.lang.OutOfMemoryError: Java heap space</code>错误。找到那段时间的应用日志，最终问题定位到了某个<code>SQL</code>语句上，该<code>SQL</code>是个单表查询语句，但是返回的记录行数竟然有10w+。</p><p>追查源头，发现就是首页上的监控告警。前端定时器每隔20秒调用一次后端服务扫描该表的记录，筛选出状态异常的数据并返回，但是没有做分页限制，导致某个业务人员上传了一个超大的Excel表，但是有个关键数据项填写错误，该批数据10w+行记录全部被系统标记为异常，当有多个运营人员登录系统并进入首页后，就会反复触发该查询语句，进而导致内存溢出。</p><p><strong>解决方案</strong>：限制首页监控查询行数，同时优化监控逻辑，建立查询缓存，防止短时间内重复扫描业务表。</p><h2 id="0x08-案例八"><a href="#0x08-案例八" class="headerlink" title="0x08 案例八"></a>0x08 案例八</h2><p><strong>事故时间</strong>：2024年12月5日</p><p><strong>故障类型</strong>：<code>java.lang.OutOfMemoryError: GC Overhead limit exceeded</code></p><p><strong>事故经过</strong>：某查询接口服务，上线后基本稳定运行，三个月后有用户反映查询缓慢。</p><p>遂查之，发现GC日志中频繁出现<code>java.lang.OutOfMemoryError: GC Overhead limit exceeded</code>报告。第一时间做了堆栈快照，发现内存中有大量的<code>List</code>容器未释放，MAT分析Incoming references指向了<code>ThreadLocalMap</code>，基本可以定位到是<code>ThreadLocal</code>中的数据没有及时清理，无法被GC回收，导致的内存泄露，最终频繁Full GC也无法回收足够空间。</p><p><strong>解决方案</strong>：严格遵循使用后释放的原则，及时移除<code>ThreadLocal</code>中的数据引用。</p>]]></content>
      
      
      <categories>
          
          <category> 排忧解难 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OOM </tag>
            
            <tag> 线上事故 </tag>
            
            <tag> 运维调优 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线上事故记录-接口超时&amp;锁表--转载</title>
      <link href="/2025/03/11/%E7%94%9F%E4%BA%A7%E4%BA%8B%E6%95%85%E8%AE%B0%E5%BD%95%E5%8C%BB%E7%96%97%E9%A1%B9%E7%9B%AE/"/>
      <url>/2025/03/11/%E7%94%9F%E4%BA%A7%E4%BA%8B%E6%95%85%E8%AE%B0%E5%BD%95%E5%8C%BB%E7%96%97%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>年前放假的几个月内，公司项目发生了两次事故，虽然与我无关，但事故发生后整个团队都受到影响，主管需要给客户写事故报告，客户甚至打电话给公司领导严肃批评，我想经历过这种事的朋友不在少数，但很多刚入行的朋友可能不太清楚其中利害，这里我分享出来希望对大家有所帮助。</p></blockquote><h3 id="事故经过"><a href="#事故经过" class="headerlink" title="事故经过"></a>事故经过</h3><blockquote><p>三个月内一共发生两次生产环境事故，一个是接口超时导致服务雪崩，一个是锁表导致核心功能停滞一小时。</p></blockquote><h4 id="1、接口超时事故"><a href="#1、接口超时事故" class="headerlink" title="1、接口超时事故"></a>1、接口超时事故</h4><h5 id="1）现象"><a href="#1）现象" class="headerlink" title="1）现象"></a>1）现象</h5><p>2021年12月某周一上午，负责管理网络的同事(俗称网管)一大早巡检过程中发现有一个服务挂掉了，他当时没在意，直接重启就好了，但到了10点左右，忽然三四个服务：挂号服务、门诊服务、检查报告服务等一起挂掉了，而且重启十几分钟后又会挂掉，瞬间公司就炸锅了，网管、开发人员、技术主管集体冒汗，在紧急处理过程中，还不断有院方电话打给主管、总经理直到大老板，领导就站在我们背后着急的等待我们处理，我想很多人应该有画面了。</p><h5 id="2原因"><a href="#2原因" class="headerlink" title="2原因"></a>2原因</h5><p>大概到中午都没解决，因为没有日志平台的情况下，定位问题是一件不容易的事情，后来在中午休息时间技术主管和我们终于发现了门诊服务中调用某软his接口出现超时，而周一上午的流量又很大，平常偶尔超时也没问题没人在意，这次一个小小的接口超时竟然直接把服务全部堵塞，调用该接口的挂号和门诊服务全部挂掉，而和门诊服务有一点耦合的检查报告服务也在疯狂的超时等待又超时又等待中挂掉了。</p><p>最终，紧急联系院方找厂商服务团队查找该接口问题，同时我们临时把几个服务全部重启，总算在所有人惶惶不安的努力下3点之前恢复了正常。</p><h5 id="3）总结及处理"><a href="#3）总结及处理" class="headerlink" title="3）总结及处理"></a>3）总结及处理</h5><p>事后，老板大发雷霆，并召开批斗大会点出了团队没有危机处理预案等等种种问题，据说是被院方碉堡了。我们怀着谦虚忐忑的心情在小本上疯狂做笔记(做样子)，算是挺过去了，唯独主管比较难受，要亲自写好几个事故报告给甲方，懂的都懂。</p><p>接口超时时间之后发现设置为60秒，真特么离谱啊，之前竟没一个人关注(包括我)，没问题的情况下自然万事大吉，但凡出了问题，60秒的超时时间这是人干的事么，有什么接口若需要60秒，那本身就是一枚定时炸弹，必须一开始就拆掉。</p><p>很多公司的项目其实都存在这个问题，碍于调用第三方接口难以预估超时时间，所以就设置的比较长，可实际上，这会给项目带来莫大的隐患，处理方式很简单：</p><blockquote><ul><li>一定要和对接的厂商确定接口的大概超时时间，有个基本的范围，因为你很难要求其他公司给你做好接口的完善，很多是不会搭理你的，你也看不见人家接口怎么写的，那么就要知道个大概，然后自己这边才好设置；</li><li>在预估项目上线后流量会成倍增长的情况下，一定要对项目主要接口做压测，这是公司的测试团队必须要做的事情，我们公司这次就是测试人员不会压测，也没人重视，所以功能没问题就上线了，事后所有测试人员都被要求参加压测培训；</li><li>只要是微服务，请一定<strong>引入熔断机制</strong> ，这次事故过后，团队深刻反思，明明用了SpringCloud，但调用第三方接口的位置都没有做熔断处理，如果一开始做了，那么这次事故至少我们可以抽身，服务熔断降级后，既不会出现雪崩影响到其他服务，主要责任也在某软，给自己公司更多弹性处理的空间，而不是现在反而担负了主要责任。</li></ul></blockquote><h4 id="2、锁表事故"><a href="#2、锁表事故" class="headerlink" title="2、锁表事故"></a>2、锁表事故</h4><h5 id="1）现象-1"><a href="#1）现象-1" class="headerlink" title="1）现象"></a>1）现象</h5><p>这个事故和前面的相比算是小事故了，但依然令人心惊胆战，毕竟快过年了，谁也不想出问题。墨菲定律讲过，越是你害怕的事情越是会到来，果不其然，年前大概就是前一两周的样子，某天下午一家三甲医院的挂号服务未响应，在前端的效果就是，你打开了小程序，点击了挂号服务，然后某个功能一直加载中，最后页面未响应或假死。</p><h5 id="2）原因"><a href="#2）原因" class="headerlink" title="2）原因"></a>2）原因</h5><p>锁表，因为负责维护该医院的同事，在下午四点中的时候给挂号表新增了一个可以为空的字段，而挂号表是百万数据的大表，直接执行SQL新增字段还附带部分条件，直接导致整个表都锁掉了，前端发来的请求就一直无法对该表执行其他操作，最终未响应及假死。</p><p>既然锁了就要解，操作很简单，但集成同事刚好一时联系不上，开发人员又不熟悉内网环境，前后花了一个小时时间才解锁恢复正常，在一堆病患使用过程中，一个小时时间内都无法挂号，这背后的凶残你可想而知。</p><h5 id="3）总结及处理-1"><a href="#3）总结及处理-1" class="headerlink" title="3）总结及处理"></a>3）总结及处理</h5><p>给该表迅速解锁，有条件的话最好让本公司专业DBA或集成同事来操作，他们更熟悉数据库服务及项目部署，操作更安全，如果公司没有这样的同事，只能百度一下咯。</p><p>MySQL解锁方式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1.</span> 查看当前数据库锁表的情况 </span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.INNODB_TRX; </span><br><span class="line"># <span class="number">2.</span> 杀掉查询结果中锁表的trx_mysql_thread_id </span><br><span class="line">kill trx_mysql_thread_id</span><br></pre></td></tr></table></figure><p>Oracle解锁方式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 查看被锁的表ct</span><br><span class="line"><span class="keyword">select</span> b.owner, b.object_name, a.session_id, a.locked_mode</span><br><span class="line"><span class="keyword">from</span> v$locked_object a, dba_objects b <span class="keyword">where</span> b.OBJECT_ID <span class="operator">=</span> a.OBJECT_ID</span><br><span class="line"></span><br><span class="line"># 查看连接的进程</span><br><span class="line"><span class="keyword">select</span> sid, serial#, username, osuser <span class="keyword">from</span> v$session;</span><br><span class="line"></span><br><span class="line"># 杀掉进程 sid, serial#</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> kill session <span class="string">&#x27;678,983&#x27;</span>;</span><br></pre></td></tr></table></figure><blockquote><p><strong>切记，给大表新增字段以及其他操作，一定要选择流量最小的时间段，比如凌晨以后，这样可以避免造成生产环境事故。</strong></p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>1）首先，接口超时时间的设置不是小问题，希望大家引以为戒，一是要充分和对接厂商沟通，对接口情况有底，一个接口的响应时间理论上是毫秒级的，大厂甚至对接口超时时间都有明确规范，小厂因为身不由己，只能曲线救国，设置一个合理的范围； <strong>其次</strong>，一定要在测试阶段进行核心接口的压测，某种程度上可以提前暴露问题；<strong>最后</strong>，微服务一定要引入<strong>熔断机制</strong>，并且重视使用；</p><p>2）大表操作要谨慎，要么选择合适的工具来实时操作大表(可以百度非常多)，要么就选择流量最少的时间去操作，无非也就是凌晨，因为没啥人用，而且执行SQL操作大表时最好不要附带条件比如设置默认值之类的，这样会明显提升速度，把复杂的语句分段执行效果更佳，大家可以试试。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 排忧解难 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维调优 </tag>
            
            <tag> 接口超时 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8新特性</title>
      <link href="/2025/02/18/Java8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2025/02/18/Java8%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<!-- markdownlint-disable MD024 --><p>Oracle 于 2014 发布了 Java8（jdk1.8），它较 jdk7 有很多变化或者说是优化，比如 interface 里可以有静态方法，并且可以有方法体，这一点就颠覆了之前的认知；<code>java.util.HashMap</code> 数据结构里增加了红黑树；还有众所周知的 Lambda 表达式等等。本文不能把所有的新特性都给大家一一分享，只列出比较常用的新特性给大家做详细讲解。更多相关内容请看<a href="https://www.oracle.com/java/technologies/javase/8-whats-new.html">官网关于 Java8 的新特性的介绍</a>。</p><h2 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h2><p>interface 的设计初衷是面向抽象，提高扩展性。这也留有一点遗憾，Interface 修改的时候，实现它的类也必须跟着改。</p><p>为了解决接口的修改与现有的实现不兼容的问题。新 interface 的方法可以用<code>default</code> 或 <code>static</code>修饰，这样就可以有方法体，实现类也不必重写此方法。</p><p>一个 interface 中可以有多个方法被它们修饰，这 2 个修饰符的区别主要也是普通方法和静态方法的区别。</p><ol><li><code>default</code>修饰的方法，是普通实例方法，可以用<code>this</code>调用，可以被子类继承、重写。</li><li><code>static</code>修饰的方法，使用上和一般类静态方法一样。但它不能被子类继承，只能用<code>Interface</code>调用。</li></ol><p>我们来看一个实际的例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InterfaceNew</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sm</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;interface提供的方式实现&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sm2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;interface提供的方式实现&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">def</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;interface default方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">def2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;interface default2方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//须要实现类重写</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InterfaceNew1</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">def</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;InterfaceNew1 default方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有一个类既实现了 <code>InterfaceNew</code> 接口又实现了 <code>InterfaceNew1</code>接口，它们都有<code>def()</code>，并且 <code>InterfaceNew</code> 接口和 <code>InterfaceNew1</code>接口没有继承关系的话，这时就必须重写<code>def()</code>。不然的话，编译的时候就会报错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterfaceNewImpl</span> <span class="keyword">implements</span> <span class="title class_">InterfaceNew</span> , InterfaceNew1&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">InterfaceNewImpl</span> <span class="variable">interfaceNew</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterfaceNewImpl</span>();</span><br><span class="line">        interfaceNew.def();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">def</span><span class="params">()</span> &#123;</span><br><span class="line">        InterfaceNew1.<span class="built_in">super</span>.def();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在 Java 8 ，接口和抽象类有什么区别的？</strong></p><p>很多小伙伴认为：“既然 interface 也可以有自己的方法实现，似乎和 abstract class 没多大区别了。”</p><p>其实它们还是有区别的</p><ol><li><p>interface 和 class 的区别，好像是废话，主要有：</p><ul><li>接口多实现，类单继承</li><li>接口的方法是 public abstract 修饰，变量是 public static final 修饰。 abstract class 可以用其他修饰符</li></ul></li><li><p>interface 的方法是更像是一个扩展插件。而 abstract class 的方法是要继承的。</p></li></ol><p>开始我们也提到，interface 新增<code>default</code>和<code>static</code>修饰的方法，为了解决接口的修改与现有的实现不兼容的问题，并不是为了要替代<code>abstract class</code>。在使用上，该用 abstract class 的地方还是要用 abstract class，不要因为 interface 的新特性而将之替换。</p><p><strong>记住接口永远和类不一样。</strong></p><h2 id="functional-interface-函数式接口"><a href="#functional-interface-函数式接口" class="headerlink" title="functional interface 函数式接口"></a>functional interface 函数式接口</h2><p><strong>定义</strong>：也称 SAM 接口，即 Single Abstract Method interfaces，有且只有一个抽象方法，但可以有多个非抽象方法的接口。</p><p>在 java 8 中专门有一个包放函数式接口<code>java.util.function</code>，该包下的所有接口都有 <code>@FunctionalInterface</code> 注解，提供函数式编程。</p><p>在其他包中也有函数式接口，其中一些没有<code>@FunctionalInterface</code> 注解，但是只要符合函数式接口的定义就是函数式接口，与是否有<code>@FunctionalInterface</code>注解无关，注解只是在编译时起到强制规范定义的作用。其在 Lambda 表达式中有广泛的应用。</p><h2 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h2><p>接下来谈众所周知的 Lambda 表达式。它是推动 Java 8 发布的最重要新特性。是继泛型(<code>Generics</code>)和注解(<code>Annotation</code>)以来最大的变化。</p><p>使用 Lambda 表达式可以使代码变的更加简洁紧凑。让 java 也能支持简单的<em>函数式编程</em>。</p><blockquote><p>Lambda 表达式是一个匿名函数，java 8 允许把函数作为参数传递进方法中。</p></blockquote><h3 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(parameters) -&gt; expression 或</span><br><span class="line">(parameters) -&gt;&#123; statements; &#125;</span><br></pre></td></tr></table></figure><h3 id="Lambda-实战"><a href="#Lambda-实战" class="headerlink" title="Lambda 实战"></a>Lambda 实战</h3><p>我们用常用的实例来感受 Lambda 带来的便利</p><h4 id="替代匿名内部类"><a href="#替代匿名内部类" class="headerlink" title="替代匿名内部类"></a>替代匿名内部类</h4><p>过去给方法传动态参数的唯一方法是使用内部类。比如</p><p><strong>1.<code>Runnable</code> 接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;The runable now is using!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"><span class="comment">//用lambda</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; System.out.println(<span class="string">&quot;It&#x27;s a lambda function!&quot;</span>)).start();</span><br></pre></td></tr></table></figure><p><strong>2.<code>Comparator</code> 接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; strings = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">Collections.sort(strings, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> o1 - o2;&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Lambda</span></span><br><span class="line">Collections.sort(strings, (Integer o1, Integer o2) -&gt; o1 - o2);</span><br><span class="line"><span class="comment">//分解开</span></span><br><span class="line">Comparator&lt;Integer&gt; comparator = (Integer o1, Integer o2) -&gt; o1 - o2;</span><br><span class="line">Collections.sort(strings, comparator);</span><br></pre></td></tr></table></figure><p><strong>3.<code>Listener</code> 接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">JButton</span> <span class="variable">button</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>();</span><br><span class="line">button.addItemListener(<span class="keyword">new</span> <span class="title class_">ItemListener</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">itemStateChanged</span><span class="params">(ItemEvent e)</span> &#123;</span><br><span class="line">   e.getItem();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//lambda</span></span><br><span class="line">button.addItemListener(e -&gt; e.getItem());</span><br></pre></td></tr></table></figure><p><strong>4.自定义接口</strong></p><p>上面的 3 个例子是我们在开发过程中最常见的，从中也能体会到 Lambda 带来的便捷与清爽。它只保留实际用到的代码，把无用代码全部省略。那它对接口有没有要求呢？我们发现这些匿名内部类只重写了接口的一个方法，当然也只有一个方法须要重写。这就是我们上文提到的<strong>函数式接口</strong>，也就是说只要方法的参数是函数式接口都可以用 Lambda 表达式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparator</span>&lt;T&gt;&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>我们自定义一个函数式接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LambdaInterface</span> &#123;</span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">forEg</span><span class="params">()</span> &#123;</span><br><span class="line">        lambdaInterfaceDemo(()-&gt; System.out.println(<span class="string">&quot;自定义函数式接口&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//函数式接口参数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">lambdaInterfaceDemo</span><span class="params">(LambdaInterface i)</span>&#123;</span><br><span class="line">        i.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="集合迭代"><a href="#集合迭代" class="headerlink" title="集合迭代"></a>集合迭代</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">lamndaFor</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>);</span><br><span class="line">        <span class="comment">//传统foreach</span></span><br><span class="line">        <span class="keyword">for</span> (String s : strings) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Lambda foreach</span></span><br><span class="line">        strings.forEach((s) -&gt; System.out.println(s));</span><br><span class="line">        <span class="comment">//or</span></span><br><span class="line">        strings.forEach(System.out::println);</span><br><span class="line">     <span class="comment">//map</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.forEach((k,v)-&gt;System.out.println(v));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法的引用"><a href="#方法的引用" class="headerlink" title="方法的引用"></a>方法的引用</h4><p>Java 8 允许使用 <code>::</code> 关键字来传递方法或者构造函数引用，无论如何，表达式返回的类型必须是 functional-interface。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaClassSuper</span> &#123;</span><br><span class="line">    LambdaInterface <span class="title function_">sf</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaClass</span> <span class="keyword">extends</span> <span class="title class_">LambdaClassSuper</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LambdaInterface <span class="title function_">staticF</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> LambdaInterface <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1.调用静态函数，返回类型必须是functional-interface</span></span><br><span class="line">        <span class="type">LambdaInterface</span> <span class="variable">t</span> <span class="operator">=</span> LambdaClass::staticF;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.实例方法调用</span></span><br><span class="line">        <span class="type">LambdaClass</span> <span class="variable">lambdaClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LambdaClass</span>();</span><br><span class="line">        <span class="type">LambdaInterface</span> <span class="variable">lambdaInterface</span> <span class="operator">=</span> lambdaClass::f;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.超类上的方法调用</span></span><br><span class="line">        <span class="type">LambdaInterface</span> <span class="variable">superf</span> <span class="operator">=</span> <span class="built_in">super</span>::sf;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 构造方法调用</span></span><br><span class="line">        <span class="type">LambdaInterface</span> <span class="variable">tt</span> <span class="operator">=</span> LambdaClassSuper::<span class="keyword">new</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="访问变量"><a href="#访问变量" class="headerlink" title="访问变量"></a>访问变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">Collections.sort(strings, (Integer o1, Integer o2) -&gt; o1 - i);</span><br><span class="line"><span class="comment">//i =3;</span></span><br></pre></td></tr></table></figure><p>lambda 表达式可以引用外边变量，但是该变量默认拥有 final 属性，不能被修改，如果修改，编译时就报错。</p><h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><p>java 新增了 <code>java.util.stream</code> 包，它和之前的流大同小异。之前接触最多的是资源流，比如<code>java.io.FileInputStream</code>，通过流把文件从一个地方输入到另一个地方，它只是内容搬运工，对文件内容不做任何<em>CRUD</em>。</p><p><code>Stream</code>依然不存储数据，不同的是它可以检索(Retrieve)和逻辑处理集合数据、包括筛选、排序、统计、计数等。可以想象成是 Sql 语句。</p><p>它的源数据可以是 <code>Collection</code>、<code>Array</code> 等。由于它的方法参数都是函数式接口类型，所以一般和 Lambda 配合使用。</p><h3 id="流类型"><a href="#流类型" class="headerlink" title="流类型"></a>流类型</h3><ol><li>stream 串行流</li><li>parallelStream 并行流，可多线程执行</li></ol><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p>接下来我们看<code>java.util.stream.Stream</code>常用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回一个串行流</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title function_">stream</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回一个并行流</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title function_">parallelStream</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回T的流</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title function_">of</span><span class="params">(T t)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回其元素是指定值的顺序流。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title function_">of</span><span class="params">(T... values)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.stream(values);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 过滤，返回由与给定predicate匹配的该流的元素组成的流</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Stream&lt;T&gt; <span class="title function_">filter</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 此流的所有元素是否与提供的predicate匹配。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">allMatch</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 此流任意元素是否有与提供的predicate匹配。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">anyMatch</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回一个 Stream的构建器。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Builder&lt;T&gt; <span class="title function_">builder</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 使用 Collector对此流的元素进行归纳</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&lt;R, A&gt; R <span class="title function_">collect</span><span class="params">(Collector&lt;? <span class="built_in">super</span> T, A, R&gt; collector)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回此流中的元素数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">count</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回由该流的不同元素（根据 Object.equals(Object) ）组成的流。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Stream&lt;T&gt; <span class="title function_">distinct</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 遍历</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 用于获取指定数量的流，截短长度不能超过 maxSize 。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Stream&lt;T&gt; <span class="title function_">limit</span><span class="params">(<span class="type">long</span> maxSize)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 用于映射每个元素到对应的结果</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&lt;R&gt; Stream&lt;R&gt; <span class="title function_">map</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, ? extends R&gt; mapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 根据提供的 Comparator进行排序。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Stream&lt;T&gt; <span class="title function_">sorted</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> T&gt; comparator)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 在丢弃流的第一个 n元素后，返回由该流的 n元素组成的流。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Stream&lt;T&gt; <span class="title function_">skip</span><span class="params">(<span class="type">long</span> n)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回一个包含此流的元素的数组。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Object[] toArray();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 使用提供的 generator函数返回一个包含此流的元素的数组，以分配返回的数组，以及分区执行或调整大小可能需要的任何其他数组。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&lt;A&gt; A[] toArray(IntFunction&lt;A[]&gt; generator);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 合并流</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Stream&lt;T&gt; <span class="title function_">concat</span><span class="params">(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)</span></span><br></pre></td></tr></table></figure><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>本文列出 <code>Stream</code> 具有代表性的方法之使用，更多的使用方法还是要看 Api。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">  List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;gkh&quot;</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    <span class="comment">//返回符合条件的stream</span></span><br><span class="line">    Stream&lt;String&gt; stringStream = strings.stream().filter(s -&gt; <span class="string">&quot;abc&quot;</span>.equals(s));</span><br><span class="line">    <span class="comment">//计算流符合条件的流的数量</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> stringStream.count();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//forEach遍历-&gt;打印元素</span></span><br><span class="line">    strings.stream().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//limit 获取到1个元素的stream</span></span><br><span class="line">    Stream&lt;String&gt; limit = strings.stream().limit(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//toArray 比如我们想看这个limitStream里面是什么，比如转换成String[],比如循环</span></span><br><span class="line">    String[] array = limit.toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//map 对每个元素进行操作返回新流</span></span><br><span class="line">    Stream&lt;String&gt; map = strings.stream().map(s -&gt; s + <span class="string">&quot;22&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//sorted 排序并打印</span></span><br><span class="line">    strings.stream().sorted().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Collectors collect 把abc放入容器中</span></span><br><span class="line">    List&lt;String&gt; collect = strings.stream().filter(string -&gt; <span class="string">&quot;abc&quot;</span>.equals(string)).collect(Collectors.toList());</span><br><span class="line">    <span class="comment">//把list转为string，各元素用，号隔开</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">mergedString</span> <span class="operator">=</span> strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.joining(<span class="string">&quot;,&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对数组的统计，比如用</span></span><br><span class="line">    List&lt;Integer&gt; number = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">IntSummaryStatistics</span> <span class="variable">statistics</span> <span class="operator">=</span> number.stream().mapToInt((x) -&gt; x).summaryStatistics();</span><br><span class="line">    System.out.println(<span class="string">&quot;列表中最大的数 : &quot;</span>+statistics.getMax());</span><br><span class="line">    System.out.println(<span class="string">&quot;列表中最小的数 : &quot;</span>+statistics.getMin());</span><br><span class="line">    System.out.println(<span class="string">&quot;平均数 : &quot;</span>+statistics.getAverage());</span><br><span class="line">    System.out.println(<span class="string">&quot;所有数之和 : &quot;</span>+statistics.getSum());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//concat 合并流</span></span><br><span class="line">    List&lt;String&gt; strings2 = Arrays.asList(<span class="string">&quot;xyz&quot;</span>, <span class="string">&quot;jqx&quot;</span>);</span><br><span class="line">    Stream.concat(strings2.stream(),strings.stream()).count();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意 一个Stream只能操作一次，不能断开，否则会报错。</span></span><br><span class="line">    <span class="type">Stream</span> <span class="variable">stream</span> <span class="operator">=</span> strings.stream();</span><br><span class="line">    <span class="comment">//第一次使用</span></span><br><span class="line">    stream.limit(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//第二次使用</span></span><br><span class="line">    stream.forEach(System.out::println);</span><br><span class="line">    <span class="comment">//报错 java.lang.IllegalStateException: stream has already been operated upon or closed</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//但是可以这样, 连续使用</span></span><br><span class="line">    stream.limit(<span class="number">2</span>).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="延迟执行"><a href="#延迟执行" class="headerlink" title="延迟执行"></a>延迟执行</h3><p>在执行返回 <code>Stream</code> 的方法时，并不立刻执行，而是等返回一个非 <code>Stream</code> 的方法后才执行。因为拿到 <code>Stream</code> 并不能直接用，而是需要处理成一个常规类型。这里的 <code>Stream</code> 可以想象成是二进制流（2 个完全不一样的东东），拿到也看不懂。</p><p>我们下面分解一下 <code>filter</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">laziness</span><span class="params">()</span>&#123;</span><br><span class="line">  List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;gkh&quot;</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">  Stream&lt;Integer&gt; stream = strings.stream().filter(<span class="keyword">new</span> <span class="title class_">Predicate</span>() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Predicate.test 执行&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">   System.out.println(<span class="string">&quot;count 执行&quot;</span>);</span><br><span class="line">   stream.count();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*-------执行结果--------*/</span></span><br><span class="line">count 执行</span><br><span class="line">Predicate.test 执行</span><br><span class="line">Predicate.test 执行</span><br><span class="line">Predicate.test 执行</span><br><span class="line">Predicate.test 执行</span><br></pre></td></tr></table></figure><p>按执行顺序应该是先打印 4 次「<code>Predicate.test</code> 执行」，再打印「<code>count</code> 执行」。实际结果恰恰相反。说明 filter 中的方法并没有立刻执行，而是等调用<code>count()</code>方法后才执行。</p><p>上面都是串行 <code>Stream</code> 的实例。并行 <code>parallelStream</code> 在使用方法上和串行一样。主要区别是 <code>parallelStream</code> 可多线程执行，是基于 ForkJoin 框架实现的，有时间大家可以了解一下 <code>ForkJoin</code> 框架和 <code>ForkJoinPool</code>。这里可以简单的理解它是通过线程池来实现的，这样就会涉及到线程安全，线程消耗等问题。下面我们通过代码来体验一下并行流的多线程执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parallelStreamTest</span><span class="params">()</span>&#123;</span><br><span class="line">   List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>);</span><br><span class="line">   numbers.parallelStream() .forEach(num-&gt;System.out.println(Thread.currentThread().getName()+<span class="string">&quot;&gt;&gt;&quot;</span>+num));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line">main&gt;&gt;<span class="number">5</span></span><br><span class="line">ForkJoinPool.commonPool-worker-<span class="number">2</span>&gt;&gt;<span class="number">4</span></span><br><span class="line">ForkJoinPool.commonPool-worker-<span class="number">11</span>&gt;&gt;<span class="number">1</span></span><br><span class="line">ForkJoinPool.commonPool-worker-<span class="number">9</span>&gt;&gt;<span class="number">2</span></span><br></pre></td></tr></table></figure><p>从结果中我们看到，for-each 用到的是多线程。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>从源码和实例中我们可以总结出一些 stream 的特点</p><ol><li>通过简单的链式编程，使得它可以方便地对遍历处理后的数据进行再处理。</li><li>方法参数都是函数式接口类型</li><li>一个 Stream 只能操作一次，操作完就关闭了，继续使用这个 stream 会报错。</li><li>Stream 不保存数据，不改变数据源</li></ol><h2 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h2><p>在<a href="https://share.weiyun.com/ThuqEbD5">阿里巴巴开发手册关于 Optional 的介绍</a>中这样写到：</p><blockquote><p>防止 NPE，是程序员的基本修养，注意 NPE 产生的场景：</p><p>1） 返回类型为基本数据类型，return 包装数据类型的对象时，自动拆箱有可能产生 NPE。</p><p>反例：public int f() { return Integer 对象}， 如果为 null，自动解箱抛 NPE。</p><p>2） 数据库的查询结果可能为 null。</p><p>3） 集合里的元素即使 isNotEmpty，取出的数据元素也可能为 null。</p><p>4） 远程调用返回对象时，一律要求进行空指针判断，防止 NPE。</p><p>5） 对于 Session 中获取的数据，建议进行 NPE 检查，避免空指针。</p><p>6） 级联调用 obj.getA().getB().getC()；一连串调用，易产生 NPE。</p><p>正例：使用 JDK8 的 Optional 类来防止 NPE 问题。</p></blockquote><p>他建议使用 <code>Optional</code> 解决 NPE（<code>java.lang.NullPointerException</code>）问题，它就是为 NPE 而生的，其中可以包含空值或非空值。下面我们通过源码逐步揭开 <code>Optional</code> 的红盖头。</p><p>假设有一个 <code>Zoo</code> 类，里面有个属性 <code>Dog</code>，需求要获取 <code>Dog</code> 的 <code>age</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Zoo</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> Dog dog;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传统解决 NPE 的办法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Zoo</span> <span class="variable">zoo</span> <span class="operator">=</span> getZoo();</span><br><span class="line"><span class="keyword">if</span>(zoo != <span class="literal">null</span>)&#123;</span><br><span class="line">   <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> zoo.getDog();</span><br><span class="line">   <span class="keyword">if</span>(dog != <span class="literal">null</span>)&#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> dog.getAge();</span><br><span class="line">      System.out.println(age);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>层层判断对象非空，有人说这种方式很丑陋不优雅，我并不这么认为。反而觉得很整洁，易读，易懂。你们觉得呢？</p><p><code>Optional</code> 是这样的实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optional.ofNullable(zoo).map(o -&gt; o.getDog()).map(d -&gt; d.getAge()).ifPresent(age -&gt;</span><br><span class="line">    System.out.println(age)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>是不是简洁了很多呢？</p><h3 id="如何创建一个-Optional"><a href="#如何创建一个-Optional" class="headerlink" title="如何创建一个 Optional"></a>如何创建一个 Optional</h3><p>上例中<code>Optional.ofNullable</code>是其中一种创建 Optional 的方式。我们先看一下它的含义和其他创建 Optional 的源码方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Common instance for &#123;<span class="doctag">@code</span> empty()&#125;. 全局EMPTY对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Optional&lt;?&gt; EMPTY = <span class="keyword">new</span> <span class="title class_">Optional</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Optional维护的值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> T value;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 如果value是null就返回EMPTY，否则就返回of(T)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Optional&lt;T&gt; <span class="title function_">ofNullable</span><span class="params">(T value)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> value == <span class="literal">null</span> ? empty() : of(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回 EMPTY 对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Optional&lt;T&gt; <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">   Optional&lt;T&gt; t = (Optional&lt;T&gt;) EMPTY;</span><br><span class="line">   <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回Optional对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Optional&lt;T&gt; <span class="title function_">of</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Optional</span>&lt;&gt;(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 私有构造方法，给value赋值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Optional</span><span class="params">(T value)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.value = Objects.requireNonNull(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 所以如果of(T value) 的value是null，会抛出NullPointerException异常，这样貌似就没处理NPE问题</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">requireNonNull</span><span class="params">(T obj)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (obj == <span class="literal">null</span>)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ofNullable</code> 方法和<code>of</code>方法唯一区别就是当 value 为 null 时，<code>ofNullable</code> 返回的是<code>EMPTY</code>，of 会抛出 <code>NullPointerException</code> 异常。如果需要把 <code>NullPointerException</code> 暴漏出来就用 <code>of</code>，否则就用 <code>ofNullable</code>。</p><p><strong><code>map()</code> 和 <code>flatMap()</code> 有什么区别的？</strong></p><p><code>map</code> 和 <code>flatMap</code> 都是将一个函数应用于集合中的每个元素，但不同的是<code>map</code>返回一个新的集合，<code>flatMap</code>是将每个元素都映射为一个集合，最后再将这个集合展平。</p><p>在实际应用场景中，如果<code>map</code>返回的是数组，那么最后得到的是一个二维数组，使用<code>flatMap</code>就是为了将这个二维数组展平变成一个一维数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapAndFlatMapExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String[]&gt; listOfArrays = Arrays.asList(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;cherry&quot;</span>&#125;,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;orange&quot;</span>, <span class="string">&quot;grape&quot;</span>, <span class="string">&quot;pear&quot;</span>&#125;,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;kiwi&quot;</span>, <span class="string">&quot;melon&quot;</span>, <span class="string">&quot;pineapple&quot;</span>&#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        List&lt;String[]&gt; mapResult = listOfArrays.stream()</span><br><span class="line">                .map(array -&gt; Arrays.stream(array).map(String::toUpperCase).toArray(String[]::<span class="keyword">new</span>))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Using map:&quot;</span>);</span><br><span class="line">        mapResult.forEach(arrays-&gt; System.out.println(Arrays.toString(arrays)));</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; flatMapResult = listOfArrays.stream()</span><br><span class="line">                .flatMap(array -&gt; Arrays.stream(array).map(String::toUpperCase))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Using flatMap:&quot;</span>);</span><br><span class="line">        System.out.println(flatMapResult);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Using map:</span><br><span class="line">[[APPLE, BANANA, CHERRY], [ORANGE, GRAPE, PEAR], [KIWI, MELON, PINEAPPLE]]</span><br><span class="line"></span><br><span class="line">Using flatMap:</span><br><span class="line">[APPLE, BANANA, CHERRY, ORANGE, GRAPE, PEAR, KIWI, MELON, PINEAPPLE]</span><br></pre></td></tr></table></figure><p>最简单的理解就是<code>flatMap()</code>可以将<code>map()</code>的结果展开。</p><p>在<code>Optional</code>里面，当使用<code>map()</code>时，如果映射函数返回的是一个普通值，它会将这个值包装在一个新的<code>Optional</code>中。而使用<code>flatMap</code>时，如果映射函数返回的是一个<code>Optional</code>，它会将这个返回的<code>Optional</code>展平，不再包装成嵌套的<code>Optional</code>。</p><p>下面是一个对比的示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">userId</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用flatMap的代码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">cityUsingFlatMap</span> <span class="operator">=</span> getUserById(userId)</span><br><span class="line">                .flatMap(OptionalExample::getAddressByUser)</span><br><span class="line">                .map(Address::getCity)</span><br><span class="line">                .orElse(<span class="string">&quot;Unknown&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;User&#x27;s city using flatMap: &quot;</span> + cityUsingFlatMap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不使用flatMap的代码</span></span><br><span class="line">        Optional&lt;Optional&lt;Address&gt;&gt; optionalAddress = getUserById(userId)</span><br><span class="line">                .map(OptionalExample::getAddressByUser);</span><br><span class="line"></span><br><span class="line">        String cityWithoutFlatMap;</span><br><span class="line">        <span class="keyword">if</span> (optionalAddress.isPresent()) &#123;</span><br><span class="line">            Optional&lt;Address&gt; addressOptional = optionalAddress.get();</span><br><span class="line">            <span class="keyword">if</span> (addressOptional.isPresent()) &#123;</span><br><span class="line">                <span class="type">Address</span> <span class="variable">address</span> <span class="operator">=</span> addressOptional.get();</span><br><span class="line">                cityWithoutFlatMap = address.getCity();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cityWithoutFlatMap = <span class="string">&quot;Unknown&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cityWithoutFlatMap = <span class="string">&quot;Unknown&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;User&#x27;s city without flatMap: &quot;</span> + cityWithoutFlatMap);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在<code>Stream</code>和<code>Optional</code>中正确使用<code>flatMap</code>可以减少很多不必要的代码。</p><h3 id="判断-value-是否为-null"><a href="#判断-value-是否为-null" class="headerlink" title="判断 value 是否为 null"></a>判断 value 是否为 null</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* value是否为null</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPresent</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 如果value不为null执行consumer.accept</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ifPresent</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; consumer)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (value != <span class="literal">null</span>)</span><br><span class="line">    consumer.accept(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取-value"><a href="#获取-value" class="headerlink" title="获取 value"></a>获取 value</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Return the value if present, otherwise invoke &#123;<span class="doctag">@code</span> other&#125; and return</span></span><br><span class="line"><span class="comment">* the result of that invocation.</span></span><br><span class="line"><span class="comment">* 如果value != null 返回value，否则返回other的执行结果</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">orElseGet</span><span class="params">(Supplier&lt;? extends T&gt; other)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value != <span class="literal">null</span> ? value : other.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 如果value != null 返回value，否则返回T</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">orElse</span><span class="params">(T other)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value != <span class="literal">null</span> ? value : other;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 如果value != null 返回value，否则抛出参数返回的异常</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> &lt;X <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt; T <span class="title function_">orElseThrow</span><span class="params">(Supplier&lt;? extends X&gt; exceptionSupplier)</span> <span class="keyword">throws</span> X &#123;</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> exceptionSupplier.get();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* value为null抛出NoSuchElementException，不为空返回value。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>(<span class="string">&quot;No value present&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="过滤值"><a href="#过滤值" class="headerlink" title="过滤值"></a>过滤值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 1. 如果是empty返回empty</span></span><br><span class="line"><span class="comment">* 2. predicate.test(value)==true 返回this，否则返回empty</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> Optional&lt;T&gt; <span class="title function_">filter</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(predicate);</span><br><span class="line">        <span class="keyword">if</span> (!isPresent())</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> predicate.test(value) ? <span class="built_in">this</span> : empty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>看完 <code>Optional</code> 源码，<code>Optional</code> 的方法真的非常简单，值得注意的是如果坚决不想看见 <code>NPE</code>，就不要用 <code>of()</code>、 <code>get()</code>、<code>flatMap(..)</code>。最后再综合用一下 <code>Optional</code> 的高频方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional.ofNullable(zoo).map(o -&gt; o.getDog()).map(d -&gt; d.getAge()).filter(v-&gt;v==<span class="number">1</span>).orElse(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><h2 id="Date-Time-API"><a href="#Date-Time-API" class="headerlink" title="Date-Time API"></a>Date-Time API</h2><p>这是对<code>java.util.Date</code>强有力的补充，解决了 Date 类的大部分痛点：</p><ol><li>非线程安全</li><li>时区处理麻烦</li><li>各种格式化、和时间计算繁琐</li><li>设计有缺陷，Date 类同时包含日期和时间；还有一个 java.sql.Date，容易混淆。</li></ol><p>我们从常用的时间实例来对比 java.util.Date 和新 Date 有什么区别。用<code>java.util.Date</code>的代码该改改了。</p><h3 id="java-time-主要类"><a href="#java-time-主要类" class="headerlink" title="java.time 主要类"></a>java.time 主要类</h3><p><code>java.util.Date</code> 既包含日期又包含时间，而 <code>java.time</code> 把它们进行了分离</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime.class <span class="comment">//日期+时间 format: yyyy-MM-ddTHH:mm:ss.SSS</span></span><br><span class="line">LocalDate.class <span class="comment">//日期 format: yyyy-MM-dd</span></span><br><span class="line">LocalTime.class <span class="comment">//时间 format: HH:mm:ss</span></span><br></pre></td></tr></table></figure><h3 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h3><p><strong>Java 8 之前:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">oldFormat</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Date</span> <span class="variable">now</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="comment">//format yyyy-MM-dd</span></span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">date</span>  <span class="operator">=</span> sdf.format(now);</span><br><span class="line">    System.out.println(String.format(<span class="string">&quot;date format : %s&quot;</span>, date));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//format HH:mm:ss</span></span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">sdft</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;HH:mm:ss&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">time</span> <span class="operator">=</span> sdft.format(now);</span><br><span class="line">    System.out.println(String.format(<span class="string">&quot;time format : %s&quot;</span>, time));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//format yyyy-MM-dd HH:mm:ss</span></span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">sdfdt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">datetime</span> <span class="operator">=</span> sdfdt.format(now);</span><br><span class="line">    System.out.println(String.format(<span class="string">&quot;dateTime format : %s&quot;</span>, datetime));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Java 8 之后:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">newFormat</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//format yyyy-MM-dd</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">date</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">    System.out.println(String.format(<span class="string">&quot;date format : %s&quot;</span>, date));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//format HH:mm:ss</span></span><br><span class="line">    <span class="type">LocalTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalTime.now().withNano(<span class="number">0</span>);</span><br><span class="line">    System.out.println(String.format(<span class="string">&quot;time format : %s&quot;</span>, time));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//format yyyy-MM-dd HH:mm:ss</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">dateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="type">DateTimeFormatter</span> <span class="variable">dateTimeFormatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">dateTimeStr</span> <span class="operator">=</span> dateTime.format(dateTimeFormatter);</span><br><span class="line">    System.out.println(String.format(<span class="string">&quot;dateTime format : %s&quot;</span>, dateTimeStr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符串转日期格式"><a href="#字符串转日期格式" class="headerlink" title="字符串转日期格式"></a>字符串转日期格式</h3><p><strong>Java 8 之前:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//已弃用</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&quot;2021-01-26&quot;</span>);</span><br><span class="line"><span class="comment">//替换为</span></span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line"><span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> sdf.parse(<span class="string">&quot;2021-01-26&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>Java 8 之后:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDate</span> <span class="variable">date</span> <span class="operator">=</span> LocalDate.of(<span class="number">2021</span>, <span class="number">1</span>, <span class="number">26</span>);</span><br><span class="line">LocalDate.parse(<span class="string">&quot;2021-01-26&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">dateTime</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2021</span>, <span class="number">1</span>, <span class="number">26</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">22</span>);</span><br><span class="line">LocalDateTime.parse(<span class="string">&quot;2021-01-26 12:12:22&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">LocalTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalTime.of(<span class="number">12</span>, <span class="number">12</span>, <span class="number">22</span>);</span><br><span class="line">LocalTime.parse(<span class="string">&quot;12:12:22&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>Java 8 之前</strong> 转换都需要借助 <code>SimpleDateFormat</code> 类，而<strong>Java 8 之后</strong>只需要 <code>LocalDate</code>、<code>LocalTime</code>、<code>LocalDateTime</code>的 <code>of</code> 或 <code>parse</code> 方法。</p><h3 id="日期计算"><a href="#日期计算" class="headerlink" title="日期计算"></a>日期计算</h3><p>下面仅以<strong>一周后日期</strong>为例，其他单位（年、月、日、1&#x2F;2 日、时等等）大同小异。另外，这些单位都在 <em>java.time.temporal.ChronoUnit</em> 枚举中定义。</p><p><strong>Java 8 之前:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterDay</span><span class="params">()</span>&#123;</span><br><span class="line">     <span class="comment">//一周后的日期</span></span><br><span class="line">     <span class="type">SimpleDateFormat</span> <span class="variable">formatDate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">     <span class="type">Calendar</span> <span class="variable">ca</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">     ca.add(Calendar.DATE, <span class="number">7</span>);</span><br><span class="line">     <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> ca.getTime();</span><br><span class="line">     <span class="type">String</span> <span class="variable">after</span> <span class="operator">=</span> formatDate.format(d);</span><br><span class="line">     System.out.println(<span class="string">&quot;一周后日期：&quot;</span> + after);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//算两个日期间隔多少天，计算间隔多少年，多少月方法类似</span></span><br><span class="line">     <span class="type">String</span> <span class="variable">dates1</span> <span class="operator">=</span> <span class="string">&quot;2021-12-23&quot;</span>;</span><br><span class="line">   <span class="type">String</span> <span class="variable">dates2</span> <span class="operator">=</span> <span class="string">&quot;2021-02-26&quot;</span>;</span><br><span class="line">     <span class="type">SimpleDateFormat</span> <span class="variable">format</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">     <span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> format.parse(dates1);</span><br><span class="line">     <span class="type">Date</span> <span class="variable">date2</span> <span class="operator">=</span> format.parse(dates2);</span><br><span class="line">     <span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> (<span class="type">int</span>) ((date1.getTime() - date2.getTime()) / (<span class="number">1000</span> * <span class="number">3600</span> * <span class="number">24</span>));</span><br><span class="line">     System.out.println(dates1 + <span class="string">&quot;和&quot;</span> + dates2 + <span class="string">&quot;相差&quot;</span> + day + <span class="string">&quot;天&quot;</span>);</span><br><span class="line">     <span class="comment">//结果：2021-02-26和2021-12-23相差300天</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Java 8 之后:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushWeek</span><span class="params">()</span>&#123;</span><br><span class="line">     <span class="comment">//一周后的日期</span></span><br><span class="line">     <span class="type">LocalDate</span> <span class="variable">localDate</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">     <span class="comment">//方法1</span></span><br><span class="line">     <span class="type">LocalDate</span> <span class="variable">after</span> <span class="operator">=</span> localDate.plus(<span class="number">1</span>, ChronoUnit.WEEKS);</span><br><span class="line">     <span class="comment">//方法2</span></span><br><span class="line">     <span class="type">LocalDate</span> <span class="variable">after2</span> <span class="operator">=</span> localDate.plusWeeks(<span class="number">1</span>);</span><br><span class="line">     System.out.println(<span class="string">&quot;一周后日期：&quot;</span> + after);</span><br><span class="line"></span><br><span class="line">     <span class="comment">//算两个日期间隔多少天，计算间隔多少年，多少月</span></span><br><span class="line">     <span class="type">LocalDate</span> <span class="variable">date1</span> <span class="operator">=</span> LocalDate.parse(<span class="string">&quot;2021-02-26&quot;</span>);</span><br><span class="line">     <span class="type">LocalDate</span> <span class="variable">date2</span> <span class="operator">=</span> LocalDate.parse(<span class="string">&quot;2021-12-23&quot;</span>);</span><br><span class="line">     <span class="type">Period</span> <span class="variable">period</span> <span class="operator">=</span> Period.between(date1, date2);</span><br><span class="line">     System.out.println(<span class="string">&quot;date1 到 date2 相隔：&quot;</span></span><br><span class="line">                + period.getYears() + <span class="string">&quot;年&quot;</span></span><br><span class="line">                + period.getMonths() + <span class="string">&quot;月&quot;</span></span><br><span class="line">                + period.getDays() + <span class="string">&quot;天&quot;</span>);</span><br><span class="line">   <span class="comment">//打印结果是 “date1 到 date2 相隔：0年9月27天”</span></span><br><span class="line">     <span class="comment">//这里period.getDays()得到的天是抛去年月以外的天数，并不是总天数</span></span><br><span class="line">     <span class="comment">//如果要获取纯粹的总天数应该用下面的方法</span></span><br><span class="line">     <span class="type">long</span> <span class="variable">day</span> <span class="operator">=</span> date2.toEpochDay() - date1.toEpochDay();</span><br><span class="line">     System.out.println(date1 + <span class="string">&quot;和&quot;</span> + date2 + <span class="string">&quot;相差&quot;</span> + day + <span class="string">&quot;天&quot;</span>);</span><br><span class="line">     <span class="comment">//打印结果：2021-02-26和2021-12-23相差300天</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取指定日期"><a href="#获取指定日期" class="headerlink" title="获取指定日期"></a>获取指定日期</h3><p>除了日期计算繁琐，获取特定一个日期也很麻烦，比如获取本月最后一天，第一天。</p><p><strong>Java 8 之前:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDay</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">format</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">        <span class="comment">//获取当前月第一天：</span></span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">c</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        c.set(Calendar.DAY_OF_MONTH, <span class="number">1</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">first</span> <span class="operator">=</span> format.format(c.getTime());</span><br><span class="line">        System.out.println(<span class="string">&quot;first day:&quot;</span> + first);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取当前月最后一天</span></span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">ca</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        ca.set(Calendar.DAY_OF_MONTH, ca.getActualMaximum(Calendar.DAY_OF_MONTH));</span><br><span class="line">        <span class="type">String</span> <span class="variable">last</span> <span class="operator">=</span> format.format(ca.getTime());</span><br><span class="line">        System.out.println(<span class="string">&quot;last day:&quot;</span> + last);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当年最后一天</span></span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">currCal</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        calendar.clear();</span><br><span class="line">        calendar.set(Calendar.YEAR, currCal.get(Calendar.YEAR));</span><br><span class="line">        calendar.roll(Calendar.DAY_OF_YEAR, -<span class="number">1</span>);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">time</span> <span class="operator">=</span> calendar.getTime();</span><br><span class="line">        System.out.println(<span class="string">&quot;last day:&quot;</span> + format.format(time));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Java 8 之后:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getDayNew</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">today</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">    <span class="comment">//获取当前月第一天：</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">firstDayOfThisMonth</span> <span class="operator">=</span> today.with(TemporalAdjusters.firstDayOfMonth());</span><br><span class="line">    <span class="comment">// 取本月最后一天</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">lastDayOfThisMonth</span> <span class="operator">=</span> today.with(TemporalAdjusters.lastDayOfMonth());</span><br><span class="line">    <span class="comment">//取下一天：</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">nextDay</span> <span class="operator">=</span> lastDayOfThisMonth.plusDays(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//当年最后一天</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">lastday</span> <span class="operator">=</span> today.with(TemporalAdjusters.lastDayOfYear());</span><br><span class="line">    <span class="comment">//2021年最后一个周日，如果用Calendar是不得烦死。</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">lastMondayOf2021</span> <span class="operator">=</span> LocalDate.parse(<span class="string">&quot;2021-12-31&quot;</span>).with(TemporalAdjusters.lastInMonth(DayOfWeek.SUNDAY));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>java.time.temporal.TemporalAdjusters</code> 里面还有很多便捷的算法，这里就不带大家看 Api 了，都很简单，看了秒懂。</p><h3 id="JDBC-和-java8"><a href="#JDBC-和-java8" class="headerlink" title="JDBC 和 java8"></a>JDBC 和 java8</h3><p>现在 jdbc 时间类型和 java8 时间类型对应关系是</p><ol><li><code>Date</code> —&gt; <code>LocalDate</code></li><li><code>Time</code> —&gt; <code>LocalTime</code></li><li><code>Timestamp</code> —&gt; <code>LocalDateTime</code></li></ol><p>而之前统统对应 <code>Date</code>，也只有 <code>Date</code>。</p><h3 id="时区"><a href="#时区" class="headerlink" title="时区"></a>时区</h3><blockquote><p>时区：正式的时区划分为每隔经度 15° 划分一个时区，全球共 24 个时区，每个时区相差 1 小时。但为了行政上的方便，常将 1 个国家或 1 个省份划在一起，比如我国幅员宽广，大概横跨 5 个时区，实际上只用东八时区的标准时即北京时间为准。</p></blockquote><p><code>java.util.Date</code> 对象实质上存的是 1970 年 1 月 1 日 0 点（ GMT）至 Date 对象所表示时刻所经过的毫秒数。也就是说不管在哪个时区 new Date，它记录的毫秒数都一样，和时区无关。但在使用上应该把它转换成当地时间，这就涉及到了时间的国际化。<code>java.util.Date</code> 本身并不支持国际化，需要借助 <code>TimeZone</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//北京时间：Wed Jan 27 14:05:29 CST 2021</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">bjSdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="comment">//北京时区</span></span><br><span class="line">bjSdf.setTimeZone(TimeZone.getTimeZone(<span class="string">&quot;Asia/Shanghai&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;毫秒数:&quot;</span> + date.getTime() + <span class="string">&quot;, 北京时间:&quot;</span> + bjSdf.format(date));</span><br><span class="line"></span><br><span class="line"><span class="comment">//东京时区</span></span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">tokyoSdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">tokyoSdf.setTimeZone(TimeZone.getTimeZone(<span class="string">&quot;Asia/Tokyo&quot;</span>));  <span class="comment">// 设置东京时区</span></span><br><span class="line">System.out.println(<span class="string">&quot;毫秒数:&quot;</span> + date.getTime() + <span class="string">&quot;, 东京时间:&quot;</span> + tokyoSdf.format(date));</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果直接print会自动转成当前时区的时间</span></span><br><span class="line">System.out.println(date);</span><br><span class="line"><span class="comment">//Wed Jan 27 14:05:29 CST 2021</span></span><br></pre></td></tr></table></figure><p>在新特性中引入了 <code>java.time.ZonedDateTime</code> 来表示带时区的时间。它可以看成是 <code>LocalDateTime + ZoneId</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前时区时间</span></span><br><span class="line"><span class="type">ZonedDateTime</span> <span class="variable">zonedDateTime</span> <span class="operator">=</span> ZonedDateTime.now();</span><br><span class="line">System.out.println(<span class="string">&quot;当前时区时间: &quot;</span> + zonedDateTime);</span><br><span class="line"></span><br><span class="line"><span class="comment">//东京时间</span></span><br><span class="line"><span class="type">ZoneId</span> <span class="variable">zoneId</span> <span class="operator">=</span> ZoneId.of(ZoneId.SHORT_IDS.get(<span class="string">&quot;JST&quot;</span>));</span><br><span class="line"><span class="type">ZonedDateTime</span> <span class="variable">tokyoTime</span> <span class="operator">=</span> zonedDateTime.withZoneSameInstant(zoneId);</span><br><span class="line">System.out.println(<span class="string">&quot;东京时间: &quot;</span> + tokyoTime);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ZonedDateTime 转 LocalDateTime</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> tokyoTime.toLocalDateTime();</span><br><span class="line">System.out.println(<span class="string">&quot;东京时间转当地时间: &quot;</span> + localDateTime);</span><br><span class="line"></span><br><span class="line"><span class="comment">//LocalDateTime 转 ZonedDateTime</span></span><br><span class="line"><span class="type">ZonedDateTime</span> <span class="variable">localZoned</span> <span class="operator">=</span> localDateTime.atZone(ZoneId.systemDefault());</span><br><span class="line">System.out.println(<span class="string">&quot;本地时区时间: &quot;</span> + localZoned);</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line">当前时区时间: <span class="number">2021</span>-<span class="number">01</span>-27T14:<span class="number">43</span>:<span class="number">58.735</span>+08:<span class="number">00</span>[Asia/Shanghai]</span><br><span class="line">东京时间: <span class="number">2021</span>-<span class="number">01</span>-27T15:<span class="number">43</span>:<span class="number">58.735</span>+09:<span class="number">00</span>[Asia/Tokyo]</span><br><span class="line">东京时间转当地时间: <span class="number">2021</span>-<span class="number">01</span>-27T15:<span class="number">43</span>:<span class="number">58.735</span></span><br><span class="line">当地时区时间: <span class="number">2021</span>-<span class="number">01</span>-27T15:<span class="number">53</span>:<span class="number">35.618</span>+08:<span class="number">00</span>[Asia/Shanghai]</span><br></pre></td></tr></table></figure><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>通过上面比较新老 <code>Date</code> 的不同，当然只列出部分功能上的区别，更多功能还得自己去挖掘。总之 date-time-api 给日期操作带来了福利。在日常工作中遇到 date 类型的操作，第一考虑的是 date-time-api，实在解决不了再考虑老的 Date。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们梳理总结的 java 8 新特性有</p><ul><li>Interface &amp; functional Interface</li><li>Lambda</li><li>Stream</li><li>Optional</li><li>Date time-api</li></ul><p>这些都是开发当中比较常用的特性。梳理下来发现它们真香，而我却没有更早的应用。总觉得学习 java 8 新特性比较麻烦，一直使用老的实现方式。其实这些新特性几天就可以掌握，一但掌握，效率会有很大的提高。其实我们涨工资也是涨的学习的钱，不学习终究会被淘汰，35 岁危机会提前来临。</p><!-- @include: @article-footer.snippet.md -->]]></content>
      
      
      <categories>
          
          <category> Java核心系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java核心 </tag>
            
            <tag> Java版本新特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java核心编程-JVM</title>
      <link href="/2025/02/18/Java%E5%9B%9E%E9%A1%BE-JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
      <url>/2025/02/18/Java%E5%9B%9E%E9%A1%BE-JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="虚拟机篇"><a href="#虚拟机篇" class="headerlink" title="虚拟机篇"></a>虚拟机篇</h1><h2 id="1-JVM-内存结构"><a href="#1-JVM-内存结构" class="headerlink" title="1. JVM 内存结构"></a>1. JVM 内存结构</h2><p><strong>要求</strong></p><ul><li>掌握 JVM 内存结构划分</li><li>尤其要知道方法区、永久代、元空间的关系</li></ul><p><strong>结合一段 java 代码的执行理解内存划分</strong></p><ul><li>执行 javac 命令编译源代码为字节码</li><li>执行 java 命令<ol><li>创建 JVM，调用类加载子系统加载 class，将类的信息存入<strong>方法区</strong></li><li>创建 main 线程，使用的内存区域是 <strong>JVM 虚拟机栈</strong>，开始执行 main 方法代码</li><li>如果遇到了未见过的类，会继续触发类加载过程，同样会存入<strong>方法区</strong></li><li>需要创建对象，会使用<strong>堆</strong>内存来存储对象</li><li>不再使用的对象，会由<strong>垃圾回收器</strong>在内存不足时回收其内存</li><li>调用方法时，方法内的局部变量、方法参数所使用的是  <strong>JVM 虚拟机栈</strong>中的栈帧内存</li><li>调用方法时，先要到<strong>方法区</strong>获得到该方法的字节码指令，由<strong>解释器</strong>将字节码指令解释为机器码执行</li><li>调用方法时，会将要执行的指令行号读到<strong>程序计数器</strong>，这样当发生了线程切换，恢复时就可以从中断的位置继续</li><li>对于非 java 实现的方法调用，使用内存称为<strong>本地方法栈</strong>（见说明）</li><li>对于热点方法调用，或者频繁的循环代码，由 <strong>JIT 即时编译器</strong>将这些代码编译成机器码缓存，提高执行性能</li></ol></li></ul><p>说明</p><ul><li>加粗字体代表了 JVM 虚拟机组件</li><li>对于 Oracle 的 Hotspot 虚拟机实现，不区分虚拟机栈和本地方法栈</li></ul><p><strong>会发生内存溢出的区域</strong></p><ul><li>不会出现内存溢出的区域 – 程序计数器</li><li>出现 OutOfMemoryError 的情况<ul><li>堆内存耗尽 – 对象越来越多，又一直在使用，不能被垃圾回收</li><li>方法区内存耗尽 – 加载的类越来越多，很多框架都会在运行期间动态产生新的类</li><li>虚拟机栈累积 – 每个线程最多会占用 1 M 内存，线程个数越来越多，而又长时间运行不销毁时</li></ul></li><li>出现 StackOverflowError 的区域<ul><li>JVM 虚拟机栈，原因有方法递归调用未正确结束、反序列化 json 时循环引用</li></ul></li></ul><p><strong>方法区、永久代、元空间</strong></p><ul><li><strong>方法区</strong>是 JVM 规范中定义的一块内存区域，用来存储类元数据、方法字节码、即时编译器需要的信息等</li><li><strong>永久代</strong>是 Hotspot 虚拟机对 JVM 规范的实现（1.8 之前）</li><li><strong>元空间</strong>是 Hotspot 虚拟机对 JVM 规范的另一种实现（1.8 以后），使用本地内存作为这些信息的存储空间</li></ul><p>从这张图学到三点</p><ul><li>当第一次用到某个类是，由类加载器将 class 文件的类元信息读入，并存储于元空间</li><li>X，Y 的类元信息是存储于元空间中，无法直接访问</li><li>可以用 X.class，Y.class 间接访问类元信息，它们俩属于 java 对象，我们的代码中可以使用</li></ul><p>从这张图可以学到</p><ul><li>堆内存中：当一个<strong>类加载器对象</strong>，这个类加载器对象加载的所有<strong>类对象</strong>，这些类对象对应的所有<strong>实例对象</strong>都没人引用时，GC 时就会对它们占用的对内存进行释放</li><li>元空间中：内存释放<strong>以类加载器为单位</strong>，当堆中类加载器内存释放时，对应的元空间中的类元信息也会释放</li></ul><h2 id="2-JVM-内存参数"><a href="#2-JVM-内存参数" class="headerlink" title="2. JVM 内存参数"></a>2. JVM 内存参数</h2><p><strong>要求</strong> </p><ul><li>熟悉常见的 JVM 参数，尤其和大小相关的</li></ul><p><strong>堆内存，按大小设置</strong></p><p>解释：</p><ul><li>-Xms 最小堆内存（包括新生代和老年代）</li><li>-Xmx 最大对内存（包括新生代和老年代）</li><li>通常建议将 -Xms 与 -Xmx 设置为大小相等，即不需要保留内存，不需要从小到大增长，这样性能较好</li><li>-XX:NewSize 与 -XX:MaxNewSize 设置新生代的最小与最大值，但一般不建议设置，由 JVM 自己控制</li><li>-Xmn 设置新生代大小，相当于同时设置了 -XX:NewSize 与 -XX:MaxNewSize 并且取值相等</li><li>保留是指，一开始不会占用那么多内存，随着使用内存越来越多，会逐步使用这部分保留内存。下同</li></ul><p><strong>堆内存，按比例设置</strong></p><p>解释：</p><ul><li>-XX:NewRatio&#x3D;2:1 表示老年代占两份，新生代占一份</li><li>-XX:SurvivorRatio&#x3D;4:1 表示新生代分成六份，伊甸园占四份，from 和 to 各占一份</li></ul><p><strong>元空间内存设置</strong></p><p>解释：</p><ul><li>class space 存储类的基本信息，最大值受 -XX:CompressedClassSpaceSize 控制</li><li>non-class space 存储除类的基本信息以外的其它信息（如方法字节码、注解等）</li><li>class space 和 non-class space 总大小受 -XX:MaxMetaspaceSize 控制</li></ul><p>注意：</p><ul><li>这里 -XX:CompressedClassSpaceSize 这段空间还与是否开启了指针压缩有关，这里暂不深入展开，可以简单认为指针压缩默认开启</li></ul><p><strong>代码缓存内存设置</strong></p><p>解释：</p><ul><li>如果 -XX:ReservedCodeCacheSize &lt; 240m，所有优化机器代码不加区分存在一起</li><li>否则，分成三个区域（图中笔误 mthod 拼写错误，少一个 e）<ul><li>non-nmethods - JVM 自己用的代码</li><li>profiled nmethods - 部分优化的机器码</li><li>non-profiled nmethods - 完全优化的机器码</li></ul></li></ul><p><strong>线程内存设置</strong></p><blockquote><p><em><strong>官方参考文档</strong></em></p><ul><li><a href="https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE">https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE</a></li></ul></blockquote><h2 id="3-JVM-垃圾回收"><a href="#3-JVM-垃圾回收" class="headerlink" title="3. JVM 垃圾回收"></a>3. JVM 垃圾回收</h2><p><strong>要求</strong></p><ul><li>掌握垃圾回收算法</li><li>掌握分代回收思想</li><li>理解三色标记及漏标处理</li><li>了解常见垃圾回收器</li></ul><p><strong>三种垃圾回收算法</strong></p><p><strong>标记清除法</strong></p><p>解释：</p><ol><li>找到 GC Root 对象，即那些一定不会被回收的对象，如正执行方法内局部变量引用的对象、静态变量引用的对象</li><li>标记阶段：沿着 GC Root 对象的引用链找，直接或间接引用到的对象加上标记</li><li>清除阶段：释放未加标记的对象占用的内存</li></ol><p>要点：</p><ul><li>标记速度与存活对象线性关系</li><li>清除速度与内存大小线性关系</li><li>缺点是会产生内存碎片</li></ul><p>标记整理法</p><p>解释：</p><ol><li>前面的标记阶段、清理阶段与标记清除法类似</li><li>多了一步整理的动作，将存活对象向一端移动，可以避免内存碎片产生</li></ol><p>特点：</p><ul><li><p>标记速度与存活对象线性关系</p></li><li><p>清除与整理速度与内存大小成线性关系</p></li><li><p>缺点是性能上较慢</p></li></ul><p><strong>标记复制法</strong></p><p>解释：</p><ol><li>将整个内存分成两个大小相等的区域，from 和 to，其中 to 总是处于空闲，from 存储新创建的对象</li><li>标记阶段与前面的算法类似</li><li>在找出存活对象后，会将它们从 from 复制到 to 区域，复制的过程中自然完成了碎片整理</li><li>复制完成后，交换 from 和 to 的位置即可</li></ol><p>特点：</p><ul><li>标记与复制速度与存活对象成线性关系</li><li>缺点是会占用成倍的空间</li></ul><p><strong>GC 与分代回收算法</strong></p><p>GC 的目的在于实现无用对象内存自动释放，减少内存碎片、加快分配速度</p><p>GC 要点：</p><ul><li>回收区域是<strong>堆内存</strong>，不包括虚拟机栈</li><li>判断无用对象，使用<strong>可达性分析算法</strong>，<strong>三色标记法</strong>标记存活对象，回收未标记对象</li><li>GC 具体的实现称为<strong>垃圾回收器</strong></li><li>GC 大都采用了<strong>分代回收思想</strong><ul><li>理论依据是大部分对象朝生夕灭，用完立刻就可以回收，另有少部分对象会长时间存活，每次很难回收</li><li>根据这两类对象的特性将回收区域分为<strong>新生代</strong>和<strong>老年代</strong>，新生代采用标记复制法、老年代一般采用标记整理法</li></ul></li><li>根据 GC 的规模可以分成 <strong>Minor GC</strong>，<strong>Mixed GC</strong>，<strong>Full GC</strong></li></ul><p><strong>分代回收</strong></p><ol><li><p>伊甸园 eden，最初对象都分配到这里，与幸存区 survivor（分成 from 和 to）合称新生代，</p></li><li><p>当伊甸园内存不足，标记伊甸园与 from（现阶段没有）的存活对象</p></li><li><p>将存活对象采用复制算法复制到 to 中，复制完毕后，伊甸园和 from 内存都得到释放</p></li><li><p>将 from 和 to 交换位置</p></li><li><p>经过一段时间后伊甸园的内存又出现不足</p></li><li><p>标记伊甸园与 from（现阶段没有）的存活对象</p></li><li><p>将存活对象采用复制算法复制到 to 中</p></li><li><p>复制完毕后，伊甸园和 from 内存都得到释放</p></li><li><p>将 from 和 to 交换位置</p></li><li><p>老年代 old，当幸存区对象熬过几次回收（最多15次），晋升到老年代（幸存区内存不足或大对象会导致提前晋升）</p></li></ol><p><strong>GC 规模</strong></p><ul><li><p>Minor GC 发生在新生代的垃圾回收，暂停时间短</p></li><li><p>Mixed GC 新生代 + 老年代部分区域的垃圾回收，G1 收集器特有</p></li><li><p>Full GC 新生代 + 老年代完整垃圾回收，暂停时间长，<strong>应尽力避免</strong></p></li></ul><p><strong>三色标记</strong></p><p>即用三种颜色记录对象的标记状态</p><ul><li>黑色 – 已标记</li><li>灰色 – 标记中</li><li>白色 – 还未标记</li></ul><ol><li><p>起始的三个对象还未处理完成，用灰色表示</p></li><li><p>该对象的引用已经处理完成，用黑色表示，黑色引用的对象变为灰色</p></li><li><p>依次类推</p></li><li><p>沿着引用链都标记了一遍</p></li><li><p>最后为标记的白色对象，即为垃圾</p></li></ol><p><strong>并发漏标问题</strong></p><p>比较先进的垃圾回收器都支持<strong>并发标记</strong>，即在标记过程中，用户线程仍然能工作。但这样带来一个新的问题，如果用户线程修改了对象引用，那么就存在漏标问题。例如：</p><ol><li><p>如图所示标记工作尚未完成</p></li><li><p>用户线程同时在工作，断开了第一层 3、4 两个对象之间的引用，这时对于正在处理 3 号对象的垃圾回收线程来讲，它会将 4 号对象当做是白色垃圾</p></li><li><p>但如果其他用户线程又建立了 2、4 两个对象的引用，这时因为 2 号对象是黑色已处理对象了，因此垃圾回收线程不会察觉到这个引用关系的变化，从而产生了漏标</p></li><li><p>如果用户线程让黑色对象引用了一个新增对象，一样会存在漏标问题</p></li></ol><p>因此对于<strong>并发标记</strong>而言，必须解决漏标问题，也就是要记录标记过程中的变化。有两种解决方法：</p><ol><li>Incremental Update 增量更新法，CMS 垃圾回收器采用<ul><li>思路是拦截每次赋值动作，只要赋值发生，被赋值的对象就会被记录下来，在重新标记阶段再确认一遍</li></ul></li><li>Snapshot At The Beginning，SATB 原始快照法，G1 垃圾回收器采用<ul><li>思路也是拦截每次赋值动作，不过记录的对象不同，也需要在重新标记阶段对这些对象二次处理</li><li>新加对象会被记录</li><li>被删除引用关系的对象也被记录</li></ul></li></ol><p><strong>垃圾回收器 - Parallel GC</strong></p><ul><li><p>eden 内存不足发生 Minor GC，采用标记复制算法，需要暂停用户线程</p></li><li><p>old 内存不足发生 Full GC，采用标记整理算法，需要暂停用户线程</p></li><li><p><strong>注重吞吐量</strong></p></li></ul><p><strong>垃圾回收器 - ConcurrentMarkSweep GC</strong></p><ul><li><p>它是工作在 old 老年代，支持<strong>并发标记</strong>的一款回收器，采用<strong>并发清除</strong>算法</p><ul><li>并发标记时不需暂停用户线程</li><li>重新标记时仍需暂停用户线程</li></ul></li><li><p>如果并发失败（即回收速度赶不上创建新对象速度），会触发 Full GC</p></li><li><p><strong>注重响应时间</strong></p></li></ul><p><strong>垃圾回收器 - G1 GC</strong></p><ul><li><strong>响应时间与吞吐量兼顾</strong></li><li>划分成多个区域，每个区域都可以充当 eden，survivor，old， humongous，其中 humongous 专为大对象准备</li><li>分成三个阶段：新生代回收、并发标记、混合收集</li><li>如果并发失败（即回收速度赶不上创建新对象速度），会触发 Full GC</li></ul><p><strong>G1 回收阶段 - 新生代回收</strong></p><ol><li><p>初始时，所有区域都处于空闲状态</p></li><li><p>创建了一些对象，挑出一些空闲区域作为伊甸园区存储这些对象</p></li><li><p>当伊甸园需要垃圾回收时，挑出一个空闲区域作为幸存区，用复制算法复制存活对象，需要暂停用户线程</p></li><li><p>复制完成，将之前的伊甸园内存释放</p></li><li><p>随着时间流逝，伊甸园的内存又有不足</p></li><li><p>将伊甸园以及之前幸存区中的存活对象，采用复制算法，复制到新的幸存区，其中较老对象晋升至老年代</p></li><li><p>释放伊甸园以及之前幸存区的内存</p></li></ol><p><strong>G1 回收阶段 - 并发标记与混合收集</strong></p><ol><li><p>当老年代占用内存超过阈值后，触发并发标记，这时无需暂停用户线程</p></li><li><p>并发标记之后，会有重新标记阶段解决漏标问题，此时需要暂停用户线程。这些都完成后就知道了老年代有哪些存活对象，随后进入混合收集阶段。此时不会对所有老年代区域进行回收，而是根据<strong>暂停时间目标</strong>优先回收价值高（存活对象少）的区域（这也是 Gabage First 名称的由来）。</p></li><li><p>混合收集阶段中，参与复制的有 eden、survivor、old，下图显示了伊甸园和幸存区的存活对象复制</p></li><li><p>下图显示了老年代和幸存区晋升的存活对象的复制</p></li><li><p>复制完成，内存得到释放。进入下一轮的新生代回收、并发标记、混合收集</p></li></ol><h2 id="4-内存溢出"><a href="#4-内存溢出" class="headerlink" title="4. 内存溢出"></a>4. 内存溢出</h2><p><strong>要求</strong></p><ul><li>能够说出几种典型的导致内存溢出的情况</li></ul><p><strong>典型情况</strong></p><ul><li>误用线程池导致的内存溢出<ul><li>参考 day03.TestOomThreadPool</li></ul></li><li>查询数据量太大导致的内存溢出<ul><li>参考 day03.TestOomTooManyObject</li></ul></li><li>动态生成类导致的内存溢出<ul><li>参考 day03.TestOomTooManyClass</li></ul></li></ul><h2 id="5-类加载"><a href="#5-类加载" class="headerlink" title="5. 类加载"></a>5. 类加载</h2><p><strong>要求</strong></p><ul><li>掌握类加载阶段</li><li>掌握类加载器</li><li>理解双亲委派机制</li></ul><p><strong>类加载过程的三个阶段</strong></p><ol><li><p>加载</p><ol><li><p>将类的字节码载入方法区，并创建类.class 对象</p></li><li><p>如果此类的父类没有加载，先加载父类</p></li><li><p>加载是懒惰执行</p></li></ol></li><li><p>链接</p><ol><li>验证 – 验证类是否符合 Class 规范，合法性、安全性检查</li><li>准备 – 为 static 变量分配空间，设置默认值</li><li>解析 – 将常量池的符号引用解析为直接引用</li></ol></li><li><p>初始化</p><ol><li>静态代码块、static 修饰的变量赋值、static final 修饰的引用类型变量赋值，会被合并成一个 <code>&lt;cinit&gt;</code> 方法，在初始化时被调用</li><li>static final 修饰的基本类型变量赋值，在链接阶段就已完成</li><li>初始化是懒惰执行</li></ol></li></ol><blockquote><p><em><strong>验证手段</strong></em></p><ul><li>使用 jps 查看进程号</li><li>使用 jhsdb 调试，执行命令 <code>jhsdb.exe hsdb</code> 打开它的图形界面<ul><li>Class Browser 可以查看当前 jvm 中加载了哪些类</li><li>控制台的 universe 命令查看堆内存范围</li><li>控制台的 g1regiondetails 命令查看 region 详情</li><li><code>scanoops 起始地址 结束地址 对象类型</code> 可以根据类型查找某个区间内的对象地址</li><li>控制台的 <code>inspect 地址</code> 指令能够查看这个地址对应的对象详情</li></ul></li><li>使用 javap 命令可以查看 class 字节码</li></ul></blockquote><blockquote><p><em><strong>代码说明</strong></em></p><ul><li>day03.loader.TestLazy - 验证类的加载是懒惰的，用到时才触发类加载</li><li>day03.loader.TestFinal - 验证使用 final 修饰的变量不会触发类加载</li></ul></blockquote><p><strong>jdk 8 的类加载器</strong></p><table><thead><tr><th><strong>名称</strong></th><th><strong>加载哪的类</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>Bootstrap ClassLoader</td><td>JAVA_HOME&#x2F;jre&#x2F;lib</td><td>无法直接访问</td></tr><tr><td>Extension ClassLoader</td><td>JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext</td><td>上级为 Bootstrap，显示为  null</td></tr><tr><td>Application ClassLoader</td><td>classpath</td><td>上级为 Extension</td></tr><tr><td>自定义类加载器</td><td>自定义</td><td>上级为 Application</td></tr></tbody></table><p><strong>双亲委派机制</strong></p><p>所谓的双亲委派，就是指优先委派上级类加载器进行加载，如果上级类加载器</p><ul><li>能找到这个类，由上级加载，加载后该类也对下级加载器可见</li><li>找不到这个类，则下级类加载器才有资格执行加载</li></ul><p>双亲委派的目的有两点</p><ol><li><p>让上级类加载器中的类对下级共享（反之不行），即能让你的类能依赖到 jdk 提供的核心类</p></li><li><p>让类的加载有优先次序，保证核心类优先加载</p></li></ol><p><strong>对双亲委派的误解</strong></p><p>下面面试题的回答是错误的</p><p>错在哪了？</p><ul><li><p>自己编写类加载器就能加载一个假冒的 java.lang.System 吗? 答案是不行。</p></li><li><p>假设你自己的类加载器用双亲委派，那么优先由启动类加载器加载真正的 java.lang.System，自然不会加载假冒的</p></li><li><p>假设你自己的类加载器不用双亲委派，那么你的类加载器加载假冒的 java.lang.System 时，它需要先加载父类 java.lang.Object，而你没有用委派，找不到 java.lang.Object 所以加载会失败</p></li><li><p><strong>以上也仅仅是假设</strong>。事实上操作你就会发现，自定义类加载器加载以 java. 打头的类时，会抛安全异常，在 jdk9 以上版本这些特殊包名都与模块进行了绑定，更连编译都过不了</p></li></ul><blockquote><p><em><strong>代码说明</strong></em></p><ul><li>day03.loader.TestJdk9ClassLoader - 演示类加载器与模块的绑定关系</li></ul></blockquote><h2 id="6-四种引用"><a href="#6-四种引用" class="headerlink" title="6. 四种引用"></a>6. 四种引用</h2><p><strong>要求</strong></p><ul><li>掌握四种引用</li></ul><p><strong>强引用</strong></p><ol><li><p>普通变量赋值即为强引用，如 A a &#x3D; new A();</p></li><li><p>通过 GC Root 的引用链，如果强引用不到该对象，该对象才能被回收</p></li></ol><p><strong>软引用（SoftReference）</strong></p><ol><li><p>例如：SoftReference a &#x3D; new SoftReference(new A());</p></li><li><p>如果仅有软引用该对象时，首次垃圾回收不会回收该对象，如果内存仍不足，再次回收时才会释放对象</p></li><li><p>软引用自身需要配合引用队列来释放</p></li><li><p>典型例子是反射数据</p></li></ol><p><strong>弱引用（WeakReference）</strong></p><ol><li><p>例如：WeakReference a &#x3D; new WeakReference(new A());</p></li><li><p>如果仅有弱引用引用该对象时，只要发生垃圾回收，就会释放该对象</p></li><li><p>弱引用自身需要配合引用队列来释放</p></li><li><p>典型例子是 ThreadLocalMap 中的 Entry 对象</p></li></ol><p><strong>虚引用（PhantomReference）</strong></p><ol><li><p>例如： PhantomReference a &#x3D; new PhantomReference(new A(), referenceQueue);</p></li><li><p>必须配合引用队列一起使用，当虚引用所引用的对象被回收时，由 Reference Handler 线程将虚引用对象入队，这样就可以知道哪些对象被回收，从而对它们关联的资源做进一步处理</p></li><li><p>典型例子是 Cleaner 释放 DirectByteBuffer 关联的直接内存</p></li></ol><blockquote><p><em><strong>代码说明</strong></em></p><ul><li>day03.reference.TestPhantomReference - 演示虚引用的基本用法</li><li>day03.reference.TestWeakReference - 模拟 ThreadLocalMap, 采用引用队列释放 entry 内存</li></ul></blockquote><h2 id="7-finalize"><a href="#7-finalize" class="headerlink" title="7. finalize"></a>7. finalize</h2><p><strong>要求</strong></p><ul><li>掌握 finalize 的工作原理与缺点</li></ul><p><strong>finalize</strong></p><ul><li>它是 Object 中的一个方法，如果子类重写它，垃圾回收时此方法会被调用，可以在其中进行资源释放和清理工作</li><li>将资源释放和清理放在 finalize 方法中非常不好，非常影响性能，严重时甚至会引起 OOM，从 Java9 开始就被标注为 @Deprecated，不建议被使用了</li></ul><p><strong>finalize 原理</strong></p><ol><li><p>对 finalize 方法进行处理的核心逻辑位于 java.lang.ref.Finalizer 类中，它包含了名为 unfinalized 的静态变量（双向链表结构），Finalizer 也可被视为另一种引用对象（地位与软、弱、虚相当，只是不对外，无法直接使用）</p></li><li><p>当重写了 finalize 方法的对象，在构造方法调用之时，JVM 都会将其包装成一个 Finalizer 对象，并加入 unfinalized 链表中</p></li><li><p>Finalizer 类中还有另一个重要的静态变量，即 ReferenceQueue 引用队列，刚开始它是空的。当狗对象可以被当作垃圾回收时，就会把这些狗对象对应的 Finalizer 对象加入此引用队列</p></li><li><p>但此时 Dog 对象还没法被立刻回收，因为 unfinalized -&gt; Finalizer 这一引用链还在引用它嘛，为的是【先别着急回收啊，等我调完 finalize 方法，再回收】</p></li><li><p>FinalizerThread 线程会从 ReferenceQueue 中逐一取出每个 Finalizer 对象，把它们从链表断开并真正调用 finallize 方法</p></li><li><p>由于整个 Finalizer 对象已经从 unfinalized 链表中断开，这样没谁能引用到它和狗对象，所以下次 gc 时就被回收了</p></li></ol><p><strong>finalize 缺点</strong></p><ul><li>无法保证资源释放：FinalizerThread 是守护线程，代码很有可能没来得及执行完，线程就结束了</li><li>无法判断是否发生错误：执行 finalize 方法时，会吞掉任意异常（Throwable）</li><li>内存释放不及时：重写了 finalize 方法的对象在第一次被 gc 时，并不能及时释放它占用的内存，因为要等着 FinalizerThread 调用完 finalize，把它从 unfinalized 队列移除后，第二次 gc 时才能真正释放内存</li><li>有的文章提到【Finalizer 线程会和我们的主线程进行竞争，不过由于它的优先级较低，获取到的CPU时间较少，因此它永远也赶不上主线程的步伐】这个显然是错误的，FinalizerThread 的优先级较普通线程更高，原因应该是 finalize 串行执行慢等原因综合导致</li></ul><blockquote><p><em><strong>代码说明</strong></em></p><ul><li>day03.reference.TestFinalize - finalize 的测试代码</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java核心系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java核心 </tag>
            
            <tag> JVM虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础</title>
      <link href="/2025/02/18/Java%E5%9B%9E%E9%A1%BE-%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
      <url>/2025/02/18/Java%E5%9B%9E%E9%A1%BE-%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><blockquote><p><em><strong>基础篇要点：算法、数据结构、基础设计模式</strong></em></p></blockquote><h2 id="1-二分查找"><a href="#1-二分查找" class="headerlink" title="1. 二分查找"></a>1. 二分查找</h2><p><strong>要求</strong></p><ul><li>能够用自己语言描述二分查找算法</li><li>能够手写二分查找代码</li><li>能够解答一些变化后的考法</li></ul><p><strong>算法描述</strong></p><ol><li><p>前提：有已排序数组 A（假设已经做好）</p></li><li><p>定义左边界 L、右边界 R，确定搜索范围，循环执行二分查找（3、4两步）</p></li><li><p>获取中间索引 M &#x3D; Floor((L+R) &#x2F;2)</p></li><li><p>中间索引的值  A[M] 与待搜索的值 T 进行比较</p><p>① A[M] &#x3D;&#x3D; T 表示找到，返回中间索引</p><p>② A[M] &gt; T，中间值右侧的其它元素都大于 T，无需比较，中间索引左边去找，M - 1 设置为右边界，重新查找</p><p>③ A[M] &lt; T，中间值左侧的其它元素都小于 T，无需比较，中间索引右边去找， M + 1 设置为左边界，重新查找</p></li><li><p>当 L &gt; R 时，表示没有找到，应结束循环</p></li></ol><blockquote><p><em>更形象的描述请参考：binary_search.html</em></p></blockquote><p><strong>算法实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = a.length - <span class="number">1</span>, m;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[m] == t) &#123;</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[m] &gt; t) &#123;</span><br><span class="line">            r = m - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] array = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">19</span>, <span class="number">22</span>, <span class="number">31</span>, <span class="number">35</span>, <span class="number">40</span>, <span class="number">45</span>, <span class="number">48</span>, <span class="number">49</span>, <span class="number">50</span>&#125;;</span><br><span class="line">    <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> <span class="number">47</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> binarySearch(array, target);</span><br><span class="line">    System.out.println(idx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解决整数溢出问题</strong></p><p>当 l 和 r 都较大时，<code>l + r</code> 有可能超过整数范围，造成运算错误，解决方法有两种：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> l + (r - l) / <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>还有一种是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (l + r) &gt;&gt;&gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><strong>其它考法</strong></p><ol><li><p>有一个有序表为 1,5,8,11,19,22,31,35,40,45,48,49,50 当二分查找值为 48 的结点时，查找成功需要比较的次数 </p></li><li><p>使用二分法在序列 1,4,6,7,15,33,39,50,64,78,75,81,89,96 中查找元素 81 时，需要经过（   ）次比较</p></li><li><p>在拥有128个元素的数组中二分查找一个数，需要比较的次数最多不超过多少次</p></li></ol><p>对于前两个题目，记得一个简要判断口诀：奇数二分取中间，偶数二分取中间靠左。对于后一道题目，需要知道公式：</p><p>$$n &#x3D; log_2N &#x3D; log_{10}N&#x2F;log_{10}2$$</p><p>其中 n 为查找次数，N 为元素个数</p><h2 id="2-冒泡排序"><a href="#2-冒泡排序" class="headerlink" title="2. 冒泡排序"></a>2. 冒泡排序</h2><p><strong>要求</strong></p><ul><li>能够用自己语言描述冒泡排序算法</li><li>能够手写冒泡排序代码</li><li>了解一些冒泡排序的优化手段</li></ul><p><strong>算法描述</strong></p><ol><li>依次比较数组中相邻两个元素大小，若 a[j] &gt; a[j+1]，则交换两个元素，两两都比较一遍称为一轮冒泡，结果是让最大的元素排至最后</li><li>重复以上步骤，直到整个数组有序</li></ol><blockquote><p><em>更形象的描述请参考：bubble_sort.html</em></p></blockquote><p><strong>算法实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubble</span><span class="params">(<span class="type">int</span>[] a)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; a.length - <span class="number">1</span>; j++) &#123;</span><br><span class="line">        <span class="comment">// 一轮冒泡</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">swapped</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 是否发生了交换</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length - <span class="number">1</span> - j; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;比较次数&quot;</span> + i);</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; a[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                Utils.swap(a, i, i + <span class="number">1</span>);</span><br><span class="line">                swapped = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;第&quot;</span> + j + <span class="string">&quot;轮冒泡&quot;</span></span><br><span class="line">                           + Arrays.toString(a));</span><br><span class="line">        <span class="keyword">if</span> (!swapped) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优化点1：每经过一轮冒泡，内层循环就可以减少一次</li><li>优化点2：如果某一轮冒泡没有发生交换，则表示所有数据有序，可以结束外层循环</li></ul><p><strong>进一步优化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubble_v2</span><span class="params">(<span class="type">int</span>[] a)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> a.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 表示最后一次交换索引位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;比较次数&quot;</span> + i);</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; a[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                Utils.swap(a, i, i + <span class="number">1</span>);</span><br><span class="line">                last = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        n = last;</span><br><span class="line">        System.out.println(<span class="string">&quot;第轮冒泡&quot;</span></span><br><span class="line">                           + Arrays.toString(a));</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>每轮冒泡时，最后一次交换索引可以作为下一轮冒泡的比较次数，如果这个值为零，表示整个数组有序，直接退出外层循环即可</li></ul><h2 id="3-选择排序"><a href="#3-选择排序" class="headerlink" title="3. 选择排序"></a>3. 选择排序</h2><p><strong>要求</strong></p><ul><li>能够用自己语言描述选择排序算法</li><li>能够比较选择排序与冒泡排序</li><li>理解非稳定排序与稳定排序</li></ul><p><strong>算法描述</strong></p><ol><li><p>将数组分为两个子集，排序的和未排序的，每一轮从未排序的子集中选出最小的元素，放入排序子集</p></li><li><p>重复以上步骤，直到整个数组有序</p></li></ol><blockquote><p><em>更形象的描述请参考：selection_sort.html</em></p></blockquote><p><strong>算法实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selection</span><span class="params">(<span class="type">int</span>[] a)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// i 代表每轮选择最小元素要交换到的目标索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> i; <span class="comment">// 代表最小元素的索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> s + <span class="number">1</span>; j &lt; a.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[s] &gt; a[j]) &#123; <span class="comment">// j 元素比 s 元素还要小, 更新 s</span></span><br><span class="line">                s = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s != i) &#123;</span><br><span class="line">            swap(a, s, i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优化点：为减少交换次数，每一轮可以先找最小的索引，在每轮最后再交换元素</li></ul><p><strong>与冒泡排序比较</strong></p><ol><li><p>二者平均时间复杂度都是 $O(n^2)$</p></li><li><p>选择排序一般要快于冒泡，因为其交换次数少</p></li><li><p>但如果集合有序度高，冒泡优于选择</p></li><li><p>冒泡属于稳定排序算法，而选择属于不稳定排序</p><ul><li>稳定排序指，按对象中不同字段进行多次排序，不会打乱同值元素的顺序</li><li>不稳定排序则反之</li></ul></li></ol><p><strong>稳定排序与不稳定排序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;=================不稳定================&quot;</span>);</span><br><span class="line">Card[] cards = getStaticCards();</span><br><span class="line">System.out.println(Arrays.toString(cards));</span><br><span class="line">selection(cards, Comparator.comparingInt((Card a) -&gt; a.sharpOrder).reversed());</span><br><span class="line">System.out.println(Arrays.toString(cards));</span><br><span class="line">selection(cards, Comparator.comparingInt((Card a) -&gt; a.numberOrder).reversed());</span><br><span class="line">System.out.println(Arrays.toString(cards));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;=================稳定=================&quot;</span>);</span><br><span class="line">cards = getStaticCards();</span><br><span class="line">System.out.println(Arrays.toString(cards));</span><br><span class="line">bubble(cards, Comparator.comparingInt((Card a) -&gt; a.sharpOrder).reversed());</span><br><span class="line">System.out.println(Arrays.toString(cards));</span><br><span class="line">bubble(cards, Comparator.comparingInt((Card a) -&gt; a.numberOrder).reversed());</span><br><span class="line">System.out.println(Arrays.toString(cards));</span><br></pre></td></tr></table></figure><p>都是先按照花色排序（♠♥♣♦），再按照数字排序（AKQJ…）</p><ul><li><p>不稳定排序算法按数字排序时，会打乱原本同值的花色顺序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[♠7], [♠2], [♠4], [♠5], [♥2], [♥5]]</span><br><span class="line">[[♠7], [♠5], [♥5], [♠4], [♥2], [♠2]]</span><br></pre></td></tr></table></figure><p>原来 ♠2 在前 ♥2 在后，按数字再排后，他俩的位置变了</p></li><li><p>稳定排序算法按数字排序时，会保留原本同值的花色顺序，如下所示 ♠2 与 ♥2 的相对位置不变</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[♠7], [♠2], [♠4], [♠5], [♥2], [♥5]]</span><br><span class="line">[[♠7], [♠5], [♥5], [♠4], [♠2], [♥2]]</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-插入排序"><a href="#4-插入排序" class="headerlink" title="4. 插入排序"></a>4. 插入排序</h2><p><strong>要求</strong></p><ul><li>能够用自己语言描述插入排序算法</li><li>能够比较插入排序与选择排序</li></ul><p><strong>算法描述</strong></p><ol><li><p>将数组分为两个区域，排序区域和未排序区域，每一轮从未排序区域中取出第一个元素，插入到排序区域（需保证顺序）</p></li><li><p>重复以上步骤，直到整个数组有序</p></li></ol><blockquote><p><em>更形象的描述请参考：insertion_sort.html</em></p></blockquote><p><strong>算法实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改了代码与希尔排序一致</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span>[] a)</span> &#123;</span><br><span class="line">    <span class="comment">// i 代表待插入元素的索引</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a[i]; <span class="comment">// 代表待插入的元素值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">        System.out.println(j);</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t &lt; a[j - <span class="number">1</span>]) &#123; <span class="comment">// j-1 是上一个元素索引，如果 &gt; t，后移</span></span><br><span class="line">                a[j] = a[j - <span class="number">1</span>];</span><br><span class="line">                j--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果 j-1 已经 &lt;= t, 则 j 就是插入位置</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a[j] = t;</span><br><span class="line">        System.out.println(Arrays.toString(a) + <span class="string">&quot; &quot;</span> + j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>与选择排序比较</strong></p><ol><li><p>二者平均时间复杂度都是 $O(n^2)$</p></li><li><p>大部分情况下，插入都略优于选择</p></li><li><p>有序集合插入的时间复杂度为 $O(n)$</p></li><li><p>插入属于稳定排序算法，而选择属于不稳定排序</p></li></ol><p><strong>提示</strong></p><blockquote><p><em>插入排序通常被同学们所轻视，其实它的地位非常重要。小数据量排序，都会优先选择插入排序</em></p></blockquote><h2 id="5-希尔排序"><a href="#5-希尔排序" class="headerlink" title="5. 希尔排序"></a>5. 希尔排序</h2><p><strong>要求</strong></p><ul><li>能够用自己语言描述希尔排序算法</li></ul><p><strong>算法描述</strong></p><ol><li><p>首先选取一个间隙序列，如 (n&#x2F;2，n&#x2F;4 … 1)，n 为数组长度</p></li><li><p>每一轮将间隙相等的元素视为一组，对组内元素进行插入排序，目的有二</p><p>① 少量元素插入排序速度很快</p><p>② 让组内值较大的元素更快地移动到后方</p></li><li><p>当间隙逐渐减少，直至为 1 时，即可完成排序</p></li></ol><blockquote><p><em>更形象的描述请参考：shell_sort.html</em></p></blockquote><p><strong>算法实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shell</span><span class="params">(<span class="type">int</span>[] a)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> a.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> n / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// i 代表待插入元素的索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> gap; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a[i]; <span class="comment">// 代表待插入的元素值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= gap) &#123;</span><br><span class="line">                <span class="comment">// 每次与上一个间隙为 gap 的元素进行插入排序</span></span><br><span class="line">                <span class="keyword">if</span> (t &lt; a[j - gap]) &#123; <span class="comment">// j-gap 是上一个元素索引，如果 &gt; t，后移</span></span><br><span class="line">                    a[j] = a[j - gap];</span><br><span class="line">                    j -= gap;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果 j-1 已经 &lt;= t, 则 j 就是插入位置</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            a[j] = t;</span><br><span class="line">            System.out.println(Arrays.toString(a) + <span class="string">&quot; gap:&quot;</span> + gap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>参考资料</strong></p><ul><li><a href="https://en.wikipedia.org/wiki/Shellsort">https://en.wikipedia.org/wiki/Shellsort</a></li></ul><h2 id="6-快速排序"><a href="#6-快速排序" class="headerlink" title="6. 快速排序"></a>6. 快速排序</h2><p><strong>要求</strong></p><ul><li>能够用自己语言描述快速排序算法</li><li>掌握手写单边循环、双边循环代码之一</li><li>能够说明快排特点</li><li>了解洛穆托与霍尔两种分区方案的性能比较</li></ul><p><strong>算法描述</strong></p><ol><li>每一轮排序选择一个基准点（pivot）进行分区<ol><li>让小于基准点的元素的进入一个分区，大于基准点的元素的进入另一个分区</li><li>当分区完成时，基准点元素的位置就是其最终位置</li></ol></li><li>在子分区内重复以上过程，直至子分区元素个数少于等于 1，这体现的是分而治之的思想 （<a href="https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm">divide-and-conquer</a>）</li><li>从以上描述可以看出，一个关键在于分区算法，常见的有洛穆托分区方案、双边循环分区方案、霍尔分区方案</li></ol><blockquote><p><em>更形象的描述请参考：quick_sort.html</em></p></blockquote><p><strong>单边循环快排（lomuto 洛穆托分区方案）</strong></p><ol><li><p>选择最右元素作为基准点元素</p></li><li><p>j 指针负责找到比基准点小的元素，一旦找到则与 i 进行交换</p></li><li><p>i 指针维护小于基准点元素的边界，也是每次交换的目标索引</p></li><li><p>最后基准点与 i 交换，i 即为分区位置</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quick</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> l, <span class="type">int</span> h)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= h) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> partition(a, l, h); <span class="comment">// p 索引值</span></span><br><span class="line">    quick(a, l, p - <span class="number">1</span>); <span class="comment">// 左边分区的范围确定</span></span><br><span class="line">    quick(a, p + <span class="number">1</span>, h); <span class="comment">// 左边分区的范围确定</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> l, <span class="type">int</span> h)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pv</span> <span class="operator">=</span> a[h]; <span class="comment">// 基准点元素</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> l; j &lt; h; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[j] &lt; pv) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != j) &#123;</span><br><span class="line">                swap(a, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i != h) &#123;</span><br><span class="line">        swap(a, h, i);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Arrays.toString(a) + <span class="string">&quot; i=&quot;</span> + i);</span><br><span class="line">    <span class="comment">// 返回值代表了基准点元素所在的正确索引，用它确定下一轮分区的边界</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>双边循环快排（不完全等价于 hoare 霍尔分区方案）</strong></p><ol><li>选择最左元素作为基准点元素</li><li>j 指针负责从右向左找比基准点小的元素，i 指针负责从左向右找比基准点大的元素，一旦找到二者交换，直至 i，j 相交</li><li>最后基准点与 i（此时 i 与 j 相等）交换，i 即为分区位置</li></ol><p>要点</p><ol><li><p>基准点在左边，并且要先 j 后 i</p></li><li><p>while( <strong>i</strong> **&lt; j** &amp;&amp; a[j] &gt; pv ) j– </p></li><li><p>while ( <strong>i</strong> <strong>&lt; j</strong> &amp;&amp; a[i] <strong>&lt;&#x3D;</strong> pv ) i++</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quick</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> l, <span class="type">int</span> h)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= h) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> partition(a, l, h);</span><br><span class="line">    quick(a, l, p - <span class="number">1</span>);</span><br><span class="line">    quick(a, p + <span class="number">1</span>, h);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> l, <span class="type">int</span> h)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pv</span> <span class="operator">=</span> a[l];</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> h;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="comment">// j 从右找小的</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; a[j] &gt; pv) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// i 从左找大的</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; a[i] &lt;= pv) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(a, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(a, l, j);</span><br><span class="line">    System.out.println(Arrays.toString(a) + <span class="string">&quot; j=&quot;</span> + j);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>快排特点</strong></p><ol><li><p>平均时间复杂度是 $O(nlog_2⁡n )$，最坏时间复杂度 $O(n^2)$</p></li><li><p>数据量较大时，优势非常明显</p></li><li><p>属于不稳定排序</p></li></ol><p><strong>洛穆托分区方案 vs 霍尔分区方案</strong></p><ul><li>霍尔的移动次数平均来讲比洛穆托少3倍</li><li><a href="https://qastack.cn/cs/11458/quicksort-partitioning-hoare-vs-lomuto">https://qastack.cn/cs/11458/quicksort-partitioning-hoare-vs-lomuto</a></li></ul><blockquote><p><em><strong>补充代码说明</strong></em></p><ul><li>day01.sort.QuickSort3 演示了空穴法改进的双边快排，比较次数更少</li><li>day01.sort.QuickSortHoare 演示了霍尔分区的实现</li><li>day01.sort.LomutoVsHoare 对四种分区实现的移动次数比较</li></ul></blockquote><h2 id="7-ArrayList"><a href="#7-ArrayList" class="headerlink" title="7. ArrayList"></a>7. ArrayList</h2><p><strong>要求</strong></p><ul><li>掌握 ArrayList 扩容规则</li></ul><p><strong>扩容规则</strong></p><ol><li><p>ArrayList() 会使用长度为零的数组</p></li><li><p>ArrayList(int initialCapacity) 会使用指定容量的数组</p></li><li><p>public ArrayList(Collection&lt;? extends E&gt; c) 会使用 c 的大小作为数组容量</p></li><li><p>add(Object o) 首次扩容为 10，再次扩容为上次容量的 1.5 倍</p></li><li><p>addAll(Collection c) 没有元素时，扩容为 Math.max(10, 实际元素个数)，有元素时为 Math.max(原容量 1.5 倍, 实际元素个数)</p></li></ol><p>其中第 4 点必须知道，其它几点视个人情况而定</p><p><strong>提示</strong></p><ul><li>测试代码见 <code>day01.list.TestArrayList</code> ，这里不再列出</li><li>要<strong>注意</strong>的是，示例中用反射方式来更直观地反映 ArrayList 的扩容特征，但从 JDK 9 由于模块化的影响，对反射做了较多限制，需要在运行测试代码时添加 VM 参数 <code>--add-opens java.base/java.util=ALL-UNNAMED</code> 方能运行通过，后面的例子都有相同问题</li></ul><blockquote><p><em><strong>代码说明</strong></em></p><ul><li>day01.list.TestArrayList#arrayListGrowRule 演示了 add(Object) 方法的扩容规则，输入参数 n 代表打印多少次扩容后的数组长度</li></ul></blockquote><h2 id="8-Iterator"><a href="#8-Iterator" class="headerlink" title="8. Iterator"></a>8. Iterator</h2><p><strong>要求</strong></p><ul><li>掌握什么是 Fail-Fast、什么是 Fail-Safe</li></ul><p>Fail-Fast 与 Fail-Safe</p><ul><li><p>ArrayList 是 fail-fast 的典型代表，遍历的同时不能修改，尽快失败</p></li><li><p>CopyOnWriteArrayList 是 fail-safe 的典型代表，遍历的同时可以修改，原理是读写分离</p></li></ul><p><strong>提示</strong></p><ul><li>测试代码见 <code>day01.list.FailFastVsFailSafe</code>，这里不再列出</li></ul><h2 id="9-LinkedList"><a href="#9-LinkedList" class="headerlink" title="9. LinkedList"></a>9. LinkedList</h2><p><strong>要求</strong></p><ul><li>能够说清楚 LinkedList 对比 ArrayList 的区别，并重视纠正部分错误的认知</li></ul><p><strong>LinkedList</strong></p><ol><li>基于双向链表，无需连续内存</li><li>随机访问慢（要沿着链表遍历）</li><li>头尾插入删除性能高</li><li>占用内存多</li></ol><p><strong>ArrayList</strong></p><ol><li>基于数组，需要连续内存</li><li>随机访问快（指根据下标访问）</li><li>尾部插入、删除性能可以，其它部分插入、删除都会移动数据，因此性能会低</li><li>可以利用 cpu 缓存，局部性原理</li></ol><blockquote><p><em><strong>代码说明</strong></em></p><ul><li>day01.list.ArrayListVsLinkedList#randomAccess 对比随机访问性能</li><li>day01.list.ArrayListVsLinkedList#addMiddle 对比向中间插入性能</li><li>day01.list.ArrayListVsLinkedList#addFirst 对比头部插入性能</li><li>day01.list.ArrayListVsLinkedList#addLast 对比尾部插入性能</li><li>day01.list.ArrayListVsLinkedList#linkedListSize 打印一个 LinkedList 占用内存</li><li>day01.list.ArrayListVsLinkedList#arrayListSize 打印一个 ArrayList 占用内存</li></ul></blockquote><h2 id="10-HashMap"><a href="#10-HashMap" class="headerlink" title="10. HashMap"></a>10. HashMap</h2><p><strong>要求</strong></p><ul><li>掌握 HashMap 的基本数据结构</li><li>掌握树化</li><li>理解索引计算方法、二次 hash 的意义、容量对索引计算的影响</li><li>掌握 put 流程、扩容、扩容因子</li><li>理解并发使用 HashMap 可能导致的问题</li><li>理解 key 的设计</li></ul><h3 id="1）基本数据结构"><a href="#1）基本数据结构" class="headerlink" title="1）基本数据结构"></a>1）基本数据结构</h3><ul><li>1.7 数组 + 链表</li><li>1.8 数组 + （链表 | 红黑树）</li></ul><blockquote><p>更形象的演示，见资料中的 hash-demo.jar，运行需要 jdk14 以上环境，进入 jar 包目录，执行下面命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar --add-exports java.base/jdk.internal.misc=ALL-UNNAMED hash-demo.jar</span><br></pre></td></tr></table></figure></blockquote><h3 id="2）树化与退化"><a href="#2）树化与退化" class="headerlink" title="2）树化与退化"></a>2）树化与退化</h3><p><strong>树化意义</strong></p><ul><li>红黑树用来避免 DoS 攻击，防止链表超长时性能下降，树化应当是偶然情况，是保底策略</li><li>hash 表的查找，更新的时间复杂度是 $O(1)$，而红黑树的查找，更新的时间复杂度是 $O(log_2⁡n )$，TreeNode 占用空间也比普通 Node 的大，如非必要，尽量还是使用链表</li><li>hash 值如果足够随机，则在 hash 表内按泊松分布，在负载因子 0.75 的情况下，长度超过 8 的链表出现概率是 0.00000006，树化阈值选择 8 就是为了让树化几率足够小</li></ul><p><strong>树化规则</strong></p><ul><li>当链表长度超过树化阈值 8 时，先尝试扩容来减少链表长度，如果数组容量已经 &gt;&#x3D;64，才会进行树化</li></ul><p><strong>退化规则</strong></p><ul><li>情况1：在扩容时如果拆分树时，树元素个数 &lt;&#x3D; 6 则会退化链表</li><li>情况2：remove 树节点时，若 root、root.left、root.right、root.left.left 有一个为 null ，也会退化为链表</li></ul><h3 id="3）索引计算"><a href="#3）索引计算" class="headerlink" title="3）索引计算"></a>3）索引计算</h3><p><strong>索引计算方法</strong></p><ul><li>首先，计算对象的 hashCode()</li><li>再进行调用 HashMap 的 hash() 方法进行二次哈希<ul><li>二次 hash() 是为了综合高位数据，让哈希分布更为均匀</li></ul></li><li>最后 &amp; (capacity – 1) 得到索引</li></ul><p><strong>数组容量为何是 2 的 n 次幂</strong></p><ol><li>计算索引时效率更高：如果是 2 的 n 次幂可以使用位与运算代替取模</li><li>扩容时重新计算索引效率更高： hash &amp; oldCap &#x3D;&#x3D; 0 的元素留在原来位置 ，否则新位置 &#x3D; 旧位置 + oldCap</li></ol><p><strong>注意</strong></p><ul><li>二次 hash 是为了配合 <strong>容量是 2 的 n 次幂</strong> 这一设计前提，如果 hash 表的容量不是 2 的 n 次幂，则不必二次 hash</li><li><strong>容量是 2 的 n 次幂</strong> 这一设计计算索引效率更好，但 hash 的分散性就不好，需要二次 hash 来作为补偿，没有采用这一设计的典型例子是 Hashtable</li></ul><h3 id="4）put-与扩容"><a href="#4）put-与扩容" class="headerlink" title="4）put 与扩容"></a>4）put 与扩容</h3><p><strong>put 流程</strong></p><ol><li>HashMap 是懒惰创建数组的，首次使用才创建数组</li><li>计算索引（桶下标）</li><li>如果桶下标还没人占用，创建 Node 占位返回</li><li>如果桶下标已经有人占用<ol><li>已经是 TreeNode 走红黑树的添加或更新逻辑</li><li>是普通 Node，走链表的添加或更新逻辑，如果链表长度超过树化阈值，走树化逻辑</li></ol></li><li>返回前检查容量是否超过阈值，一旦超过进行扩容</li></ol><p><strong>1.7 与 1.8 的区别</strong></p><ol><li><p>链表插入节点时，1.7 是头插法，1.8 是尾插法</p></li><li><p>1.7 是大于等于阈值且没有空位时才扩容，而 1.8 是大于阈值就扩容</p></li><li><p>1.8 在扩容计算 Node 索引时，会优化</p></li></ol><p><strong>扩容（加载）因子为何默认是 0.75f</strong></p><ol><li>在空间占用与查询时间之间取得较好的权衡</li><li>大于这个值，空间节省了，但链表就会比较长影响性能</li><li>小于这个值，冲突减少了，但扩容就会更频繁，空间占用也更多</li></ol><h3 id="5）并发问题"><a href="#5）并发问题" class="headerlink" title="5）并发问题"></a>5）并发问题</h3><p><strong>扩容死链（1.7 会存在）</strong></p><p>1.7 源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Entry[] newTable, <span class="type">boolean</span> rehash)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="literal">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>e 和 next 都是局部变量，用来指向当前节点和下一个节点</li><li>线程1（绿色）的临时变量 e 和 next 刚引用了这俩节点，还未来得及移动节点，发生了线程切换，由线程2（蓝色）完成扩容和迁移</li></ul><p><a href="https://imags-563.pages.dev/file/AgACAgUAAxkDAAMsZ7SUGnXmbtzlYLLgJOQS_q3C4MMAAp3BMRtiZKBVCRNvwcSPQtQBAAMCAAN5AAM2BA.png">图1</a><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAMsZ7SUGnXmbtzlYLLgJOQS_q3C4MMAAp3BMRtiZKBVCRNvwcSPQtQBAAMCAAN5AAM2BA.png"></p><ul><li><p>线程2 扩容完成，由于头插法，链表顺序颠倒。但线程1 的临时变量 e 和 next 还引用了这俩节点，还要再来一遍迁移</p></li><li><p>第一次循环</p><ul><li>循环接着线程切换前运行，注意此时 e 指向的是节点 a，next 指向的是节点 b</li><li>e 头插 a 节点，注意图中画了两份 a 节点，但事实上只有一个（为了不让箭头特别乱画了两份）</li><li>当循环结束是 e 会指向 next 也就是 b 节点</li></ul></li><li><p>第二次循环</p><ul><li>next 指向了节点 a</li><li>e 头插节点 b</li><li>当循环结束时，e 指向 next 也就是节点 a</li></ul></li><li><p>第三次循环</p><ul><li>next 指向了 null</li><li>e 头插节点 a，<strong>a 的 next 指向了 b</strong>（之前 a.next 一直是 null），b 的 next 指向 a，死链已成</li><li>当循环结束时，e 指向 next 也就是 null，因此第四次循环时会正常退出</li></ul></li></ul><p><strong>数据错乱（1.7，1.8 都会存在）</strong></p><ul><li>代码参考 <code>day01.map.HashMapMissData</code>，具体调试步骤参考视频</li></ul><blockquote><p><em><strong>补充代码说明</strong></em></p><ul><li>day01.map.HashMapDistribution 演示 map 中链表长度符合泊松分布</li><li>day01.map.DistributionAffectedByCapacity 演示容量及 hashCode 取值对分布的影响<ul><li>day01.map.DistributionAffectedByCapacity#hashtableGrowRule 演示了 Hashtable 的扩容规律</li><li>day01.sort.Utils#randomArray 如果 hashCode 足够随机，容量是否是 2 的 n 次幂影响不大</li><li>day01.sort.Utils#lowSameArray 如果 hashCode 低位一样的多，容量是 2 的 n 次幂会导致分布不均匀</li><li>day01.sort.Utils#evenArray 如果 hashCode 偶数的多，容量是 2 的 n 次幂会导致分布不均匀</li><li>由此得出对于容量是 2 的 n 次幂的设计来讲，二次 hash 非常重要</li></ul></li><li>day01.map.HashMapVsHashtable 演示了对于同样数量的单词字符串放入 HashMap 和 Hashtable 分布上的区别</li></ul></blockquote><h3 id="6）key-的设计"><a href="#6）key-的设计" class="headerlink" title="6）key 的设计"></a>6）key 的设计</h3><p><strong>key 的设计要求</strong></p><ol><li>HashMap 的 key 可以为 null，但 Map 的其他实现则不然</li><li>作为 key 的对象，必须实现 hashCode 和 equals，并且 key 的内容不能修改（不可变）</li><li>key 的 hashCode 应该有良好的散列性</li></ol><p>如果 key 可变，例如修改了 age 会导致再次查询时查询不到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapMutableKey</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        HashMap&lt;Student, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        map.put(stu, <span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line"></span><br><span class="line">        System.out.println(map.get(stu));</span><br><span class="line"></span><br><span class="line">        stu.age = <span class="number">19</span>;</span><br><span class="line">        System.out.println(map.get(stu));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">        String name;</span><br><span class="line">        <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="built_in">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) o;</span><br><span class="line">            <span class="keyword">return</span> age == student.age &amp;&amp; Objects.equals(name, student.name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>String 对象的 hashCode() 设计</strong></p><ul><li>目标是达到较为均匀的散列效果，每个字符串的 hashCode 足够独特</li><li>字符串中的每个字符都可以表现为一个数字，称为 $S_i$，其中 i 的范围是 0 ~ n - 1 </li><li>散列公式为： $S_0∗31^{(n-1)}+ S_1∗31^{(n-2)}+ … S_i ∗ 31^{(n-1-i)}+ …S_{(n-1)}∗31^0$</li><li>31 代入公式有较好的散列特性，并且 31 * h 可以被优化为 <ul><li>即 $32 ∗h -h $</li><li>即 $2^5  ∗h -h$</li><li>即 $h≪5  -h$</li></ul></li></ul><h2 id="11-单例模式"><a href="#11-单例模式" class="headerlink" title="11. 单例模式"></a>11. 单例模式</h2><p><strong>要求</strong></p><ul><li>掌握五种单例模式的实现方式</li><li>理解为何 DCL 实现时要使用 volatile 修饰静态变量</li><li>了解 jdk 中用到单例的场景</li></ul><p><strong>饿汉式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton1</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;单例对象不能重复创建&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;private Singleton1()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton1</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton1</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">otherMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;otherMethod()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">readResolve</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>构造方法抛出异常是防止反射破坏单例</li><li><code>readResolve()</code> 是防止反序列化破坏单例</li></ul><p><strong>枚举饿汉式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton2</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;private Singleton2()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">otherMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;otherMethod()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>枚举饿汉式能天然防止反射、反序列化破坏单例</li></ul><p><strong>懒汉式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton3</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton3</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;private Singleton3()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton3</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Singleton3.class</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton3 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">            INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton3</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">otherMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;otherMethod()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>其实只有首次创建单例对象时才需要同步，但该代码实际上每次调用都会同步</li><li>因此有了下面的双检锁改进</li></ul><p><strong>双检锁懒汉式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton4</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton4</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;private Singleton4()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">Singleton4</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 可见性，有序性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton4 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton4.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton4</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">otherMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;otherMethod()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为何必须加 volatile：</p><ul><li><code>INSTANCE = new Singleton4()</code> 不是原子的，分成 3 步：创建对象、调用构造、给静态变量赋值，其中后两步可能被指令重排序优化，变成先赋值、再调用构造</li><li>如果线程1 先执行了赋值，线程2 执行到第一个 <code>INSTANCE == null</code> 时发现 INSTANCE 已经不为 null，此时就会返回一个未完全构造的对象</li></ul><p><strong>内部类懒汉式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton5</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton5</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;private Singleton5()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Holder</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="type">Singleton5</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton5</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton5 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Holder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">otherMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;otherMethod()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>避免了双检锁的缺点</li></ul><p><strong>JDK 中单例的体现</strong></p><ul><li>Runtime 体现了饿汉式单例</li><li>Console 体现了双检锁懒汉式单例</li><li>Collections 中的 EmptyNavigableSet 内部类懒汉式单例</li><li>ReverseComparator.REVERSE_ORDER 内部类懒汉式单例</li><li>Comparators.NaturalOrderComparator.INSTANCE 枚举饿汉式单例</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java核心系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java核心 </tag>
            
            <tag> Java基础 </tag>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程</title>
      <link href="/2025/02/18/Java%E5%9B%9E%E9%A1%BE-%E5%B9%B6%E5%8F%91%E7%AF%87/"/>
      <url>/2025/02/18/Java%E5%9B%9E%E9%A1%BE-%E5%B9%B6%E5%8F%91%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="并发篇"><a href="#并发篇" class="headerlink" title="并发篇"></a>并发篇</h1><h2 id="1-线程状态"><a href="#1-线程状态" class="headerlink" title="1. 线程状态"></a>1. 线程状态</h2><p><strong>要求</strong></p><ul><li>掌握 Java 线程六种状态</li><li>掌握 Java 线程状态转换</li><li>能理解五种状态与六种状态两种说法的区别</li></ul><p><strong>六种状态及转换</strong></p><p>分别是</p><ul><li>新建<ul><li>当一个线程对象被创建，但还未调用 start 方法时处于<strong>新建</strong>状态</li><li>此时未与操作系统底层线程关联</li></ul></li><li>可运行<ul><li>调用了 start 方法，就会由<strong>新建</strong>进入<strong>可运行</strong></li><li>此时与底层线程关联，由操作系统调度执行</li></ul></li><li>终结<ul><li>线程内代码已经执行完毕，由<strong>可运行</strong>进入<strong>终结</strong></li><li>此时会取消与底层线程关联</li></ul></li><li>阻塞<ul><li>当获取锁失败后，由<strong>可运行</strong>进入 Monitor 的阻塞队列<strong>阻塞</strong>，此时不占用 cpu 时间</li><li>当持锁线程释放锁时，会按照一定规则唤醒阻塞队列中的<strong>阻塞</strong>线程，唤醒后的线程进入<strong>可运行</strong>状态</li></ul></li><li>等待<ul><li>当获取锁成功后，但由于条件不满足，调用了 wait() 方法，此时从<strong>可运行</strong>状态释放锁进入 Monitor 等待集合<strong>等待</strong>，同样不占用 cpu 时间</li><li>当其它持锁线程调用 notify() 或 notifyAll() 方法，会按照一定规则唤醒等待集合中的<strong>等待</strong>线程，恢复为<strong>可运行</strong>状态</li></ul></li><li>有时限等待<ul><li>当获取锁成功后，但由于条件不满足，调用了 wait(long) 方法，此时从<strong>可运行</strong>状态释放锁进入 Monitor 等待集合进行<strong>有时限等待</strong>，同样不占用 cpu 时间</li><li>当其它持锁线程调用 notify() 或 notifyAll() 方法，会按照一定规则唤醒等待集合中的<strong>有时限等待</strong>线程，恢复为<strong>可运行</strong>状态，并重新去竞争锁</li><li>如果等待超时，也会从<strong>有时限等待</strong>状态恢复为<strong>可运行</strong>状态，并重新去竞争锁</li><li>还有一种情况是调用 sleep(long) 方法也会从<strong>可运行</strong>状态进入<strong>有时限等待</strong>状态，但与 Monitor 无关，不需要主动唤醒，超时时间到自然恢复为<strong>可运行</strong>状态</li></ul></li></ul><blockquote><p><em><strong>其它情况（只需了解）</strong></em></p><ul><li>可以用 interrupt() 方法打断<strong>等待</strong>、<strong>有时限等待</strong>的线程，让它们恢复为<strong>可运行</strong>状态</li><li>park，unpark 等方法也可以让线程等待和唤醒</li></ul></blockquote><p><strong>五种状态</strong></p><p>五种状态的说法来自于操作系统层面的划分</p><ul><li>运行态：分到 cpu 时间，能真正执行线程内代码的</li><li>就绪态：有资格分到 cpu 时间，但还未轮到它的</li><li>阻塞态：没资格分到 cpu 时间的<ul><li>涵盖了 java 状态中提到的<strong>阻塞</strong>、<strong>等待</strong>、<strong>有时限等待</strong></li><li>多出了阻塞 I&#x2F;O，指线程在调用阻塞 I&#x2F;O 时，实际活由 I&#x2F;O 设备完成，此时线程无事可做，只能干等</li></ul></li><li>新建与终结态：与 java 中同名状态类似，不再啰嗦</li></ul><h2 id="2-线程池"><a href="#2-线程池" class="headerlink" title="2. 线程池"></a>2. 线程池</h2><p><strong>要求</strong></p><ul><li>掌握线程池的 7 大核心参数</li></ul><p><strong>七大参数</strong></p><ol><li>corePoolSize 核心线程数目 - 池中会保留的最多线程数</li><li>maximumPoolSize 最大线程数目 - 核心线程+救急线程的最大数目</li><li>keepAliveTime 生存时间 - 救急线程的生存时间，生存时间内没有新任务，此线程资源会释放</li><li>unit 时间单位 - 救急线程的生存时间单位，如秒、毫秒等</li><li>workQueue - 当没有空闲核心线程时，新来任务会加入到此队列排队，队列满会创建救急线程执行任务</li><li>threadFactory 线程工厂 - 可以定制线程对象的创建，例如设置线程名字、是否是守护线程等</li><li>handler 拒绝策略 - 当所有线程都在繁忙，workQueue 也放满时，会触发拒绝策略<ol><li>抛异常 java.util.concurrent.ThreadPoolExecutor.AbortPolicy</li><li>由调用者执行任务 java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy</li><li>丢弃任务 java.util.concurrent.ThreadPoolExecutor.DiscardPolicy</li><li>丢弃最早排队任务 java.util.concurrent.ThreadPoolExecutor.DiscardOldestPolicy</li></ol></li></ol><blockquote><p><em><strong>代码说明</strong></em></p><p>day02.TestThreadPoolExecutor 以较为形象的方式演示了线程池的核心组成</p></blockquote><h2 id="3-wait-vs-sleep"><a href="#3-wait-vs-sleep" class="headerlink" title="3. wait vs sleep"></a>3. wait vs sleep</h2><p><strong>要求</strong></p><ul><li>能够说出二者区别</li></ul><p><strong>一个共同点，三个不同点</strong></p><p>共同点</p><ul><li>wait() ，wait(long) 和 sleep(long) 的效果都是让当前线程暂时放弃 CPU 的使用权，进入阻塞状态</li></ul><p>不同点</p><ul><li><p>方法归属不同</p><ul><li>sleep(long) 是 Thread 的静态方法</li><li>而 wait()，wait(long) 都是 Object 的成员方法，每个对象都有</li></ul></li><li><p>醒来时机不同</p><ul><li>执行 sleep(long) 和 wait(long) 的线程都会在等待相应毫秒后醒来</li><li>wait(long) 和 wait() 还可以被 notify 唤醒，wait() 如果不唤醒就一直等下去</li><li>它们都可以被打断唤醒</li></ul></li><li><p>锁特性不同（重点）</p><ul><li>wait 方法的调用必须先获取 wait 对象的锁，而 sleep 则无此限制</li><li>wait 方法执行后会释放对象锁，允许其它线程获得该对象锁（我放弃 cpu，但你们还可以用）</li><li>而 sleep 如果在 synchronized 代码块中执行，并不会释放对象锁（我放弃 cpu，你们也用不了）</li></ul></li></ul><h2 id="4-lock-vs-synchronized"><a href="#4-lock-vs-synchronized" class="headerlink" title="4. lock vs synchronized"></a>4. lock vs synchronized</h2><p><strong>要求</strong></p><ul><li>掌握 lock 与 synchronized 的区别</li><li>理解 ReentrantLock 的公平、非公平锁</li><li>理解 ReentrantLock 中的条件变量</li></ul><p><strong>三个层面</strong></p><p>不同点</p><ul><li>语法层面<ul><li>synchronized 是关键字，源码在 jvm 中，用 c++ 语言实现</li><li>Lock 是接口，源码由 jdk 提供，用 java 语言实现</li><li>使用 synchronized 时，退出同步代码块锁会自动释放，而使用 Lock 时，需要手动调用 unlock 方法释放锁</li></ul></li><li>功能层面<ul><li>二者均属于悲观锁、都具备基本的互斥、同步、锁重入功能</li><li>Lock 提供了许多 synchronized 不具备的功能，例如获取等待状态、公平锁、可打断、可超时、多条件变量</li><li>Lock 有适合不同场景的实现，如 ReentrantLock， ReentrantReadWriteLock</li></ul></li><li>性能层面<ul><li>在没有竞争时，synchronized 做了很多优化，如偏向锁、轻量级锁，性能不赖</li><li>在竞争激烈时，Lock 的实现通常会提供更好的性能</li></ul></li></ul><p><strong>公平锁</strong></p><ul><li>公平锁的公平体现<ul><li><strong>已经处在阻塞队列</strong>中的线程（不考虑超时）始终都是公平的，先进先出</li><li>公平锁是指<strong>未处于阻塞队列</strong>中的线程来争抢锁，如果队列不为空，则老实到队尾等待</li><li>非公平锁是指<strong>未处于阻塞队列</strong>中的线程来争抢锁，与队列头唤醒的线程去竞争，谁抢到算谁的</li></ul></li><li>公平锁会降低吞吐量，一般不用</li></ul><p><strong>条件变量</strong></p><ul><li>ReentrantLock 中的条件变量功能类似于普通 synchronized 的 wait，notify，用在当线程获得锁后，发现条件不满足时，临时等待的链表结构</li><li>与 synchronized 的等待集合不同之处在于，ReentrantLock 中的条件变量可以有多个，可以实现更精细的等待、唤醒控制</li></ul><blockquote><p><em><strong>代码说明</strong></em></p><ul><li>day02.TestReentrantLock 用较为形象的方式演示 ReentrantLock 的内部结构</li></ul></blockquote><h2 id="5-voltile"><a href="#5-voltile" class="headerlink" title="5. voltile"></a>5. voltile</h2><p><strong>要求</strong></p><ul><li>掌握线程安全要考虑的三个问题</li><li>掌握 volatile 能解决哪些问题</li></ul><p><strong>原子性</strong></p><ul><li>起因：多线程下，不同线程的<strong>指令发生了交错</strong>导致的共享变量的读写混乱</li><li>解决：用悲观锁或乐观锁解决，volatile 并不能解决原子性</li></ul><p><strong>可见性</strong></p><ul><li>起因：由于<strong>编译器优化、或缓存优化、或 CPU 指令重排序优化</strong>导致的对共享变量所做的修改另外的线程看不到</li><li>解决：用 volatile 修饰共享变量，能够防止编译器等优化发生，让一个线程对共享变量的修改对另一个线程可见</li></ul><p><strong>有序性</strong></p><ul><li>起因：由于<strong>编译器优化、或缓存优化、或 CPU 指令重排序优化</strong>导致指令的实际执行顺序与编写顺序不一致</li><li>解决：用 volatile 修饰共享变量会在读、写共享变量时加入不同的屏障，阻止其他读写操作越过屏障，从而达到阻止重排序的效果</li><li>注意：<ul><li><strong>volatile 变量写</strong>加的屏障是阻止上方其它写操作越过屏障排到 <strong>volatile 变量写</strong>之下</li><li><strong>volatile 变量读</strong>加的屏障是阻止下方其它读操作越过屏障排到 <strong>volatile 变量读</strong>之上</li><li>volatile 读写加入的屏障只能防止同一线程内的指令重排</li></ul></li></ul><blockquote><p><em><strong>代码说明</strong></em></p><ul><li>day02.threadsafe.AddAndSubtract 演示原子性</li><li>day02.threadsafe.ForeverLoop 演示可见性<ul><li>注意：本例经实践检验是编译器优化导致的可见性问题</li></ul></li><li>day02.threadsafe.Reordering 演示有序性<ul><li>需要打成 jar 包后测试</li></ul></li><li>请同时参考视频讲解</li></ul></blockquote><h2 id="6-悲观锁-vs-乐观锁"><a href="#6-悲观锁-vs-乐观锁" class="headerlink" title="6. 悲观锁 vs 乐观锁"></a>6. 悲观锁 vs 乐观锁</h2><p><strong>要求</strong></p><ul><li>掌握悲观锁和乐观锁的区别</li></ul><p><strong>对比悲观锁与乐观锁</strong></p><ul><li><p>悲观锁的代表是 synchronized 和 Lock 锁</p><ul><li>其核心思想是【线程只有占有了锁，才能去操作共享变量，每次只有一个线程占锁成功，获取锁失败的线程，都得停下来等待】</li><li>线程从运行到阻塞、再从阻塞到唤醒，涉及线程上下文切换，如果频繁发生，影响性能</li><li>实际上，线程在获取 synchronized 和 Lock 锁时，如果锁已被占用，都会做几次重试操作，减少阻塞的机会</li></ul></li><li><p>乐观锁的代表是 AtomicInteger，使用 cas 来保证原子性</p><ul><li>其核心思想是【无需加锁，每次只有一个线程能成功修改共享变量，其它失败的线程不需要停止，不断重试直至成功】</li><li>由于线程一直运行，不需要阻塞，因此不涉及线程上下文切换</li><li>它需要多核 cpu 支持，且线程数不应超过 cpu 核数</li></ul></li></ul><blockquote><p><em><strong>代码说明</strong></em></p><ul><li>day02.SyncVsCas 演示了分别使用乐观锁和悲观锁解决原子赋值</li><li>请同时参考视频讲解</li></ul></blockquote><h2 id="7-Hashtable-vs-ConcurrentHashMap"><a href="#7-Hashtable-vs-ConcurrentHashMap" class="headerlink" title="7. Hashtable vs ConcurrentHashMap"></a>7. Hashtable vs ConcurrentHashMap</h2><p><strong>要求</strong></p><ul><li>掌握 Hashtable 与 ConcurrentHashMap 的区别</li><li>掌握 ConcurrentHashMap 在不同版本的实现区别</li></ul><blockquote><p>更形象的演示，见资料中的 hash-demo.jar，运行需要 jdk14 以上环境，进入 jar 包目录，执行下面命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar --add-exports java.base/jdk.internal.misc=ALL-UNNAMED hash-demo.jar</span><br></pre></td></tr></table></figure></blockquote><p><strong>Hashtable 对比 ConcurrentHashMap</strong></p><ul><li>Hashtable 与 ConcurrentHashMap 都是线程安全的 Map 集合</li><li>Hashtable 并发度低，整个 Hashtable 对应一把锁，同一时刻，只能有一个线程操作它</li><li>ConcurrentHashMap 并发度高，整个 ConcurrentHashMap 对应多把锁，只要线程访问的是不同锁，那么不会冲突</li></ul><p><strong>ConcurrentHashMap 1.7</strong></p><ul><li>数据结构：<code>Segment(大数组) + HashEntry(小数组) + 链表</code>，每个 Segment 对应一把锁，如果多个线程访问不同的 Segment，则不会冲突</li><li>并发度：Segment 数组大小即并发度，决定了同一时刻最多能有多少个线程并发访问。Segment 数组不能扩容，意味着并发度在 ConcurrentHashMap 创建时就固定了</li><li>索引计算<ul><li>假设大数组长度是 $2^m$，key 在大数组内的索引是 key 的二次 hash 值的高 m 位</li><li>假设小数组长度是 $2^n$，key 在小数组内的索引是 key 的二次 hash 值的低 n 位</li></ul></li><li>扩容：每个小数组的扩容相对独立，小数组在超过扩容因子时会触发扩容，每次扩容翻倍</li><li>Segment[0] 原型：首次创建其它小数组时，会以此原型为依据，数组长度，扩容因子都会以原型为准</li></ul><p><strong>ConcurrentHashMap 1.8</strong></p><ul><li>数据结构：<code>Node 数组 + 链表或红黑树</code>，数组的每个头节点作为锁，如果多个线程访问的头节点不同，则不会冲突。首次生成头节点时如果发生竞争，利用 cas 而非 syncronized，进一步提升性能</li><li>并发度：Node 数组有多大，并发度就有多大，与 1.7 不同，Node 数组可以扩容</li><li>扩容条件：Node 数组满 3&#x2F;4 时就会扩容</li><li>扩容单位：以链表为单位从后向前迁移链表，迁移完成的将旧数组头节点替换为 ForwardingNode</li><li>扩容时并发 get<ul><li>根据是否为 ForwardingNode 来决定是在新数组查找还是在旧数组查找，不会阻塞</li><li>如果链表长度超过 1，则需要对节点进行复制（创建新节点），怕的是节点迁移后 next 指针改变</li><li>如果链表最后几个元素扩容后索引不变，则节点无需复制</li></ul></li><li>扩容时并发 put<ul><li>如果 put 的线程与扩容线程操作的链表是同一个，put 线程会阻塞</li><li>如果 put 的线程操作的链表还未迁移完成，即头节点不是 ForwardingNode，则可以并发执行</li><li>如果 put 的线程操作的链表已经迁移完成，即头结点是 ForwardingNode，则可以协助扩容</li></ul></li><li>与 1.7 相比是懒惰初始化</li><li>capacity 代表预估的元素个数，capacity &#x2F; factory 来计算出初始数组大小，需要贴近 $2^n$ </li><li>loadFactor 只在计算初始数组大小时被使用，之后扩容固定为 3&#x2F;4</li><li>超过树化阈值时的扩容问题，如果容量已经是 64，直接树化，否则在原来容量基础上做 3 轮扩容</li></ul><h2 id="8-ThreadLocal"><a href="#8-ThreadLocal" class="headerlink" title="8. ThreadLocal"></a>8. ThreadLocal</h2><p><strong>要求</strong></p><ul><li>掌握 ThreadLocal 的作用与原理</li><li>掌握 ThreadLocal 的内存释放时机</li></ul><p><strong>作用</strong></p><ul><li>ThreadLocal 可以实现【资源对象】的线程隔离，让每个线程各用各的【资源对象】，避免争用引发的线程安全问题</li><li>ThreadLocal 同时实现了线程内的资源共享</li></ul><p><strong>原理</strong></p><p>每个线程内有一个 ThreadLocalMap 类型的成员变量，用来存储资源对象</p><ul><li>调用 set 方法，就是以 ThreadLocal 自己作为 key，资源对象作为 value，放入当前线程的 ThreadLocalMap 集合中</li><li>调用 get 方法，就是以 ThreadLocal 自己作为 key，到当前线程中查找关联的资源值</li><li>调用 remove 方法，就是以 ThreadLocal 自己作为 key，移除当前线程关联的资源值</li></ul><p>ThreadLocalMap 的一些特点</p><ul><li>key 的 hash 值统一分配</li><li>初始容量 16，扩容因子 2&#x2F;3，扩容容量翻倍</li><li>key 索引冲突后用开放寻址法解决冲突</li></ul><p><strong>弱引用 key</strong></p><p>ThreadLocalMap 中的 key 被设计为弱引用，原因如下</p><ul><li>Thread 可能需要长时间运行（如线程池中的线程），如果 key 不再使用，需要在内存不足（GC）时释放其占用的内存</li></ul><p><strong>内存释放时机</strong></p><ul><li>被动 GC 释放 key<ul><li>仅是让 key 的内存释放，关联 value 的内存并不会释放</li></ul></li><li>懒惰被动释放 value<ul><li>get key 时，发现是 null key，则释放其 value 内存</li><li>set key 时，会使用启发式扫描，清除临近的 null key 的 value 内存，启发次数与元素个数，是否发现 null key 有关</li></ul></li><li>主动 remove 释放 key，value<ul><li>会同时释放 key，value 的内存，也会清除临近的 null key 的 value 内存</li><li>推荐使用它，因为一般使用 ThreadLocal 时都把它作为静态变量（即强引用），因此无法被动依靠 GC 回收。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java核心系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 高并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java核心系列1：泛型机制详解</title>
      <link href="/2025/02/18/Java%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%861-%E6%B3%9B%E5%9E%8B%E6%9C%BA%E5%88%B6/"/>
      <url>/2025/02/18/Java%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%861-%E6%B3%9B%E5%9E%8B%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="1-理解泛型的本质"><a href="#1-理解泛型的本质" class="headerlink" title="1 理解泛型的本质"></a>1 理解泛型的本质</h1><p>JDK 1.5开始引入Java泛型（generics）这个特性，该特性提供了编译时类型安全检测机制，允许程序员在编译时检测到非法的类型。</p><p>泛型的本质是参数化类型，即给类型指定一个参数，然后在使用时再指定此参数具体的值，那样这个类型就可以在使用时决定了。这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。为了兼容之前的版本，Java泛型的实现采取了“伪泛型”的策略，即Java在语法上支持泛型，但是在编译阶段会进行所谓的“类型擦除”（Type Erasure），将所有的泛型表示（尖括号中的内容）都替换为具体的类型（其对应的原生态类型）。<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAOpaUZCdbr-3Q4mRwABnz5OkXUcZaTZAAKfC2sb0X4wVpouh-KnjVvcAQADAgADeAADNgQ.png" alt="图1 泛型的语法"></p><h1 id="2-泛型的作用"><a href="#2-泛型的作用" class="headerlink" title="2 泛型的作用"></a>2 泛型的作用</h1><p>泛型有四个作用：类型安全、自动转换、性能提升、可复用性。即在编译的时候检查类型安全，将所有的强制转换都自动和隐式进行，同时提高代码的可复用性。<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAOqaUZCg4TYvcwFSxpxjtU0uT_K58kAAqALaxvRfjBWf6EQVcklU1YBAAMCAAN4AAM2BA.png" alt="图2 泛型的四个作用"></p><h2 id="2-1-泛型如何保证类型安全"><a href="#2-1-泛型如何保证类型安全" class="headerlink" title="2.1 泛型如何保证类型安全"></a>2.1 泛型如何保证类型安全</h2><p>在没有泛型之前，从集合中读取到的每一个对象都必须进行类型转换，如果不小心插入了错误的类型对象，在运行时的转换处理就会出错。比如：没有泛型的情况下使用集合：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">noGenericTest</span>()</span> &#123;</span><br><span class="line">        <span class="comment">// 编译正常通过，但是使用的时候可能转换处理出现问题</span></span><br><span class="line">        ArrayList arr = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        arr.<span class="keyword">add</span>(<span class="string">&quot;加入一个字符串&quot;</span>);</span><br><span class="line">        arr.<span class="keyword">add</span>(<span class="number">1</span>);</span><br><span class="line">        arr.<span class="keyword">add</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>有泛型的情况下使用集合：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">genericTest</span>()</span> &#123;</span><br><span class="line">        <span class="comment">// 编译不通过，直接提示异常，Required type：String</span></span><br><span class="line">        ArrayList&lt;String&gt; arr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        arr.<span class="keyword">add</span>(<span class="string">&quot;加入一个字符串&quot;</span>);</span><br><span class="line">        arr.<span class="keyword">add</span>(<span class="number">1</span>);</span><br><span class="line">        arr.<span class="keyword">add</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>有了泛型后，会对类型进行验证，所以集合arr在编译的时候add(1)、add(‘a’) 都会编译不通过。这个过程相当于告诉编译器每个集合接收的对象类型是什么，编译器在编译期就会做类型检查，告知是否插入了错误类型的对象，使得程序更加安全，增强了程序的健壮性。</p><h2 id="2-2-类型自动转换，消除强转"><a href="#2-2-类型自动转换，消除强转" class="headerlink" title="2.2 类型自动转换，消除强转"></a>2.2 类型自动转换，消除强转</h2><p>泛型的另一个好处是消除源代码中的强制类型转换，这样代码可读性更强，且减少了转换类型出错的可能性。以下面的代码为例子，以下代码段需要强制转换，否则编译会通不过：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList list  = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.<span class="keyword">add</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">int</span> i = (<span class="built_in">int</span>) list.<span class="keyword">get</span>(<span class="number">0</span>);  <span class="comment">// 需强转</span></span><br></pre></td></tr></table></figure><p>当重写为使用泛型时，代码不需要强制转换：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list  = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.<span class="keyword">add</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">int</span> i = list.<span class="keyword">get</span>(<span class="number">0</span>);  <span class="comment">// 无需转换</span></span><br></pre></td></tr></table></figure><h2 id="2-3-避免装箱、拆箱，提高性能"><a href="#2-3-避免装箱、拆箱，提高性能" class="headerlink" title="2.3 避免装箱、拆箱，提高性能"></a>2.3 避免装箱、拆箱，提高性能</h2><p>在非泛型编程中，将简单类型作为Object传递时会引起Boxing（装箱）和Unboxing（拆箱）操作，这两个过程都是具有很大开销的。引入泛型后，就不必进行Boxing和Unboxing操作了，所以运行效率相对较高，特别在对集合操作非常频繁的系统中，这个特点带来的性能提升更加明显。泛型变量固定了类型，使用的时候就已经知道是值类型还是引用类型，避免了不必要的装箱、拆箱操作。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">object</span> a=<span class="number">1</span>;<span class="comment">//由于是object类型，会自动进行装箱操作。</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">int</span> b=(<span class="built_in">int</span>)a;<span class="comment">//强制转换，拆箱操作。这样一去一来，当次数多了以后会影响程序的运行效率。</span></span><br></pre></td></tr></table></figure><p>使用泛型后</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">GetValue</span>&lt;<span class="title">T</span>&gt;(<span class="params">T a</span>)</span> &#123;</span><br><span class="line">　　<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span>&#123;</span><br><span class="line">　　<span class="built_in">int</span> b=GetValue&lt;<span class="built_in">int</span>&gt;(<span class="number">1</span>);<span class="comment">//使用这个方法的时候已经指定了类型是int，所以不会有装箱和拆箱的操作。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-提升程序可复用性"><a href="#2-4-提升程序可复用性" class="headerlink" title="2.4 提升程序可复用性"></a>2.4 提升程序可复用性</h2><p>引入泛型的另一个意义在于：适用于多种数据类型执行相同的代码（代码复用）我们通过下面的例子来说明，代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">add</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span> &#123;</span><br><span class="line">    System.<span class="keyword">out</span>.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a + b));</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">float</span> <span class="title">add</span>(<span class="params"><span class="built_in">float</span> a, <span class="built_in">float</span> b</span>)</span> &#123;</span><br><span class="line">    System.<span class="keyword">out</span>.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a + b));</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">double</span> <span class="title">add</span>(<span class="params"><span class="built_in">double</span> a, <span class="built_in">double</span> b</span>)</span> &#123;</span><br><span class="line">    System.<span class="keyword">out</span>.println(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a + b));</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有泛型，要实现不同类型的加法，每种类型都需要重载一个add方法；通过泛型，我们可以复用为一个方法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; double <span class="title function_">add</span>(<span class="params">T a, T b</span>) &#123;</span><br><span class="line">    <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(a + <span class="string">&quot;+&quot;</span> + b + <span class="string">&quot;=&quot;</span> + (a.<span class="title function_">doubleValue</span>() + b.<span class="title function_">doubleValue</span>()));</span><br><span class="line">    <span class="keyword">return</span> a.<span class="title function_">doubleValue</span>() + b.<span class="title function_">doubleValue</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-泛型的使用"><a href="#3-泛型的使用" class="headerlink" title="3 泛型的使用"></a>3 泛型的使用</h1><h2 id="3-1-泛型类"><a href="#3-1-泛型类" class="headerlink" title="3.1 泛型类"></a>3.1 泛型类</h2><p>泛型类是指把泛型定义在类上，具体的定义格式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> 类名 &lt;泛型类型<span class="number">1</span>,...&gt; &#123;</span><br><span class="line"><span class="comment">// todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意事项：泛型类型必须是引用类型，非基本数据类型定义泛型类，在类名后添加一对尖括号，并在尖括号中填写类型参数，参数可以有多个，多个参数使用逗号分隔：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GenericClass</span>&lt;<span class="title">ab</span>,<span class="title">a</span>,<span class="title">c</span>&gt; &#123;</span><br><span class="line">  <span class="comment">// todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，这个后面的参数类型也是有规范的，不能像上面一样随意，通常类型参数我们都使用大写的单个字母表，可以任意指定，但是还是建议使用有字面含义的，让人通俗易懂，下面的字母可以参考使用：</p><ul><li>T：任意类型 type</li><li>E：集合中元素的类型 element</li><li>K：key-value形式 key</li><li>V： key-value形式 value</li><li>N： Number（数值类型）</li><li>？： 表示不确定的java类型</li></ul><p>这边举个例子，假设我们写一个通用的返回对象，对象中的某个字段的类型不定：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Response</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> boolean status;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接口返回内容，不同的接口返回的内容不一致，使用泛型数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T <span class="keyword">data</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> status</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> code</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Response(boolean status,int code,String msg,T <span class="keyword">data</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.status = status;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">data</span> = <span class="keyword">data</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>做成泛型类，他的通用性就很强了，这时候他返回的情况可能如下：先定义一个用户信息对象</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserInfo</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户编号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> userCode;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> userName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尝试返回不同的数据类型：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">Response</span>&lt;<span class="type">String</span>&gt; responseStr <span class="operator">=</span> new <span class="type">Response</span>&lt;&gt;(<span class="literal">true</span>,<span class="number">200</span>,<span class="string">&quot;success&quot;</span>,<span class="string">&quot;Hello Word&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回用户对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">UserInfo</span> userInfo <span class="operator">=</span> new <span class="type">UserInfo</span>();</span><br><span class="line">userInfo.setUserCode(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">userInfo.setUserName(<span class="string">&quot;Brand&quot;</span>);</span><br><span class="line"><span class="type">Response</span>&lt;<span class="type">UserInfo</span>&gt; responseObj <span class="operator">=</span> new <span class="type">Response</span>&lt;&gt;(<span class="literal">true</span>,<span class="number">200</span>,<span class="string">&quot;success&quot;</span>,userInfo);</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">200</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;success&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Hello Word&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="comment">// 和</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">200</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;success&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;user_code&quot;</span><span class="punctuation">:</span> <span class="string">&quot;123456&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;user_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Brand&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="3-2-泛型接口"><a href="#3-2-泛型接口" class="headerlink" title="3.2 泛型接口"></a>3.2 泛型接口</h2><p>泛型方法概述：把泛型定义在接口上，他的格式如下</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> 接口名&lt;T&gt; &#123;</span><br><span class="line">  <span class="comment">// todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意点1：方法声明中定义的形参只能在该方法里使用，而接口、类声明中定义的类型形参则可以在整个接口、类中使用。当调用fun()方法时，根据传入的实际对象，编译器就会判断出类型形参T所代表的实际类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GenericInterface</span>&lt;T&gt; &#123;</span><br><span class="line"><span class="built_in">void</span> <span class="title function_">show</span>(T value);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringShowImpl</span> <span class="keyword">implements</span> <span class="title class_">GenericInterface</span>&lt;<span class="title class_">String</span>&gt; &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">show</span>(<span class="params"><span class="title class_">String</span> value</span>) &#123;</span><br><span class="line"><span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(value);</span><br><span class="line">&#125;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NumberShowImpl</span> <span class="keyword">implements</span> <span class="title class_">GenericInterface</span>&lt;<span class="title class_">Integer</span>&gt; &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">show</span>(<span class="params"><span class="title class_">Integer</span> value</span>) &#123;</span><br><span class="line"><span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(value);</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><p>注意点2：使用泛型的时候，前后定义的泛型类型必须保持一致，否则会出现编译异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译的时候会报错，因为前后类型不一致</span></span><br><span class="line">GenericInterface&lt;String&gt; genericInterface = <span class="keyword">new</span> <span class="title class_">NumberShowImpl</span>();</span><br><span class="line"><span class="comment">// 编译正常，前面泛型接口不指定类型，由new后面的实例化来推导。</span></span><br><span class="line"><span class="type">GenericInterface</span> <span class="variable">g1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NumberShowImpl</span>();</span><br><span class="line"><span class="type">GenericInterface</span> <span class="variable">g2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringShowImpl</span>();</span><br></pre></td></tr></table></figure><h2 id="3-3-泛型方法"><a href="#3-3-泛型方法" class="headerlink" title="3.3 泛型方法"></a>3.3 泛型方法</h2><p>泛型方法，是在调用方法的时候指明泛型的具体类型 。定义格式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;泛型类型&gt; 返回类型 方法名（泛型类型 变量名） &#123;</span><br><span class="line">   <span class="comment">// todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例说明，下面是一个典型的泛型方法，根据传入的对象，打印它的值和类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 泛型方法    </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; 泛型的类型</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> c 传入泛型的参数对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> T 返回值为T类型</span></span><br><span class="line"><span class="comment">     * 说明：</span></span><br><span class="line"><span class="comment">     *   1）public 与 返回值中间&lt;T&gt;非常重要，可以理解为声明此方法为泛型方法。</span></span><br><span class="line"><span class="comment">     *   2）只有声明了&lt;T&gt;的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。</span></span><br><span class="line"><span class="comment">     *   3）&lt;T&gt;表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。</span></span><br><span class="line"><span class="comment">     *   4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E等形式的参数常用于表示泛型。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">genercMethod</span>(<span class="params">T c</span>) &#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(c.<span class="title function_">getClass</span>());</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(c);</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">   &#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="title class_">String</span>[] args</span>) &#123;</span><br><span class="line">    <span class="title class_">GenericsClassDemo</span>&lt;<span class="title class_">String</span>&gt; genericString  = <span class="keyword">new</span> <span class="title class_">GenericsClassDemo</span>(<span class="string">&quot;Hello World&quot;</span>); <span class="comment">//这里的泛型跟下面调用的泛型方法可以不一样。</span></span><br><span class="line">    <span class="title class_">String</span> str = genericString.<span class="title function_">genercMethod</span>(<span class="string">&quot;brand&quot;</span>);<span class="comment">//传入的是String类型,返回的也是String类型</span></span><br><span class="line">    <span class="title class_">Integer</span> i = genericString.<span class="title function_">genercMethod</span>(<span class="number">100</span>);<span class="comment">//传入的是Integer类型,返回的也是Integer类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> java.lang.<span class="type">String</span></span><br><span class="line">brand </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> java.lang.<span class="type">Integer</span></span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure><p>从上面可以看出，泛型方法随着我们的传入参数类型不同，执行的效果不同，拿到的结果也不一样。泛型方法能使方法独立于类而产生变化。</p><h2 id="3-4-泛型通配符（上下界）"><a href="#3-4-泛型通配符（上下界）" class="headerlink" title="3.4 泛型通配符（上下界）"></a>3.4 泛型通配符（上下界）</h2><p>Java泛型的通配符是用于解决泛型之间引用传递问题的特殊语法, 主要有以下三类:</p><ul><li>无边界的通配符，使用精确的参数类型</li><li>关键字声明了类型的上界，表示参数化的类型可能是所指定的类型，或者是此类型的子类</li><li>关键字声明了类型的下界，表示参数化的类型可能是指定的类型，或者是此类型的父类</li></ul><p>结构如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示类型参数可以是任何类型</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">B&lt;?&gt;</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 上界：表示类型参数必须是A或者是A的子类</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">B&lt;T</span> <span class="keyword">extends</span> <span class="title">A&gt;</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 下界：表示类型参数必须是A或者是A的超类型</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">B&lt;T</span> <span class="title">supers</span> <span class="title">A&gt;</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上界示例：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Info</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt;&#123;    <span class="comment">// 此处泛型只能是数字类型</span></span><br><span class="line">    <span class="keyword">private</span> T <span class="keyword">var</span> ;        <span class="comment">// 定义泛型变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">setVar</span>(<span class="params">T <span class="keyword">var</span></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">var</span> = <span class="keyword">var</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getVar</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">var</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">String</span> <span class="title function_">toString</span>(<span class="params"></span>)&#123;    <span class="comment">// 直接打印</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">var</span>.<span class="title function_">toString</span>() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo1</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="title class_">String</span> args[]</span>)&#123;</span><br><span class="line">        <span class="title class_">Info</span>&lt;<span class="title class_">Integer</span>&gt; i1 = <span class="keyword">new</span> <span class="title class_">Info</span>&lt;<span class="title class_">Integer</span>&gt;() ;        <span class="comment">// 声明Integer的泛型对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下界示例：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Info</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> T <span class="keyword">var</span> ;        <span class="comment">// 定义泛型变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">setVar</span>(<span class="params">T <span class="keyword">var</span></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">var</span> = <span class="keyword">var</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getVar</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">var</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">String</span> <span class="title function_">toString</span>(<span class="params"></span>)&#123;    <span class="comment">// 直接打印</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">var</span>.<span class="title function_">toString</span>() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericsDemo21</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="title class_">String</span> args[]</span>)&#123;</span><br><span class="line">        <span class="title class_">Info</span>&lt;<span class="title class_">String</span>&gt; i1 = <span class="keyword">new</span> <span class="title class_">Info</span>&lt;<span class="title class_">String</span>&gt;() ;        <span class="comment">// 声明String的泛型对象</span></span><br><span class="line">        <span class="title class_">Info</span>&lt;<span class="title class_">Object</span>&gt; i2 = <span class="keyword">new</span> <span class="title class_">Info</span>&lt;<span class="title class_">Object</span>&gt;() ;        <span class="comment">// 声明Object的泛型对象</span></span><br><span class="line">        i1.<span class="title function_">setVar</span>(<span class="string">&quot;hello&quot;</span>) ;</span><br><span class="line">        i2.<span class="title function_">setVar</span>(<span class="keyword">new</span> <span class="title class_">Object</span>()) ;</span><br><span class="line">        <span class="title function_">fun</span>(i1) ;</span><br><span class="line">        <span class="title function_">fun</span>(i2) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">fun</span>(<span class="params"><span class="title class_">Info</span>&lt;? <span class="variable language_">super</span> <span class="title class_">String</span>&gt; temp</span>)&#123;    <span class="comment">// 只能接收String或Object类型的泛型，String类的父类只有Object类</span></span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">print</span>(temp + <span class="string">&quot;, &quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-泛型实现原理"><a href="#4-泛型实现原理" class="headerlink" title="4 泛型实现原理"></a>4 泛型实现原理</h1><p>Java泛型这个特性是从JDK 1.5才开始加入的，因此为了兼容之前的版本，Java泛型的实现采取了“伪泛型”的策略，即Java在语法上支持泛型，但是在编译阶段会进行所谓的“类型擦除”（Type Erasure），将所有的泛型表示（尖括号中的内容）都替换为具体的类型（其对应的原生态类型），就像完全没有泛型一样。泛型本质是将数据类型参数化，它通过擦除的方式来实现，即编译器会在编译期间「擦除」泛型语法并相应的做出一些类型转换动作。</p><h2 id="4-1-泛型的类型擦除原则"><a href="#4-1-泛型的类型擦除原则" class="headerlink" title="4.1 泛型的类型擦除原则"></a>4.1 泛型的类型擦除原则</h2><ul><li>消除类型参数声明，即删除&lt;&gt;及其包围的部分。</li><li>根据类型参数的上下界推断并替换所有的类型参数为原生态类型：如果类型参数是无限制通配符或没有上下界限定则替换为Object，如果存在上下界限定则根据子类替换原则取类型参数的最左边限定类型（即父类）。</li><li>为了保证类型安全，必要时插入强制类型转换代码。</li><li>自动产生“桥接方法”以保证擦除类型后的代码仍然具有泛型的“多态性”。</li></ul><h2 id="4-2-擦除的方式"><a href="#4-2-擦除的方式" class="headerlink" title="4.2 擦除的方式"></a>4.2 擦除的方式</h2><p>擦除类定义中的类型参数 - 无限制类型擦除当类定义中的类型参数没有任何限制时，在类型擦除中直接被替换为Object，即形如和&lt;?&gt;的类型参数都被替换为Object。<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAOuaUZEE7kXf-LskRyKeVD8U5gSW_MAAqQLaxvRfjBWhlqk_K2Zn5YBAAMCAAN4AAM2BA.png" alt="image"></p><p>擦除类定义中的类型参数 - 有限制类型擦除当类定义中的类型参数存在限制（上下界）时，在类型擦除中替换为类型参数的上界或者下界，比如形如和&lt;? extends Number&gt;的类型参数被替换为Number，&lt;? super Number&gt;被替换为Object。<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAOwaUZEbYG6OtsOFfmEjXV5RpPnMCMAAqYLaxvRfjBWFY3al3FhwbgBAAMCAAN4AAM2BA.png" alt="image"></p><p>擦除方法定义中的类型参数<br>擦除方法定义中的类型参数原则和擦除类定义中的类型参数是一样的，这里仅以擦除方法定义中的有限制类型参数为例。<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAOxaUZEjIuz4SZomFu9lisvA8Lfu4wAAqcLaxvRfjBWtquZ5GSxUg0BAAMCAAN5AAM2BA.png" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> Java核心系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java核心 </tag>
            
            <tag> Java基础 </tag>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring框架核心知识</title>
      <link href="/2025/02/18/Java%E5%9B%9E%E9%A1%BE-%E6%A1%86%E6%9E%B6%E7%AF%87/"/>
      <url>/2025/02/18/Java%E5%9B%9E%E9%A1%BE-%E6%A1%86%E6%9E%B6%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="框架篇"><a href="#框架篇" class="headerlink" title="框架篇"></a>框架篇</h1><h2 id="1-Spring-refresh-流程"><a href="#1-Spring-refresh-流程" class="headerlink" title="1. Spring refresh 流程"></a>1. Spring refresh 流程</h2><p><strong>要求</strong></p><ul><li>掌握 refresh 的 12 个步骤</li></ul><p><strong>Spring refresh 概述</strong></p><p>refresh 是 AbstractApplicationContext 中的一个方法，负责初始化 ApplicationContext 容器，容器必须调用 refresh 才能正常工作。它的内部主要会调用 12 个方法，我们把它们称为 refresh 的 12 个步骤：</p><ol><li>prepareRefresh</li><li>obtainFreshBeanFactory</li><li>prepareBeanFactory</li><li>postProcessBeanFactory</li><li>invokeBeanFactoryPostProcessors</li><li>registerBeanPostProcessors</li><li>initMessageSource</li><li>initApplicationEventMulticaster</li><li>onRefresh</li><li>registerListeners</li><li>finishBeanFactoryInitialization</li><li>finishRefresh</li></ol><blockquote><p><em><strong>功能分类</strong></em></p><ul><li><p>1 为准备环境</p></li><li><p>2 3 4 5 6 为准备 BeanFactory</p></li><li><p>7 8 9 10 12 为准备 ApplicationContext</p></li><li><p>11 为初始化 BeanFactory 中非延迟单例 bean</p></li></ul></blockquote><p><strong>1. prepareRefresh</strong></p><ul><li><p>这一步创建和准备了 Environment 对象，它作为 ApplicationContext 的一个成员变量</p></li><li><p>Environment 对象的作用之一是为后续 @Value，值注入时提供键值</p></li><li><p>Environment 分成三个主要部分</p><ul><li>systemProperties - 保存 java 环境键值</li><li>systemEnvironment - 保存系统环境键值</li><li>自定义 PropertySource - 保存自定义键值，例如来自于 *.properties 文件的键值</li></ul></li></ul><p><strong>2. obtainFreshBeanFactory</strong></p><ul><li>这一步获取（或创建） BeanFactory，它也是作为 ApplicationContext 的一个成员变量</li><li>BeanFactory 的作用是负责 bean 的创建、依赖注入和初始化，bean 的各项特征由 BeanDefinition 定义<ul><li>BeanDefinition 作为 bean 的设计蓝图，规定了 bean 的特征，如单例多例、依赖关系、初始销毁方法等</li><li>BeanDefinition 的来源有多种多样，可以是通过 xml 获得、配置类获得、组件扫描获得，也可以是编程添加</li></ul></li><li>所有的 BeanDefinition 会存入 BeanFactory 中的 beanDefinitionMap 集合</li></ul><p>![](.&#x2F;Java%E5%9B%9E%E9%A1%BE-%E6%A1%86%E6%9E%B6%E7%AF%87&#x2F;AgACAgUAAxkDAAMqZ7SS9ZPpRGk_NZNn7ypO3Jpfl8gAApnBMRtiZKBVLulZj_H_mKMBAAMCAAN4AAM2BA.png</p><p><strong>3. prepareBeanFactory</strong></p><ul><li>这一步会进一步完善 BeanFactory，为它的各项成员变量赋值</li><li>beanExpressionResolver 用来解析 SpEL，常见实现为 StandardBeanExpressionResolver</li><li>propertyEditorRegistrars 会注册类型转换器<ul><li>它在这里使用了 ResourceEditorRegistrar 实现类</li><li>并应用 ApplicationContext 提供的 Environment 完成 ${ } 解析</li></ul></li><li>registerResolvableDependency 来注册 beanFactory 以及 ApplicationContext，让它们也能用于依赖注入</li><li>beanPostProcessors 是 bean 后处理器集合，会工作在 bean 的生命周期各个阶段，此处会添加两个：<ul><li>ApplicationContextAwareProcessor 用来解析 Aware 接口</li><li>ApplicationListenerDetector 用来识别容器中 ApplicationListener 类型的 bean</li></ul></li></ul><p><strong>4. postProcessBeanFactory</strong></p><ul><li>这一步是空实现，留给子类扩展。<ul><li>一般 Web 环境的 ApplicationContext 都要利用它注册新的 Scope，完善 Web 下的 BeanFactory</li></ul></li><li>这里体现的是模板方法设计模式</li></ul><p><strong>5. invokeBeanFactoryPostProcessors</strong></p><ul><li>这一步会调用 beanFactory 后处理器</li><li>beanFactory 后处理器，充当 beanFactory 的扩展点，可以用来补充或修改 BeanDefinition</li><li>常见的 beanFactory 后处理器有<ul><li>ConfigurationClassPostProcessor – 解析 @Configuration、@Bean、@Import、@PropertySource 等</li><li>PropertySourcesPlaceHolderConfigurer – 替换 BeanDefinition 中的 ${ }</li><li>MapperScannerConfigurer – 补充 Mapper 接口对应的 BeanDefinition</li></ul></li></ul><p><strong>6. registerBeanPostProcessors</strong></p><ul><li>这一步是继续从 beanFactory 中找出 bean 后处理器，添加至 beanPostProcessors 集合中</li><li>bean 后处理器，充当 bean 的扩展点，可以工作在 bean 的实例化、依赖注入、初始化阶段，常见的有：<ul><li>AutowiredAnnotationBeanPostProcessor 功能有：解析 @Autowired，@Value 注解</li><li>CommonAnnotationBeanPostProcessor 功能有：解析 @Resource，@PostConstruct，@PreDestroy</li><li>AnnotationAwareAspectJAutoProxyCreator 功能有：为符合切点的目标 bean 自动创建代理</li></ul></li></ul><p><strong>7. initMessageSource</strong></p><ul><li>这一步是为 ApplicationContext 添加 messageSource 成员，实现国际化功能</li><li>去 beanFactory 内找名为 messageSource 的 bean，如果没有，则提供空的 MessageSource 实现</li></ul><p><strong>8. initApplicationContextEventMulticaster</strong></p><ul><li>这一步为 ApplicationContext 添加事件广播器成员，即 applicationContextEventMulticaster</li><li>它的作用是发布事件给监听器</li><li>去 beanFactory 找名为 applicationEventMulticaster 的 bean 作为事件广播器，若没有，会创建默认的事件广播器</li><li>之后就可以调用 ApplicationContext.publishEvent(事件对象) 来发布事件</li></ul><p><strong>9. onRefresh</strong></p><ul><li>这一步是空实现，留给子类扩展<ul><li>SpringBoot 中的子类在这里准备了 WebServer，即内嵌 web 容器</li></ul></li><li>体现的是模板方法设计模式</li></ul><p><strong>10. registerListeners</strong></p><ul><li>这一步会从多种途径找到事件监听器，并添加至 applicationEventMulticaster</li><li>事件监听器顾名思义，用来接收事件广播器发布的事件，有如下来源<ul><li>事先编程添加的</li><li>来自容器中的 bean</li><li>来自于 @EventListener 的解析</li></ul></li><li>要实现事件监听器，只需要实现 ApplicationListener 接口，重写其中 onApplicationEvent(E e) 方法即可</li></ul><p><strong>11. finishBeanFactoryInitialization</strong></p><ul><li>这一步会将 beanFactory 的成员补充完毕，并初始化所有非延迟单例 bean</li><li>conversionService 也是一套转换机制，作为对 PropertyEditor 的补充</li><li>embeddedValueResolvers 即内嵌值解析器，用来解析 @Value 中的 ${ }，借用的是 Environment 的功能</li><li>singletonObjects 即单例池，缓存所有单例对象<ul><li>对象的创建都分三个阶段，每一阶段都有不同的 bean 后处理器参与进来，扩展功能</li></ul></li></ul><p><strong>12. finishRefresh</strong></p><ul><li>这一步会为 ApplicationContext 添加 lifecycleProcessor 成员，用来控制容器内需要生命周期管理的 bean</li><li>如果容器中有名称为 lifecycleProcessor 的 bean 就用它，否则创建默认的生命周期管理器</li><li>准备好生命周期管理器，就可以实现<ul><li>调用 context 的 start，即可触发所有实现 LifeCycle 接口 bean 的 start</li><li>调用 context 的 stop，即可触发所有实现 LifeCycle 接口 bean 的 stop</li></ul></li><li>发布 ContextRefreshed 事件，整个 refresh 执行完成</li></ul><h2 id="2-Spring-bean-生命周期"><a href="#2-Spring-bean-生命周期" class="headerlink" title="2. Spring bean 生命周期"></a>2. Spring bean 生命周期</h2><p><strong>要求</strong></p><ul><li>掌握 Spring bean 的生命周期</li></ul><p><strong>bean 生命周期 概述</strong></p><p>bean 的生命周期从调用 beanFactory 的 getBean 开始，到这个 bean 被销毁，可以总结为以下七个阶段：</p><ol><li>处理名称，检查缓存</li><li>处理父子容器</li><li>处理 dependsOn</li><li>选择 scope 策略</li><li>创建 bean</li><li>类型转换处理</li><li>销毁 bean</li></ol><blockquote><p><em><strong>注意</strong></em></p><ul><li>划分的阶段和名称并不重要，重要的是理解整个过程中做了哪些事情</li></ul></blockquote><p><strong>1. 处理名称，检查缓存</strong></p><ul><li>这一步会处理别名，将别名解析为实际名称</li><li>对 FactoryBean 也会特殊处理，如果以 &amp; 开头表示要获取 FactoryBean 本身，否则表示要获取其产品</li><li>这里针对单例对象会检查一级、二级、三级缓存<ul><li>singletonFactories 三级缓存，存放单例工厂对象</li><li>earlySingletonObjects 二级缓存，存放单例工厂的产品对象<ul><li>如果发生循环依赖，产品是代理；无循环依赖，产品是原始对象</li></ul></li><li>singletonObjects 一级缓存，存放单例成品对象</li></ul></li></ul><p><strong>2. 处理父子容器</strong></p><ul><li>如果当前容器根据名字找不到这个 bean，此时若父容器存在，则执行父容器的 getBean 流程</li><li>父子容器的 bean 名称可以重复</li></ul><p><strong>3. 处理 dependsOn</strong></p><ul><li>如果当前 bean 有通过 dependsOn 指定了非显式依赖的 bean，这一步会提前创建这些 dependsOn 的 bean </li><li>所谓非显式依赖，就是指两个 bean 之间不存在直接依赖关系，但需要控制它们的创建先后顺序</li></ul><p><strong>4. 选择 scope 策略</strong></p><ul><li>对于 singleton scope，首先到单例池去获取 bean，如果有则直接返回，没有再进入创建流程</li><li>对于 prototype scope，每次都会进入创建流程</li><li>对于自定义 scope，例如 request，首先到 request 域获取 bean，如果有则直接返回，没有再进入创建流程</li></ul><p><strong>5.1 创建 bean - 创建 bean 实例</strong></p><table><thead><tr><th><strong>要点</strong></th><th><strong>总结</strong></th></tr></thead><tbody><tr><td>有自定义 TargetSource 的情况</td><td>由 AnnotationAwareAspectJAutoProxyCreator 创建代理返回</td></tr><tr><td>Supplier 方式创建 bean 实例</td><td>为 Spring 5.0 新增功能，方便编程方式创建  bean  实例</td></tr><tr><td>FactoryMethod 方式  创建 bean  实例</td><td>① 分成静态工厂与实例工厂；② 工厂方法若有参数，需要对工厂方法参数进行解析，利用  resolveDependency；③ 如果有多个工厂方法候选者，还要进一步按权重筛选</td></tr><tr><td>AutowiredAnnotationBeanPostProcessor</td><td>① 优先选择带  @Autowired  注解的构造；② 若有唯一的带参构造，也会入选</td></tr><tr><td>mbd.getPreferredConstructors</td><td>选择所有公共构造，这些构造之间按权重筛选</td></tr><tr><td>采用默认构造</td><td>如果上面的后处理器和 BeanDefiniation 都没找到构造，采用默认构造，即使是私有的</td></tr></tbody></table><p><strong>5.2 创建 bean - 依赖注入</strong></p><table><thead><tr><th><strong>要点</strong></th><th><strong>总结</strong></th></tr></thead><tbody><tr><td>AutowiredAnnotationBeanPostProcessor</td><td>识别   @Autowired  及 @Value  标注的成员，封装为  InjectionMetadata 进行依赖注入</td></tr><tr><td>CommonAnnotationBeanPostProcessor</td><td>识别   @Resource  标注的成员，封装为  InjectionMetadata 进行依赖注入</td></tr><tr><td>resolveDependency</td><td>用来查找要装配的值，可以识别：① Optional；② ObjectFactory 及 ObjectProvider；③ @Lazy  注解；④ @Value  注解（${  }, #{ }, 类型转换）；⑤ 集合类型（Collection，Map，数组等）；⑥ 泛型和  @Qualifier（用来区分类型歧义）；⑦ primary  及名字匹配（用来区分类型歧义）</td></tr><tr><td>AUTOWIRE_BY_NAME</td><td>根据成员名字找 bean 对象，修改 mbd 的 propertyValues，不会考虑简单类型的成员</td></tr><tr><td>AUTOWIRE_BY_TYPE</td><td>根据成员类型执行 resolveDependency 找到依赖注入的值，修改  mbd 的 propertyValues</td></tr><tr><td>applyPropertyValues</td><td>根据 mbd 的 propertyValues 进行依赖注入（即xml中 &#96;&lt;property name ref</td></tr></tbody></table><p><strong>5.3 创建 bean - 初始化</strong></p><table><thead><tr><th><strong>要点</strong></th><th><strong>总结</strong></th></tr></thead><tbody><tr><td>内置 Aware 接口的装配</td><td>包括 BeanNameAware，BeanFactoryAware 等</td></tr><tr><td>扩展 Aware 接口的装配</td><td>由 ApplicationContextAwareProcessor 解析，执行时机在  postProcessBeforeInitialization</td></tr><tr><td>@PostConstruct</td><td>由 CommonAnnotationBeanPostProcessor 解析，执行时机在  postProcessBeforeInitialization</td></tr><tr><td>InitializingBean</td><td>通过接口回调执行初始化</td></tr><tr><td>initMethod</td><td>根据 BeanDefinition 得到的初始化方法执行初始化，即 <code>&lt;bean init-method&gt;</code> 或 @Bean(initMethod)</td></tr><tr><td>创建 aop 代理</td><td>由 AnnotationAwareAspectJAutoProxyCreator 创建，执行时机在  postProcessAfterInitialization</td></tr></tbody></table><p><strong>5.4 创建 bean - 注册可销毁 bean</strong></p><p>在这一步判断并登记可销毁 bean</p><ul><li>判断依据<ul><li>如果实现了 DisposableBean 或 AutoCloseable 接口，则为可销毁 bean</li><li>如果自定义了 destroyMethod，则为可销毁 bean</li><li>如果采用 @Bean 没有指定 destroyMethod，则采用自动推断方式获取销毁方法名（close，shutdown）</li><li>如果有 @PreDestroy 标注的方法</li></ul></li><li>存储位置<ul><li>singleton scope 的可销毁 bean 会存储于 beanFactory 的成员当中</li><li>自定义 scope 的可销毁 bean 会存储于对应的域对象当中</li><li>prototype scope 不会存储，需要自己找到此对象销毁</li></ul></li><li>存储时都会封装为 DisposableBeanAdapter 类型对销毁方法的调用进行适配</li></ul><p><strong>6. 类型转换处理</strong></p><ul><li>如果 getBean 的 requiredType 参数与实际得到的对象类型不同，会尝试进行类型转换</li></ul><p><strong>7. 销毁 bean</strong></p><ul><li>销毁时机<ul><li>singleton bean 的销毁在 ApplicationContext.close 时，此时会找到所有 DisposableBean 的名字，逐一销毁</li><li>自定义 scope bean 的销毁在作用域对象生命周期结束时</li><li>prototype bean 的销毁可以通过自己手动调用 AutowireCapableBeanFactory.destroyBean 方法执行销毁</li></ul></li><li>同一 bean 中不同形式销毁方法的调用次序<ul><li>优先后处理器销毁，即 @PreDestroy</li><li>其次 DisposableBean 接口销毁</li><li>最后 destroyMethod 销毁（包括自定义名称，推断名称，AutoCloseable 接口 多选一）</li></ul></li></ul><h2 id="3-Spring-bean-循环依赖"><a href="#3-Spring-bean-循环依赖" class="headerlink" title="3. Spring bean 循环依赖"></a>3. Spring bean 循环依赖</h2><p><strong>要求</strong></p><ul><li>掌握单例 set 方式循环依赖的原理</li><li>掌握其它循环依赖的解决方法</li></ul><p><strong>循环依赖的产生</strong></p><ul><li><p>首先要明白，bean 的创建要遵循一定的步骤，必须是创建、注入、初始化三步，这些顺序不能乱</p></li><li><p>set 方法（包括成员变量）的循环依赖如图所示</p><ul><li><p>可以在【a 创建】和【a set 注入 b】之间加入 b 的整个流程来解决</p></li><li><p>【b set 注入 a】 时可以成功，因为之前 a 的实例已经创建完毕</p></li><li><p>a 的顺序，及 b 的顺序都能得到保障</p></li></ul></li><li><p>构造方法的循环依赖如图所示，显然无法用前面的方法解决</p></li></ul><p><strong>构造循环依赖的解决</strong></p><ul><li><p>思路1</p><ul><li>a 注入 b 的代理对象，这样能够保证 a 的流程走通</li><li>后续需要用到 b 的真实对象时，可以通过代理间接访问</li></ul></li><li><p>思路2</p><ul><li>a 注入 b 的工厂对象，让 b 的实例创建被推迟，这样能够保证 a 的流程先走通</li><li>后续需要用到 b 的真实对象时，再通过 ObjectFactory 工厂间接访问</li></ul></li><li><p>示例1：用 @Lazy 为构造方法参数生成代理</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App60_1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        <span class="keyword">private</span> B b;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(<span class="meta">@Lazy</span> B b)</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;A(B b) &#123;&#125;&quot;</span>, b.getClass());</span><br><span class="line">            <span class="built_in">this</span>.b = b;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@PostConstruct</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;init()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        <span class="keyword">private</span> A a;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">B</span><span class="params">(A a)</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;B(&#123;&#125;)&quot;</span>, a);</span><br><span class="line">            <span class="built_in">this</span>.a = a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@PostConstruct</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;init()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">        context.registerBean(<span class="string">&quot;a&quot;</span>, A.class);</span><br><span class="line">        context.registerBean(<span class="string">&quot;b&quot;</span>, B.class);</span><br><span class="line">        AnnotationConfigUtils.registerAnnotationConfigProcessors(context.getDefaultListableBeanFactory());</span><br><span class="line">        context.refresh();</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>示例2：用 ObjectProvider 延迟依赖对象的创建</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App60_2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        <span class="keyword">private</span> ObjectProvider&lt;B&gt; b;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(ObjectProvider&lt;B&gt; b)</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;A(&#123;&#125;)&quot;</span>, b);</span><br><span class="line">            <span class="built_in">this</span>.b = b;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@PostConstruct</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;init()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        <span class="keyword">private</span> A a;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">B</span><span class="params">(A a)</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;B(&#123;&#125;)&quot;</span>, a);</span><br><span class="line">            <span class="built_in">this</span>.a = a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@PostConstruct</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;init()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">        context.registerBean(<span class="string">&quot;a&quot;</span>, A.class);</span><br><span class="line">        context.registerBean(<span class="string">&quot;b&quot;</span>, B.class);</span><br><span class="line">        AnnotationConfigUtils.registerAnnotationConfigProcessors(context.getDefaultListableBeanFactory());</span><br><span class="line">        context.refresh();</span><br><span class="line"></span><br><span class="line">        System.out.println(context.getBean(A.class).b.getObject());</span><br><span class="line">        System.out.println(context.getBean(B.class));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>示例3：用 @Scope 产生代理</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App60_3</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">        <span class="type">ClassPathBeanDefinitionScanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathBeanDefinitionScanner</span>(context.getDefaultListableBeanFactory());</span><br><span class="line">        scanner.scan(<span class="string">&quot;com.itheima.app60.sub&quot;</span>);</span><br><span class="line">        context.refresh();</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(B b)</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;A(B b) &#123;&#125;&quot;</span>, b.getClass());</span><br><span class="line">        <span class="built_in">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;init()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope(proxyMode = ScopedProxyMode.TARGET_CLASS)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">(A a)</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;B(&#123;&#125;)&quot;</span>, a);</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;init()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>示例4：用 Provider 接口解决，原理上与 ObjectProvider 一样，Provider 接口是独立的 jar 包，需要加入依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.inject<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.inject<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App60_4</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        <span class="keyword">private</span> Provider&lt;B&gt; b;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(Provider&lt;B&gt; b)</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;A(&#123;&#125;&#125;)&quot;</span>, b);</span><br><span class="line">            <span class="built_in">this</span>.b = b;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@PostConstruct</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;init()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        <span class="keyword">private</span> A a;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">B</span><span class="params">(A a)</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;B(&#123;&#125;&#125;)&quot;</span>, a);</span><br><span class="line">            <span class="built_in">this</span>.a = a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@PostConstruct</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;init()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">        context.registerBean(<span class="string">&quot;a&quot;</span>, A.class);</span><br><span class="line">        context.registerBean(<span class="string">&quot;b&quot;</span>, B.class);</span><br><span class="line">        AnnotationConfigUtils.registerAnnotationConfigProcessors(context.getDefaultListableBeanFactory());</span><br><span class="line">        context.refresh();</span><br><span class="line"></span><br><span class="line">        System.out.println(context.getBean(A.class).b.get());</span><br><span class="line">        System.out.println(context.getBean(B.class));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解决-set-循环依赖的原理"><a href="#解决-set-循环依赖的原理" class="headerlink" title="解决 set 循环依赖的原理"></a>解决 set 循环依赖的原理</h3><p><strong>一级缓存</strong></p><p>作用是保证单例对象仅被创建一次</p><ul><li>第一次走 <code>getBean(&quot;a&quot;)</code> 流程后，最后会将成品 a 放入 singletonObjects 一级缓存</li><li>后续再走 <code>getBean(&quot;a&quot;)</code> 流程时，先从一级缓存中找，这时已经有成品 a，就无需再次创建</li></ul><p><strong>一级缓存与循环依赖</strong></p><p>一级缓存无法解决循环依赖问题，分析如下</p><ul><li>无论是获取 bean a 还是获取 bean b，走的方法都是同一个 getBean 方法，假设先走 <code>getBean(&quot;a&quot;)</code></li><li>当 a 的实例对象创建，接下来执行 <code>a.setB()</code> 时，需要走 <code>getBean(&quot;b&quot;)</code> 流程，红色箭头 1</li><li>当 b 的实例对象创建，接下来执行 <code>b.setA()</code> 时，又回到了 <code>getBean(&quot;a&quot;)</code> 的流程，红色箭头 2</li><li>但此时 singletonObjects 一级缓存内没有成品的 a，陷入了死循环</li></ul><p><strong>二级缓存</strong></p><p>解决思路如下：</p><ul><li>再增加一个 singletonFactories 缓存</li><li>在依赖注入前，即 <code>a.setB()</code> 以及 <code>b.setA()</code> 将 a 及 b 的半成品对象（未完成依赖注入和初始化）放入此缓存</li><li>执行依赖注入时，先看看 singletonFactories 缓存中是否有半成品的对象，如果有拿来注入，顺利走完流程</li></ul><p>对于上面的图</p><ul><li><code>a = new A()</code> 执行之后就会把这个半成品的 a 放入 singletonFactories 缓存，即 <code>factories.put(a)</code></li><li>接下来执行 <code>a.setB()</code>，走入 <code>getBean(&quot;b&quot;)</code> 流程，红色箭头 3</li><li>这回再执行到 <code>b.setA()</code> 时，需要一个 a 对象，有没有呢？有！</li><li><code>factories.get()</code> 在 singletonFactories  缓存中就可以找到，红色箭头 4 和 5</li><li>b 的流程能够顺利走完，将 b 成品放入 singletonObject 一级缓存，返回到 a 的依赖注入流程，红色箭头 6</li></ul><p><strong>二级缓存与创建代理</strong></p><p>二级缓存无法正确处理循环依赖并且包含有代理创建的场景，分析如下</p><ul><li>spring 默认要求，在 <code>a.init</code> 完成之后才能创建代理 <code>pa = proxy(a)</code></li><li>由于 a 的代理创建时机靠后，在执行 <code>factories.put(a)</code> 向 singletonFactories 中放入的还是原始对象</li><li>接下来箭头 3、4、5 这几步 b 对象拿到和注入的都是原始对象</li></ul><p><strong>三级缓存</strong></p><p>简单分析的话，只需要将代理的创建时机放在依赖注入之前即可，但 spring 仍然希望代理的创建时机在 init 之后，只有出现循环依赖时，才会将代理的创建时机提前。所以解决思路稍显复杂：</p><ul><li>图中 <code>factories.put(fa)</code> 放入的既不是原始对象，也不是代理对象而是工厂对象 fa</li><li>当检查出发生循环依赖时，fa 的产品就是代理 pa，没有发生循环依赖，fa 的产品是原始对象 a</li><li>假设出现了循环依赖，拿到了 singletonFactories 中的工厂对象，通过在依赖注入前获得了 pa，红色箭头 5</li><li>这回 <code>b.setA()</code> 注入的就是代理对象，保证了正确性，红色箭头 7</li><li>还需要把 pa 存入新加的 earlySingletonObjects 缓存，红色箭头 6</li><li><code>a.init</code> 完成后，无需二次创建代理，从哪儿找到 pa 呢？earlySingletonObjects 已经缓存，蓝色箭头 9</li></ul><p>当成品对象产生，放入 singletonObject 后，singletonFactories 和 earlySingletonObjects 就中的对象就没有用处，清除即可</p><h2 id="4-Spring-事务失效"><a href="#4-Spring-事务失效" class="headerlink" title="4. Spring 事务失效"></a>4. Spring 事务失效</h2><p><strong>要求</strong></p><ul><li>掌握事务失效的八种场景</li></ul><p><strong>1. 抛出检查异常导致事务不能正确回滚</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountMapper accountMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> amount)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fromBalance</span> <span class="operator">=</span> accountMapper.findBalanceBy(from);</span><br><span class="line">        <span class="keyword">if</span> (fromBalance - amount &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            accountMapper.update(from, -<span class="number">1</span> * amount);</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">            accountMapper.update(to, amount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>原因：Spring 默认只会回滚非检查异常</p></li><li><p>解法：配置 rollbackFor 属性</p><ul><li><code>@Transactional(rollbackFor = Exception.class)</code></li></ul></li></ul><p><strong>2. 业务方法内自己 try-catch 异常导致事务不能正确回滚</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountMapper accountMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> amount)</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">fromBalance</span> <span class="operator">=</span> accountMapper.findBalanceBy(from);</span><br><span class="line">            <span class="keyword">if</span> (fromBalance - amount &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                accountMapper.update(from, -<span class="number">1</span> * amount);</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">                accountMapper.update(to, amount);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>原因：事务通知只有捉到了目标抛出的异常，才能进行后续的回滚处理，如果目标自己处理掉异常，事务通知无法知悉</p></li><li><p>解法1：异常原样抛出</p><ul><li>在 catch 块添加 <code>throw new RuntimeException(e);</code></li></ul></li><li><p>解法2：手动设置 TransactionStatus.setRollbackOnly()</p><ul><li>在 catch 块添加 <code>TransactionInterceptor.currentTransactionStatus().setRollbackOnly();</code></li></ul></li></ul><p><strong>3. aop 切面顺序导致导致事务不能正确回滚</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service3</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountMapper accountMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> amount)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fromBalance</span> <span class="operator">=</span> accountMapper.findBalanceBy(from);</span><br><span class="line">        <span class="keyword">if</span> (fromBalance - amount &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            accountMapper.update(from, -<span class="number">1</span> * amount);</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">            accountMapper.update(to, amount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line">    <span class="meta">@Around(&quot;execution(* transfer(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        LoggerUtils.get().debug(<span class="string">&quot;log:&#123;&#125;&quot;</span>, pjp.getTarget());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> pjp.proceed();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>原因：事务切面优先级最低，但如果自定义的切面优先级和他一样，则还是自定义切面在内层，这时若自定义切面没有正确抛出异常…</p></li><li><p>解法1、2：同情况2 中的解法:1、2</p></li><li><p>解法3：调整切面顺序，在 MyAspect 上添加 <code>@Order(Ordered.LOWEST_PRECEDENCE - 1)</code> （不推荐）</p></li></ul><p><strong>4. 非 public 方法导致的事务失效</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service4</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountMapper accountMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> amount)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fromBalance</span> <span class="operator">=</span> accountMapper.findBalanceBy(from);</span><br><span class="line">        <span class="keyword">if</span> (fromBalance - amount &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            accountMapper.update(from, -<span class="number">1</span> * amount);</span><br><span class="line">            accountMapper.update(to, amount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>原因：Spring 为方法创建代理、添加事务通知、前提条件都是该方法是 public 的</p></li><li><p>解法1：改为 public 方法</p></li><li><p>解法2：添加 bean 配置如下（不推荐）</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> TransactionAttributeSource <span class="title function_">transactionAttributeSource</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AnnotationTransactionAttributeSource</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5. 父子容器导致的事务失效</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> day04.tx.app.service;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service5</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountMapper accountMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> amount)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fromBalance</span> <span class="operator">=</span> accountMapper.findBalanceBy(from);</span><br><span class="line">        <span class="keyword">if</span> (fromBalance - amount &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            accountMapper.update(from, -<span class="number">1</span> * amount);</span><br><span class="line">            accountMapper.update(to, amount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制器类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> day04.tx.app.controller;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> Service5 service;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> amount)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        service.transfer(from, to, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>App 配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;day04.tx.app.service&quot;)</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="comment">// ... 有事务相关配置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Web 配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;day04.tx.app&quot;)</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> &#123;</span><br><span class="line">    <span class="comment">// ... 无事务配置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在配置了父子容器，WebConfig 对应子容器，AppConfig 对应父容器，发现事务依然失效</p><ul><li><p>原因：子容器扫描范围过大，把未加事务配置的 service 扫描进来</p></li><li><p>解法1：各扫描各的，不要图简便</p></li><li><p>解法2：不要用父子容器，所有 bean 放在同一容器</p></li></ul><p><strong>6. 调用本类方法导致传播行为失效</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service6</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED, rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        LoggerUtils.get().debug(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">        bar();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW, rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        LoggerUtils.get().debug(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>原因：本类方法调用不经过代理，因此无法增强</p></li><li><p>解法1：依赖注入自己（代理）来调用</p></li><li><p>解法2：通过 AopContext 拿到代理对象，来调用</p></li><li><p>解法3：通过 CTW，LTW 实现功能增强</p></li></ul><p>解法1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service6</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Service6 proxy; <span class="comment">// 本质上是一种循环依赖</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED, rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        LoggerUtils.get().debug(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">System.out.println(proxy.getClass());</span><br><span class="line">proxy.bar();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW, rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        LoggerUtils.get().debug(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解法2，还需要在 AppConfig 上添加 <code>@EnableAspectJAutoProxy(exposeProxy = true)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service6</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED, rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        LoggerUtils.get().debug(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">        ((Service6) AopContext.currentProxy()).bar();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW, rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        LoggerUtils.get().debug(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>7. @Transactional 没有保证原子行为</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service7</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(Service7.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountMapper accountMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fromBalance</span> <span class="operator">=</span> accountMapper.findBalanceBy(from);</span><br><span class="line">        logger.debug(<span class="string">&quot;更新前查询余额为: &#123;&#125;&quot;</span>, fromBalance);</span><br><span class="line">        <span class="keyword">if</span> (fromBalance - amount &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            accountMapper.update(from, -<span class="number">1</span> * amount);</span><br><span class="line">            accountMapper.update(to, amount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findBalance</span><span class="params">(<span class="type">int</span> accountNo)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> accountMapper.findBalanceBy(accountNo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码实际上是有 bug 的，假设 from 余额为 1000，两个线程都来转账 1000，可能会出现扣减为负数的情况</p><ul><li><p>原因：事务的原子性仅涵盖 insert、update、delete、select … for update 语句，select 方法并不阻塞</p></li><li><p>如上图所示，红色线程和蓝色线程的查询都发生在扣减之前，都以为自己有足够的余额做扣减</p></li></ul><p><strong>8. @Transactional 方法导致的 synchronized 失效</strong></p><p>针对上面的问题，能否在方法上加 synchronized 锁来解决呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service7</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(Service7.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountMapper accountMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fromBalance</span> <span class="operator">=</span> accountMapper.findBalanceBy(from);</span><br><span class="line">        logger.debug(<span class="string">&quot;更新前查询余额为: &#123;&#125;&quot;</span>, fromBalance);</span><br><span class="line">        <span class="keyword">if</span> (fromBalance - amount &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            accountMapper.update(from, -<span class="number">1</span> * amount);</span><br><span class="line">            accountMapper.update(to, amount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findBalance</span><span class="params">(<span class="type">int</span> accountNo)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> accountMapper.findBalanceBy(accountNo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案是不行，原因如下：</p><ul><li><p>synchronized 保证的仅是目标方法的原子性，环绕目标方法的还有 commit 等操作，它们并未处于 sync 块内</p></li><li><p>可以参考下图发现，蓝色线程的查询只要在红色线程提交之前执行，那么依然会查询到有 1000 足够余额来转账</p></li><li><p>解法1：synchronized 范围应扩大至代理方法调用</p></li><li><p>解法2：使用 select … for update 替换 select</p></li></ul><h2 id="5-Spring-MVC-执行流程"><a href="#5-Spring-MVC-执行流程" class="headerlink" title="5. Spring MVC 执行流程"></a>5. Spring MVC 执行流程</h2><p><strong>要求</strong></p><ul><li>掌握 Spring MVC 的执行流程</li><li>了解 Spring MVC 的重要组件的作用</li></ul><p><strong>概要</strong></p><p>我把整个流程分成三个阶段</p><ul><li>准备阶段</li><li>匹配阶段</li><li>执行阶段</li></ul><p><strong>准备阶段</strong></p><ol><li><p>在 Web 容器第一次用到 DispatcherServlet 的时候，会创建其对象并执行 init 方法</p></li><li><p>init 方法内会创建 Spring Web 容器，并调用容器 refresh 方法</p></li><li><p>refresh 过程中会创建并初始化 SpringMVC 中的重要组件， 例如 MultipartResolver，HandlerMapping，HandlerAdapter，HandlerExceptionResolver、ViewResolver 等</p></li><li><p>容器初始化后，会将上一步初始化好的重要组件，赋值给 DispatcherServlet 的成员变量，留待后用</p></li></ol><p><strong>匹配阶段</strong></p><ol><li><p>用户发送的请求统一到达前端控制器 DispatcherServlet</p></li><li><p>DispatcherServlet 遍历所有 HandlerMapping ，找到与路径匹配的处理器</p><p>① HandlerMapping 有多个，每个 HandlerMapping 会返回不同的处理器对象，谁先匹配，返回谁的处理器。其中能识别 @RequestMapping 的优先级最高</p><p>② 对应 @RequestMapping 的处理器是 HandlerMethod，它包含了控制器对象和控制器方法信息</p><p>③ 其中路径与处理器的映射关系在 HandlerMapping 初始化时就会建立好</p></li><li><p>将 HandlerMethod 连同匹配到的拦截器，生成调用链对象 HandlerExecutionChain 返回</p></li><li><p>遍历HandlerAdapter 处理器适配器，找到能处理 HandlerMethod 的适配器对象，开始调用</p></li></ol><p><strong>调用阶段</strong></p><ol><li><p>执行拦截器 preHandle</p></li><li><p>由 HandlerAdapter 调用 HandlerMethod</p><p>① 调用前处理不同类型的参数</p><p>② 调用后处理不同类型的返回值</p></li><li><p>第 2 步没有异常</p><p>① 返回 ModelAndView</p><p>② 执行拦截器 postHandle 方法</p><p>③ 解析视图，得到 View 对象，进行视图渲染</p></li><li><p>第 2 步有异常，进入 HandlerExceptionResolver 异常处理流程</p></li><li><p>最后都会执行拦截器的 afterCompletion 方法</p></li><li><p>如果控制器方法标注了 @ResponseBody 注解，则在第 2 步，就会生成 json 结果，并标记 ModelAndView 已处理，这样就不会执行第 3 步的视图渲染</p></li></ol><h2 id="6-Spring-注解"><a href="#6-Spring-注解" class="headerlink" title="6. Spring 注解"></a>6. Spring 注解</h2><p><strong>要求</strong></p><ul><li>掌握 Spring 常见注解</li></ul><blockquote><p><em><strong>提示</strong></em></p><ul><li>注解的详细列表请参考：面试题-spring-注解.xmind</li><li>下面列出了视频中重点提及的注解，考虑到大部分注解同学们已经比较熟悉了，仅对个别的作简要说明</li></ul></blockquote><p><strong>事务注解</strong></p><ul><li>@EnableTransactionManagement，会额外加载 4 个 bean<ul><li>BeanFactoryTransactionAttributeSourceAdvisor 事务切面类</li><li>TransactionAttributeSource 用来解析事务属性</li><li>TransactionInterceptor 事务拦截器</li><li>TransactionalEventListenerFactory 事务监听器工厂</li></ul></li><li>@Transactional</li></ul><p><strong>核心</strong></p><ul><li>@Order</li></ul><p><strong>切面</strong></p><ul><li>@EnableAspectJAutoProxy<ul><li>会加载 AnnotationAwareAspectJAutoProxyCreator，它是一个 bean 后处理器，用来创建代理</li><li>如果没有配置 @EnableAspectJAutoProxy，又需要用到代理（如事务）则会使用 InfrastructureAdvisorAutoProxyCreator 这个 bean 后处理器</li></ul></li></ul><p><strong>组件扫描与配置类</strong></p><ul><li><p>@Component</p></li><li><p>@Controller</p></li><li><p>@Service</p></li><li><p>@Repository</p></li><li><p>@ComponentScan</p></li><li><p>@Conditional </p></li><li><p>@Configuration</p><ul><li>配置类其实相当于一个工厂, 标注 @Bean 注解的方法相当于工厂方法</li><li>@Bean 不支持方法重载, 如果有多个重载方法, 仅有一个能入选为工厂方法</li><li>@Configuration 默认会为标注的类生成代理, 其目的是保证 @Bean 方法相互调用时, 仍然能保证其单例特性</li><li>@Configuration 中如果含有 BeanFactory 后处理器, 则实例工厂方法会导致 MyConfig 提前创建, 造成其依赖注入失败，解决方法是改用静态工厂方法或直接为 @Bean 的方法参数依赖注入, 针对 Mapper 扫描可以改用注解方式</li></ul></li><li><p>@Bean</p></li><li><p>@Import </p><ul><li><p>四种用法</p><p>① 引入单个 bean</p><p>② 引入一个配置类</p><p>③ 通过 Selector 引入多个类</p><p>④ 通过 beanDefinition 注册器</p></li><li><p>解析规则</p><ul><li>同一配置类中, @Import 先解析  @Bean 后解析</li><li>同名定义, 默认后面解析的会覆盖前面解析的</li><li>不允许覆盖的情况下, 如何能够让 MyConfig(主配置类) 的配置优先? (虽然覆盖方式能解决)</li><li>采用 DeferredImportSelector，因为它最后工作, 可以简单认为先解析 @Bean, 再 Import</li></ul></li></ul></li><li><p>@Lazy</p><ul><li>加在类上，表示此类延迟实例化、初始化</li><li>加在方法参数上，此参数会以代理方式注入</li></ul></li><li><p>@PropertySource</p></li></ul><p><strong>依赖注入</strong></p><ul><li>@Autowired</li><li>@Qualifier</li><li>@Value</li></ul><p><strong>mvc mapping</strong></p><ul><li>@RequestMapping，可以派生多个注解如 @GetMapping 等</li></ul><p><strong>mvc rest</strong></p><ul><li>@RequestBody</li><li>@ResponseBody，组合 @Controller &#x3D;&gt;  @RestController</li><li>@ResponseStatus</li></ul><p><strong>mvc 统一处理</strong></p><ul><li>@ControllerAdvice，组合 @ResponseBody &#x3D;&gt; @RestControllerAdvice</li><li>@ExceptionHandler</li></ul><p><strong>mvc 参数</strong></p><ul><li>@PathVariable</li></ul><p><strong>mvc ajax</strong></p><ul><li>@CrossOrigin</li></ul><p><strong>boot auto</strong></p><ul><li>@SpringBootApplication</li><li>@EnableAutoConfiguration</li><li>@SpringBootConfiguration</li></ul><p><strong>boot condition</strong></p><ul><li>@ConditionalOnClass，classpath 下存在某个 class 时，条件才成立</li><li>@ConditionalOnMissingBean，beanFactory 内不存在某个 bean 时，条件才成立</li><li>@ConditionalOnProperty，配置文件中存在某个 property（键、值）时，条件才成立</li></ul><p><strong>boot properties</strong></p><ul><li>@ConfigurationProperties，会将当前 bean 的属性与配置文件中的键值进行绑定</li><li>@EnableConfigurationProperties，会添加两个较为重要的 bean<ul><li>ConfigurationPropertiesBindingPostProcessor，bean 后处理器，在 bean 初始化前调用下面的 binder</li><li>ConfigurationPropertiesBinder，真正执行绑定操作</li></ul></li></ul><h2 id="7-SpringBoot-自动配置原理"><a href="#7-SpringBoot-自动配置原理" class="headerlink" title="7. SpringBoot 自动配置原理"></a>7. SpringBoot 自动配置原理</h2><p><strong>要求</strong></p><ul><li>掌握 SpringBoot 自动配置原理</li></ul><p><strong>自动配置原理</strong></p><p>@SpringBootConfiguration 是一个组合注解，由 @ComponentScan、@EnableAutoConfiguration 和 @SpringBootConfiguration 组成</p><ol><li><p>@SpringBootConfiguration 与普通 @Configuration 相比，唯一区别是前者要求整个 app 中只出现一次</p></li><li><p>@ComponentScan</p><ul><li>excludeFilters - 用来在组件扫描时进行排除，也会排除自动配置类</li></ul></li><li><p>@EnableAutoConfiguration 也是一个组合注解，由下面注解组成</p><ul><li>@AutoConfigurationPackage – 用来记住扫描的起始包</li><li>@Import(AutoConfigurationImportSelector.class) 用来加载 <code>META-INF/spring.factories</code> 中的自动配置类</li></ul></li></ol><p><strong>为什么不使用 @Import 直接引入自动配置类</strong></p><p>有两个原因：</p><ol><li>让主配置类和自动配置类变成了强耦合，主配置类不应该知道有哪些从属配置</li><li>直接用 <code>@Import(自动配置类.class)</code>，引入的配置解析优先级较高，自动配置类的解析应该在主配置没提供时作为默认配置</li></ol><p>因此，采用了 <code>@Import(AutoConfigurationImportSelector.class)</code></p><ul><li>由 <code>AutoConfigurationImportSelector.class</code> 去读取 <code>META-INF/spring.factories</code> 中的自动配置类，实现了弱耦合。</li><li>另外 <code>AutoConfigurationImportSelector.class</code> 实现了 DeferredImportSelector 接口，让自动配置的解析晚于主配置的解析</li></ul><h2 id="8-Spring-中的设计模式"><a href="#8-Spring-中的设计模式" class="headerlink" title="8. Spring 中的设计模式"></a>8. Spring 中的设计模式</h2><p><strong>要求</strong></p><ul><li>掌握 Spring 中常见的设计模式</li></ul><p><strong>1. Spring 中的 Singleton</strong></p><p>请大家区分 singleton pattern 与 Spring 中的 singleton bean</p><ul><li>根据单例模式的目的 <em>Ensure a class only has one instance, and provide a global point of access to it</em> </li><li>显然 Spring 中的 singleton bean 并非实现了单例模式，singleton bean 只能保证每个容器内，相同 id 的 bean 单实例</li><li>当然 Spring 中也用到了单例模式，例如<ul><li>org.springframework.transaction.TransactionDefinition#withDefaults</li><li>org.springframework.aop.TruePointcut#INSTANCE</li><li>org.springframework.aop.interceptor.ExposeInvocationInterceptor#ADVISOR</li><li>org.springframework.core.annotation.AnnotationAwareOrderComparator#INSTANCE</li><li>org.springframework.core.OrderComparator#INSTANCE</li></ul></li></ul><p><strong>2. Spring 中的 Builder</strong></p><p>定义 <em>Separate the construction of a complex object from its representation so that the same construction process can create different representations</em> </p><p>它的主要亮点有三处：</p><ol><li><p>较为灵活的构建产品对象</p></li><li><p>在不执行最后 build 方法前，产品对象都不可用</p></li><li><p>构建过程采用链式调用，看起来比较爽</p></li></ol><p>Spring 中体现 Builder 模式的地方：</p><ul><li><p>org.springframework.beans.factory.support.BeanDefinitionBuilder</p></li><li><p>org.springframework.web.util.UriComponentsBuilder</p></li><li><p>org.springframework.http.ResponseEntity.HeadersBuilder</p></li><li><p>org.springframework.http.ResponseEntity.BodyBuilder</p></li></ul><p><strong>3. Spring 中的 Factory Method</strong></p><p>定义 <em>Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses</em> </p><p>根据上面的定义，Spring 中的 ApplicationContext 与 BeanFactory 中的 getBean 都可以视为工厂方法，它隐藏了 bean （产品）的创建过程和具体实现</p><p>Spring 中其它工厂：</p><ul><li><p>org.springframework.beans.factory.FactoryBean</p></li><li><p>@Bean 标注的静态方法及实例方法</p></li><li><p>ObjectFactory 及 ObjectProvider</p></li></ul><p>前两种工厂主要封装第三方的 bean 的创建过程，后两种工厂可以推迟 bean 创建，解决循环依赖及单例注入多例等问题</p><p><strong>4. Spring 中的 Adapter</strong></p><p>定义 <em>Convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldn’t otherwise because of incompatible interfaces</em> </p><p>典型的实现有两处：</p><ul><li>org.springframework.web.servlet.HandlerAdapter – 因为控制器实现有各种各样，比如有<ul><li>大家熟悉的 @RequestMapping 标注的控制器实现</li><li>传统的基于 Controller 接口（不是 @Controller注解啊）的实现</li><li>较新的基于 RouterFunction 接口的实现</li><li>它们的处理方法都不一样，为了统一调用，必须适配为 HandlerAdapter 接口</li></ul></li><li>org.springframework.beans.factory.support.DisposableBeanAdapter – 因为销毁方法多种多样，因此都要适配为 DisposableBean 来统一调用销毁方法</li></ul><p><strong>5. Spring 中的 Composite</strong></p><p>定义 <em>Compose objects into tree structures to represent part-whole hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly</em> </p><p>典型实现有：</p><ul><li>org.springframework.web.method.support.HandlerMethodArgumentResolverComposite</li><li>org.springframework.web.method.support.HandlerMethodReturnValueHandlerComposite</li><li>org.springframework.web.servlet.handler.HandlerExceptionResolverComposite</li><li>org.springframework.web.servlet.view.ViewResolverComposite</li></ul><p>composite 对象的作用是，将分散的调用集中起来，统一调用入口，它的特征是，与具体干活的实现实现同一个接口，当调用 composite 对象的接口方法时，其实是委托具体干活的实现来完成</p><p><strong>6. Spring 中的 Decorator</strong></p><p>定义 <em>Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality</em> </p><p>典型实现：</p><ul><li>org.springframework.web.util.ContentCachingRequestWrapper</li></ul><p><strong>7. Spring 中的 Proxy</strong></p><p>定义 <em>Provide a surrogate or placeholder for another object to control access to it</em> </p><p>装饰器模式注重的是功能增强，避免子类继承方式进行功能扩展，而代理模式更注重控制目标的访问</p><p>典型实现：</p><ul><li>org.springframework.aop.framework.JdkDynamicAopProxy</li><li>org.springframework.aop.framework.ObjenesisCglibAopProxy</li></ul><p><strong>8. Spring 中的 Chain of Responsibility</strong></p><p>定义 <em>Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request. Chain the receiving objects and pass the request along the chain until an object handles it</em> </p><p>典型实现：</p><ul><li>org.springframework.web.servlet.HandlerInterceptor</li></ul><p><strong>9. Spring 中的 Observer</strong></p><p>定义 <em>Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically</em> </p><p>典型实现：</p><ul><li>org.springframework.context.ApplicationListener</li><li>org.springframework.context.event.ApplicationEventMulticaster</li><li>org.springframework.context.ApplicationEvent</li></ul><p><strong>10. Spring 中的 Strategy</strong></p><p>定义 <em>Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it</em> </p><p>典型实现：</p><ul><li>org.springframework.beans.factory.support.InstantiationStrategy</li><li>org.springframework.core.annotation.MergedAnnotations.SearchStrategy</li><li>org.springframework.boot.autoconfigure.condition.SearchStrategy</li></ul><p><strong>11. Spring 中的 Template Method</strong></p><p>定义 <em>Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm’s structure</em> </p><p>典型实现：</p><ul><li>大部分以 Template 命名的类，如 JdbcTemplate，TransactionTemplate</li><li>很多以 Abstract 命名的类，如 AbstractApplicationContext</li></ul>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SSM </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java核心系列2：注解机制详解</title>
      <link href="/2025/02/18/Java%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%862-%E6%B3%A8%E8%A7%A3%E6%9C%BA%E5%88%B6/"/>
      <url>/2025/02/18/Java%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%862-%E6%B3%A8%E8%A7%A3%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Java注解基础"><a href="#1-Java注解基础" class="headerlink" title="1 Java注解基础"></a>1 Java注解基础</h1><p>注解是JDK1.5版本开始引入的一个特性，用于对程序代码的说明，可以对包、类、接口、字段、方法参数、局部变量等进行注解。<br>它主要的作用有以下四方面：</p><ul><li>生成javadoc文档，通过在代码里面标识元数据生成javadoc文档。</li><li>编译期的检查，通过标识的元数据让编译器在编译期间对代码进行验证。</li><li>编译时动态处理，编译时通过代码中标识的元数据动态处理，比如动态生成代码。</li><li>运行时动态处理，运行时通过代码中标识的元数据动态处理，比如使用反射技术注入实例。</li></ul><p>注解的常见分类有三种：</p><ul><li><p><strong>Java自带的标准注解</strong>，包括 @Override、@Deprecated和@SuppressWarnings，分别代表 方法重写、某个类或方法过时、以及忽略警告，用这些注解标明后编译器就会进行检查。</p></li><li><p><strong>元注解</strong>，元注解是用于定义注解的注解，包括@Retention、@Target、@Inherited、@Documented 等6种</p><ul><li>@Retention：指定其所修饰的注解的保留策略</li><li>@Document：该注解是一个标记注解，用于指示一个注解将被文档化</li><li>@Target：用来限制注解的使用范围</li><li>@Inherited：该注解使父类的注解能被其子类继承</li><li>@Repeatable：该注解是Java8新增的注解，用于开发重复注解</li><li>类型注解（Type Annotation）：该注解是Java8新增的注解，可以用在任何用到类型的地方</li></ul></li><li><p><strong>自定义注解</strong>，可以根据自己的需求定义注解，并可用元注解对自定义注解进行注解。</p></li></ul><p>接下来我们通过这三种分类来逐一理解注解。</p><h2 id="1-1-Java内置注解"><a href="#1-1-Java内置注解" class="headerlink" title="1.1 Java内置注解"></a>1.1 Java内置注解</h2><p>我们先从Java内置注解开始说起，先看下下面的代码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">rewriteMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Parent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 重载父类的 rewriteMethod() 方法</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">rewriteMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 被弃用的过时方法</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">oldMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 忽略告警</span></span><br><span class="line"><span class="comment">        * </span></span><br><span class="line"><span class="comment">        * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">&quot;keep run&quot;</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">List</span> <span class="title function_">infoList</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title class_">List</span> list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 1.5开始自带的标准注解，包括@Override、@Deprecated和@SuppressWarnings：</p><ul><li><code>@Override</code>：表示当前类中的方法定义将覆盖父类中的方法</li><li><code>@Deprecated</code>：表示该代码段被弃用，但是可以使用，只是编译器会发出警告而已</li><li><code>@SuppressWarnings</code>：表示关闭编译器的警告信息<br>我们再具体看下这几个内置注解，同时通过这几个内置注解中的元注解的定义来引出元注解。</li></ul><h3 id="1-1-1-内置注解-Override"><a href="#1-1-1-内置注解-Override" class="headerlink" title="1.1.1 内置注解 - @Override"></a>1.1.1 内置注解 - @Override</h3><p>我们先来看一下这个注解类型的定义：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="variable">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line">public <span class="variable">@interface</span> Override &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从它的定义我们可以看到，这个注解可以被用来修饰方法，并且它只在编译时有效，在编译后的class文件中便不再存在。这个注解的作用我们大家都不陌生，那就是告诉编译器被修饰的方法是重写的父类的中的相同签名的方法，编译器会对此做出检查，若发现父类中不存在这个方法或是存在的方法签名不同，则会报错。</p><h3 id="1-1-2-内置注解-Deprecated"><a href="#1-1-2-内置注解-Deprecated" class="headerlink" title="1.1.2 内置注解 - @Deprecated"></a>1.1.2 内置注解 - @Deprecated</h3><p>这个注解的定义如下：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Documented</span></span><br><span class="line"><span class="variable">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="variable">@Target</span>(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)</span><br><span class="line">public <span class="variable">@interface</span> Deprecated &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从它的定义我们可以知道，它会被文档化，能够保留到运行时，能够修饰构造方法、属性、局部变量、方法、包、参数、类型。这个注解的作用是告诉编译器被修饰的程序元素已被“废弃”，不再建议用户使用。</p><h3 id="1-1-3-内置注解-SuppressWarnings"><a href="#1-1-3-内置注解-SuppressWarnings" class="headerlink" title="1.1.3 内置注解 - @SuppressWarnings"></a>1.1.3 内置注解 - @SuppressWarnings</h3><p>这个注解我们也比较常用到，先来看下它的定义：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Target</span>(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</span><br><span class="line"><span class="variable">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line">public <span class="variable">@interface</span> SuppressWarnings &#123;</span><br><span class="line">    <span class="selector-tag">String</span><span class="selector-attr">[]</span> <span class="selector-tag">value</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它能够修饰的程序元素包括类型、属性、方法、参数、构造器、局部变量，只能存活在源码时，取值为String[]。它的作用是告诉编译器忽略指定的警告信息，它可以取的值如下所示：</p><table><thead><tr><th>参数</th><th>作用</th><th>原描述</th></tr></thead><tbody><tr><td>all</td><td>抑制所有警告</td><td>to suppress all warnings</td></tr><tr><td>boxing</td><td>抑制装箱、拆箱操作时候的警告</td><td>to suppress warnings relative to boxing&#x2F;unboxing operations</td></tr><tr><td>cast</td><td>抑制映射相关的警告</td><td>to suppress warnings relative to cast operations</td></tr><tr><td>dep-ann</td><td>抑制启用注释的警告</td><td>to suppress warnings relative to deprecated annotation</td></tr><tr><td>deprecation</td><td>抑制过期方法警告</td><td>to suppress warnings relative to deprecation</td></tr><tr><td>fallthrough</td><td>抑制确在switch中缺失breaks的警告</td><td>to suppress warnings relative to missing breaks in switch statements</td></tr><tr><td>finally</td><td>抑制finally模块没有返回的警告</td><td>to suppress warnings relative to finally block that don’t return</td></tr><tr><td>hiding</td><td>抑制与隐藏变数的区域变数相关的警告</td><td>to suppress warnings relative to locals that hide variable（）</td></tr><tr><td>incomplete-switch</td><td>忽略没有完整的switch语句</td><td>to suppress warnings relative to missing entries in a switch statement (enum case)</td></tr><tr><td>nls</td><td>忽略非nls格式的字符</td><td>to suppress warnings relative to non-nls string literals</td></tr><tr><td>null</td><td>忽略对null的操作</td><td>to suppress warnings relative to null analysis</td></tr><tr><td>rawtype</td><td>使用generics时忽略没有指定相应的类型</td><td>to suppress warnings relative to un-specific types when using</td></tr><tr><td>restriction</td><td>抑制与使用不建议或禁止参照相关的警告</td><td>to suppress warnings relative to usage of discouraged or</td></tr><tr><td>serial</td><td>忽略在serializable类中没有声明serialVersionUID变量</td><td>to suppress warnings relative to missing serialVersionUID field for a serializable class</td></tr><tr><td>static-access</td><td>抑制不正确的静态访问方式警告</td><td>to suppress warnings relative to incorrect static access</td></tr><tr><td>synthetic-access</td><td>抑制子类没有按最优方法访问内部类的警告</td><td>to suppress warnings relative to unoptimized access from inner classes</td></tr><tr><td>unchecked</td><td>抑制没有进行类型检查操作的警告</td><td>to suppress warnings relative to unchecked operations</td></tr><tr><td>unqualified-field-access</td><td>抑制没有权限访问的域的警告</td><td>to suppress warnings relative to field access unqualified</td></tr><tr><td>unused</td><td>抑制没被使用过的代码的警告</td><td>to suppress warnings relative to unused code</td></tr></tbody></table><h2 id="1-2-元注解"><a href="#1-2-元注解" class="headerlink" title="1.2 元注解"></a>1.2 元注解</h2><p>上述内置注解的定义中使用了一些元注解（注解类型进行注解的注解类），在JDK 1.5中提供了4个标准的元注解：@Target，@Retention，@Documented，@Inherited, 在JDK 1.8中提供了两个新的元注解 @Repeatable和@Native。</p><h3 id="1-2-1-元注解-Target"><a href="#1-2-1-元注解-Target" class="headerlink" title="1.2.1 元注解 - @Target"></a>1.2.1 元注解 - @Target</h3><blockquote><p>Target注解的作用是：描述注解的使用范围（即：被修饰的注解可以用在什么地方） 。</p></blockquote><p>Target注解用来说明那些被它所注解的注解类可修饰的对象范围：</p><ul><li>packages、types（类、接口、枚举、注解类）</li><li>类成员（方法、构造方法、成员变量、枚举值）</li><li>方法参数和本地变量（如循环变量、catch参数）<br>在定义注解类时使用了@Target 能够更加清晰的知道它能够被用来修饰哪些对象，它的取值范围定义在ElementType 枚举中。枚举信息如下：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ElementType</span> &#123; </span><br><span class="line">    TYPE, <span class="comment">// 类、接口、枚举类 </span></span><br><span class="line">    FIELD, <span class="comment">// 成员变量（包括：枚举常量） </span></span><br><span class="line">    METHOD, <span class="comment">// 成员方法 </span></span><br><span class="line">    PARAMETER, <span class="comment">// 方法参数 </span></span><br><span class="line">    CONSTRUCTOR, <span class="comment">// 构造方法 </span></span><br><span class="line">    LOCAL_VARIABLE, <span class="comment">// 局部变量 </span></span><br><span class="line">    ANNOTATION_TYPE, <span class="comment">// 注解类 </span></span><br><span class="line">    PACKAGE, <span class="comment">// 可用于修饰：包 </span></span><br><span class="line">    TYPE_PARAMETER, <span class="comment">// 类型参数，JDK 1.8 新增 </span></span><br><span class="line">    TYPE_USE <span class="comment">// 使用类型的任何地方，JDK 1.8 新增 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-2-元注解-Retention-RetentionTarget"><a href="#1-2-2-元注解-Retention-RetentionTarget" class="headerlink" title="1.2.2 元注解 - @Retention &amp; @RetentionTarget"></a>1.2.2 元注解 - @Retention &amp; @RetentionTarget</h3><blockquote><p>Reteniton注解的作用是：描述注解保留的时间范围（即：被描述的注解在它所修饰的类中可以被保留到何时） 。</p></blockquote><p>Reteniton注解用来限定那些被它所注解的注解类在注解到其他类上以后，可被保留到何时，一共有三种策略，定义在RetentionPolicy枚举中。枚举如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">RetentionPolicy</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="type">SOURCE</span>,    <span class="comment">// 源文件保留</span></span><br><span class="line">    <span class="type">CLASS</span>,       <span class="comment">// 编译期保留，默认为该值，CLASS</span></span><br><span class="line">    <span class="type">RUNTIME</span>   <span class="comment">// 运行期保留，可通过反射去获取注解信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们测试下这三种策略，在定义注解类的时候什么区别：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line">public <span class="variable">@interface</span> SourcePolicy &#123;</span><br><span class="line">  <span class="comment">// 源文件保留策略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">@Retention</span>(RetentionPolicy.CLASS)</span><br><span class="line">public <span class="variable">@interface</span> ClassPolicy &#123;</span><br><span class="line">  <span class="comment">// 编译器保留策略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line">public <span class="variable">@interface</span> RuntimePolicy &#123;</span><br><span class="line">  <span class="comment">// 运行期保留策略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面已经定义好了三个注解类，我们再用这三个注解类再去注解方法，如下：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">class</span> <span class="selector-tag">RetentionTest</span> &#123;</span><br><span class="line"> </span><br><span class="line"><span class="variable">@SourcePolicy</span></span><br><span class="line">public void <span class="built_in">sourcePolicy</span>() &#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="variable">@ClassPolicy</span></span><br><span class="line">public void <span class="built_in">classPolicy</span>() &#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="variable">@RuntimePolicy</span></span><br><span class="line">public void <span class="built_in">runtimePolicy</span>() &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过执行 javap -verbose RetentionTest命令获取到的RetentionTest 的 class 字节码内容如下。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">public</span> <span class="string">retention.RetentionTest();</span></span><br><span class="line">    <span class="attr">flags:</span> <span class="string">ACC_PUBLIC</span></span><br><span class="line">    <span class="attr">Code:</span></span><br><span class="line">      <span class="string">stack=1</span>, <span class="string">locals=1</span>, <span class="string">args_size=1</span></span><br><span class="line">         <span class="attr">0:</span> <span class="string">aload_0</span></span><br><span class="line">         <span class="attr">1:</span> <span class="string">invokespecial</span>   <span class="comment">#1            // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="attr">4:</span> <span class="string">return</span></span><br><span class="line">      <span class="attr">LineNumberTable:</span></span><br><span class="line">        <span class="attr">line 3:</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="string">public</span> <span class="string">void</span> <span class="string">sourcePolicy();</span></span><br><span class="line">    <span class="attr">flags:</span> <span class="string">ACC_PUBLIC</span></span><br><span class="line">    <span class="attr">Code:</span></span><br><span class="line">      <span class="string">stack=0</span>, <span class="string">locals=1</span>, <span class="string">args_size=1</span></span><br><span class="line">         <span class="attr">0:</span> <span class="string">return</span></span><br><span class="line">      <span class="attr">LineNumberTable:</span></span><br><span class="line">        <span class="attr">line 7:</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="string">public</span> <span class="string">void</span> <span class="string">classPolicy();</span></span><br><span class="line">    <span class="attr">flags:</span> <span class="string">ACC_PUBLIC</span></span><br><span class="line">    <span class="attr">Code:</span></span><br><span class="line">      <span class="string">stack=0</span>, <span class="string">locals=1</span>, <span class="string">args_size=1</span></span><br><span class="line">         <span class="attr">0:</span> <span class="string">return</span></span><br><span class="line">      <span class="attr">LineNumberTable:</span></span><br><span class="line">        <span class="attr">line 11:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">RuntimeInvisibleAnnotations:</span></span><br><span class="line">      <span class="attr">0:</span> <span class="comment">#11()</span></span><br><span class="line"></span><br><span class="line">  <span class="string">public</span> <span class="string">void</span> <span class="string">runtimePolicy();</span></span><br><span class="line">    <span class="attr">flags:</span> <span class="string">ACC_PUBLIC</span></span><br><span class="line">    <span class="attr">Code:</span></span><br><span class="line">      <span class="string">stack=0</span>, <span class="string">locals=1</span>, <span class="string">args_size=1</span></span><br><span class="line">         <span class="attr">0:</span> <span class="string">return</span></span><br><span class="line">      <span class="attr">LineNumberTable:</span></span><br><span class="line">        <span class="attr">line 15:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">RuntimeVisibleAnnotations:</span></span><br><span class="line">      <span class="attr">0:</span> <span class="comment">#14()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 RetentionTest 的字节码内容我们可以得出以下两点结论：</p><ul><li>编译器并没有记录下 sourcePolicy() 方法的注解信息</li><li>编译器使用 RuntimeInvisibleAnnotations 去记录 classPolicy()方法的注解信息</li><li>编译器使用 RuntimeVisibleAnnotations 去记录 runtimePolicy()方法的注解信息</li></ul><h3 id="1-2-3-元注解-Documented"><a href="#1-2-3-元注解-Documented" class="headerlink" title="1.2.3 元注解 - @Documented"></a>1.2.3 元注解 - @Documented</h3><blockquote><p>Documented注解的作用如下：使用 javadoc 工具为类生成帮助文档，并确认是否保留注解信息。</p></blockquote><p>以下代码在使用Javadoc工具可以生成 @DocAnnotation注解信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DocAnnotation &#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;default&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@DocAnnotation(&quot;some method doc&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 测试方法的文档注解</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-4-元注解-Inherited"><a href="#1-2-4-元注解-Inherited" class="headerlink" title="1.2.4 元注解 - @Inherited"></a>1.2.4 元注解 - @Inherited</h3><blockquote><p>Inherited注解的作用：被它修饰的Annotation将具有继承特性。父类使用了被@Inherited修饰的Annotation，则子类将自动具备该注解。</p></blockquote><p>我们来测试下这个注解：</p><ul><li>定义@Inherited注解：</li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Inherited</span></span><br><span class="line"><span class="variable">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="variable">@Target</span>(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span><br><span class="line">public <span class="variable">@interface</span> InheritedAnnotation &#123;</span><br><span class="line">    <span class="selector-tag">String</span> <span class="selector-attr">[]</span> <span class="selector-tag">values</span>();</span><br><span class="line">    <span class="selector-tag">int</span> <span class="selector-tag">number</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用这个注解</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@InheritedAnnotation</span>(values = &#123;<span class="string">&quot;brand&quot;</span>&#125;, number = <span class="number">100</span>)</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> <span class="keyword">extends</span> <span class="title">UserInfo</span> </span>&#123;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">    public void testMethod()&#123;</span><br><span class="line">        <span class="type">Class</span> clazz = <span class="type">Student</span>.<span class="keyword">class</span>;</span><br><span class="line">        <span class="type">Annotation</span>[] annotations = clazz.getAnnotations();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Annotation</span> annotation : annotations) &#123;</span><br><span class="line">            <span class="type">System</span>.out.println(annotation.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>输出</li></ul><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxx.InheritedAnnotation(<span class="keyword">values</span>=[brand], number=<span class="number">100</span>)</span><br></pre></td></tr></table></figure><p>虽然Customer类没有显示地被注解@InheritedAnnotation，但是它的父类UserInfo被注解，而且@InheritedAnnotation被@Inherited注解，因此Customer类自动继承注解</p><h3 id="1-2-4-元注解-Repeatable-Java8"><a href="#1-2-4-元注解-Repeatable-Java8" class="headerlink" title="1.2.4 元注解 - @Repeatable (Java8)"></a>1.2.4 元注解 - @Repeatable (Java8)</h3><blockquote><p>Repeatable是可重复使用的意思，允许在同一声明的类型(类，属性，或方法)中，可以多次使用同一个注解</p></blockquote><p>JDK8之前要想实现注解重复使用，需要组合模式，编写和可读性都不是很好</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">public</span> @<span class="selector-tag">interface</span> <span class="selector-tag">Pet</span> &#123;</span><br><span class="line">     <span class="selector-tag">String</span> <span class="selector-tag">myPet</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">public</span> @<span class="selector-tag">interface</span> <span class="selector-tag">Pets</span> &#123;</span><br><span class="line">    <span class="selector-tag">Pet</span><span class="selector-attr">[]</span> <span class="selector-tag">value</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">class</span> <span class="selector-tag">RepeatAnnotationOV</span> &#123;</span><br><span class="line">    <span class="variable">@Pets</span>(&#123;<span class="variable">@Pet</span>(myPet=<span class="string">&quot;dog&quot;</span>),<span class="variable">@Pet</span>(myPet=<span class="string">&quot;cat&quot;</span>)&#125;)</span><br><span class="line">    public void <span class="built_in">workMethod</span>()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由另一个注解来存储重复注解，在使用时候，用存储注解Authorities来扩展重复注解。Java 8中的做法：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Repeatable</span>(Pets.class)</span><br><span class="line">public <span class="variable">@interface</span> Pet &#123;</span><br><span class="line">     <span class="selector-tag">String</span> <span class="selector-tag">myPet</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">public</span> @<span class="selector-tag">interface</span> <span class="selector-tag">Pets</span> &#123;</span><br><span class="line">    <span class="selector-tag">Pet</span><span class="selector-attr">[]</span> <span class="selector-tag">value</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">class</span> <span class="selector-tag">RepeatAnnotationNV</span> &#123;</span><br><span class="line">    <span class="variable">@Pet</span>(role=<span class="string">&quot;dog&quot;</span>)</span><br><span class="line">    <span class="variable">@Pet</span>(role=<span class="string">&quot;cat&quot;</span>)</span><br><span class="line">    public void <span class="built_in">workMethod</span>()&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同的地方是，创建重复注解Authority时，加上@Repeatable,指向存储注解Authorities，在使用时候，直接可以重复使用Authority注解。从上面例子看出，java 8里面做法更适合常规的思维，可读性强一点</p><h3 id="1-2-5-元注解-Native-Java8"><a href="#1-2-5-元注解-Native-Java8" class="headerlink" title="1.2.5 元注解 - @Native (Java8)"></a>1.2.5 元注解 - @Native (Java8)</h3><p>使用 @Native 注解修饰成员变量，则表示这个变量可以被本地代码引用，常常被代码生成工具使用。对于 @Native 注解不常使用，了解即可</p><h2 id="1-3-注解与反射接口"><a href="#1-3-注解与反射接口" class="headerlink" title="1.3 注解与反射接口"></a>1.3 注解与反射接口</h2><blockquote><p>定义注解后，如何获取注解中的内容呢？反射包java.lang.reflect下的AnnotatedElement接口提供这些方法。这里注意：只有注解被定义为RUNTIME后，该注解才能是运行时可见，当class文件被装载时被保存在class文件中的Annotation才会被虚拟机读取。</p></blockquote><p>AnnotatedElement 接口是所有程序元素（Class、Method和Constructor）的父接口，所以程序通过反射获取了某个类的AnnotatedElement对象之后，程序就可以调用该对象的方法来访问Annotation信息。我们看下具体的先关接口</p><ul><li>boolean isAnnotationPresent(Class&lt;?extends Annotation&gt; annotationClass)<br>判断该程序元素上是否包含指定类型的注解，存在则返回true，否则返回false。注意：此方法会忽略注解对应的注解容器。</li><li>T getAnnotation(Class annotationClass)<br>返回该程序元素上存在的、指定类型的注解，如果该类型注解不存在，则返回null。</li><li>Annotation[] getAnnotations()<br>返回该程序元素上存在的所有注解，若没有注解，返回长度为0的数组。</li><li>T[] getAnnotationsByType(Class annotationClass)<br>返回该程序元素上存在的、指定类型的注解数组。没有注解对应类型的注解时，返回长度为0的数组。该方法的调用者可以随意修改返回的数组，而不会对其他调用者返回的数组产生任何影响。getAnnotationsByType方法与 getAnnotation的区别在于，getAnnotationsByType会检测注解对应的重复注解容器。若程序元素为类，当前类上找不到注解，且该注解为可继承的，则会去父类上检测对应的注解。</li><li>T getDeclaredAnnotation(Class annotationClass)<br>返回直接存在于此元素上的所有注解。与此接口中的其他方法不同，该方法将忽略继承的注释。如果没有注释直接存在于此元素上，则返回null</li><li>T[] getDeclaredAnnotationsByType(Class annotationClass)<br>返回直接存在于此元素上的所有注解。与此接口中的其他方法不同，该方法将忽略继承的注释</li><li>Annotation[] getDeclaredAnnotations()<br>返回直接存在于此元素上的所有注解及注解对应的重复注解容器。与此接口中的其他方法不同，该方法将忽略继承的注解。如果没有注释直接存在于此元素上，则返回长度为零的一个数组。该方法的调用者可以随意修改返回的数组，而不会对其他调用者返回的数组产生任何影响。</li></ul><h2 id="1-4-自定义注解"><a href="#1-4-自定义注解" class="headerlink" title="1.4 自定义注解"></a>1.4 自定义注解</h2><blockquote><p>当我们理解了内置注解, 元注解和获取注解的反射接口后，我们便可以开始自定义注解了。这个例子我把上述的知识点全部融入进来, 代码很简单：</p></blockquote><ul><li><em><strong>定义自己的注解</strong></em></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.helenlyn.common.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Description: 水果供应者注解        &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Copyright: Copyright (c) 2021 &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Company: helenlyn Co., Ltd.             &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Update Time:                      &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Updater:                          &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Update Comments:                  &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FruitProvider &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 供应商编号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">id</span><span class="params">()</span> <span class="keyword">default</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 供应商名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 供应商地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">address</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><em><strong>使用注解</strong></em></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.helenlyn.common.dto;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.helenlyn.common.<span class="keyword">annotation</span>.FruitColor;</span><br><span class="line"><span class="keyword">import</span> com.helenlyn.common.<span class="keyword">annotation</span>.FruitName;</span><br><span class="line"><span class="keyword">import</span> com.helenlyn.common.<span class="keyword">annotation</span>.FruitProvider;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Description:               &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Copyright: Copyright (c) 2021 &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Company: helenlyn Co., Ltd.             &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Update Time:                      &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Updater:                          &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Update Comments:                  &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppleDto</span> &#123;</span><br><span class="line">   <span class="meta">@FruitName(<span class="string">&quot;Apple&quot;</span>)</span></span><br><span class="line">    <span class="keyword">private</span> String appleName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@FruitColor(fruitColor=FruitColor.Color.RED)</span></span><br><span class="line">    <span class="keyword">private</span> String appleColor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@FruitProvider(id=1,name=<span class="string">&quot;helenlyn 贸易公司&quot;</span>,address=<span class="string">&quot;福州xx路xxx大楼&quot;</span>)</span></span><br><span class="line">    <span class="keyword">private</span> String appleProvider;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><em><strong>用反射接口获取注解信息</strong></em><br>在 FruitInfoUtil 中进行测试：</li></ul><figure class="highlight php-template"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml">/**</span></span><br><span class="line"><span class="language-xml"> * <span class="tag">&lt;<span class="name">p</span>&gt;</span>Description: FruitInfoUtil注解实现 <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"> * <span class="tag">&lt;<span class="name">p</span>&gt;</span>Copyright: Copyright (c) 2021 <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"> * <span class="tag">&lt;<span class="name">p</span>&gt;</span>Company: helenlyn Co., Ltd.             <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"> * <span class="tag">&lt;<span class="name">p</span>&gt;</span>Update Time:                      <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"> * <span class="tag">&lt;<span class="name">p</span>&gt;</span>Updater:                          <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"> * <span class="tag">&lt;<span class="name">p</span>&gt;</span>Update Comments:                  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"> */</span></span><br><span class="line"><span class="language-xml">public class FruitInfoUtil &#123;</span></span><br><span class="line"><span class="language-xml">    public static String getFruitInfo(Class</span><span class="language-php"><span class="meta">&lt;?</span>&gt; clazz) &#123;</span></span><br><span class="line"><span class="language-php">        String strFruitName = <span class="string">&quot; 水果名称：&quot;</span>;</span></span><br><span class="line"><span class="language-php">        String strFruitColor = <span class="string">&quot; 水果颜色：&quot;</span>;</span></span><br><span class="line"><span class="language-php">        String strFruitProvicer = <span class="string">&quot;供应商信息：&quot;</span>;</span></span><br><span class="line"><span class="language-php"></span></span><br><span class="line"><span class="language-php">        Field[] fields = clazz.<span class="title function_ invoke__">getDeclaredFields</span>();</span></span><br><span class="line"><span class="language-php"></span></span><br><span class="line"><span class="language-php">        <span class="keyword">for</span> (Field field : fields) &#123;</span></span><br><span class="line"><span class="language-php">            <span class="keyword">if</span> (field.<span class="title function_ invoke__">isAnnotationPresent</span>(FruitName.<span class="keyword">class</span>)) &#123;</span></span><br><span class="line"><span class="language-php">                FruitName fruitName = (FruitName) field.<span class="title function_ invoke__">getAnnotation</span>(FruitName.<span class="keyword">class</span>);</span></span><br><span class="line"><span class="language-php">                strFruitName += fruitName.<span class="title function_ invoke__">value</span>();</span></span><br><span class="line"><span class="language-php">                System.out.<span class="title function_ invoke__">println</span>(strFruitName);</span></span><br><span class="line"><span class="language-php">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (field.<span class="title function_ invoke__">isAnnotationPresent</span>(FruitColor.<span class="keyword">class</span>)) &#123;</span></span><br><span class="line"><span class="language-php">                FruitColor fruitColor = (FruitColor) field.<span class="title function_ invoke__">getAnnotation</span>(FruitColor.<span class="keyword">class</span>);</span></span><br><span class="line"><span class="language-php">                strFruitColor += fruitColor.<span class="title function_ invoke__">fruitColor</span>().<span class="title function_ invoke__">toString</span>();</span></span><br><span class="line"><span class="language-php">                System.out.<span class="title function_ invoke__">println</span>(strFruitColor);</span></span><br><span class="line"><span class="language-php">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (field.<span class="title function_ invoke__">isAnnotationPresent</span>(FruitProvider.<span class="keyword">class</span>)) &#123;</span></span><br><span class="line"><span class="language-php">                FruitProvider fruitProvider = (FruitProvider) field.<span class="title function_ invoke__">getAnnotation</span>(FruitProvider.<span class="keyword">class</span>);</span></span><br><span class="line"><span class="language-php">                strFruitProvicer = <span class="string">&quot; 供应商编号：&quot;</span> + fruitProvider.<span class="title function_ invoke__">id</span>() + <span class="string">&quot; 供应商名称：&quot;</span> + fruitProvider.<span class="title function_ invoke__">name</span>() + <span class="string">&quot; 供应商地址：&quot;</span> + fruitProvider.<span class="title function_ invoke__">address</span>();</span></span><br><span class="line"><span class="language-php">                System.out.<span class="title function_ invoke__">println</span>(strFruitProvicer);</span></span><br><span class="line"><span class="language-php">            &#125;</span></span><br><span class="line"><span class="language-php">        &#125;</span></span><br><span class="line"><span class="language-php">        <span class="keyword">return</span> String.<span class="title function_ invoke__">format</span>(<span class="string">&quot;%s;%s;%s;&quot;</span>, strFruitName, strFruitColor, strFruitProvicer);</span></span><br><span class="line"><span class="language-php">    &#125;</span></span><br><span class="line"><span class="language-php">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><em><strong>测试的输出</strong></em></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2022</span><span class="number">-07</span><span class="number">-09</span> <span class="number">11</span>:<span class="number">33</span>:<span class="number">41.688</span>  INFO <span class="number">5895</span> <span class="comment">--- [TaskExecutor-35] o.s.a.r.c.CachingConnectionFactory       : Attempting to connect to: cl-debug-rabbitmq-erp-service-7w0cpa.docker.sdp:9146</span></span><br><span class="line">Hibernate: <span class="keyword">update</span> UserBasicInfo <span class="keyword">set</span> personName<span class="operator">=</span>? <span class="keyword">where</span> personCode<span class="operator">=</span>?</span><br><span class="line"> 水果名称：Apple</span><br><span class="line"> 水果颜色：RED</span><br><span class="line"> 供应商编号：<span class="number">1</span> 供应商名称：helenlyn 贸易公司 供应商地址：福州xx路xxx大楼</span><br></pre></td></tr></table></figure><h1 id="2-理解注解的原理"><a href="#2-理解注解的原理" class="headerlink" title="2 理解注解的原理"></a>2 理解注解的原理</h1><h1 id="2-1-Java-8-提供了哪些新的注解"><a href="#2-1-Java-8-提供了哪些新的注解" class="headerlink" title="2.1 Java 8 提供了哪些新的注解"></a>2.1 Java 8 提供了哪些新的注解</h1><ul><li>@Repeatable</li><li>ElementType.TYPE_USE</li><li>ElementType.TYPE_PARAMETER</li></ul><p>ElementType.TYPE_USE(此类型包括类型声明和类型参数声明，是为了方便设计者进行类型检查)包含了ElementType.TYPE(类、接口（包括注解类型）和枚举的声明)和ElementType.TYPE_PARAMETER(类型参数声明), 可以看下面这个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义ElementType.TYPE_PARAMETER注解</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE_PARAMETER)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyNotEmpty &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义ElementType.TYPE_USE注解</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE_USE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyNotNull &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TypeParameterAndTypeUseAnnotation</span>&lt;<span class="meta">@MyNotEmpty</span> T&gt;&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//使用TYPE_PARAMETER类型，会编译不通过</span></span><br><span class="line"><span class="comment">//public @MyNotEmpty T test(@MyNotEmpty T a)&#123;</span></span><br><span class="line"><span class="comment">//new ArrayList&lt;@MyNotEmpty String&gt;();</span></span><br><span class="line"><span class="comment">//return a;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//使用TYPE_USE类型，编译通过</span></span><br><span class="line">  <span class="keyword">public</span> <span class="meta">@MyNotNull</span> T <span class="title function_">test2</span><span class="params">(<span class="meta">@MyNotNull</span> T a)</span>&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;<span class="meta">@MyNotNull</span> String&gt;();</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-注解支持继承吗？"><a href="#2-2-注解支持继承吗？" class="headerlink" title="2.2 注解支持继承吗？"></a>2.2 注解支持继承吗？</h2><blockquote><ul><li>注解是不支持继承的</li><li>不能使用关键字extends来继承某个@interface，但注解在编译后，编译器会自动继java.lang.annotation.Annotation接口。虽然反编译后发现注解继承了Annotation接口，请记住，即使Java的接口可以实现多继承，但定义注解时依然无法使用extends关键字继承@interface。 区别于注解的继承，被注解的子类继承父类注解可以用@Inherited： 如果某个类使用了被@Inherited修饰的Annotation，则其子类将自动具有该注解。</li></ul></blockquote><h1 id="3-注解的应用场景"><a href="#3-注解的应用场景" class="headerlink" title="3 注解的应用场景"></a>3 注解的应用场景</h1><h2 id="自定义注解和AOP-通过切面实现解耦"><a href="#自定义注解和AOP-通过切面实现解耦" class="headerlink" title="自定义注解和AOP - 通过切面实现解耦"></a>自定义注解和AOP - 通过切面实现解耦</h2><blockquote><p>笔者曾经在 《<a href="https://www.cnblogs.com/wzh2010/p/15023339.html">基于AOP的动态数据源切换</a>》 这篇文章中有个典型的例子，就是使用AOP切面来对多数据源进行使用场景的切换，下面展示下如何通过注解实现解耦的。</p></blockquote><ul><li><em><strong>自定义Annotation，映射的目标范围为 类型和方法。</strong></em></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 数据源切换注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(&#123; ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DataSource &#123;</span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><em><strong>编写AOP实现,切面代码，以实现对注解的PointCut,切点拦截</strong></em></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceAspect</span> <span class="keyword">implements</span> <span class="title class_">Ordered</span>  &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个切入点，匹配到上面的注解DataSource</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;@annotation(com.helenlyn.dataassist.annotation.DataSource)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dataSourcePointCut</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Around 环绕方式做切面注入</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> point</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Around(&quot;dataSourcePointCut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint point)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">MethodSignature</span> <span class="variable">signature</span> <span class="operator">=</span> (MethodSignature) point.getSignature();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> signature.getMethod();</span><br><span class="line">        <span class="type">DataSource</span> <span class="variable">ds</span> <span class="operator">=</span> method.getAnnotation(DataSource.class);</span><br><span class="line">        <span class="type">String</span> <span class="variable">routeKey</span> <span class="operator">=</span> ds.name();  <span class="comment">// 从头部中取出注解的name（basic 或 cloudoffice 或 attend），用这个name进行数据源查找。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">dataSourceRouteKey</span> <span class="operator">=</span> DynamicDataSourceRouteHolder.getDataSourceRouteKey();</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotEmpty(dataSourceRouteKey)) &#123;</span><br><span class="line">            <span class="comment">// StringBuilder currentRouteKey = new StringBuilder(dataSourceRouteKey);</span></span><br><span class="line">            routeKey = ds.name();</span><br><span class="line">        &#125;</span><br><span class="line">        DynamicDataSourceRouteHolder.setDataSourceRouteKey(routeKey);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> point.proceed();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123; <span class="comment">// 最后做清理，这个步骤很重要，因为我们的配置中有一个默认的数据源，执行完要回到默认的数据源。</span></span><br><span class="line">            DynamicDataSource.clearDataSource();</span><br><span class="line">            DynamicDataSourceRouteHolder.clearDataSourceRouteKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><em><strong>测试，在Control中写三个测试方法</strong></em></li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无注解默认情况：数据源指向basic</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="variable">@RequestMapping</span>(value = <span class="string">&quot;/default/&#123;user_code&#125;&quot;</span>, method = RequestMethod.GET)</span><br><span class="line">    public UserInfoDto <span class="built_in">getUserInfo</span>(<span class="variable">@PathVariable</span>(<span class="string">&quot;user_code&quot;</span>) String userCode) &#123;</span><br><span class="line">        <span class="selector-tag">return</span> <span class="selector-tag">userInfoService</span><span class="selector-class">.getUserInfo</span>(userCode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据源指向attend</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    @<span class="selector-tag">DataSource</span>(name= Constant.DATA_SOURCE_ATTEND_NAME)</span><br><span class="line">    @<span class="selector-tag">RequestMapping</span>(value = <span class="string">&quot;/attend/&#123;user_code&#125;&quot;</span>, method = RequestMethod.GET)</span><br><span class="line">    <span class="selector-tag">public</span> <span class="selector-tag">UserInfoDto</span> <span class="selector-tag">getUserInfoAttend</span>(<span class="variable">@PathVariable</span>(<span class="string">&quot;user_code&quot;</span>) String userCode) &#123;</span><br><span class="line">        <span class="selector-tag">return</span> <span class="selector-tag">userInfoService</span><span class="selector-class">.getUserInfo</span>(userCode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据源指向cloud</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    @<span class="selector-tag">DataSource</span>(name= Constant.DATA_SOURCE_CLOUD_NAME)</span><br><span class="line">    @<span class="selector-tag">RequestMapping</span>(value = <span class="string">&quot;/cloud/&#123;user_code&#125;&quot;</span>, method = RequestMethod.GET)</span><br><span class="line">    <span class="selector-tag">public</span> <span class="selector-tag">UserInfoDto</span> <span class="selector-tag">getUserInfoCloud</span>(<span class="variable">@PathVariable</span>(<span class="string">&quot;user_code&quot;</span>) String userCode) &#123;</span><br><span class="line">        <span class="selector-tag">return</span> <span class="selector-tag">userInfoService</span><span class="selector-class">.getUserInfo</span>(userCode);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>执行效果<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAO1aUaYPT2B-r5FFaxTa9UDaphH5YUAAkILaxvRfjhWgBzNBUcmMgMBAAMCAAN4AAM2BA.png"><br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAO0aUaYFr4FzOH-jB1_7TJCFHPIFWUAAj8LaxvRfjhWOUWtLCQxXOsBAAMCAAN4AAM2BA.png"><br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAO2aUaYR6kvTdhTCncm9BrkqmudIV8AAkQLaxvRfjhWusSK9H2hlQgBAAMCAAN4AAM2BA.png"></li></ul><blockquote><p>除此之外，我们可以看到很多日志管理、权限管理，也都是也是通过类似的注解机制来实现的，通过注解+AOP来最终实现模块之间的解耦，以及业务与系统层面的解耦 。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java核心系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java核心 </tag>
            
            <tag> Java基础 </tag>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java核心系列3：异常机制详解</title>
      <link href="/2025/02/18/Java%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%863-%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6/"/>
      <url>/2025/02/18/Java%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%863-%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="1-什么是异常"><a href="#1-什么是异常" class="headerlink" title="1 什么是异常"></a>1 什么是异常</h1><p>异常是指程序在运行过程中发生的，由于外部问题导致的运行异常事件，如：文件找不到、网络连接失败、空指针、非法参数等。异常是一个事件，它发生在程序运行期间，且中断程序的运行。Java 是一种面向对象的编程语言，它的异常都是对象，是Throwable子类的实例，当程序中存在错误条件时，且条件生成时，错误就会引发异常。</p><h1 id="2-异常的分类"><a href="#2-异常的分类" class="headerlink" title="2 异常的分类"></a>2 异常的分类</h1><p>要了解异常的分类，我们先看看Java异常类的继承结构图：<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAO4aUaaC7RpB2BfX5nQpndSuAtRZxYAAlMLaxvRfjhWbxOERJ73DLwBAAMCAAN4AAM2BA.png"></p><h2 id="2-1-Throwable"><a href="#2-1-Throwable" class="headerlink" title="2.1 Throwable"></a>2.1 Throwable</h2><p>Throwable 是 Java 语言中所有错误与异常的顶层父类，其他类都继承于该类。 Throwable 包含两个子类：Error（错误）和Exception（异常），它们通常用于指示发生了异常情况。 Throwable 包含了其线程创建时线程执行堆栈的快照，它提供printStackTrace() 等接口用于获取堆栈跟踪数据等信息。</p><h2 id="2-2-Error（错误）"><a href="#2-2-Error（错误）" class="headerlink" title="2.2 Error（错误）"></a>2.2 Error（错误）</h2><p>Error 类及其子类：程序中无法处理的错误，表示运行应用程序中出现了严重的错误。通常情况为下应用程序 <strong>“不应该试图捕获的严重问题”</strong> 。此类错误一般表示代码运行时 JVM 出现问题。通常有 Virtual MachineError（虚拟机运行错误）、NoClassDefFoundError（类定义错误）等。比如 OutOfMemoryError：内存不足错误；StackOverflowError：栈溢出错误。这些错误是不可查的，因为它们在应用程序的控制和处理能力之 外，而且绝大多数是程序运行时不允许出现的状况。在 Java中，错误通过Error的子类描述。</p><h2 id="2-3-Exception（异常）"><a href="#2-3-Exception（异常）" class="headerlink" title="2.3 Exception（异常）"></a>2.3 Exception（异常）</h2><p>Exception以及它的子类，代表程序运行时发送的各种不期望发生的事件。可以被Java异常处理机制使用，是异常处理的核心。Exception 这种异常又分为两类：运行时异常和编译时异常。</p><h3 id="2-3-1-运行时异常"><a href="#2-3-1-运行时异常" class="headerlink" title="2.3.1 运行时异常"></a>2.3.1 运行时异常</h3><p>都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。 运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。</p><h3 id="2-3-2-非运行时异常-（编译异常）"><a href="#2-3-2-非运行时异常-（编译异常）" class="headerlink" title="2.3.2 非运行时异常 （编译异常）"></a>2.3.2 非运行时异常 （编译异常）</h3><p>是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。</p><h3 id="2-3-3-检查性异常（checked-exception）"><a href="#2-3-3-检查性异常（checked-exception）" class="headerlink" title="2.3.3 检查性异常（checked exception）"></a>2.3.3 检查性异常（checked exception）</h3><p>正确的程序在运行中，很容易出现的、情理可容的异常状况。可查异常虽然是异常状况，但在一定程度上它的发生是可以预计的，而且一旦发生这种异常状况，就必须采取某种方式进行处理。除了Error 和 RuntimeException的其它异常。Java语言强制要求程序员为这样的异常做预备处理工作（使用try…catch…finally或者throws）。在方法中要么用try-catch语句捕获它并处理，要么用throws子句声明抛出它，否则编译不会通过。类似如SQLException，IOException，ClassNotFoundException 等。<br>常见的检查性异常如下：</p><table><thead><tr><th>异常</th><th>描述</th></tr></thead><tbody><tr><td>Classnotfoundexception</td><td>当应用程序试图加数一个,通过名字查找时超发现没有该的定义时,抛出该异常</td></tr><tr><td>Clonenotsupportedexcept</td><td>当去克一个对象时,发现该对象没有实现Cloneable接口时,抛出该异常</td></tr><tr><td>lllegalaccessexception</td><td>当应用程序芸试通过反射的方式来访间类、成员变量或调用方法时,却无法访问这些类、成员变量或方法的定义时,抛出该异常</td></tr><tr><td>Instantiationexception</td><td>当试图使用 Class:类中的 newinstance方法創建一个类的实例,而制定的类对象因为是一个接口或是一个抽象类而无法实例化时,抛出该异常</td></tr><tr><td>Interruptedexception</td><td>个线程被另一个线程中断时,抛出该异常</td></tr><tr><td>NosuchFieldexception</td><td>当拢不到指定的变量字段时,抛出该异常</td></tr><tr><td>NosuchMethodexception</td><td>当我不到指定的类方法时,抛出该异常</td></tr></tbody></table><h3 id="2-3-4-非检查性异常-checked-exception"><a href="#2-3-4-非检查性异常-checked-exception" class="headerlink" title="2.3.4 非检查性异常(checked exception)"></a>2.3.4 非检查性异常(checked exception)</h3><p>包括运行时异常（RuntimeException与其子类）和错误（Error）及其子类。Java语言在编译时，不会提示和发现这样的异常，不要求在程序中处理这些异常。所以我们可以在程序中编写代码来处理（使用try…catch…finally）这样的异常，也可以不做任何处理。但是这种错误或异常，一般来说是程序逻辑错误导致的异常，所以我们应该修正代码，而不是通过异常处理器处理。<br>常见的非检查性异常如下：</p><table><thead><tr><th>异常</th><th>描述</th></tr></thead><tbody><tr><td>Arithmeticexception</td><td>当出现异常的运算条件时,抛出异常。例如,一个整数“除以零”时,抛出此美的一个实例</td></tr><tr><td>Arrayindexoutofboundsexcep</td><td>用非法索引访问数组时跑出的异常。如果索引为负或大于等于数组大小,则该索引为非法索引异常描述</td></tr><tr><td>Arraystoreexception</td><td>试图将错误类型的对象存储到一个对象数组时,抛出的异常</td></tr><tr><td>Classcastexception</td><td>试图将对象强制转换为不是同一个类型或其子类的实例时,抛出的异常</td></tr><tr><td>Illegalargumentexception</td><td>当向一个方法传递非法或不正确的参数时,抛出该异常</td></tr><tr><td>IllegalmonitorstateException</td><td>当某一线程已经试图等待对象的监视器,或者通知其他正在等待该对象监视器的线程,而该线程本身没有获得指定监视器时抛出该异常</td></tr><tr><td>Illegalstateexception</td><td>在非法或不适当的时间调用方法时产生的信号。或者说Java环境或应用程序没有处于请求操作所要求的适当状态下</td></tr><tr><td>IllegalthreadstateException</td><td>线程没有处于请求操作所要求的适当状态时,抛出该异常。</td></tr><tr><td>Indexoutofboundsexception</td><td>当某种排序的索引超出范围时抛出的异常,例如,一个数组,字符串或一个向量的排序等</td></tr><tr><td>Negativearraysizeexception</td><td>如果应用程序试图创建大小为负的数组时,抛出该异常</td></tr><tr><td>Nullpointerexception</td><td>当应用程序在需要操作对象的时候而获得的对象实例是nu时抛出该异常</td></tr><tr><td>Numberformatexception</td><td>当应用程序试图将字符串转换成一种数值类型,但该字符串不能转换为适当格式时,抛出该异常。</td></tr><tr><td>SecurityException</td><td>由安全管理器抛出的异常,指示存在安全侵犯。</td></tr><tr><td>StringindexoutofboundsExcept</td><td>此异常由 String方法抛出,说明索引为负或者超出了字符串的大小</td></tr></tbody></table><h1 id="3-异常基础详解"><a href="#3-异常基础详解" class="headerlink" title="3 异常基础详解"></a>3 异常基础详解</h1><h2 id="3-1-异常关键字"><a href="#3-1-异常关键字" class="headerlink" title="3.1 异常关键字"></a>3.1 异常关键字</h2><ol><li>try – 用于监听。<br>将要被监听的代码(可能抛出异常的代码)放在try语句块之内，当try语句块内发生异常时，异常就被抛出。</li><li>catch – 用于捕获异常。<br>catch用来捕获try语句块中发生的异常。</li><li>finally – finally语句块总是会被执行。<br>它主要用于回收在try块里打开的物力资源(如数据库连接、网络连接和磁盘文件)。只有finally块，执行完成之后，才会回来执行try或者catch块中的return或者throw语句，如果finally中使用了return或者throw等终止方法的语句，则就不会跳回执行，直接停止。</li><li>throw – 用于抛出异常。</li><li>throws – 用在方法签名中，用于声明该方法可能抛出的异常。</li></ol><h2 id="3-2-throws-异常的显示声明"><a href="#3-2-throws-异常的显示声明" class="headerlink" title="3.2 throws-异常的显示声明"></a>3.2 throws-异常的显示声明</h2><p>在Java中，当前执行的语句必属于某个方法，Java解释器调用main方法执行开始执行程序。若方法中存在检查异常，如果不对其捕获，那必须在方法头中显式声明该异常，以便于告知方法调用者此方法有异常，需要进行处理。 在方法中声明一个异常，方法头中使用关键字throws，后面接上要声明的异常。若声明多个异常，则使用逗号分割。如下所示：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">yourMethod</span>() throws Exception</span>&#123;</span><br><span class="line">    <span class="comment">//todo  业务逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：若是父类的方法没有声明异常，则子类继承方法后，也不能声明异常。</p></blockquote><p>通常，应该捕获那些知道如何处理的异常，将不知道如何处理的异常继续传递下去。传递异常可以在方法签名处使用 throws 关键字声明可能会抛出的异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">(String filePath)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filePath);</span><br><span class="line">    String result;</span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(file));</span><br><span class="line">    <span class="keyword">while</span>((result = reader.readLine())!=<span class="literal">null</span>) &#123;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">    reader.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Throws抛出异常的规则：</p><ul><li>如果是不可查异常（unchecked exception），即Error、RuntimeException或它们的子类，那么可以不使用throws关键字来声明要抛出的异常，编译仍能顺利通过，但在运行时会被系统抛出。</li><li>必须声明方法可抛出的任何可查异常（checked exception）。即如果一个方法可能出现受可查异常，要么用try-catch语句捕获，要么用throws子句声明将它抛出，否则会导致编译错误</li><li>仅当抛出了异常，该方法的调用者才必须处理或者重新抛出该异常。当方法的调用者无力处理该异常的时候，应该继续抛出，而不是囫囵吞枣。</li><li>调用方法必须遵循任何可查异常的处理和声明规则。若覆盖一个方法，则不能声明与覆盖方法不同的异常。声明的任何异常必须是被覆盖方法所声明异常的同类或子类。</li></ul><h2 id="3-3-throw-抛出异常"><a href="#3-3-throw-抛出异常" class="headerlink" title="3.3 throw-抛出异常"></a>3.3 throw-抛出异常</h2><p>如果代码可能会引发某种错误，可以创建一个合适的异常类实例并抛出它，这就是抛出异常。如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">double</span> <span class="title">yourMethod</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(value &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">ArithmeticException</span>(<span class="string">&quot;参数不能为0&quot;</span>); <span class="comment">//抛出一个运行时异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">6.0</span> / value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大部分情况下都不需要手动抛出异常，因为Java的大部分方法要么已经处理异常，要么已声明异常。所以一般都是捕获异常或者再往上抛。有时我们会从 catch 中抛出一个异常，目的是为了改变异常的类型。多用于在多系统集成时，当某个子系统故障，异常类型可能有多种，可以用统一的异常类型向外暴露，不需暴露太多内部异常细节。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">(String filePath)</span> <span class="keyword">throws</span> MyException &#123;    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// code</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="type">MyException</span> <span class="variable">ex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(<span class="string">&quot;read file failed.&quot;</span>);</span><br><span class="line">        ex.initCause(e);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4-异常的自定义"><a href="#3-4-异常的自定义" class="headerlink" title="3.4 异常的自定义"></a>3.4 异常的自定义</h2><p>习惯上，定义一个异常类应包含两个构造函数，一个无参构造函数和一个带有详细描述信息的构造函数（Throwable 的 toString 方法会打印这些详细信息，调试时很有用）, 比如上面用到的自定义MyException：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    public <span class="type">MyException</span>()&#123; &#125;</span><br><span class="line">    public <span class="type">MyException</span>(<span class="type">String</span> msg)&#123;</span><br><span class="line">        <span class="keyword">super</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-5-异常的捕获"><a href="#3-5-异常的捕获" class="headerlink" title="3.5 异常的捕获"></a>3.5 异常的捕获</h2><p>异常捕获处理的方法通常有：</p><ul><li>try-catch</li><li>try-catch-finally</li><li>try-finally</li><li>try-with-resource</li></ul><h3 id="3-5-1-try-catch"><a href="#3-5-1-try-catch" class="headerlink" title="3.5.1 try-catch"></a>3.5.1 try-catch</h3><p>在一个 try-catch 语句块中可以捕获多个异常类型，并对不同类型的异常做出不同的处理</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">readFile</span>(<span class="params"><span class="title class_">String</span> filePath</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// code</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="title class_">FileNotFoundException</span> e) &#123;</span><br><span class="line">        <span class="comment">// handle FileNotFoundException</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="title class_">IOException</span> e)&#123;</span><br><span class="line">        <span class="comment">// handle IOException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同一个 catch 也可以捕获多种类型异常，用 | 隔开</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">readFile</span>(<span class="params"><span class="title class_">String</span> filePath</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// code</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="title class_">FileNotFoundException</span> | <span class="title class_">UnknownHostException</span> e) &#123;</span><br><span class="line">        <span class="comment">// handle FileNotFoundException or UnknownHostException</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="title class_">IOException</span> e)&#123;</span><br><span class="line">        <span class="comment">// handle IOException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-2-try-catch-finally"><a href="#3-5-2-try-catch-finally" class="headerlink" title="3.5.2 try-catch-finally"></a>3.5.2 try-catch-finally</h3><ul><li>常规语法</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;                        </span><br><span class="line">    <span class="comment">//执行程序代码，可能会出现异常                 </span></span><br><span class="line">&#125; <span class="keyword">catch</span>(<span class="built_in">Exception</span> e) &#123;   </span><br><span class="line">    <span class="comment">//捕获异常并处理   </span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//必执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>执行的顺序<ul><li>当try没有捕获到异常时：try语句块中的语句逐一被执行，程序将跳过catch语句块，执行finally语句块和其后的语句；</li><li>当try捕获到异常，catch语句块里没有处理此异常的情况：当try语句块里的某条语句出现异常时，而没有处理此异常的catch语句块时，此异常将会抛给JVM处理，finally语句块里的语句还是会被执行，但finally语句块后的语句不会被执行；</li><li>当try捕获到异常，catch语句块里有处理此异常的情况：在try语句块中是按照顺序来执行的，当执行到某一条语句出现异常时，程序将跳到catch语句块，并与catch语句块逐一匹配，找到与之对应的处理程序，其他的catch语句块将不会被执行，而try语句块中，出现异常之后的语句也不会被执行，catch语句块执行完后，执行finally语句块里的语句，最后执行finally语句块后的语句；</li></ul></li><li>无异常情况 ，catch 模块被忽略，先执行业务逻辑，再执行finally。<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAO5aUaaUxryh8ibOFf1dh3ra5ZswfEAAlULaxvRfjhWm3vR_WWHDfIBAAMCAAN4AAM2BA.png"></li><li>异常情况，假设执行到业务逻辑2的时候，出现故障异常，则业务逻辑3没有执行，直接执行catch，最后再执行finally。<br><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAO6aUaaY7SdxqnLvUOXVJZUOeatOsoAAlYLaxvRfjhWavP1YELob6cBAAMCAAN4AAM2BA.png"></li><li>一个完整的例子</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">(String filePath)</span> <span class="keyword">throws</span> MyException &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filePath);</span><br><span class="line">    String result;</span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        reader = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(file));</span><br><span class="line">        <span class="keyword">while</span>((result = reader.readLine())!=<span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;readFile method catch block.&quot;</span>);</span><br><span class="line">        <span class="type">MyException</span> <span class="variable">ex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(<span class="string">&quot;read file failed.&quot;</span>);</span><br><span class="line">        ex.initCause(e);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;readFile method finally block.&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != reader) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                reader.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-3-try-finally"><a href="#3-5-3-try-finally" class="headerlink" title="3.5.3 try-finally"></a>3.5.3 try-finally</h3><p>也可以直接用try-finally吗。try块中引起异常，异常代码之后的语句不再执行，直接执行finally语句。try块没有引发异常，则执行完try块就执行finally语句。 try-finally可用在不需要捕获异常的代码，可以保证资源在使用后被关闭。例如IO流中执行完相应操作后，关闭相应资源；使用Lock对象保证线程同步，通过finally可以保证锁会被释放；数据库连接代码时，关闭连接操作等等。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以Lock加锁为例，演示try-finally</span></span><br><span class="line">ReentrantLock <span class="keyword">lock</span> = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//需要加锁的代码</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">lock</span>.unlock(); <span class="comment">//保证锁一定被释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>finally遇见如下情况不会执行</p><ul><li>在前面的代码中用了System.exit()退出程序。</li><li>finally语句块中发生了异常。</li><li>程序所在的线程死亡。</li><li>关闭CPU。</li></ul><h3 id="3-5-4-try-with-resource"><a href="#3-5-4-try-with-resource" class="headerlink" title="3.5.4 try-with-resource"></a>3.5.4 try-with-resource</h3><p>上面例子中，finally 中的 close 方法也可能抛出 IOException, 从而覆盖了原始异常。JAVA 7 提供了更优雅的方式来实现资源的自动释放，自动释放的资源需要是实现了 AutoCloseable 接口的类。</p><ul><li>代码实现</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tryWithResourceTest</span>()</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (Scanner scanner = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;c:/abc&quot;</span>),<span class="string">&quot;UTF-8&quot;</span>))&#123;</span><br><span class="line">        <span class="comment">// code</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        <span class="comment">// handle exception</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>看下Scanner</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Scanner</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;String&gt;, Closeable &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Closeable</span> <span class="keyword">extends</span> <span class="title class_">AutoCloseable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>try 代码块退出时，会自动调用 scanner.close 方法，和把 scanner.close 方法放在 finally 代码块中不同的是，若 scanner.close 抛出异常，则会被抑制，抛出的仍然为原始异常。被抑制的异常会由 addSusppressed 方法添加到原来的异常，如果想要获取被抑制的异常列表，可以调用 getSuppressed 方法来获取。</p><h2 id="3-6-异常总结"><a href="#3-6-异常总结" class="headerlink" title="3.6 异常总结"></a>3.6 异常总结</h2><ul><li>try、catch和finally都不能单独使用，只能是try-catch、try-finally或者try-catch-finally。</li><li>try语句块监控代码，出现异常就停止执行下面的代码，然后将异常移交给catch语句块来处理。</li><li>finally语句块中的代码一定会被执行，常用于回收资源 。</li><li>throws：声明一个异常，告知方法调用者。</li><li>throw ：抛出一个异常，至于该异常被捕获还是继续抛出都与它无关。<br>Java编程思想一书中，对异常的总结。</li><li>在恰当的级别处理问题。（在知道该如何处理的情况下了捕获异常。）</li><li>解决问题并且重新调用产生异常的方法。</li><li>进行少许修补，然后绕过异常发生的地方继续执行。</li><li>用别的数据进行计算，以代替方法预计会返回的值。</li><li>把当前运行环境下能做的事尽量做完，然后把相同的异常重抛到更高层。</li><li>把当前运行环境下能做的事尽量做完，然后把不同的异常抛到更高层。</li><li>终止程序。</li><li>进行简化（如果你的异常模式使问题变得太复杂，那么用起来会非常痛苦）。</li><li>让类库和程序更安全。</li></ul><h2 id="3-7-常用的异常"><a href="#3-7-常用的异常" class="headerlink" title="3.7 常用的异常"></a>3.7 常用的异常</h2><p>在Java中提供了一些异常用来描述经常发生的错误，对于这些异常，有的需要程序员进行捕获处理或声明抛出，有的是由Java虚拟机自动进行捕获处理。Java中常见的异常类:</p><ul><li>RuntimeException<ul><li>java.lang.ArrayIndexOutOfBoundsException 数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出。</li><li>java.lang.ArithmeticException 算术条件异常。譬如：整数除零等。</li><li>java.lang.NullPointerException 空指针异常。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等</li><li>java.lang.ClassNotFoundException 找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常。</li><li>java.lang.NegativeArraySizeException 数组长度为负异常</li><li>java.lang.ArrayStoreException 数组中包含不兼容的值抛出的异常</li><li>java.lang.SecurityException 安全性异常</li><li>java.lang.IllegalArgumentException 非法参数异常</li></ul></li><li>IOException<ul><li>IOException：操作输入流和输出流时可能出现的异常。</li><li>EOFException 文件已结束异常</li><li>FileNotFoundException 文件未找到异常</li></ul></li><li>其他<ul><li>ClassCastException 类型转换异常类</li><li>ArrayStoreException 数组中包含不兼容的值抛出的异常</li><li>SQLException 操作数据库异常类</li><li>NoSuchFieldException 字段未找到异常</li><li>NoSuchMethodException 方法未找到抛出的异常</li><li>NumberFormatException 字符串转换为数字抛出的异常</li><li>StringIndexOutOfBoundsException 字符串索引超出范围抛出的异常</li><li>IllegalAccessException 不允许访问某类异常</li><li>InstantiationException 当应用程序试图使用Class类中的newInstance()方法创建一个类的实例，而指定的类对象无法被实例化时，抛出该异常</li></ul></li></ul><h1 id="4-异常实践"><a href="#4-异常实践" class="headerlink" title="4 异常实践"></a>4 异常实践</h1><p>当你抛出或捕获异常的时候，有很多不同的情况需要考虑，而且大部分事情都是为了改善代码的可读性或者 API 的可用性。异常不仅仅是一个错误控制机制，也是一个通信媒介。因此，为了和同事更好的合作，一个团队必须要制定出一个最佳实践和规则，只有这样，团队成员才能理解这些通用概念，同时在工作中使用它。这里给出几个被很多团队使用的异常处理最佳实践。</p><h2 id="4-1-只针对不正常的情况才使用异常"><a href="#4-1-只针对不正常的情况才使用异常" class="headerlink" title="4.1 只针对不正常的情况才使用异常"></a>4.1 只针对不正常的情况才使用异常</h2><blockquote><p>异常只应该被用于不正常的条件，它们永远不应该被用于正常的控制流。《阿里手册》中：【强制】Java 类库中定义的可以通过预检查方式规避的RuntimeException异常不应该通过catch 的方式来处理，比如：NullPointerException，IndexOutOfBoundsException等等。</p></blockquote><p>比如，在解析字符串形式的数字时，可能存在数字格式错误，不得通过catch Exception来实现</p><ul><li>代码1</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj != <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>代码2</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">  obj.method(); </span><br><span class="line">&#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要原因有三点：</p><ul><li>异常机制的设计初衷是用于不正常的情况，所以很少会会JVM实现试图对它们的性能进行优化。所以，创建、抛出和捕获异常的开销是很昂贵的。</li><li>把代码放在try-catch中返回阻止了JVM实现本来可能要执行的某些特定的优化。</li><li>对数组进行遍历的标准模式并不会导致冗余的检查，有些现代的JVM实现会将它们优化掉。</li></ul><h2 id="4-2-在-finally-块中清理资源或者使用-try-with-resource-语句"><a href="#4-2-在-finally-块中清理资源或者使用-try-with-resource-语句" class="headerlink" title="4.2 在 finally 块中清理资源或者使用 try-with-resource 语句"></a>4.2 在 finally 块中清理资源或者使用 try-with-resource 语句</h2><p>当使用类似InputStream这种需要使用后关闭的资源时，一个常见的错误就是在try块的最后关闭资源。</p><ul><li>错误示例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doNotCloseResourceInTry</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;./tmp.txt&quot;</span>);</span><br><span class="line">        inputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">        <span class="comment">// use the inputStream to read a file</span></span><br><span class="line">        <span class="comment">// do NOT do this</span></span><br><span class="line">        inputStream.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题就是，只有没有异常抛出的时候，这段代码才可以正常工作。try 代码块内代码会正常执行，并且资源可以正常关闭。但是，使用 try 代码块是有原因的，一般调用一个或多个可能抛出异常的方法，而且，你自己也可能会抛出一个异常，这意味着代码可能不会执行到 try 代码块的最后部分。结果就是，你并没有关闭资源。所以，你应该把清理工作的代码放到 finally 里去，或者使用 try-with-resource 特性。</p><ul><li>方法一：<strong>使用 finally 代码块</strong><br>与前面几行 try 代码块不同，finally 代码块总是会被执行。不管 try 代码块成功执行之后还是你在 catch 代码块中处理完异常后都会执行。因此，你可以确保你清理了所有打开的资源。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">closeResourceInFinally</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;./tmp.txt&quot;</span>);</span><br><span class="line">        inputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">        <span class="comment">// use the inputStream to read a file</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (inputStream != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                log.error(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方法二：<strong>Java 7 的 try-with-resource 语法</strong><br>如果你的资源实现了 AutoCloseable 接口，你可以使用这个语法。大多数的 Java 标准资源都继承了这个接口。当你在 try 子句中打开资源，资源会在 try 代码块执行后或异常处理后自动关闭。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">automaticallyCloseResource</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;./tmp.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);) &#123;</span><br><span class="line">        <span class="comment">// use the inputStream to read a file</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-尽量使用标准的异常"><a href="#4-3-尽量使用标准的异常" class="headerlink" title="4.3 尽量使用标准的异常"></a>4.3 尽量使用标准的异常</h2><p>重用现有的异常有几个好处：</p><ul><li>它使得你的API更加易于学习和使用，因为它与程序员原来已经熟悉的习惯用法是一致的。</li><li>对于用到这些API的程序而言，它们的可读性更好，因为它们不会充斥着程序员不熟悉的异常。</li><li>异常类越少，意味着内存占用越小，并且转载这些类的时间开销也越小。<br>Java标准异常中有几个是经常被使用的异常。如下表格：</li></ul><table><thead><tr><th>异常</th><th>使用场合</th></tr></thead><tbody><tr><td>IllegalArgumentException</td><td>参数的值不合适</td></tr><tr><td>IllegalStateException</td><td>参数的状态不合适</td></tr><tr><td>NullPointerException</td><td>在null被禁止的情况下参数值为null</td></tr><tr><td>IndexOutOfBoundsException</td><td>下标越界</td></tr><tr><td>ConcurrentModificationException</td><td>在禁止并发修改的情况下，对象检测到并发修改</td></tr><tr><td>UnsupportedOperationException</td><td>对象不支持客户请求的方法</td></tr></tbody></table><p>虽然它们是Java平台库迄今为止最常被重用的异常，但是，在许可的条件下，其它的异常也可以被重用。例如，如果你要实现诸如复数或者矩阵之类的算术对象，那么重用ArithmeticException和NumberFormatException将是非常合适的。</p><p>如果一个异常满足你的需要，则不要犹豫，使用就可以，不过你一定要确保抛出异常的条件与该异常的文档中描述的条件一致。这种重用必须建立在语义的基础上，而不是名字的基础上。</p><p>最后，一定要清楚，选择重用哪一种异常并没有必须遵循的规则。例如，考虑纸牌对象的情形，假设有一个用于发牌操作的方法，它的参数(handSize)是发一手牌的纸牌张数。假设调用者在这个参数中传递的值大于整副牌的剩余张数。那么这种情形既可以被解释为IllegalArgumentException(handSize的值太大)，也可以被解释为IllegalStateException(相对客户的请求而言，纸牌对象的纸牌太少)。</p><h2 id="4-4-对异常进行文档说明"><a href="#4-4-对异常进行文档说明" class="headerlink" title="4.4 对异常进行文档说明"></a>4.4 对异常进行文档说明</h2><blockquote><p>当在方法上声明抛出异常时，也需要进行文档说明。目的是为了给调用者提供尽可能多的信息，从而可以更好地避免或处理异常。<br>在 Javadoc 添加 @throws 声明，并且描述抛出异常的场景。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Method description</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> MyBusinessException - businuess exception description</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">(String input)</span> <span class="keyword">throws</span> MyBusinessException &#123;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，在抛出MyBusinessException 异常时，需要尽可能精确地描述问题和相关信息，这样无论是打印到日志中还是在监控工具中，都能够更容易被人阅读，从而可以更好地定位具体错误信息、错误的严重程度等。</p><h2 id="4-5-优先捕获最具体的异常"><a href="#4-5-优先捕获最具体的异常" class="headerlink" title="4.5 优先捕获最具体的异常"></a>4.5 优先捕获最具体的异常</h2><blockquote><p>大多数 IDE 都可以帮助你实现这个最佳实践。当你尝试首先捕获较不具体的异常时，它们会报告无法访问的代码块。</p></blockquote><p>但问题在于，只有匹配异常的第一个 catch 块会被执行。 因此，如果首先捕获 IllegalArgumentException ，则永远不会到达应该处理更具体的 NumberFormatException 的 catch 块，因为它是 IllegalArgumentException 的子类。</p><p>总是优先捕获最具体的异常类，并将不太具体的 catch 块添加到列表的末尾。</p><p>你可以在下面的代码片断中看到这样一个 try-catch 语句的例子。 第一个 catch 块处理所有 NumberFormatException 异常，第二个处理所有非 NumberFormatException 异常的IllegalArgumentException 异常。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">catchMostSpecificExceptionFirst</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        doSomething(<span class="string">&quot;A message&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">        log.error(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-6-不要捕获-Throwable-类"><a href="#4-6-不要捕获-Throwable-类" class="headerlink" title="4.6 不要捕获 Throwable 类"></a>4.6 不要捕获 Throwable 类</h2><blockquote><p>Throwable 是所有异常和错误的超类。你可以在 catch 子句中使用它，但是你永远不应该这样做！</p></blockquote><p>如果在 catch 子句中使用 Throwable ，它不仅会捕获所有异常，也将捕获所有的错误。JVM 抛出错误，指出不应该由应用程序处理的严重问题。 典型的例子是 OutOfMemoryError 或者 StackOverflowError 。两者都是由应用程序控制之外的情况引起的，无法处理。<br>所以，最好不要捕获 Throwable ，除非你确定自己处于一种特殊的情况下能够处理错误。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doNotCatchThrowable</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">// don&#x27;t do this!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-7-不要忽略异常"><a href="#4-7-不要忽略异常" class="headerlink" title="4.7 不要忽略异常"></a>4.7 不要忽略异常</h2><blockquote><p>很多时候，开发者很有自信不会抛出异常，因此写了一个catch块，但是没有做任何处理或者记录日志。</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doNotIgnoreExceptions</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        <span class="comment">// this will never happen</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但现实是经常会出现无法预料的异常，或者无法确定这里的代码未来是不是会改动(删除了阻止异常抛出的代码)，而此时由于异常被捕获，使得无法拿到足够的错误信息来定位问题。<br>合理的做法是至少要记录异常的信息。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logAnException</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;This should never happen: &quot;</span> + e); <span class="comment">// see this line</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-8不要记录并抛出异常"><a href="#4-8不要记录并抛出异常" class="headerlink" title="4.8不要记录并抛出异常"></a>4.8不要记录并抛出异常</h2><p>这可能是本文中最常被忽略的最佳实践。 可以发现很多代码甚至类库中都会有捕获异常、记录日志并再次抛出的逻辑。如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> Long(<span class="string">&quot;xyz&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">    log.error(e);</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个处理逻辑看着是合理的。但这经常会给同一个异常输出多条日志。如下：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">17</span>:<span class="number">44</span>:<span class="number">28</span>,<span class="number">945</span> ERROR TestExceptionHandling:<span class="number">65</span> - <span class="keyword">java.lang.NumberFormatException: </span>For input string: <span class="string">&quot;xyz&quot;</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> <span class="keyword">java.lang.NumberFormatException: </span>For input string: <span class="string">&quot;xyz&quot;</span></span><br><span class="line"><span class="built_in">at</span> <span class="keyword">java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)</span></span><br><span class="line"><span class="keyword"></span><span class="built_in">at</span> <span class="keyword">java.lang.Long.parseLong(Long.java:589)</span></span><br><span class="line"><span class="keyword"></span><span class="built_in">at</span> <span class="keyword">java.lang.Long.(Long.java:965)</span></span><br><span class="line"><span class="keyword"></span><span class="built_in">at</span> com.stackify.example.TestExceptionHandling.logAndThrowException(TestExceptionHandling.<span class="keyword">java:63)</span></span><br><span class="line"><span class="keyword"></span><span class="built_in">at</span> com.stackify.example.TestExceptionHandling.main(TestExceptionHandling.<span class="keyword">java:58)</span></span><br></pre></td></tr></table></figure><p>如上所示，后面的日志也没有附加更有用的信息。如果想要提供更加有用的信息，那么可以将异常包装为自定义异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">wrapException</span><span class="params">(String input)</span> <span class="keyword">throws</span> MyBusinessException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyBusinessException</span>(<span class="string">&quot;A message that describes the error.&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，仅仅当想要处理异常时才去捕获，否则只需要在方法签名中声明让调用者去处理。</p><h2 id="4-9-包装异常时不要抛弃原始的异常"><a href="#4-9-包装异常时不要抛弃原始的异常" class="headerlink" title="4.9 包装异常时不要抛弃原始的异常"></a>4.9 包装异常时不要抛弃原始的异常</h2><p>捕获标准异常并包装为自定义异常是一个很常见的做法。这样可以添加更为具体的异常信息并能够做针对的异常处理。<br>在你这样做时，请确保将原始异常设置为原因（注：参考下方代码 NumberFormatException e 中的原始异常 e ）。Exception 类提供了特殊的构造函数方法，它接受一个 Throwable 作为参数。否则，你将会丢失堆栈跟踪和原始异常的消息，这将会使分析导致异常的异常事件变得困难。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">wrapException</span><span class="params">(String input)</span> <span class="keyword">throws</span> MyBusinessException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyBusinessException</span>(<span class="string">&quot;A message that describes the error.&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-10-不要使用异常控制程序的流程"><a href="#4-10-不要使用异常控制程序的流程" class="headerlink" title="4.10 不要使用异常控制程序的流程"></a>4.10 不要使用异常控制程序的流程</h2><p>不应该使用异常控制应用的执行流程，例如，本应该使用if语句进行条件判断的情况下，你却使用异常处理，这是非常不好的习惯，会严重影响应用的性能。</p><h2 id="4-11-不要在finally块中使用return。"><a href="#4-11-不要在finally块中使用return。" class="headerlink" title="4.11 不要在finally块中使用return。"></a>4.11 不要在finally块中使用return。</h2><p>try块中的return语句执行成功后，并不马上返回，而是继续执行finally块中的语句，如果此处存在return语句，则在此直接返回，无情丢弃掉try块中的返回点。<br>如下是一个反例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">checkReturn</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// x等于1，此处不返回</span></span><br><span class="line">        <span class="keyword">return</span> ++x;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 返回的结果是2</span></span><br><span class="line">        <span class="keyword">return</span> ++x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h1><p>这边详细介绍了异常的概念、原理，以及在应用中的一些小结。异常的能力是我们快速定位程序错误的重要手段之一，也是我们不断优化程序，提高程序健壮性的依据，所以熟练掌握异常的使用是非常有必要的。</p>]]></content>
      
      
      <categories>
          
          <category> Java核心系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java核心 </tag>
            
            <tag> Java基础 </tag>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java设计模式-单例模式</title>
      <link href="/2025/02/18/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2025/02/18/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>单例模式相信大家都有所听闻，甚至也写过不少了，在面试中也是考得最多的其中一个设计模式，面试官常常会要求写出两种类型的单例模式并且解释其原理，废话不多说，我们开始学习如何很好地回答这一道面试题吧。</p><h2 id="什么是单例模式"><a href="#什么是单例模式" class="headerlink" title="什么是单例模式"></a>什么是单例模式</h2><p>面试官问什么是单例模式时，千万不要答非所问，给出单例模式有两种类型之类的回答，要围绕单例模式的定义去展开。</p><p>单例模式是指在内存中只会创建且仅创建一次对象的设计模式。在程序中多次使用同一个对象且作用相同时，为了防止频繁地创建对象使得内存飙升，单例模式可以让程序仅在内存中创建一个对象，让所有需要调用的地方都共享这一单例对象。</p><h2 id="单例模式的类型"><a href="#单例模式的类型" class="headerlink" title="单例模式的类型"></a>单例模式的类型</h2><p>单例模式有两种类型：</p><ul><li><code>懒汉式</code>：在真正需要使用对象时才去创建该单例类对象</li><li><code>饿汉式</code>：在类加载时已经创建好该单例对象，等待被程序使用</li></ul><h3 id="懒汉式创建单例对象"><a href="#懒汉式创建单例对象" class="headerlink" title="懒汉式创建单例对象"></a>懒汉式创建单例对象</h3><p>懒汉式创建对象的方法是在程序使用对象前，先判断该对象是否已经实例化（判空），若已实例化直接返回该类对象。否则则先执行实例化操作。</p><p>根据上面的流程，就可以写出下面的这段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没错，这里我们已经写出了一个很不错的单例模式，不过它不是完美的，但是这并不影响我们使用这个“单例对象”。</p><p>以上就是懒汉式创建单例对象的方法，我会在后面解释这段代码在哪里可以优化，存在什么问题。</p><h3 id="饿汉式创建单例对象"><a href="#饿汉式创建单例对象" class="headerlink" title="饿汉式创建单例对象"></a>饿汉式创建单例对象</h3><p>饿汉式在<code>类加载</code>时已经创建好该对象，在程序调用时直接返回该单例对象即可，即我们在编码时就已经指明了要马上创建这个对象，不需要等到被调用时再去创建。</p><p>关于类加载，涉及到JVM的内容，我们目前可以简单认为在程序启动时，这个单例对象就已经创建好了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">singleton</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意上面的代码在第3行已经实例化好了一个Singleton对象在内存中，不会有多个Singleton对象实例存在</p><p>类在加载时会在堆内存中创建一个Singleton对象，当类被卸载时，Singleton对象也随之消亡了。</p><h2 id="懒汉式如何保证只创建一个对象"><a href="#懒汉式如何保证只创建一个对象" class="headerlink" title="懒汉式如何保证只创建一个对象"></a>懒汉式如何保证只创建一个对象</h2><p>我们再来回顾懒汉式的核心方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">        singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singleton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法其实是存在问题的，试想一下，如果两个线程同时判断 singleton 为空，那么它们都会去实例化一个Singleton 对象，这就变成多例了。所以，我们要解决的是<code>线程安全</code>问题。</p><p>最容易想到的解决方法就是在方法上加锁，或者是对类对象加锁，程序就会变成下面这个样子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">        singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singleton;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(Singleton.class) &#123;   </span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singleton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就规避了两个线程同时创建Singleton对象的风险，但是引来另外一个问题：<strong>每次去获取对象都需要先获取锁，并发性能非常地差，极端情况下，可能会出现卡顿现象。</strong></p><p>接下来要做的就是<code>优化性能</code>：目标是如果没有实例化对象则加锁创建，如果已经实例化了，则不需要加锁，直接获取实例</p><p>所以直接在方法上加锁的方式就被废掉了，因为这种方式无论如何都需要先获取锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;  <span class="comment">// 线程A和线程B同时看到singleton = null，如果不为null，则直接返回singleton</span></span><br><span class="line">        <span class="keyword">synchronized</span>(Singleton.class) &#123; <span class="comment">// 线程A或线程B获得该锁进行初始化</span></span><br><span class="line">            <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123; <span class="comment">// 其中一个线程进入该分支，另外一个线程则不会进入该分支</span></span><br><span class="line">                singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singleton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码已经完美地解决了<strong>并发安全 + 性能低效</strong>问题：</p><ul><li>第 2 行代码，如果 singleton 不为空，则直接返回对象，不需要获取锁；而如果多个线程发现 singleton 为空，则进入分支；</li><li>第 3 行代码，多个线程尝试争抢同一个锁，只有一个线程争抢成功，第一个获取到锁的线程会再次判断singleton 是否为空，因为 singleton 有可能已经被之前的线程实例化</li><li>其它之后获取到锁的线程在执行到第 4 行校验代码，发现 singleton 已经不为空了，则不会再 new 一个对象，直接返回对象即可</li><li>之后所有进入该方法的线程都不会去获取锁，在第一次判断 singleton 对象时已经不为空了</li></ul><p>因为需要两次判空，且对类对象加锁，该懒汉式写法也被称为：<strong>Double Check（双重校验） + Lock（加锁）</strong></p><p>完整的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;  <span class="comment">// 线程A和线程B同时看到singleton = null，如果不为null，则直接返回singleton</span></span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123; <span class="comment">// 线程A或线程B获得该锁进行初始化</span></span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123; <span class="comment">// 其中一个线程进入该分支，另外一个线程则不会进入该分支</span></span><br><span class="line">                    singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码已经近似完美了，但是还存在最后一个问题：指令重排</p><h2 id="使用volatile防止指令重排"><a href="#使用volatile防止指令重排" class="headerlink" title="使用volatile防止指令重排"></a>使用volatile防止指令重排</h2><p>创建一个对象，在 JVM 中会经过三步：</p><p>（1）为singleton分配内存空间</p><p>（2）初始化 singleton 对象</p><p>（3）将singleton指向分配好的内存空间</p><p>指令重排序是指：<strong>JVM在保证最终结果正确的情况下，可以不按照程序编码的顺序执行语句，尽可能提高程序的性能</strong></p><p>在这三步中，第 2、3 步有可能会发生指令重排现象，创建对象的顺序变为 1-3-2，会导致多个线程获取对象时，有可能线程 A 创建对象的过程中，执行了 1、3 步骤，线程 B 判断 singleton 已经不为空，获取到未初始化的singleton 对象，就会报 NPE 异常。文字较为晦涩，可以看流程图：</p><p>使用 volatile 关键字可以**防止指令重排序，**其原理较为复杂，这篇文章不打算展开，可以这样理解：<strong>使用 volatile 关键字修饰的变量，可以保证其指令执行的顺序与程序指明的顺序一致，不会发生顺序变换</strong>，这样在多线程环境下就不会发生 NPE 异常了。</p><blockquote><p>volatile 还有第二个作用：使用 volatile 关键字修饰的变量，可以保证其内存可见性，即每一时刻线程读取到该变量的值都是内存中最新的那个值，线程每次操作该变量都需要先读取该变量。</p></blockquote><p>最终的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;  <span class="comment">// 线程A和线程B同时看到singleton = null，如果不为null，则直接返回singleton</span></span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123; <span class="comment">// 线程A或线程B获得该锁进行初始化</span></span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123; <span class="comment">// 其中一个线程进入该分支，另外一个线程则不会进入该分支</span></span><br><span class="line">                    singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="破坏懒汉式单例与饿汉式单例"><a href="#破坏懒汉式单例与饿汉式单例" class="headerlink" title="破坏懒汉式单例与饿汉式单例"></a>破坏懒汉式单例与饿汉式单例</h2><p>无论是完美的懒汉式还是饿汉式，终究敌不过<strong>反射和序列化</strong>，它们俩都可以把单例对象破坏掉（产生多个对象）。</p><h3 id="利用反射破坏单例模式"><a href="#利用反射破坏单例模式" class="headerlink" title="利用反射破坏单例模式"></a>利用<strong>反射</strong>破坏单例模式</h3><p>下面是一段使用反射破坏单例模式的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取类的显式构造器</span></span><br><span class="line">    Constructor&lt;Singleton&gt; construct = Singleton.class.getDeclaredConstructor();</span><br><span class="line">    <span class="comment">// 可访问私有构造器</span></span><br><span class="line">    construct.setAccessible(<span class="literal">true</span>); </span><br><span class="line">    <span class="comment">// 利用反射构造新对象</span></span><br><span class="line">    <span class="type">Singleton</span> <span class="variable">obj1</span> <span class="operator">=</span> construct.newInstance(); </span><br><span class="line">    <span class="comment">// 通过正常方式获取单例对象</span></span><br><span class="line">    <span class="type">Singleton</span> <span class="variable">obj2</span> <span class="operator">=</span> Singleton.getInstance(); </span><br><span class="line">    System.out.println(obj1 == obj2); <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的代码一针见血了：利用反射，强制访问类的私有构造器，去创建另一个对象</p><h3 id="利用序列化与反序列化破坏单例模式"><a href="#利用序列化与反序列化破坏单例模式" class="headerlink" title="利用序列化与反序列化破坏单例模式"></a>利用<strong>序列化与反序列化</strong>破坏单例模式</h3><p>下面是一种使用序列化和反序列化破坏单例模式的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建输出流</span></span><br><span class="line">    <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;Singleton.file&quot;</span>));</span><br><span class="line">    <span class="comment">// 将单例对象写到文件中</span></span><br><span class="line">    oos.writeObject(Singleton.getInstance());</span><br><span class="line">    <span class="comment">// 从文件中读取单例对象</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Singleton.file&quot;</span>);</span><br><span class="line">    <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file));</span><br><span class="line">    <span class="type">Singleton</span> <span class="variable">newInstance</span> <span class="operator">=</span> (Singleton) ois.readObject();</span><br><span class="line">    <span class="comment">// 判断是否是同一个对象</span></span><br><span class="line">    System.out.println(newInstance == Singleton.getInstance()); <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个对象地址不相等的原因是：readObject() 方法读入对象时它必定会返回一个新的对象实例，必然指向新的内存地址。</p><h2 id="让面试官鼓掌的枚举实现"><a href="#让面试官鼓掌的枚举实现" class="headerlink" title="让面试官鼓掌的枚举实现"></a>让面试官鼓掌的枚举实现</h2><p>我们已经掌握了懒汉式与饿汉式的常见写法了，通常情况下到这里已经足够了。但是，追求极致的我们，怎么能够止步于此，在《Effective Java》书中，给出了终极解决方法，话不多说，学完下面，真的不虚面试官考你了。</p><p>在 JDK 1.5 后，使用 Java 语言实现单例模式的方式又多了一种：<code>枚举</code></p><p>枚举实现单例模式完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是枚举类型的单例模式！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用枚举实现单例模式较其它两种实现方式的优势有 3 点，让我们来细品。</p><h3 id="优势1-：一目了然的代码"><a href="#优势1-：一目了然的代码" class="headerlink" title="优势1 ：一目了然的代码"></a>优势1 ：一目了然的代码</h3><p>代码对比饿汉式与懒汉式来说，更加地简洁。最少只需要3行代码，就可以完成一个单例模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们从最直观的地方入手，第一眼看到这3行代码，就会感觉到<code>少</code>，没错，就是少，虽然这优势有些牵强，但写的代码越少，越不容易出错。</p><h3 id="优势2：天然的线程安全与单一实例"><a href="#优势2：天然的线程安全与单一实例" class="headerlink" title="优势2：天然的线程安全与单一实例"></a>优势2：天然的线程安全与单一实例</h3><p>它不需要做任何额外的操作，就可以保证对象单一性与线程安全性。</p><p>我写了一段测试代码放在下面，这一段代码可以证明程序启动时仅会创建一个 Singleton 对象，且是线程安全的。</p><blockquote><p>我们可以简单地理解枚举创建实例的过程：在程序启动时，会调用 Singleton 的空参构造器，实例化好一个Singleton 对象赋给 INSTANCE，之后再也不会实例化</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    Singleton() &#123; System.out.println(<span class="string">&quot;枚举创建对象了&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; <span class="comment">/* test(); */</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">t1</span> <span class="operator">=</span> Singleton.INSTANCE;</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">t2</span> <span class="operator">=</span> Singleton.INSTANCE;</span><br><span class="line">        System.out.print(<span class="string">&quot;t1和t2的地址是否相同：&quot;</span> + t1 == t2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 枚举创建对象了</span></span><br><span class="line"><span class="comment">// t1和t2的地址是否相同：true</span></span><br></pre></td></tr></table></figure><p>除了优势1和优势2，还有最后一个优势是 <code>保护单例模式</code>，它使得枚举在当前的单例模式领域已经是 <code>无懈可击</code> 了</p><h3 id="优势-3：枚举保护单例模式不被破坏"><a href="#优势-3：枚举保护单例模式不被破坏" class="headerlink" title="优势 3：枚举保护单例模式不被破坏"></a>优势 3：枚举保护单例模式不被破坏</h3><p>使用枚举可以防止调用者使用<strong>反射、序列化与反序列化</strong>机制强制生成多个单例对象，破坏单例模式。</p><p><strong>防反射</strong></p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAOgaUYQjOwdPzUlS35SfRipHk32A1YAAlsLaxvRfjBWEo_Nh4YW0_QBAAMCAAN4AAM2BA.png"></p><p>枚举类默认继承了 Enum 类，在利用反射调用 newInstance() 时，会判断该类是否是一个枚举类，如果是，则抛出异常。</p><p><strong>防止反序列化创建多个枚举对象</strong></p><p>在读入 Singleton 对象时，每个枚举类型和枚举名字都是唯一的，所以在序列化时，仅仅只是对枚举的类型和变量名输出到文件中，在读入文件反序列化成对象时，使用 Enum 类的 valueOf(String name) 方法根据变量的名字查找对应的枚举对象。</p><p>所以，在序列化和反序列化的过程中，只是写出和读入了枚举类型和名字，没有任何关于对象的操作。</p><p>小结：</p><p>（1）Enum 类内部使用<strong>Enum 类型判定</strong>防止通过反射创建多个对象</p><p>（2）Enum 类通过写出（读入）对象类型和枚举名字将对象序列化（反序列化），<strong>通过 valueOf() 方法匹配枚举名</strong>找到内存中的唯一的对象实例，防止通过反序列化构造多个对象</p><p>（3）枚举类不需要关注线程安全、破坏单例和性能问题，因为其创建对象的时机与<strong>饿汉式单例有异曲同工之妙</strong>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>（1）单例模式常见的写法有两种：懒汉式、饿汉式</p><p>（2）懒汉式：在需要用到对象时才实例化对象，正确的实现方式是：Double Check + Lock，解决了并发安全和性能低下问题</p><p>（3）饿汉式：在类加载时已经创建好该单例对象，在获取单例对象时直接返回对象即可，不会存在并发安全和性能问题。</p><p>（4）在开发中如果对内存要求非常高，那么使用懒汉式写法，可以在特定时候才创建该对象；</p><p>（5）如果对内存要求不高使用饿汉式写法，因为简单不易出错，且没有任何并发安全和性能问题</p><p>（6）为了防止多线程环境下，因为指令重排序导致变量报NPE，需要在单例对象上添加 volatile 关键字防止指令重排序</p><p>（7）最优雅的实现方式是使用枚举，其代码精简，没有线程安全问题，且 Enum 类内部防止反射和反序列化时破坏单例。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单例模式 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java9新特性概览</title>
      <link href="/2025/02/18/java9%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2025/02/18/java9%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p><strong>Java 9</strong> 发布于 2017 年 9 月 21 日 。作为 Java 8 之后 3 年半才发布的新版本，Java 9 带来了很多重大的变化其中最重要的改动是 Java 平台模块系统的引入，其他还有诸如集合、<code>Stream</code> 流……。</p><p>你可以在 <a href="http://jdk.java.net/archive/">Archived OpenJDK General-Availability Releases</a> 上下载自己需要的 JDK 版本！官方的新特性说明文档地址：<a href="https://openjdk.java.net/projects/jdk/">https://openjdk.java.net/projects/jdk/</a> 。</p><p><strong>概览（精选了一部分）</strong>：</p><ul><li><a href="https://openjdk.java.net/jeps/222">JEP 222: Java 命令行工具</a></li><li><a href="https://openjdk.java.net/jeps/261">JEP 261: 模块化系统</a></li><li><a href="https://openjdk.java.net/jeps/248">JEP 248：G1 成为默认垃圾回收器</a></li><li><a href="https://openjdk.java.net/jeps/193">JEP 193: 变量句柄</a></li><li><a href="https://openjdk.java.net/jeps/254">JEP 254：字符串存储结构优化</a></li></ul><h2 id="JShell"><a href="#JShell" class="headerlink" title="JShell"></a>JShell</h2><p>JShell 是 Java 9 新增的一个实用工具。为 Java 提供了类似于 Python 的实时命令行交互工具。</p><p>在 JShell 中可以直接输入表达式并查看其执行结果。</p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAOoaUYcXrmBFRSTtWCc7jy3DsIz9MQAAm8LaxvRfjBWHNqAFiheQmYBAAMCAAN4AAM2BA.png"></p><p><strong>JShell 为我们带来了哪些好处呢？</strong></p><ol><li>降低了输出第一行 Java 版”Hello World！”的门槛，能够提高新手的学习热情。</li><li>在处理简单的小逻辑，验证简单的小问题时，比 IDE 更有效率（并不是为了取代 IDE，对于复杂逻辑的验证，IDE 更合适，两者互补）。</li><li>……</li></ol><p><strong>JShell 的代码和普通的可编译代码，有什么不一样？</strong></p><ol><li>一旦语句输入完成，JShell 立即就能返回执行的结果，而不再需要编辑器、编译器、解释器。</li><li>JShell 支持变量的重复声明，后面声明的会覆盖前面声明的。</li><li>JShell 支持独立的表达式比如普通的加法运算 <code>1 + 1</code>。</li><li>……</li></ol><h2 id="模块化系统"><a href="#模块化系统" class="headerlink" title="模块化系统"></a>模块化系统</h2><p>模块系统是<a href="https://openjdk.java.net/projects/jigsaw/">Jigsaw Project</a>的一部分，把模块化开发实践引入到了 Java 平台中，可以让我们的代码可重用性更好！</p><p><strong>什么是模块系统？</strong> 官方的定义是：</p><blockquote><p>A uniquely named, reusable group of related packages, as well as resources (such as images and XML files) and a module descriptor。</p></blockquote><p>简单来说，你可以将一个模块看作是一组唯一命名、可重用的包、资源和模块描述文件（<code>module-info.java</code>）。</p><p>任意一个 jar 文件，只要加上一个模块描述文件（<code>module-info.java</code>），就可以升级为一个模块。</p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAOnaUYcUuk-JQardrEnYCRXUh2SDDAAAm4LaxvRfjBW680bqHKORDwBAAMCAAN4AAM2BA.png"></p><p>在引入了模块系统之后，JDK 被重新组织成 94 个模块。Java 应用可以通过新增的 <strong><a href="http://openjdk.java.net/jeps/282">jlink</a> 工具</strong> (Jlink 是随 Java 9 一起发布的新命令行工具。它允许开发人员为基于模块的 Java 应用程序创建自己的轻量级、定制的 JRE)，创建出只包含所依赖的 JDK 模块的自定义运行时镜像。这样可以极大的减少 Java 运行时环境的大小。</p><p>我们可以通过 <code>exports</code> 关键词精准控制哪些类可以对外开放使用，哪些类只能内部使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> my.<span class="keyword">module</span> &#123;</span><br><span class="line">    <span class="comment">//exports 公开指定包的所有公共成员</span></span><br><span class="line">    <span class="keyword">exports</span> com.my.<span class="keyword">package</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> my.<span class="keyword">module</span> &#123;</span><br><span class="line">     <span class="comment">//exports…to 限制访问的成员范围</span></span><br><span class="line">    export com.my.<span class="keyword">package</span>.name to com.specific.<span class="keyword">package</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想要深入了解 Java 9 的模块化，可以参考下面这几篇文章：</p><ul><li><a href="https://openjdk.java.net/projects/jigsaw/quick-start">《Project Jigsaw: Module System Quick-Start Guide》</a></li><li><a href="https://stacktraceguru.com/java9/module-introduction">《Java 9 Modules: part 1》</a></li><li><a href="http://www.cnblogs.com/IcanFixIt/p/6947763.html">Java 9 揭秘（2. 模块化系统）</a></li></ul><h2 id="G1-成为默认垃圾回收器"><a href="#G1-成为默认垃圾回收器" class="headerlink" title="G1 成为默认垃圾回收器"></a>G1 成为默认垃圾回收器</h2><p>在 Java 8 的时候，默认垃圾回收器是 Parallel Scavenge（新生代）+Parallel Old（老年代）。到了 Java 9, CMS 垃圾回收器被废弃了，<strong>G1（Garbage-First Garbage Collector）</strong> 成为了默认垃圾回收器。</p><p>G1 还是在 Java 7 中被引入的，经过两个版本优异的表现成为成为默认垃圾回收器。</p><h2 id="快速创建不可变集合"><a href="#快速创建不可变集合" class="headerlink" title="快速创建不可变集合"></a>快速创建不可变集合</h2><p>增加了<code>List.of()</code>、<code>Set.of()</code>、<code>Map.of()</code> 和 <code>Map.ofEntries()</code>等工厂方法来创建不可变集合（有点参考 Guava 的味道）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List.of(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;C++&quot;</span>);</span><br><span class="line">Set.of(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;C++&quot;</span>);</span><br><span class="line">Map.of(<span class="string">&quot;Java&quot;</span>, <span class="number">1</span>, <span class="string">&quot;C++&quot;</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>使用 <code>of()</code> 创建的集合为不可变集合，不能进行添加、删除、替换、 排序等操作，不然会报 <code>java.lang.UnsupportedOperationException</code> 异常。</p><h2 id="String-存储结构优化"><a href="#String-存储结构优化" class="headerlink" title="String 存储结构优化"></a>String 存储结构优化</h2><p>Java 8 及之前的版本，<code>String</code> 一直是用 <code>char[]</code> 存储。在 Java 9 之后，<code>String</code> 的实现改用 <code>byte[]</code> 数组存储字符串，节省了空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable,Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">// @Stable 注解表示变量最多被修改一次，称为“稳定的”。</span></span><br><span class="line">    <span class="meta">@Stable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span>[] value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口私有方法"><a href="#接口私有方法" class="headerlink" title="接口私有方法"></a>接口私有方法</h2><p>Java 9 允许在接口中使用私有方法。这样的话，接口的使用就更加灵活了，有点像是一个简化版的抽象类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">methodPrivate</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="try-with-resources-增强"><a href="#try-with-resources-增强" class="headerlink" title="try-with-resources 增强"></a>try-with-resources 增强</h2><p>在 Java 9 之前，我们只能在 <code>try-with-resources</code> 块中声明变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;testRead.txt&quot;</span>));</span><br><span class="line">    <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;testWrite.txt&quot;</span>))) &#123;</span><br><span class="line">    <span class="comment">// omitted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Java 9 之后，在 <code>try-with-resources</code> 语句中可以使用 effectively-final 变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;testRead.txt&quot;</span>));</span><br><span class="line"><span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;testWrite.txt&quot;</span>))</span><br><span class="line"><span class="keyword">try</span> (scanner;writer) &#123;</span><br><span class="line">    <span class="comment">// omitted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>什么是 effectively-final 变量？</strong> 简单来说就是没有被 <code>final</code> 修饰但是值在初始化后从未更改的变量。</p><p>正如上面的代码所演示的那样，即使 <code>writer</code> 变量没有被显示声明为 <code>final</code>，但它在第一次被赋值后就不会改变了，因此，它就是 effectively-final 变量。</p><h2 id="Stream-Optional-增强"><a href="#Stream-Optional-增强" class="headerlink" title="Stream &amp; Optional 增强"></a>Stream &amp; Optional 增强</h2><p><code>Stream</code> 中增加了新的方法 <code>ofNullable()</code>、<code>dropWhile()</code>、<code>takeWhile()</code> 以及 <code>iterate()</code> 方法的重载方法。</p><p>Java 9 中的 <code>ofNullable()</code> 方 法允许我们创建一个单元素的 <code>Stream</code>，可以包含一个非空元素，也可以创建一个空 <code>Stream</code>。 而在 Java 8 中则不可以创建空的 <code>Stream</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stringStream = Stream.ofNullable(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">System.out.println(stringStream.count());<span class="comment">// 1</span></span><br><span class="line">Stream&lt;String&gt; nullStream = Stream.ofNullable(<span class="literal">null</span>);</span><br><span class="line">System.out.println(nullStream.count());<span class="comment">//0</span></span><br></pre></td></tr></table></figure><p><code>takeWhile()</code> 方法可以从 <code>Stream</code> 中依次获取满足条件的元素，直到不满足条件为止结束获取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; integerList = List.of(<span class="number">11</span>, <span class="number">33</span>, <span class="number">66</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">13</span>);</span><br><span class="line">integerList.stream().takeWhile(x -&gt; x &lt; <span class="number">50</span>).forEach(System.out::println);<span class="comment">// 11 33</span></span><br></pre></td></tr></table></figure><p><code>dropWhile()</code> 方法的效果和 <code>takeWhile()</code> 相反。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; integerList2 = List.of(<span class="number">11</span>, <span class="number">33</span>, <span class="number">66</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">13</span>);</span><br><span class="line">integerList2.stream().dropWhile(x -&gt; x &lt; <span class="number">50</span>).forEach(System.out::println);<span class="comment">// 66 8 9 13</span></span><br></pre></td></tr></table></figure><p><code>iterate()</code> 方法的新重载方法提供了一个 <code>Predicate</code> 参数 (判断条件)来决定什么时候结束迭代</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title function_">iterate</span><span class="params">(<span class="keyword">final</span> T seed, <span class="keyword">final</span> UnaryOperator&lt;T&gt; f)</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 新增加的重载方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title function_">iterate</span><span class="params">(T seed, Predicate&lt;? <span class="built_in">super</span> T&gt; hasNext, UnaryOperator&lt;T&gt; next)</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两者的使用对比如下，新的 <code>iterate()</code> 重载方法更加灵活一些。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用原始 iterate() 方法输出数字 1~10</span></span><br><span class="line">Stream.iterate(<span class="number">1</span>, i -&gt; i + <span class="number">1</span>).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line"><span class="comment">// 使用新的 iterate() 重载方法输出数字 1~10</span></span><br><span class="line">Stream.iterate(<span class="number">1</span>, i -&gt; i &lt;= <span class="number">10</span>, i -&gt; i + <span class="number">1</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure><p><code>Optional</code> 类中新增了 <code>ifPresentOrElse()</code>、<code>or()</code> 和 <code>stream()</code> 等方法</p><p><code>ifPresentOrElse()</code> 方法接受两个参数 <code>Consumer</code> 和 <code>Runnable</code> ，如果 <code>Optional</code> 不为空调用 <code>Consumer</code> 参数，为空则调用 <code>Runnable</code> 参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ifPresentOrElse</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action, Runnable emptyAction)</span></span><br><span class="line"></span><br><span class="line">Optional&lt;Object&gt; objectOptional = Optional.empty();</span><br><span class="line">objectOptional.ifPresentOrElse(System.out::println, () -&gt; System.out.println(<span class="string">&quot;Empty!!!&quot;</span>));<span class="comment">// Empty!!!</span></span><br></pre></td></tr></table></figure><p><code>or()</code> 方法接受一个 <code>Supplier</code> 参数 ，如果 <code>Optional</code> 为空则返回 <code>Supplier</code> 参数指定的 <code>Optional</code> 值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Optional&lt;T&gt; <span class="title function_">or</span><span class="params">(Supplier&lt;? extends Optional&lt;? extends T&gt;&gt; supplier)</span></span><br><span class="line"></span><br><span class="line">Optional&lt;Object&gt; objectOptional = Optional.empty();</span><br><span class="line">objectOptional.or(() -&gt; Optional.of(<span class="string">&quot;java&quot;</span>)).ifPresent(System.out::println);<span class="comment">//java</span></span><br></pre></td></tr></table></figure><h2 id="进程-API"><a href="#进程-API" class="headerlink" title="进程 API"></a>进程 API</h2><p>Java 9 增加了 <code>java.lang.ProcessHandle</code> 接口来实现对原生进程进行管理，尤其适合于管理长时间运行的进程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前正在运行的 JVM 的进程</span></span><br><span class="line"><span class="type">ProcessHandle</span> <span class="variable">currentProcess</span> <span class="operator">=</span> ProcessHandle.current();</span><br><span class="line"><span class="comment">// 输出进程的 id</span></span><br><span class="line">System.out.println(currentProcess.pid());</span><br><span class="line"><span class="comment">// 输出进程的信息</span></span><br><span class="line">System.out.println(currentProcess.info());</span><br></pre></td></tr></table></figure><p><code>ProcessHandle</code> 接口概览：</p><p><img src="https://imags-563.pages.dev/file/AgACAgUAAxkDAAOmaUYcQmAWoaBT0t6_gOyVBc1JKYUAAm0LaxvRfjBWZE_j89YTyiUBAAMCAAN4AAM2BA.png"></p><h2 id="响应式流-（-Reactive-Streams-）"><a href="#响应式流-（-Reactive-Streams-）" class="headerlink" title="响应式流 （ Reactive Streams ）"></a>响应式流 （ Reactive Streams ）</h2><p>在 Java 9 中的 <code>java.util.concurrent.Flow</code> 类中新增了反应式流规范的核心接口 。</p><p><code>Flow</code> 中包含了 <code>Flow.Publisher</code>、<code>Flow.Subscriber</code>、<code>Flow.Subscription</code> 和 <code>Flow.Processor</code> 等 4 个核心接口。Java 9 还提供了<code>SubmissionPublisher</code> 作为<code>Flow.Publisher</code> 的一个实现。</p><p>关于 Java 9 响应式流更详细的解读，推荐你看 <a href="https://www.cnblogs.com/IcanFixIt/p/7245377.html">Java 9 揭秘（17. Reactive Streams ）- 林本托</a> 这篇文章。</p><h2 id="变量句柄"><a href="#变量句柄" class="headerlink" title="变量句柄"></a>变量句柄</h2><p>变量句柄是一个变量或一组变量的引用，包括静态域，非静态域，数组元素和堆外数据结构中的组成部分等。</p><p>变量句柄的含义类似于已有的方法句柄 <code>MethodHandle</code> ，由 Java 类 <code>java.lang.invoke.VarHandle</code> 来表示，可以使用类 <code>java.lang.invoke.MethodHandles.Lookup</code> 中的静态工厂方法来创建 <code>VarHandle</code> 对象。</p><p><code>VarHandle</code> 的出现替代了 <code>java.util.concurrent.atomic</code> 和 <code>sun.misc.Unsafe</code> 的部分操作。并且提供了一系列标准的内存屏障操作，用于更加细粒度的控制内存排序。在安全性、可用性、性能上都要优于现有的 API。</p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ul><li><strong>平台日志 API 改进</strong>：Java 9 允许为 JDK 和应用配置同样的日志实现。新增了 <code>System.LoggerFinder</code> 用来管理 JDK 使 用的日志记录器实现。JVM 在运行时只有一个系统范围的 <code>LoggerFinder</code> 实例。我们可以通过添加自己的 <code>System.LoggerFinder</code> 实现来让 JDK 和应用使用 SLF4J 等其他日志记录框架。</li><li><strong><code>CompletableFuture</code>类增强</strong>：新增了几个新的方法（<code>completeAsync</code> ，<code>orTimeout</code> 等）。</li><li><strong>Nashorn 引擎的增强</strong>：Nashorn 是从 Java8 开始引入的 JavaScript 引擎，Java9 对 Nashorn 做了些增强，实现了一些 ES6 的新特性（Java 11 中已经被弃用）。</li><li><strong>I&#x2F;O 流的新特性</strong>：增加了新的方法来读取和复制 <code>InputStream</code> 中包含的数据。</li><li><strong>改进应用的安全性能</strong>：Java 9 新增了 4 个 SHA- 3 哈希算法，SHA3-224、SHA3-256、SHA3-384 和 SHA3-512。</li><li><strong>改进方法句柄（Method Handle）</strong>：方法句柄从 Java7 开始引入，Java9 在类<code>java.lang.invoke.MethodHandles</code> 中新增了更多的静态方法来创建不同类型的方法句柄。</li><li>……</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>Java version history：<a href="https://en.wikipedia.org/wiki/Java_version_history">https://en.wikipedia.org/wiki/Java_version_history</a></li><li>Release Notes for JDK 9 and JDK 9 Update Releases : <a href="https://www.oracle.com/java/technologies/javase/9-all-relnotes.html">https://www.oracle.com/java/technologies/javase/9-all-relnotes.html</a></li><li>《深入剖析 Java 新特性》-极客时间 - JShell：怎么快速验证简单的小问题？</li><li>New Features in Java 9: <a href="https://www.baeldung.com/new-java-9">https://www.baeldung.com/new-java-9</a></li><li>Java – Try with Resources：<a href="https://www.baeldung.com/java-try-with-resources">https://www.baeldung.com/java-try-with-resources</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java核心系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java核心 </tag>
            
            <tag> Java版本新特性 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
